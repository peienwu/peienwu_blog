[{"title":"ä½¿ç”¨Hexoæ­é…GitHubæ¶è¨­å€‹äººéƒ¨è½æ ¼","url":"/Blog/","content":"æœ¬ç¶²é å°±æ˜¯åˆ©ç”¨github pageæ¶è¨­çš„éƒ¨è½æ ¼ï¼Œä½¿ç”¨Hexoæ­é…Nextä¸»é¡Œã€‚æš‘å‡å¸¸å¸¸å¯«é¡Œï¼Œéƒ½å¹¾ä¹ç´€éŒ„åœ¨Hackmdä¸Šï¼Œå¦‚æœèƒ½æœ‰å±¬æ–¼è‡ªå·±çš„éƒ¨è½æ ¼ã€ç”¨è‡ªå·±çš„ç¶²å€ï¼Œæ„Ÿè¦ºè¶…é…·ï¼ä¾†è‡ªå·±æ¶è¨­ä¸€å€‹è©¦è©¦çœ‹ï¼\nç¶²åŸŸç¨®é¡æ¶è¨­ç¶²ç«™æœ‰å¥½å¤šç¨®æ–¹æ³•ï¼Œæœ‰æ™‚å€™æ˜¯çœ‹é¡Œè§£çœ‹åˆ°äº†å¾ˆå¤šçš„ç¶²ç«™XDï¼Œä¸Šç¶²æŸ¥äº†è³‡æ–™ä»¥åŠå¾ˆå¤šäººçš„éƒ¨è½æ ¼ï¼Œç™¼ç¾å¯«codingéƒ¨è½æ ¼çš„äººçš„ç¶²ç«™å¤§å¤šåˆ†æˆä»¥ä¸‹å››é¡ï¼š\n\nBlogger\nHexo\nGitHub Pages\nWordPress.org\n\n\næ¯ä¸€ç¨®éƒ¨è½æ ¼éƒ½æœ‰å„ªå‹¢èˆ‡åŠ£å‹¢ï¼Œå°±çœ‹ä½¿ç”¨è€…è¦ºå¾—å“ªä¸€å€‹å¹³å°ä½¿ç”¨èµ·ä¾†æ¯”è¼ƒæ–¹ä¾¿ï¼åœ¨ç¶“éå¤šæ–¹å˜—è©¦ä¹‹ä¸‹ï¼Œæœ€å¾Œæˆ‘æ˜¯é¸æ“‡äº†ä½¿ç”¨ Hexo æ­é… Github ä¾†æ¶è¨­æˆ‘çš„ç¶²ç«™ï¼Œä»¥ä¸‹ä¾†åˆ†æä¸€ä¸‹æˆ‘å€‹äººåœ¨æ¶è¨­çš„éç¨‹ä¸­ï¼Œä»¥ä¸€å€‹æ–°æ‰‹çš„è§’åº¦çœ‹å„å€‹å¹³å°ä½¿ç”¨ä¸Šçš„å„ªç¼ºé»ï¼\n\n\n\n\nç¶²ç«™æ¯”è¼ƒ\nå„ªé»\nç¼ºé»\n\n\n\n\nBlogger\n1. ä»‹é¢æ¸…æ¥šï¼Œæ“ä½œæ–¹ä¾¿2. ä¸€éµé è¦½åŠç™¼å¸ƒï¼Œå¿«é€ŸæŸ¥çœ‹æ–‡ç« æˆæœ3. å…è²»ï¼\n1. ä¸æ”¯æ´MarkDownèªæ³•2. å°æ•¸å­¸å¼ã€ç¨‹å¼ç¢¼æ”¯æ´ä¸ä¾¿åˆ©\n\n\nHexo\n1. æ”¯æ´MarkDownèªæ³•2. Macçµ‚ç«¯æ©Ÿæ“ä½œæ–¹ä¾¿3. å…è²»ï¼\n1. ç´”ç¨‹å¼ç¢¼å‘ˆç¾ï¼Œè¼ƒä¸ç›´è¦º2. ä¿®æ”¹éç¨‹ä¸­å¦‚æœç¨‹å¼ç¢¼å‡ºéŒ¯ï¼Œé€ æˆæ•´å€‹ç¶²ç«™æ›æ‰\n\n\nGitHub Pages\n1. æ”¯æ´MarkDownèªæ³•2. é€²è¡Œç‰ˆæœ¬æ§åˆ¶3. å…è²»ï¼\n1. å–®ç´”ä½¿ç”¨çš„è©±æ“ä½œã€ä¿®æ”¹ä¸æ–¹ä¾¿2. Gitæ“ä½œæœ‰ä¸€å®šé›£åº¦\n\n\nWordPress com\n1. è·ŸBloggerç›¸è¿‘ï¼Œæ“ä½œç°¡å–®æ˜“ä¸Šæ‰‹2. å¿«é€ŸæŸ¥çœ‹æ–‡ç« é•·ç›¸\n1. ä¸æ”¯æ´Markdown2. å…è²»ç‰ˆé™åˆ¶å¤šã€æ¨¡æ¿ä¸æ¼‚äº®\n\n\nWordPress org\nå¤ªè²´ä¸è€ƒæ…®\nä¸Šç¶²æŸ¥å¿…é ˆè¦å…ˆä»˜è²»æ‰èƒ½é–‹å§‹æ¶è¨­è²»ç”¨å¥½åƒä¸€å¹´3000ä»¥ä¸Š\n\n\n\n\nç¶“éå¤šæ–¹å˜—è©¦ï¼ˆèŠ±äº†æˆ‘å¥½å¤šå¤©ï¼‰ï¼Œå‡ºç”¢äº†ä¸€å †å¤±æ•—å“ï¼Œæœ€å¾Œé‚„æ˜¯ç”¨ Hexo æ­é… GitHub ä¾†æ¶è¨­ä¸€å€‹ç®—æ»¿æ„çš„ç¶²ç«™ï¼ˆè‡³å°‘çœ‹èµ·ä¾†ä¸éŒ¯XDï¼‰ã€‚ä»¥ä¸‹æ˜¯æˆ‘çš„å¤±æ•—å“ç¶²ç«™ï¼š\n\nBlogger\nWorldPress\nGithubçš„æˆ‘å·²ç¶“åˆªæ‰äº†\n\nHexo å®‰è£ä¹‹å‰é‡ä¸Šå¾ˆå¤šè»Ÿé«”å°Macéƒ½ä¸å‹å–„ï¼Œä¸éHexoå»æ˜¯å°Macçš„ç”¨æˆ¶æ¯”è¼ƒå‹å–„çš„å·¥å…·ã€‚åªè¦åœ¨çµ‚ç«¯æ©Ÿè¼¸å…¥ä»¥ä¸‹å‘½ä»¤å°±å¯ä»¥å®‰è£Hexoï¼š\nnpm install -g hexo-cli\nè©³ç´°çš„å®‰è£æ­¥é©Ÿå¯ä»¥åƒè€ƒå®˜æ–¹ç¶²ç«™ï¼Œæˆ–æ˜¯ç¶²è·¯ä¸Šçš„æ•™å­¸å½±ç‰‡å°±å¯ä»¥ä¸€æ­¥ä¸€æ­¥çš„æŠŠç¶²ç«™å»ºç«‹èµ·ä¾†ï¼\nåœ¨é€™éç¨‹ä¸­ï¼Œæˆ‘ç™¼ç¾å½±ç‰‡ä¸Šæœ‰ä½¿ç”¨åˆ°VS Codeï¼Œæ–¼æ˜¯æˆ‘å°±æŠŠå®ƒä¹Ÿè¼‰ä¸‹ä¾†äº†ã€‚ç”¨èµ·ä¾†æ„Ÿè¦ºVS Code å°å°ˆæ¡ˆè£½ä½œå¾ˆæœ‰å¹«åŠ©ï¼Œå¯ä»¥åŒæ­¥çš„åœ¨å„å€‹æª”æ¡ˆä¹‹é–“é€²è¡Œä¿®æ”¹ï¼Œè »å¯¦ç”¨çš„ä¸€å€‹IDEï¼\nGitHubåŒæ­¥å°‡ Hexo è£¡é¢çš„æª”æ¡ˆæ¨é€åˆ° Git Hub è£¡é¢çš„ä¸€å€‹Repositoryä¸­ï¼Œåˆ©ç”¨å®ƒä¾†å°‡ç¶²é çš„å…§å®¹é€²è¡Œç™¼å¸ƒã€‚åœ¨æ¯ä¸€æ¬¡æœ¬åœ°ä¿®æ”¹å®Œæˆä¹‹å¾Œï¼Œå¦‚æœæœ¬åœ°æ¸¬è©¦å¯è¡Œï¼Œå°±å¯ä»¥å°‡æª”æ¡ˆæ¨é€åˆ°Githubä¸­ï¼Œåœ¨Githubå°‡ç¶²ç«™é€²è¡Œç™¼å¸ƒã€‚æˆ‘ä½¿ç”¨ä¾†æ¶è¨­éƒ¨è½æ ¼çš„Repositoryåœ¨æ­¤ã€‚\ngit add .                //åŠ å…¥git commit -m &quot;xxx&quot;      //æäº¤git push                 //æ¨å…¥git push -f              //å¼·åˆ¶æ¨å…¥ï¼ˆè½èªªå¾ˆå±éšªï¼‰\nåœ¨æäº¤çš„å¾Œé¢çš„å­—ä¸²è¡¨ç¤ºç•¶å‰ç‰ˆæœ¬çš„ä¸€å€‹æç¤ºï¼Œä¾‹å¦‚æˆ‘åšäº†ä»€éº¼ä¿®æ”¹å°±å¯ä»¥é¡¯ç¤ºåœ¨ä¸Šé¢ï¼Œè®“åˆ¥äººçŸ¥é“é€™ä»½æª”æ¡ˆè¢«æ›´æ”¹çš„æƒ…æ³ã€‚ä¸‹åœ–å°±æ˜¯åœ¨æ¯ä¸€æ¬¡æ¨å…¥æ™‚é™„åŠ çš„ä¿®æ”¹è³‡è¨Šï¼Œè®“æˆ‘è‡ªå·±å¯ä»¥çœ‹åˆ°æª”æ¡ˆè¢«æ›´æ”¹ä»¥åŠæäº¤çš„ç‹€æ³!\n\nGitçœŸæ˜¯åšå¤§ç²¾æ·±ï¼Œç‰ˆæœ¬æ§åˆ¶çœŸçš„æœ‰é›£åº¦ï¼Œæˆ‘åªæœƒç°¡å–®çš„ä¿®æ”¹ä»¥åŠæ¨å…¥ï¼ˆä¹‹å¾Œæ‰¾æ™‚é–“å¯ä»¥å­¸ä¸€ä¸‹ï¼‰ã€‚\nå¤–æ›å®‰è£åšåˆ°é€™ä¸€å€‹æ­¥é©Ÿå·²ç¶“èŠ±äº†æˆ‘å¿«ä¸‰å°æ™‚ï¼Œå‡ºç¾çš„æ˜¯é¡ä¼¼ä»¥ä¸‹çš„ç•«é¢ï¼š\n\né€™æ˜¯ Hexo é è¨­çš„æ¨£æ¿ï¼Œæ„Ÿè¦ºé‚„ä¸éŒ¯ï¼Œä¸éæˆ‘çš„ç›®æ¨™æ˜¯ä½¿ç”¨å¦å¤–å¤–æ›çš„æ¨¡æ¿ï¼Œçœ‹èµ·ä¾†æ¯”è¼ƒæ¼‚äº®XDã€‚æ–¼æ˜¯æˆ‘å°±æ‰¾äº†Nextä¸»é¡Œçš„å¤–æ›ä¾†å®‰è£ï¼Œé€™å€‹æ¨¡æ¿å°±æ„Ÿè¦ºèˆ’æœå¾ˆå¤šã€‚é€™å€‹æ¨¡æ¿ä½¿ç”¨çš„å¤§é™¸éƒ¨è½æ ¼å¾ˆå¤šï¼Œä¹Ÿæœ‰ä¸€äº›å…¶ä»–çš„ç«¶ç¨‹éƒ¨è½æ ¼ä½¿ç”¨äº†é€™å€‹ä¸»é¡Œï¼\n\nHexo NexT ç¾åŒ–ä¸Šç¶²æŸ¥é—œéµå­—å…¶å¯¦æœ‰å¾ˆå¤šç¾åŒ–çš„è³‡è¨Šå¯ä»¥åƒè€ƒï¼Œä¸è«–æ˜¯å­—é«”æˆ–ç‰ˆé¢é…ç½®éƒ½æœ‰å¾ˆå¤šç¨®é¸é …å¯ä»¥é¸æ“‡ã€‚æœ€ä¸€é–‹å§‹æ˜¯è¨­è¨ˆç‰ˆé¢çš„éƒ¨åˆ†ï¼Œå°‡ç¶²ç«™ç¸½å…±åˆ†äº”å€‹å­é¡åˆ¥ï¼Œåˆ†åˆ¥æ˜¯é¦–é ã€æª”æ¡ˆã€é¡åˆ¥ã€æ¨™ç±¤ä»¥åŠé—œæ–¼ï¼Œé€™äº”å€‹ç¶“å…¸çš„é…ç½®ã€‚æ¥ä¸‹ä¾†å°±æ˜¯å€‹äººè³‡è¨Šçš„è¨­å®šï¼ŒåŠ å…¥è‡ªå·±çš„åœ–ç‰‡ä»¥åŠèªªæ˜ï¼š\nä»¥åŠåœ¨ç¶²é ç€è¦½æ¨™ç±¤ä¸Šæ–¹è¨­å®šiconï¼š\nç•¶ç„¶æœ€é‡è¦çš„å°±æ˜¯æ–‡ç« å…§å®¹ï¼Œå› ç‚ºæ˜¯ä½¿ç”¨Markdownèªæ³•ï¼Œå‰›å¥½æœ‰å¹¾ç¯‡ç­†è¨˜å°±ä¸Ÿä¸Šå»çœ‹çœ‹ã€‚ç•¶ç„¶é‚„æœ‰å¾ˆå¤šçš„å„ªåŒ–ä»¥åŠç¾åŒ–ï¼Œå¦‚æœæœ‰ä»€éº¼éœ€è¦æ”¹é€²çš„åœ°æ–¹è¦è·Ÿæˆ‘èªªå–”ï¼\nDisqus ç•™è¨€æ¿åŠŸèƒ½åœ¨æ¯ä¸€ç¯‡æ–‡ç« ä¸‹æ–¹åŠ å…¥ç•™è¨€æ¿åŠŸèƒ½ï¼Œæ„Ÿè¦ºé‚„è »é…·çš„ï¼\n\nGoogle Analytics è¿½è¹¤åˆ†æé€™æ˜¯é…·æ±è¥¿ï¼Œä½¿ç”¨google å¸³è™Ÿç”Ÿæˆä¸€çµ„ä»£ç¢¼ä¹‹å¾Œï¼ŒæŠŠä¸€äº›å®ƒæä¾›çš„ç¨‹å¼ç¢¼åŸ‹åˆ°ç¶²ç«™ä¸­ï¼Œå®ƒå¯ä»¥å³æ™‚çš„çµ±è¨ˆç¶²ç«™çš„ç€è¦½ç‹€æ³ï¼Œä»¥åŠè§¸åŠã€æ„Ÿèˆˆè¶£çš„ä¸»é¡Œç­‰ç­‰ã€‚å‡è¨­æœªä¾†ç€è¦½çš„äººæ¬¡æ¯”è¼ƒå¤šçš„æ™‚å€™ï¼ˆå¯èƒ½æ ¹æœ¬æ²’äººæœƒçœ‹XDDï¼‰ï¼Œé‚„å¯ä»¥ç”¨å®ƒä¾†åˆ†æå“ªä¸€ç¨®æ–‡ç« æœ€å—äººæ­¡è¿ã€å“ªä¸€ç¨®æ–‡ç« æœ€å†·é–€ä¹‹é¡çš„ï¼\n\nè³¼è²·å€‹äººç¶²å€æ˜¨å¤©çµ‚æ–¼è²·åˆ°äº†è‡ªå·±åå­—çš„ç¶²å€äº†ï¼æ–°çš„ç¶²å€åç¨±æ˜¯ï¼špeienwu.comï¼åœ¨Godaddy ä¸Šç”¨NT570å…ƒè²·äº†ä¸€å¹´é€™å€‹ç¶²å€çš„ä½¿ç”¨æ¬Šé™ï¼Œè²·å®Œä¹‹å¾Œåˆ°CloudFlareè¨­å®šå¥½Dnsä¹‹é¡çš„ï¼Œè®“é€™å€‹ç¶²å€å¯ä»¥æŒ‡å‘ä¸€å€‹IPä½å€ï¼ˆé€™å…¶ä¸­çš„åŸç†æœ‰é»è¤‡é›œï¼‰ã€‚\nè¨­å®šå®Œä¹‹å¾Œï¼Œç™¼ç¾ä»–ä¸€ç›´å‡ºç¾éŒ¯èª¤è¨Šæ¯ï¼Œé»é–‹ç¶²å€ä¹Ÿæ˜¯ä¸å¯ä½¿ç”¨çš„ï¼Œå·®é»æ˜å€’wwã€‚æ™šä¸Šè™•ç†ä¸äº†äº†ï¼Œéš”å¤©ä¸€æ—©èµ·åºŠå°±é–‹å§‹è‘—æ‰‹è™•ç†ä¸­é€™å€‹å•é¡Œï¼ŒæŠŠæª”æ¡ˆåˆªåˆªæ”¹æ”¹ï¼Œçµ‚æ–¼æˆåŠŸè®“GitHubè·³å‡ºä»¥ä¸‹è¨Šæ¯ï¼š\n\nå¾ˆè¨å­çš„ï¼Œä»–æ²’æœ‰httpsï¼Œä¹Ÿå°±æ˜¯é–é ­ï¼Œåœ¨é€™ç¨®æƒ…æ³ä¸‹ï¼Œç€è¦½å™¨å°±æœƒè‡ªå‹•è¨­ç½®ç‚ºä¸å®‰å…¨çš„ç¶²ç«™ï¼Œæ¥ä¸‹ä¾†æ—©ä¸Šçš„æ™‚é–“éƒ½æ‹¿å»è™•ç†é€™å€‹å•é¡Œã€‚åœ¨è¨­å®šä¸€äº›SSHä»¥åŠhttpsçš„å®‰å…¨æ€§è¨­å®šä¹‹å¾Œï¼Œçµ‚æ–¼ï¼Œåœ¨è¨ªå•ç¶²ç«™æ™‚æ‹¿åˆ°äº†é–é ­çš„èªè­‰ï¼\n\nç•™è¨€æ¿æ›´æ–°æœ€è¿‘é‡æ–°ç™»å…¥å¾Œç™¼ç¾æ–‡ç« åº•éƒ¨éƒ½æ˜¯ä¸€å †Disqusçš„å»£å‘Šï¼ŒçœŸçš„æœ‰å¤ è¨å­ï¼Œå¦‚æœè¦æ¶ˆé™¤å»£å‘Šçš„æ–¹æ³•åªå‰©ä¸‹ä»˜è²»ï¼Œå¥½è¨å­ï¼æ–¼æ˜¯æˆ‘æ±ºå®šæ›ä¸€å€‹è©•è«–ç³»çµ±ï¼Œå«åšValine çš„ç³»çµ±ï¼Œä»–çš„å„ªé»æ˜¯æ”¯æ´Emoji ğŸ˜‰ã€MarkDown å…¨è¯­æ³•æ”¯æŒï¼Œè€Œä¸”æ²’æœ‰å»£å‘Šï¼å¤§æ¦‚çš„ç•™è¨€å°±åƒä»¥ä¸‹é€™æ¨£ï¼š\næ”¯æ´Markdownçš„ç•™è¨€çœŸçš„å¾ˆé…·ï¼\nè‡³æ–¼ç•™è¨€ç®¡ç†çš„éƒ¨åˆ†ï¼Œå‰‡æ˜¯ç”¨LeanCloud ä¾†å¯¦ç¾ï¼Œå¯ä»¥åˆªç•™è¨€ä¹‹é¡çš„XD\næŠ±æ€¨ä¸€ä¸‹ä»Šå¤©åœ¨ç”¨Icloud çš„æ™‚å€™ï¼Œä¸å°å¿ƒæŠŠé›»è…¦ä¸Šæ‰€æœ‰çš„æª”æ¡ˆå…¨éƒ¨åˆªæ‰äº†ï¼Œå“­å•Šï¼Œé€™çœŸæ˜¯åš´é‡çš„äº‹æƒ…ï¼±ï¼±ï¼±ï¼Œç”¨åˆ°å¿«æ›äº†ï¼ç•¶ç„¶ï¼Œæˆ‘é›»è…¦ä¸Šçš„æ‰€æœ‰æ±è¥¿éƒ½ä¸è¦‹äº†ï¼Œä¹ŸåŒ…æ‹¬é€™ä¸€å€‹éƒ¨è½æ ¼çš„æœ¬åœ°ç¨‹å¼ç¢¼ï¼Œæˆ‘ç”¨äº† google drive çš„å‚™ä»½ï¼Œå¯æƒœé‚£å¾ˆé›£ä¸‹è¼‰ï¼Œæ‰€ä»¥æˆ‘å°±ç”¨äº†githubåŸæœ¬çš„å‚™ä»½çš„æ±è¥¿ã€‚\né€™çœŸæ˜¯ä¸å¹¸ä¸­çš„å¤§å¹¸ï¼Œé‚„å¥½githubçš„å‚™ä»½ç›´æ¥ä¸‹è¼‰å°±å¯ä»¥ç›´æ¥ç”¨ï¼Œä¸ç”¨ç‰¹åˆ¥å†è¨­å®šä¸€äº›å¥‡æ€ªçš„æ±è¥¿ï¼Œä½†æ‰€æœ‰çš„ hexo æŒ‡ä»¤éƒ½ä¸è¦‹äº†ï¼Œgitçš„æŒ‡ä»¤ä¹Ÿéƒ½ä¸è¦‹äº†ï¼Œå¿…é ˆè¦é‡æ–°è¨­å®šã€‚\né€™é‚Šæœ‰ä¸€å€‹å°æ±è¥¿ï¼Œå°±æ˜¯ä¸‹é¢é€™ä¸€è¡Œè­¦å‘Šï¼Œå°±æ˜¯è¦ä½ æŠŠpushè¨­å®šæˆä½ è¦pushçš„åœ°æ–¹ï¼Œä¸ç„¶åªæ‰“ä¸€å€‹pushä»–ä¸¦ä¸æœƒçŸ¥é“è¦pushå»å“ªè£ï¼Œæ‰€ä»¥è¨­å®šä¸€ä¸‹repoçš„ä½ç½®å°±å¥½äº†ã€‚\n\ngit push â€”set-upstream origin master\n\nç•¶ç„¶é‚„æœ‰ä¸€å †bug ï¼Œåªå¥½æ…¢æ…¢çˆ¬æ–‡å˜ï¼Œç•¶ä½ çœ‹åˆ°é€™ä¸€æ®µæ–‡å­—ï¼Œä¹Ÿå°±ä»£è¡¨æˆ‘æˆåŠŸæ‰¾åˆ°è§£æ±ºè¾¦æ³•äº†ï¼\næˆ‘åˆä¾†æ›´æ–°äº†é€™å¹¾å¤©ç¶²ç«™ä¸€ç›´404 not found è¶…ç…©ï¼Œæ–¼æ˜¯æˆ‘å«å‡ºä¹‹å‰çš„æ•™å­¸å½±ç‰‡ï¼Œé‡æ–°çœ‹äº†ä¹‹å¾Œï¼Œç™¼ç¾æˆ‘çš„åˆ†æ”¯åç¨±å¼„éŒ¯äº†ï¼Œä¸æ˜¯ç”¨masterè€Œæ˜¯ç”¨gh-pagesï¼Œæäº†å¥½å¤šå¤©QQ\næ¶è¨­å¿ƒå¾—éƒ¨è½æ ¼ä»¥å¾Œæœƒå¸¸å¸¸æ›´æ–°ï¼Œæœ€è¿‘ä¹Ÿæœƒé™¸çºŒæŠŠä¹‹å‰çš„æ–‡ç« æ”¾åˆ°éƒ¨è½æ ¼ä¸Šé¢ã€‚æ•´å€‹ç¶²ç«™å¾èª•ç”Ÿåˆ°ç¾åœ¨çš„çµæœå·²ç¶“èŠ±äº†15å€‹å°æ™‚ï¼Œå…¶ä¸­åœ¨Debugçš„æ™‚é–“æ‡‰è©²ä½”äº†å¤§å¤šæ•¸ï¼\né‡åˆ°äº†å¹¾å€‹éº»ç…©çš„å•é¡Œï¼Œé¦–å…ˆç¢°åˆ°çš„æ˜¯æœ¬åœ°çš„è³‡æ–™ç„¡æ³•ä¸Šå‚³åˆ°Githubï¼Œçµ‚ç«¯æ©Ÿå†’å‡ºä¾†çš„æ˜¯ï¼šPlease make sure you have the correct access rights and the repository exists.ã€‚é€™å€‹éŒ¯èª¤è¶…ç´šç…©ï¼Œçˆ¬äº†ä¸€å †æ–‡çµæœä»–è¦åœ¨GitHubä¸Šé¢è¨­å®šsshé‡‘é‘°ä¹‹é¡çš„æ±è¥¿ï¼Œæ‰èƒ½ç²å–å¾æœ¬åœ°æ›´æ–°çš„æ¬Šé™ã€‚çµæœç¶²è·¯ä¸Šçš„æ–‡ç« èªªæˆ‘è¦é–‹å•Ÿä¸€å€‹åå«â€.sshâ€çš„è³‡æ–™å¤¾ï¼Œå¯æ˜¯æˆ‘ç¿»éäº†æˆ‘çš„é›»è…¦ä¹Ÿæ‰¾ä¸åˆ°é€™ä¸€å€‹è³‡æ–™å¤¾ï¼å¾Œä¾†æˆ‘æ˜¯åˆ©ç”¨çµ‚ç«¯æ©Ÿï¼Œè¼¸å…¥è·¯å¾‘ä½ç½®ç¡¬æ˜¯æŠŠé‚£ä¸€å€‹è³‡æ–™å¤¾æ‰“é–‹ï¼Œå®ƒæ˜¯ä¸€å€‹é€æ˜çš„è³‡æ–™å¤¾ï¼Œé‚„æ˜¯ç¬¬ä¸€æ¬¡é‡åˆ°ï¼\næ¥è‘—æ˜¯çµ‚ç«¯æ©Ÿè·‘å‡ºä¸€å †errorï¼Œé‚£æ™‚å€™çœŸçš„å·®é»å´©æ½°ï¼ŒèŠ±äº†è¶…ä¹…æ¶è¨­çš„æ±è¥¿ï¼Œç«Ÿç„¶è·‘å‡ºé€™éº¼å¤šçš„éŒ¯èª¤ï¼é›£é“å…¨éƒ¨çš„æ±è¥¿éƒ½ä»˜ä¹‹ä¸€ç‚¬äº†å—ï¼Ÿç¿»äº†æ¯ä¸€å€‹è¢«è®Šæ›´éçš„è³‡æ–™å¤¾ï¼Œæ‰ç™¼ç¾åˆ°åœ¨user_nameçš„åœ°æ–¹è¸©äº†é›·ï¼ŒæŠŠä»–è®Šå›åŸæœ¬çš„è¨­å®šå°±å¥½äº†ï¼ŒçœŸæ˜¯ä¸å¹¸ä¸­çš„å¤§å¹¸ï¼Œå¹¸å¥½æˆ‘é‚„èƒ½æŠŠæ±è¥¿æ•‘å›ä¾†ï¼\næœ€å¾Œï¼Œçµ‚æ–¼èƒ½ç”¨httpsçš„å‰ç¶´é€£åˆ°æˆ‘çš„ç¶²ç«™ï¼šhttps://peienwu.com ã€‚å¦‚æœè¦æ‰“wwwé–‹é ­ä¹Ÿæ˜¯å¯ä»¥é€£å¾—ä¸Šï¼Œç›´æ¥æ‰“ peienwu.com ä¹Ÿå¯ä»¥é †åˆ©é€£ä¸Šï¼\n","categories":["å…¶ä»–"],"tags":["å€‹äººéƒ¨è½æ ¼","ç¶²ç«™æ¶è¨­"]},{"title":"æ©¢åœ“è»Œé“ä¸Šè¡Œæ˜Ÿåˆ°å¤ªé™½å¹³å‡è·é›¢","url":"/Gravity2/","content":"ç°¡ä»‹å…‹åœå‹’ç¬¬ä¸‰é‹å‹•å®šå¾‹èªªæ˜å…¬è½‰é€±æœŸçš„å¹³æ–¹èˆ‡è¡Œæ˜Ÿåˆ°å¤ªé™½çš„å¹³å‡è·é›¢ä¸‰æ¬¡æ–¹æˆæ­£æ¯”ã€‚è‹¥æ˜¯è¡Œæ˜Ÿä»¥æ©¢åœ“è»Œé“ç¹è¡Œå¤ªé™½ï¼Œå‰‡è¡Œæ˜Ÿåˆ°å¤ªé™½çš„å¹³å‡è·é›¢ $\\overline d$ æœƒæ˜¯è¿‘æ—¥é»è· $r_1$ åŠ ä¸Šé æ—¥é»è· $r_2$ çš„å¹³å‡ï¼Œä¹Ÿå°±æ˜¯æ©¢åœ“çš„åŠé•·è»¸ï¼Œè®“æˆ‘ååˆ†å¥½å¥‡è©²å¦‚ä½•è­‰æ˜é€™ä»¶äº‹ï¼\n\\overline d = \\frac{r_1+r_2}{2} = aæ‰€è¦åšçš„æ˜¯å°±æ˜¯å°‡æ©¢åœ“åœ“å‘¨ä¸Šçš„æ¯ä¸€é»ï¼Œåˆ°å¤ªé™½çš„è·é›¢é€²è¡Œç©åˆ†å¾Œå–å¹³å‡ã€‚\n\n\næ•¸å­¸è­‰æ˜å®šç¾©é€£çºŒå‡½æ•¸$f(x)$åœ¨$[a,b]$å€é–“ä¸Šçš„å¹³å‡å€¼ç‚ºï¼š\nf_{ave} = \\frac{1}{b-a}\\int_{a}^{b} f(x) dxåœ¨ä¸€å€‹ä»¥åŸé»ç‚ºä¸­å¿ƒçš„æ©¢åœ“å‘¨ä¸Šæœ‰ä¸€é»$P$ï¼Œå…¶åƒæ•¸å¼å¯ä»¥è¡¨ç¤ºæˆ$P(a\\cos\\theta,b\\sin\\theta)$ï¼Œå…¶ä¸­ $a,b$ ç‚ºåŠé•·è»¸ã€åŠçŸ­è»¸ã€‚ä»¤å¤ªé™½çš„åº§æ¨™ç‚ºæ©¢åœ“çš„å…¶ä¸­ä¸€å€‹ç„¦é»$S(-c,0)$ï¼Œå¦‚ä¸‹åœ–ï¼š\n\nå‰‡æ©¢åœ“å‘¨ä¸Šæ¯ä¸€é»$P$åˆ°å¤ªé™½$S$çš„è·é›¢å¯ä»¥è¡¨ç¤ºç‚ºï¼š\nf(x) = \\overline{PS} = \\sqrt{(a\\cos(x)+c)^2+(b\\sin( x))^2}å¦‚æ­¤ä¸€ä¾†å°±å¯ä»¥å°$f(\\theta)$åœ¨$[0,2\\pi]$å€é–“å…§å–å¹³å‡å€¼ï¼š\n\\begin{align}f_{ave} &= \\frac{1}{2\\pi}\\int_0^{2\\pi} f(x)dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{\\sqrt{(a\\cos(x)+c)^2+(b\\sin(x))^2}}\\ dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{\\sqrt{a^2\\cos^2(x)+2ac\\cdot\\cos(x)+(a^2-c^2)\\cdot\\sin^2(x)+c^2}\\ }dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{\\sqrt{c^2\\cos^2(x)+2ac\\cos(x)+a^2}}\\ dx\\\\\n&=\\frac{1}{2\\pi}\\int_0^{2\\pi}{(c\\cdot\\cos(x)+a)}\\ dx\\\\\n&=\\frac{1}{2\\pi}[c\\int_0^{2\\pi}{\\cos(x)}\\ dx+\\int_0^{2\\pi}a\\ dx]\\\\\n&=\\frac{1}{2\\pi}\\cdot(0 + 2\\pi a)\\\\\n&=a\n\\end{align}å¾—è­‰æ©¢åœ“è»Œé“ä¸Šåœ°çƒåˆ°å¤ªé™½çš„å¹³å‡è·é›¢ç‚ºåŠè»¸é•·ï¼\nç¨‹å¼å¯¦ä½œé€™æ¬¡ä¸»è¦æ˜¯ä»¥ç¨‹å¼å¯¦ä½œç©åˆ†ï¼Œé€éå°‡è§’åº¦åˆ‡æˆå¾ˆå°å¡Šå†ç–ŠåŠ èµ·ä¾†å–å¹³å‡ï¼Œå¾—åˆ°å‡½æ•¸çš„å¹³å‡å€¼ã€‚ä»¥ä¸‹å½±ç‰‡ä¸­çš„æ©¢åœ“$a = 13,b = 5,c = 12$ï¼Œé€éå°‡è§’åº¦åˆ‡æˆ30åº¦ã€15åº¦ã€1åº¦ã€0.5åº¦è§€å¯Ÿç–ŠåŠ çš„ç‹€æ³ã€‚\nè§’åº¦ = 30åº¦\n\nè§’åº¦ = 15åº¦\n\nè§’åº¦ = 1åº¦\n\nè§’åº¦ = 0.5åº¦\n\né€™å››å€‹å½±ç‰‡åŠ èµ·ä¾†çš„å¹³å‡å€¼éƒ½æ˜¯åŠé•·è»¸$a$ï¼\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","ç‰©ç†ç­†è¨˜"]},{"title":"è¬æœ‰å¼•åŠ›èˆ‡å››æ˜Ÿé‹å‹•ä¹‹æ¢è¨","url":"/Gravity1/","content":"æ­¤æ–‡å°‡å¾è¬æœ‰å¼•åŠ›å®šå¾‹é–‹å§‹ï¼Œåœ¨åªè€ƒæ…®è¬æœ‰å¼•åŠ›çš„ç‹€æ³ä¸‹ï¼Œæ¢è¨è¡›æ˜Ÿé‹å‹•ã€é›™æ˜Ÿé‹å‹•ã€ä¸‰æ˜Ÿé‹å‹•ã€å››æ˜Ÿç³»çµ±ç”šè‡³æ˜¯Né«”å•é¡Œçš„è»Œè·¡èˆ‡é‹å‹•æ¨¡å¼ä¸¦é€²è¡Œæ¨¡æ“¬ï¼Œä¸¦é€²è¡Œç†è«–çš„é©—è­‰ã€‚\næ¨¡æ“¬é€£çµï¼šé»é€™è£¡\nç†è«–èˆ‡æ•¸å­¸è¬æœ‰å¼•åŠ›å®šå¾‹ç‰›é “æ–¼1687å¹´æå‡ºï¼šã€Œä»»ä½•å…©å€‹è³ªé»ä¹‹é–“å¿…æœ‰ä¸€å¸å¼•åŠ›Fï¼Œå…¶é‡å€¼å’Œå…©è³ªé‡çš„ä¹˜ç©æˆæ­£æ¯”ï¼Œå’Œå®ƒå€‘ä¹‹é–“çš„è·é›¢å¹³æ–¹æˆåæ¯”ï¼Œå…¶æ–¹å‘åœ¨é€£å¿ƒç·šä¸Šã€‚ã€\n\nF = \\frac{GMm}{r^2}\nåœ“å‘¨é‹å‹•å…¬å¼é«˜ä¸­é¸ä¿®ç‰©ç†æåˆ°ï¼Œä¸€å€‹è³ªé‡ç‚º$m$çš„ç‰©é«”ä»¥åŠå¾‘$R$ç¹è‘—åœ“å¿ƒæ—‹è½‰ï¼Œè§’é€Ÿåº¦ç‚º$\\omega$ï¼Œå…¶é€Ÿåº¦$v$ã€åŠ é€Ÿåº¦$a$èˆ‡é€±æœŸ$T$æœ‰ä»¥ä¸‹å…¬å¼ï¼Œåœ¨åˆ†æè¡›æ˜Ÿé‹å‹•åŠå¤šé«”é‹å‹•ä¸­æœƒå¸¸å¸¸ç”¨åˆ°ã€‚åœ¨è¡Œæ˜Ÿé‹å‹•ç•¶ä¸­ï¼Œå°±æ˜¯ä»¥å½¼æ­¤é–“çš„è¬æœ‰å¼•åŠ›ç•¶ä½œå‘å¿ƒåŠ›ï¼Œé€²è¡Œåœ“å‘¨é‹å‹•ã€‚\n\n\\begin{align}\\omega &= \\frac{\\Delta\\theta}{\\Delta t} = \\frac{2\\pi}{T}\n\\\\v &= R\\omega = \\frac{2\\pi R}{T}\n\\\\a &= R\\omega^2 =\\frac{v^2}{R} =\\frac{4\\pi^2 R}{T^2}\\end{align}æ©¢åœ“æ€§è³ªä¸€å€‹æ©¢åœ“å…·æœ‰å…©å€‹ç„¦é»åˆ†åˆ¥æ˜¯ä¸‹åœ–çš„$F_1,F_2$ï¼Œå…¶å®šç¾©å°±æ˜¯æ©¢åœ“ä¸Šä»»ä¸€é»$P$åˆ°å…©ç„¦é»çš„è·é›¢å’Œå›ºå®šï¼Œä¹Ÿå°±æ˜¯$\\overline{PF_1}+\\overline{PF_1} = K$ï¼Œ$K$ç‚ºå®šå€¼ã€‚ä¸‹åœ–ä¸­ï¼Œ$a$ç‚ºåŠé•·è»¸ï¼Œ$b$ç‚ºåŠçŸ­è»¸ï¼Œæ»¿è¶³ $a^2 = b^2+c^2$ï¼Œé¢ç©ç‚º $\\pi ab$ã€‚æˆ‘å€‘å®šç¾©äº†ä¸€å€‹æ±ºå®šæ©¢åœ“æ‰å¹³ç¨‹åº¦åå¿ƒç‡ $e = \\frac{c}{a}&lt;1$ï¼Œåå¿ƒç‡æ„ˆå¤§ï¼Œæ©¢åœ“æ„ˆæ‰å¹³ã€‚\n\nä¹Ÿå¯ä»¥èªªï¼Œåœ“å°±æ˜¯ä¸€å€‹æ©¢åœ“çš„ç‰¹ä¾‹ï¼Œç•¶$F_1,F_2$é‡åˆåœ¨ä¸€é»çš„æ™‚å€™å°±è®Šæˆäº†ä¸€å€‹æ­£åœ“ã€‚åŒæ™‚ï¼Œæ©¢åœ“è»Œè·¡èƒ½ç”¨ä»¥ä¸‹æ–¹ç¨‹å¼èªªæ˜ï¼ˆå¯ç”¨è·é›¢å…¬å¼è­‰æ˜ï¼‰ï¼š\n\\frac{x^2}{a^2}+\\frac{y^2}{b^2} = 1å¹³æ–¹ç›¸åŠ å®¹æ˜“è¯æƒ³åˆ°ä¸‰è§’å‡½æ•¸çš„å¹³æ–¹é—œä¿‚ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥å‡è¨­ $x = a\\cos\\theta,y = b\\sin\\theta$ï¼Œå¦‚æ­¤ä¸€ä¾†å¹³æ–¹ç›¸åŠ å¯å¾—è­‰ã€‚ç”±æ­¤å¯çŸ¥ï¼Œå°æ–¼ä¸€å€‹ä¸­å¿ƒé»ç‚º$(h,k)$çš„æ©¢åœ“è€Œè¨€ï¼Œå…¶åƒæ•¸å¼ç‚ºï¼š\n\\left\\{\\begin{aligned} x &= h+a\\cos\\theta\n\\\\y &= k+b\\cos\\theta\\end{aligned}\\right.-\\piâ‰¤\\thetaâ‰¤\\piå…‹æ™®å‹’ä¸‰å¤§è¡Œæ˜Ÿé‹å‹•å®šå¾‹å…‹æ™®å‹’æå‡ºäº†è¡Œæ˜Ÿä¸‰å¤§é‹å‹•å®šå¾‹ï¼Œåˆ†åˆ¥ç‚ºï¼š\n\nè»Œé“å®šå¾‹ï¼šæ‰€æœ‰è¡Œæ˜Ÿå„ä»¥å¤ªé™½ç‚ºç„¦é»çš„æ©¢åœ“å½¢è»Œé“ä¸Šé‹å‹•ã€‚\né¢ç©å®šå¾‹ï¼šå¤ªé™½èˆ‡è¡Œæ˜Ÿçš„é€£ç·šåœ¨ç›¸åŒæ™‚é–“é–“éš”å…§æƒéç›¸ç­‰çš„é¢ç©ã€‚\né€±æœŸå®šå¾‹ï¼šå„è¡Œæ˜Ÿç¹è¡ŒåŒä¸€æ†æ˜Ÿï¼Œå…¶å…¬è½‰é€±æœŸçš„å¹³æ–¹èˆ‡è¡Œæ˜Ÿåˆ°å¤ªé™½å¹³å‡è·é›¢çš„ä¸‰æ¬¡æ–¹æˆæ­£æ¯”ã€‚\n\nä¸‹é¢ä¸»è¦æœƒç”¨åˆ°çš„æ˜¯ç¬¬ä¸€å’Œç¬¬äºŒå®šå¾‹ï¼Œä»¥åŠå…¬å¼ $r_Av_A = r_Bv_B$é€²è¡Œè­‰æ˜ã€‚\n\nåŠ›å­¸èƒ½å®ˆæ†å®šå¾‹ä¸€å€‹è³ªé‡ç‚º$m$çš„ç‰©é«”ä»¥é€Ÿåº¦$v$å‰é€²ï¼Œèˆ‡åœ°å¿ƒç›¸è·$r$ï¼Œå‰‡è©²ç‰©é«”çš„å‹•èƒ½èˆ‡è©²è™•çš„é‡åŠ›ä½èƒ½ç‚ºï¼š\n\\begin{align}E_k &= \\frac{1}{2}mv^2\\\\U &= -\\frac{GMm}{r}\\end{align}åœ¨ç³»çµ±åªæœ‰ä¿å®ˆåŠ›åšåŠŸä¸‹ï¼Œå…¶åŠ›å­¸èƒ½ä¿æŒä¸è®Šã€‚åœ¨åˆ†æä»¥åŠå¾‘$r$çš„ç­‰é€Ÿç‡åœ“å‘¨é‹å‹•çš„éç¨‹ä¸­ï¼Œå…¶åŠ›å­¸èƒ½å¯ä»¥è¡¨ç¤ºç‚ºï¼š\nE = U+E_k = \\frac{-GMm}{r}+\\frac{1}{2}m\\frac{GM}{r} = \\frac{-GMm}{2r}ç”±æ­¤æˆ‘å€‘å¯ä»¥å¾—åˆ°ï¼š\nE_k = \\frac{-1}{2}Uè¡Œæ˜Ÿèˆ‡äººé€ è¡›æ˜Ÿé‹å‹•ç†è«–èˆ‡æ•¸å­¸è¡›æ˜Ÿè³ªé‡$m$ä»¥è»Œé“åŠå¾‘$r$ç¹è³ªé‡ç‚º$M$çš„è¡Œæ˜Ÿè¡Œç­‰é€Ÿç‡åœ“å‘¨é‹å‹•ï¼Œå…¶è¬æœ‰å¼•åŠ›æ†æŒ‡å‘$M$çƒå¿ƒï¼Œä½œç‚ºåœ“å‘¨é‹å‹•æ‰€éœ€è¦çš„å‘å¿ƒåŠ›ã€‚\nF = \\frac{GMm}{r^2} = ma_c = m\\frac{v^2}{r}ç”±æ­¤å¯çŸ¥ï¼Œç•¶æœ‰ä¸€å€‹ç‰©é«”è³ªé‡$m$åœ¨è·é›¢è¡Œæ˜Ÿ$r$è™•è¡Œç­‰é€Ÿç‡åœ“å‘¨é‹å‹•ï¼Œå…¶é€Ÿåº¦å¤§å°$v = \\sqrt{\\frac{GM}{r}}$ï¼Œé€Ÿåº¦æ–¹å‘èˆ‡å‘å¿ƒåŠ›æ–¹å‘å‚ç›´ã€‚åœ¨æ¨¡æ“¬éç¨‹ä¸­ï¼Œæœ‰å…©å€‹å¾ˆé‡è¦çš„è¦ç´ ï¼Œåˆ†åˆ¥æ˜¯åˆå§‹çš„é€Ÿåº¦å¤§å°ã€ä»¥åŠé€Ÿåº¦çš„æ–¹å‘ï¼Œæœ‰äº†é€™å…©å€‹æ±è¥¿ä»¥å¾Œï¼Œå°±èƒ½è®“é›»è…¦ä»¥å½¼æ­¤ä¹‹é–“çš„è¬æœ‰å¼•åŠ›é€²è¡Œæ¨¡æ“¬ã€‚\næ©¢åœ“è»Œé“èˆ‡é‹å‹•è»Œè·¡æ–¹ç¨‹å¼åœ¨å¯¦ä½œçš„éç¨‹ä¸­ï¼Œæˆ‘ç™¼ç¾åˆ°ç•¶é€Ÿåº¦ $v$ æ¯”$\\sqrt{\\frac{GM}{r}}$å¤§ä¸€é»æˆ–å°ä¸€é»æ™‚ï¼Œè·‘å‡ºä¾†çš„è»Œè·¡å°±ä¸æœƒæ˜¯æ­£åœ“è€Œæ˜¯æ©¢åœ“ï¼Œè®“æˆ‘ååˆ†å¥½å¥‡èƒ½å¦åœ¨çµ¦å®šä¸€å€‹é€Ÿåº¦çš„æƒ…æ³ä¸‹ï¼Œè¨ˆç®—å‡ºæ©¢åœ“è»Œè·¡æ–¹ç¨‹å¼ã€‚\nä¸‹åœ–æ˜¯åˆå§‹ç‹€æ…‹çš„è¨­å®šï¼Œç™½çƒè³ªé‡$M$ã€ä½ç½®ç‚ºåŸé»ã€ç´…çƒè³ªé‡$m$ï¼Œç´…çƒè·é›¢ç™½çƒ$H$ã€åˆå§‹é€Ÿåº¦$v=k\\sqrt{\\frac{GM}{H}}$å‚ç›´å‘ä¸Šï¼Œé€éèª¿æ•´$k$çš„å¤§å°ï¼Œé æ¸¬å…¶é‹å‹•è»Œè·¡ã€‚é¡¯ç„¶ï¼Œç•¶$k = 1$æ™‚è»Œè·¡æœƒæ˜¯æ­£åœ“å½¢ï¼Œ$k1$å‰‡æ˜¯åˆ†åˆ¥ä»¥Hç‚ºè¿‘æ—¥é»ã€é æ—¥é»åŠå¾‘çš„æ©¢åœ“ã€‚\n\nè‹¥è¿‘æ—¥é»è·ç‚º$r_1$ã€é æ—¥é»è·ç‚º$r_2$ï¼ŒåŠè»¸é•·$a = \\frac{r_1+r_2}{2}$ï¼Œæ ¹æ“šé æ—¥é»ä»¥åŠè¿‘æ—¥é»çš„åŠ›å­¸èƒ½å®ˆæ†ä»¥åŠå…‹åœå‹’ç¬¬äºŒå®šå¾‹ï¼Œå¯ä»¥åˆ—å‡ºä»¥ä¸‹å…©å¼ï¼š\n\\begin{aligned}\\frac{1}{2}mv_1^2 - \\frac{GMm}{r_1} &= \\frac{1}{2}mv_2^2 - \\frac{GMm}{r_2}\\\\\\\\\n\\frac{\\pi ab}{T} = \\frac{1}{2}r_1v_1 &= \\frac{1}{2}r_2v_2\\end{aligned}å°‡äºŒå¼å¸¶å…¥ä¸€å¼å¯å¾—ï¼š\n(r_1v_1)^2 = \\frac{GMr_1r_2}{\\frac{1}{2}(r_1+r_2)} =\n\\frac{GM(a+c)(a-c)}{a} = \\frac{GMb^2}{a}å¸¶å…¥æˆ‘å€‘çš„åˆå§‹é€Ÿåº¦èˆ‡è¿‘ã€é æ—¥é»è·ï¼š\n(H\\cdot k\\sqrt{\\frac{GM}{H}})^2 = k^2GMH=\\frac{GMb^2}{a}ä¸Šé¢æ˜¯ç¬¬ä¸€å¼ï¼Œé‚„æœ‰å…©æ¢æ¯”è¼ƒé¡¯è€Œæ˜“è¦‹çš„å…©æ¢æ–¹ç¨‹å¼ï¼Œç¸½å…±ç”¨ä¸‰æ¢æ–¹ç¨‹å¼è§£ä¸‰å€‹æœªçŸ¥æ•¸ï¼š\n\\left\\{\\begin{aligned} \\frac{b^2}{a} &= k^2H\n\\\\a^2 &= b^2+c^2\n\\\\a &= H-c\\end{aligned}\\right.å°‡ä¸‰å¼å¸¶å…¥äºŒå¼æ¶ˆå»$c$ï¼Œå¾—åˆ°ï¼š\n\\left\\{\\begin{aligned} a &= \\frac{H}{2-k^2}\n\\\\b &= \\sqrt{aHk^2}\\end{aligned}\\right.æœ‰äº†$a,b$ä¹‹å¾Œï¼Œå°±å¯ä»¥å›æ¨é€±æœŸï¼š\n\\begin{aligned}\\frac{\\pi ab}{T} &= \\frac{1}{2}r_1v_1\n\\\\\\\\\\Longrightarrow \\ T &= \\frac{2\\pi ab}{r_1v_1}\\end{aligned}æœ€å¾Œï¼Œå°±å¯ä»¥ç”¨æ©¢åœ“åƒæ•¸å¼ç•«å‡ºè»Œè·¡ï¼Œä¸¦ä¸”å®Œå…¨å»åˆç´…çƒçš„é‹å‹•è»Œè·¡ï¼\nç¨‹å¼å¯¦ä½œç¨‹å¼é€£çµï¼šé»é€™è£¡\nåˆ†åˆ¥å°‡$k$å¸¶å…¥ä¸åŒæ•¸å€¼ï¼Œè§€å¯Ÿè»Œè·¡çš„è®ŠåŒ–ã€‚å·¦é‚Šç‚ºæ¨¡æ“¬çš„ç‹€æ³ï¼Œå³é‚Šå‰‡æ˜¯ç´…çƒå‹•èƒ½ï¼ˆé»‘ç·šï¼‰ã€ä½èƒ½ï¼ˆç¶ ç·šï¼‰ä»¥åŠåŠ›å­¸èƒ½ï¼ˆç´…ç·šï¼‰å¤§å°ï¼Œç”±æ–¼åªæœ‰ä¿å®ˆåŠ›åšåŠŸï¼Œå…¶åŠ›å­¸èƒ½ç¸½å’Œä¿æŒä¸è®Šã€‚åˆå§‹ç‹€æ…‹å¦‚ä¸‹ï¼š$M = 10,m = 1,H = 5$ã€‚\nK = 0.6ä»£å…¥\n\\left\\{\\begin{aligned}\na &= 3.0488\n\\\\b &= 2.3426\n\\\\c &= 1.9512\\\n\\\\T &= 4.0955\\end{aligned}\\right.K = 1ä»£å…¥\n\\left\\{\\begin{aligned}\na &= 5.0000\n\\\\b &= 5.0000\n\\\\c &= 0.0000\n\\\\T &= 8.6015\\end{aligned}\\right.K = 1.3ä»£å…¥\n\\left\\{\\begin{aligned}\na &= 16.1290\n\\\\b &= 11.6743\n\\\\c &= 11.1290\n\\\\T &= 49.8344\\end{aligned}\\right.K = 2ä»£å…¥\n\\left\\{\\begin{aligned}\na &= -2.5000\n\\\\b &= nan\n\\\\c &= nan\n\\\\T &= nan\\end{aligned}\\right.é€™ç¨®æƒ…æ³æ˜¯ç´…çƒè„«é›¢äº†é»‘çƒçš„é‡åŠ›æŸç¸›ï¼Œä¸€å»ä¸å¾©è¿”ã€‚å¯ä»¥çœ‹åˆ°ï¼Œå‹•èƒ½èˆ‡ä½èƒ½å‘ˆç¾å°ç¨±ç¸®å°çš„ç‹€æ³ï¼Œå‹•èƒ½é€æ¼¸è¶¨è¿‘æ–¼ç¸½åŠ›å­¸èƒ½ï¼Œè€Œé‡åŠ›ä½èƒ½é€æ¼¸è¶¨è¿‘æ–¼é›¶ã€‚\né€™è£¡ç™¼ç”Ÿäº†ä¸€å€‹æœ‰è¶£çš„ç¾è±¡ï¼Œç•¶æˆ‘æŠŠ$k$ç¹¼çºŒèª¿å°åˆ°è¶³å¤ å°ï¼Œç´…çƒæœƒç¹è¡Œä¸€å€‹éå¸¸æ‰å¹³çš„æ©¢åœ“è»Œè·¡ï¼Œåœ¨ç¾å¯¦ä¸–ç•Œä¸­ä¹Ÿå°±æ˜¯ç´…çƒæ’ä¸Šç™½çƒçš„æ„Ÿè¦ºã€‚\nåä¹‹ï¼Œç•¶æˆ‘æŠŠ$k$ç¹¼çºŒå¾€ä¸Šèª¿å¤§æ™‚ï¼Œæœƒç™¼ç¾ç´…çƒè„«é›¢äº†ç™½çƒçš„é‡åŠ›å ´è€Œä¸€å»ä¸å¾©è¿”ï¼Œæˆ‘è©¦è‘—æ‰¾å‡ºé€™å€‹è‡¨ç•Œå€¼ï¼Œå¾æˆ‘å€‘ä¸Šé¢çš„æ¨å°å¯çŸ¥$a = H/(2-k^2),b = \\sqrt{aHk^2}$ï¼Œç•¶$k&gt;\\sqrt{2}$æ™‚ï¼Œ$b$ç„¡è§£ï¼Œä¹Ÿå°±ä»£è¡¨é€™æ¨£çš„æ©¢åœ“å½¢è»Œè·¡æ˜¯ä¸å­˜åœ¨çš„ã€‚æ›å¥è©±èªªï¼Œç•¶$v&gt;\\sqrt 2\\cdot\\sqrt{\\frac{GM}{H}}$æ™‚ï¼Œç´…çƒæœƒæ“ºè„«ç™½çƒé‡åŠ›çš„å½±éŸ¿ï¼Œä¹Ÿå°±æ˜¯ç¬¬äºŒå®‡å®™é€Ÿåº¦æˆ–è„«é›¢é€Ÿåº¦ã€‚\nç”±æ­¤å¯çŸ¥ï¼Œ$|k|&lt;\\sqrt 2$ã€‚\n\n            ç¬¬äºŒå®‡å®™é€Ÿåº¦æˆ–è„«é›¢é€Ÿåº¦æ˜¯æŒ‡åœ¨åœ°çƒä¸Šç™¼å°„çš„ç‰©é«”æ“ºè„«åœ°çƒé‡åŠ›æŸç¸›ï¼Œé£›é›¢åœ°çƒæ‰€éœ€çš„æœ€å°åˆå§‹é€Ÿåº¦ã€‚å‡è¨­è³ªé‡$m$çš„ç‰©é«”é€Ÿåº¦ç‚º$v$ï¼Œå‰‡å¦‚æœè¦æ“ºè„«åœ°çƒé‡åŠ›çš„æŸç¸›ï¼Œå…¶å‹•èƒ½è¦å¤§æ–¼å…¶é‡åŠ›ä½èƒ½ï¼Œå–æœ€å°å€¼å°±æ˜¯å…©è€…ç›¸ç­‰ï¼Œå› æ­¤ï¼š\\frac{1}{2}mv^2 =\\frac{GMm}{r}å¾—åˆ°è„«é›¢é€Ÿåº¦ï¼šv = \\sqrt{\\frac{2GM}{r}}\n          \nå¾ˆå·§çš„æ˜¯ï¼Œæˆ‘å€‘å¯ä»¥å¾æ©¢åœ“åŠçŸ­è»¸é•·çš„ç„¡è§£æ¨å‡ºè„«é›¢é€Ÿåº¦ï¼Œä¹Ÿèƒ½å¾åŠ›å­¸èƒ½çš„æ–¹å‘è§’åº¦åˆ‡å…¥ï¼Œå¾—åˆ°ä¸€æ¨£çš„çµæœï¼Œå¯è¬‚æ®Šé€”åŒæ­¸ï¼\né›™æ˜Ÿé‹å‹•è§€å¯Ÿå…©å€‹è³ªé‡åˆ†åˆ¥ç‚º$m1,m2$çš„ç‰©é«”ï¼Œç¹è‘—å½¼æ­¤çš„è³ªå¿ƒé€²è¡Œé€±æœŸé‹å‹•ã€‚\n\nç†è«–èˆ‡æ•¸å­¸ä»¤å…©ç‰©é«”å½¼æ­¤é–“è·é›¢ç‚º$d$ï¼Œå‰‡æœ‰ä»¥ä¸‹çš„æ•¸å­¸é—œä¿‚å¼ï¼š\n\n\n\n\n\nm_1\nm_2\n\n\n\n\nè»Œé“åŠå¾‘\nr_1 = \\frac{m_2}{m_1+m_2}\\cdot d\nr_2 = \\frac{m_1}{m_1+m_2}\\cdot d\n\n\nå‘å¿ƒåŠ é€Ÿåº¦\na_1 = \\frac{Gm_2}{d^2}\na_2 = \\frac{Gm_1}{d^2}\n\n\nè»Œé“é€Ÿç‡\nv_1 = m_2\\sqrt{\\frac{G}{d(m_1+m_2)}}\nv_2 = m_1\\sqrt{\\frac{G}{d(m_1+m_2)}}\n\n\n\n\næ¨¡æ“¬å¯¦ä½œæ¨¡æ“¬é€£çµï¼šé»é€™è£¡\næ­£åœ“é›™æ˜Ÿé‹å‹•æ­£åœ“å½¢çš„è»Œé“ä¸­ï¼Œè»Œé“åŠå¾‘èˆ‡å…¶è³ªé‡å‘ˆåæ¯”ã€‚\n\n\\left\\{\\begin{aligned}\nm1 &= 3.0000\\\\\nm2 &= 1.0000\\\\\nv1 &= 0.7455\\\\\nv2 &= 2.2366\\\\\\end{aligned}\\right.æ©¢åœ“é›™æ˜Ÿé‹å‹•ï¼ˆè³ªé‡ä¸åŒï¼‰æ©¢åœ“å½¢çš„è»Œé“ä¸­ï¼Œè»Œé“åŠå¾‘ä¹Ÿæœƒèˆ‡å…¶è³ªé‡å‘ˆåæ¯”ï¼ˆæ­¤è»Œé“åŠå¾‘å¯ä»¥å®šç¾©ç‚ºåŠè»¸é•·ï¼Œç”±å¾®ç©åˆ†å¯å¾—è­‰ï¼‰ã€‚\n\n\\left\\{\\begin{aligned}\nm1 &= 3.0000\\\\\nm2 &= 1.0000\\\\\nv1 &= 0.3728\\\\\nv2 &= 1.1183\\\\\\end{aligned}\\right.æ©¢åœ“é›™æ˜Ÿé‹å‹•ï¼ˆè³ªé‡ç›¸åŒï¼‰\n\\left\\{\\begin{aligned}\nm1 &= 1.0000\\\\\nm2 &= 1.0000\\\\\nv1 &= 0.5272\\\\\nv2 &= 0.5272\\\\\\end{aligned}\\right.ä¸‰æ˜Ÿé‹å‹•å†ç ”ç©¶å¤©é«”åŠ›å­¸ä¸Šï¼Œé›™æ˜Ÿå•é¡Œï¼ˆTwo-Body Problemï¼‰æ˜¯å·²ç¶“è¢«è­‰æ˜æœ‰ç²¾ç¢ºè§£ï¼Œä½†å°æ–¼ä¸‰é«”å•é¡Œï¼ˆThree-body problemï¼‰ç”šè‡³æ˜¯å¤šé«”å•é¡Œï¼ˆN-body problemï¼‰å•é¡Œå°±è®Šå¾—ç‰¹åˆ¥è¤‡é›œï¼Œé™¤ç‰¹åˆ¥æ¡ˆä¾‹ä»¥å¤–ï¼Œä¸¦æ²’æœ‰è¾¦æ³•èƒ½ç²¾ç¢ºæè¿°å„ç‰©é«”é‹å‹•çš„è¡Œç‚ºã€‚å„˜ç®¡å¦‚æ­¤ï¼Œæ­¤ç³»çµ±é‚„æ˜¯æœƒéµå®ˆå‹•é‡å®ˆæ†ï¼Œå…¶è³ªå¿ƒä¸æœƒç§»å‹•ã€‚\nä¸‰æ˜Ÿå•é¡Œå›°é›£çš„åœ°æ–¹åœ¨æ–¼ï¼Œå¾€å¾€åˆå§‹éå¸¸å¾®å°çš„èª¤å·®ï¼Œå°±æœ‰å¯èƒ½é€ æˆä¹‹å¾Œå®Œå…¨ä¸åŒçš„çµæœï¼Œè®Šå¾—æ··äº‚è€Œä¸å¯é æ¸¬ï¼Œä¹Ÿå°±æ˜¯æ··æ²Œç‹€æ…‹ã€‚\nç†è«–èˆ‡æ•¸å­¸ç”±æ–¼ä¸‰é«”å•é¡Œéæ–¼è¤‡é›œï¼Œæˆ‘å€‘ç°¡åŒ–æˆå°‡ä¸‰å€‹ç‰©é«”çš„è³ªé‡éƒ½è¨­ç‚º$m$ï¼Œæ”¾åœ¨é‚Šé•·ç‚º$L$çš„æ­£ä¸‰è§’å½¢ä¸‰å€‹é ‚é»ä¸Šï¼Œèˆ‡è³ªå¿ƒè·é›¢$r = \\frac{\\sqrt3}{3}L$ï¼Œå‰‡å½¼æ­¤é–“çš„è¬æœ‰å¼•åŠ›å–é¤˜å¼¦å°‡ä½œç‚ºç¹è³ªå¿ƒæ—‹è½‰æ‰€éœ€è¦çš„å‘å¿ƒåŠ›ï¼š\n\\sqrt 3\\frac{Gm^2}{L^2} = ma_c = m\\frac{v^2}{r} = m\\frac{4\\pi^2r}{T}å¯å¾—åˆ°ä»¥ä¸‹ï¼š\n\\left\\{\\begin{aligned}\nv &= \\sqrt{\\frac{Gm}{L}}\\\\\nT &= 2\\pi\\sqrt{\\frac{L^3}{G(3m)}}\n\\end{aligned}\\right.æ­£åœ“è»Œè·¡ä¸‰æ˜Ÿé‹å‹•æ¨¡æ“¬æ¨¡æ“¬é€£çµï¼šé»é€™è£¡\næ­£ä¸‰è§’å½¢çš„ä¸‰å€‹é ‚é»ä»¥ç›¸å°ä½ç½®å›ºå®šã€å…±åŒè³ªå¿ƒç‚ºæ—‹è½‰ä¸­å¿ƒé€²è¡Œæ—‹è½‰ã€‚é€éå½¼æ­¤çš„è¬æœ‰å¼•åŠ›é¤˜å¼¦çµæœç•¶ä½œå‘å¿ƒåŠ›ï¼Œè¨­å®šå¥½åˆå§‹é€Ÿåº¦å¤§å°èˆ‡æ–¹å‘ï¼ˆåˆ†åˆ¥åœ¨90åº¦ã€210åº¦ã€300åº¦ï¼‰ï¼Œå°±èƒ½è®“é›»è…¦å®Œæˆå‰©ä¸‹çš„å·¥ä½œï¼\n\næ©¢åœ“è»Œè·¡ä¸‰æ˜Ÿé‹å‹•æ¨¡æ“¬æ¨¡æ“¬é€£çµï¼šé»é€™è£¡å½±ç‰‡é€£çµï¼šé»é€™è£¡\næ­¤ç‚ºä¸ç©©å®šçš„æ¨¡æ“¬ï¼Œä¹Ÿå°±æ˜¯èªªåœ¨ä¸€æ®µæ™‚é–“éå¾Œï¼Œæ•´å€‹ç³»çµ±æœƒå¤±åºï¼Œå‘ˆç¾æ··äº‚çš„ç‹€æ…‹ã€‚\n\nå…¶ä»–è»Œè·¡çš„ä¸‰æ˜Ÿé‹å‹•å…¶ä»–ä¸‰é«”äº’ç¹çš„è»Œè·¡å¦‚å…«å­—å‹ï¼Œå°±è¢«è­‰æ˜å‡ºä¾†æ˜¯ä¸€å€‹ç©©å®šçš„é‹å‹•æ¨¡å¼ã€‚\n\nä»¥åŠè¡›æ˜Ÿçš„äº”å€‹æ‹‰æ ¼æœ—æ—¥é»ï¼Œå¯ä»¥åœ¨ä¸‹åœ–äº”å€‹ä½ç½®æ”¾å…¥ç¬¬ä¸‰å€‹ä¸è€ƒæ…®å…¶è³ªé‡çš„ç‰©é«”ï¼Œä½¿å…¶èˆ‡å…¶ä»–æ˜Ÿé«”çš„ç›¸å°ä½ç½®ä¸è®Šã€‚\n\nå››æ˜Ÿé‹å‹•åœ¨ä¸€å ‚ç‰©ç†èª²ï¼Œè€å¸«æ•™åˆ°ä¸‰æ˜Ÿç³»çµ±æ™‚ï¼Œé †ä¾¿æåŠäº†å››æ˜Ÿé‹å‹•æ‡‰è©²ä»¥ä»€éº¼æ¨£çš„æ€§ç‹€ã€ä»€éº¼æ–¹å¼é‹å‹•ã€‚è‹¥è¦ä¿æŒå››å€‹ç‰©é«”ç­‰è·ï¼Œå”¯ä¸€çš„æ–¹å¼å°±æ˜¯æŠŠä»–å€‘æ”¾åœ¨æ­£å››é¢é«”ä¸Šçš„å››å€‹é ‚é»ä¸Šï¼Œä»¥æ­£å››é¢é«”ä¹‹å¤–å¿ƒç‚ºæ—‹è½‰ä¸­å¿ƒé€²è¡Œæ—‹è½‰\nç†è«–èˆ‡æ•¸å­¸å‡è¨­å››å€‹è³ªé‡å‡ç‚º$m$çš„ç‰©é«”ï¼Œåˆ†åˆ¥è½åœ¨æ­£å››é¢é«”çš„å››å€‹é ‚é»ä¸Šï¼Œè‹¥ä»¥æ­£å…­é¢é«”æ€è€ƒæ­£å››é¢é«”ï¼Œæ­£å››å€‹é ‚é»åˆ†åˆ¥æ˜¯$(0,0,0),(1,1,0),(1,0,1),(0,1,1)$\n\nå¦‚ä¸‹åœ–ï¼Œå‡è¨­$A,B,C,D$ä¸Šå‡æœ‰ä¸€å€‹è³ªé‡ç‚º$m$çš„ç‰©é«”ï¼Œæˆ‘å€‘é‡å°$B$åˆ†æå…¶å—åŠ›ç‹€æ³ï¼ˆå…¶ä»–é»å…¶å¯¦æ˜¯ä¸€æ¨£çš„ï¼‰ã€‚å¯ä»¥çœ‹åˆ°ï¼Œ$B$å—åˆ°äº†åˆ†åˆ¥æŒ‡å‘$A,B,D$ä¸‰é»ã€å¤§å°ç‚º$\\frac{Gm^2}{L^2}$çš„åŠ›ï¼Œå°‡é€™äº›åŠ›åœ¨æŒ‡å‘è³ªå¿ƒ$M$æ–¹å‘åšåˆ†åŠ›ã€‚\n\n\næ°´å¹³æ–¹å‘ï¼ˆABCå¹³é¢ï¼‰ï¼š\n\n2\\times\\frac{Gm^2}{L^2}\\cdot\\cos30^{\\circ}+\\frac{Gm^2}{L^2}\\cdot\\cos\\theta\nå‚ç›´æ–¹å‘ï¼š\n\n\\frac{Gm^2}{L^2}\\cdot\\sin\\thetaåˆ†ææ­£å››é‚Šå½¢çš„é•·åº¦æ€§è³ªï¼Œç”±æ–¼å››é¢é«”é«˜åº¦æ˜¯$h = \\frac{\\sqrt6}{3}$ã€æ­£ä¸‰è§’å½¢å¤–æ¥åœ“$\\frac{\\sqrt3}{3}$ï¼Œæˆ‘å€‘å¯ä»¥å¾—åˆ°$\\sin\\theta = \\frac{\\sqrt3}{3},\\cos\\theta = \\frac{\\sqrt 6}{3}$ï¼Œä»£å…¥ä¸Šå¼å¯å¾—ä¸¦åšç•¢æ°å®šç†å¯å¾—ï¼š\n\\begin{align}F_B &= \\frac{Gm^2}{L^2}\\sqrt{(\\sqrt3+\\frac{\\sqrt3}{3})^2 + (\\frac{\\sqrt6}{3})^2}\\\\\n&=\\sqrt6\\cdot\\frac{Gm^2}{L^2}\\end{align}æ­£å››é¢é«”çš„å¤–æ¥åœ“åŠå¾‘$R = \\frac{\\sqrt6}{4}L$ï¼Œå› æ­¤å¯å¾—ï¼š\n\\frac{mv^2}{R} = \\sqrt6\\cdot\\frac{Gm^2}{L^2}æœ€å¾Œå¾—åˆ°è»Œé“é€Ÿåº¦èˆ‡æ—‹è½‰é€±æœŸï¼š\n\\begin{align}v &= \\sqrt{\\frac{3Gm}{2L}}\\\\\nT &= 2\\pi\\sqrt{\\frac{L^3}{G\\cdot(4m)}}\n\\end{align}ç¨‹å¼å¯¦ä½œæ¨¡æ“¬é€£çµï¼šé»é€™è£¡å½±ç‰‡é€£çµï¼šé»é€™è£¡\næœ‰äº†é€Ÿåº¦å¤§å°ä»¥å¾Œï¼Œæ¥ä¸‹ä¾†å°±æ˜¯åˆå§‹é€Ÿåº¦æ–¹å‘çš„è¨­å®šã€‚é€™ä¸€éƒ¨åˆ†ç‰¹åˆ¥å›°é›£ï¼Œä»¥æ­£å››é¢é«”çš„å››æ˜Ÿåœ¨ç«‹é«”ç©ºé–“çš„é‹å‹•ï¼Œæ—‹è½‰çš„è§’åº¦è‹¥æ²’æœ‰æŠ“å¥½ï¼Œå¾ˆæœ‰å¯èƒ½æ•´å€‹çµæ§‹æœƒå´©å¡Œã€‚ä¾‹å¦‚ä¸‹åœ–æƒ…æ³ï¼Œå‰å¾Œå…©å€‹ç‰©é«”æœƒå› ç‚ºè¬æœ‰å¼•åŠ›ä½œç”¨è€Œä¸æ–·å¸å¼•ï¼š\n\nå˜—è©¦è§£æ±ºçš„æ–¹æ³•æ˜¯ï¼Œå°‡æ­£å››é¢é«”çš„å››å€‹é ‚é»åº§æ¨™æŠ•å½±åˆ°$xy$å¹³é¢ï¼Œå› ç‚ºå››å€‹é ‚é»æ˜¯$z$åº§æ¨™æ¥µå¤§æˆ–æ¥µå°ï¼Œå¦‚æ­¤ä¸€ä¾†å°±èƒ½è®“æ‰€æœ‰é€Ÿåº¦æ–¹å‘çš„$z$åˆ†é‡ç‚ºé›¶ã€‚æ¥è‘—ï¼Œåªè¦å°‡é€Ÿåº¦æ–¹å‘ä¾ç…§ä¸‹åœ–åˆ†è§£å³å¯ï¼š\n\nå¯ä»¥çœ‹åˆ°ä¸‹åœ–å·¦æ–¹æœ‰å…©å¼µåœ–ï¼Œä¸Šåœ–æ˜¯å››é¡†çƒçš„ç¸½å‹•èƒ½ã€ä½èƒ½èˆ‡åŠ›å­¸èƒ½çš„åœ–ã€ä¸‹åœ–æ˜¯é»ƒçƒèˆ‡å…¶ä»–çƒçš„è·é›¢ï¼ˆé»‘ç·šæ˜¯èˆ‡è³ªå¿ƒè·é›¢ï¼‰ã€‚åœ¨ç†æƒ³çš„ç‹€æ³ä¸‹ï¼Œæˆ‘å€‘é æœŸæ‰€æœ‰çƒçš„ç›¸å°ä½ç½®æ‡‰è©²ä¿æŒä¸è®Šï¼Œä½†åœ¨æ¨¡æ“¬ä¸­å»æ˜¯å‘ˆç¾é€±æœŸæ€§çš„è®ŠåŒ–ï¼Œä¸¦ä¸”å¯ä»¥è§€å¯Ÿçƒèˆ‡è³ªå¿ƒçš„è·é›¢ä¸¦ä¸æ˜¯å›ºå®šçš„ï¼Œè€Œæ˜¯æœ‰ä¸Šä¸‹èµ·ä¼çš„è®ŠåŒ–ã€‚\n\nè½‰äº†å·®ä¸å¤šååœˆå¾Œï¼Œæœƒç™¼ç¾å››æ˜Ÿç³»çµ±å‘ˆç¾æ··æ²Œç‹€æ…‹ï¼Œåˆ†æåŸå› å¯èƒ½æœ‰ä»¥ä¸‹å…©å€‹ï¼š\n\nç²¾åº¦å•é¡Œï¼šåˆå§‹ç‹€æ…‹é€Ÿåº¦æ–¹å‘å‘é‡ç²¾åº¦ä¸è¶³ï¼Œåˆå§‹çš„äº›è¨±å·®åˆ¥å°è‡´å¾ŒçºŒçš„æ··äº‚ã€‚\næ¨¡æ“¬æœ¬èº«é™åˆ¶ï¼šæˆ‘å€‘æ¡ç”¨çš„æ˜¯å°æ™‚é–“å¾®åˆ†é€²è¡Œæ¯ä¸€å€‹ç¬é–“çš„åŠ›å­¸åˆ†æï¼Œæ™‚é–“é–“éš”å¤§å°ä¹Ÿæœƒå½±éŸ¿åˆ°æ•´å€‹æ¨¡æ“¬çš„çµæœã€‚\n\n\né€™ä¹Ÿè®“æˆ‘å€‘æ€è€ƒä¸€å€‹è »æœ‰è¶£å•é¡Œï¼Œæ˜¯å¦çœŸçš„å­˜åœ¨ä¸€å€‹ç©©å®šçš„å››æ˜Ÿç³»çµ±å½¼æ­¤èƒ½åœ¨ç›¸å°ä½ç½®å›ºå®šçš„ç‹€æ³ä¸‹é€²è¡Œé‹å‹•ï¼Ÿ\nNé«”å•é¡Œé‹å‹•æ¨¡æ“¬æ¨¡æ“¬é€£çµï¼šé»é€™è£¡\næœ€å¾Œå°±æ˜¯Né«”å•é¡Œçš„æ¨¡æ“¬ï¼Œå°‡50å€‹è³ªé‡ç‚º$m$çš„ç‰©é«”åœ¨éš¨æ©Ÿç”Ÿæˆçš„ä½ç½®ä¸Šï¼Œå½¼æ­¤å—åˆ°è¬æœ‰å¼•åŠ›é‹å‹•ã€‚å³åœ–çš„é»‘ç·šç‚º50å€‹ç‰©é«”çš„ç¸½å‹•èƒ½ã€ç¶ ç·šç‚ºå½¼æ­¤çš„ä½èƒ½ï¼Œç´…ç·šç‚ºå…©è€…ç›¸åŠ ï¼Œä¹Ÿå°±æ˜¯ç¸½åŠ›å­¸èƒ½ã€‚åœ¨æ²’æœ‰å¤–åŠ›ä½œç”¨çš„ç‹€æ³ä¸‹ï¼Œèƒ½ç”±å³åœ–çœ‹å‡ºä¾†åŠ›å­¸èƒ½æ˜¯å®ˆæ†çš„ï¼\n\nç¸½çµèˆ‡å»¶ä¼¸å•é¡Œå¾è¬æœ‰å¼•åŠ›çš„ç†è«–èˆ‡æ•¸å­¸å‡ºç™¼ï¼Œæ•´ç†è¡Œæ˜Ÿçš„é‹å‹•è»Œè·¡ã€é›™æ˜Ÿã€ä¸‰æ˜Ÿã€å››æ˜Ÿç”šè‡³åˆ°Næ˜Ÿçš„é‹å‹•æ¨¡å¼ä»¥åŠæ¨¡æ“¬ï¼Œè®“æˆ‘å€‘èƒ½å¾ä¸ä¸€æ¨£çš„è§’åº¦åˆ‡å…¥ç‰©ç†å•é¡Œã€‚é€™é‚Šé‚„æœ‰ä¸€å€‹ååˆ†æœ‰è¶£çš„å•é¡Œå°šæœªè§£æ±ºï¼Œä¹Ÿå°±æ˜¯æ˜¯å¦å­˜åœ¨ä¸€å€‹ç©©å®šçš„å››æ˜Ÿç³»çµ±ï¼Ÿåœ¨å¤§éƒ¨åˆ†çš„Né«”å•é«”çš„æƒ…æ³ä¸­ï¼Œéƒ½æ²’æœ‰è¾¦æ³•å¾—åˆ°ä¸€å€‹ç©©å®šçš„é‹å‹•æ¨¡å¼ï¼Œç¸½æœƒå› ç‚ºèµ·å§‹ç‹€æ…‹çš„å°å°èª¤å·®å°è‡´æˆªç„¶ä¸åŒçš„çµæœï¼Œç©©å®šçš„å››æ˜Ÿç³»çµ±ä¹Ÿå°±è®Šæˆè »é›£è§£æ±ºçš„å•é¡Œã€‚\nåƒè€ƒè³‡æ–™\nWiki:Two-body problem\nWiki:Three-body problem\nWiki:N-body problem\nç§‘å­¸onlineï¼šåŠ›å­¸èƒ½(Mechanical energy)\n\nç‰©ç†è¬›ç¾©ï¼šç¬¬å…«ã€ä¹ç« \n\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","ç‰©ç†ç­†è¨˜"]},{"title":"æ•¸ç¨å•é¡Œï¼ˆSudokuï¼‰ï¼šä»¥C++å¯¦ä½œ","url":"/Sudoku/","content":"è³‡è¨Šä¹‹èŠ½çš„ä¸Šèª²å…§å®¹ï¼Œç”¨äº†å¹¾ç¯€ä¸‹èª²åŠ å›å®¶çš„æ™‚é–“æŠŠç¨‹å¼å¯¦ä½œå‡ºä¾†ç”¨ç´™è·Ÿç­†è§£æ•¸ç¨çš„éç¨‹å°±æ˜¯æŠŠæ‰€æœ‰å¯èƒ½å‰”é™¤æ˜é¡¯ä¸å¯èƒ½çš„ä¹‹å¾Œä¸‹å»è©¦ï¼Œå¦‚æœé‡åˆ°å•é¡Œå°±æ›ä¸‹ä¸€ç¨®æ–¹å¼ç”¨ç¨‹å¼æ¨¡æ“¬ä¹Ÿæ˜¯ä¸€æ¨£çš„æ¦‚å¿µï¼Œå…ˆæŠŠæ˜é¡¯ä¸å¯èƒ½çš„æƒ…æ³å‰”é™¤ï¼Œæ¥ä¸‹ä¾†å°±ä¸€ä¸€é€éDFSæœå°‹ä¸‹å»ï¼Œå¦‚æœç¢°å£å°±å›æœ”å›ä¾†NEOJã€TIOJï¼ˆä»–çš„ç¯„æ¸¬çµ¦å¾—ä¸æ˜¯å¾ˆå¥½é–±è®€XD\næ¶æ§‹å…ˆæƒ³å‡ºä»¥ä¸‹çš„å¯¦ä½œæ­¥é©Ÿï¼Œå°±å¯ä»¥é€éç¨‹å¼ç¢¼å¯¦ç¾\n\nè®€æ¸¬è³‡ä¸¦è™•ç†\nå¾å·¦åˆ°å³ã€ç”±ä¸Šè€Œä¸‹ï¼Œæ‰¾å‡ºä¸‹ä¸€å€‹è¦å¡«å…¥æ•¸å­—çš„ä½ç½®\nå°æ¯ä¸€å€‹é»è¦çŸ¥é“æœ‰å“ªäº›æ•¸å­—å¯ä»¥è¢«æ”¾å…¥ï¼ˆæŠŠæ˜é¡¯ä¸è¡Œçš„å‰”é™¤ï¼‰\nå¾å·¦ä¸Šè§’çš„ç©ºæ ¼é–‹å§‹DFS\n\nå¤§æ¦‚å°±æ˜¯é€™ä¸€äº›å¯¦ä½œæ­¥é©Ÿï¼Œå¦‚æœç”¨ç‰©ä»¶å°å‘class æŠŠæ‰€æœ‰æ±è¥¿åŒ…èµ·ä¾†ï¼Œçœ‹èµ·ä¾†æ¯”è¼ƒå²å®³DFS å‰ªæï¼\næ•´å€‹å¤§è‡´æ¶æ§‹ï¼š\nclass Sudoku&#123;private:    int maze[9][9];    bool flag = false;    public:    void print(string s);    void scan_maze();    vector&lt;int&gt; select(int, int);    int next_empty(int, int);    void solving();    void dfs(int row, int col );&#125;;\né€™å¯ä»¥è®“mainå‡½å¼é¡¯å¾—æ›´ç°¡å–®ï¼š\nint main()&#123;    Sudoku sodoku1;//å®£å‘Šç‰©ä»¶    sodoku1.scan_maze();//è®€å…¥æ¸¬è³‡    sodoku1.print(&quot;begin&quot;);//å°å‡ºç›®å‰æ•¸ç¨ï¼ˆæœªè§£ï¼‰    sodoku1.solving();//é–‹å§‹è§£&#125;\nè¼¸å…¥èˆ‡è¼¸å‡ºè¨­è¨ˆä¸€å€‹å°å‡ºæ•¸ç¨çš„å‡½å¼ï¼Œè®“è¼¸å‡ºæ–¹ä¾¿é–±è®€ä¸€é»ï¼ˆä¸€è¡Œ81å€‹å­—å…ƒæœ‰å¤ é†œã€‚ã€‚ã€‚\nvoid Sudoku::print(string s)&#123;    cout&lt;&lt;endl&lt;&lt;&quot;=====&quot;&lt;&lt;s&lt;&lt;&quot;======&quot;&lt;&lt;endl;    for (int i=0; i&lt;9;i++)&#123;        cout&lt;&lt;&quot;|&quot;;        for (int j=0;j&lt;9;j++)&#123;            cout&lt;&lt;maze[i][j];            if(j%3==2)cout&lt;&lt;&quot;|&quot;;        &#125;        cout&lt;&lt;endl;        if(i%3==2)cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;    &#125;&#125;\næ¥ä¸‹ä¾†æ˜¯è®€å…¥æ¸¬è³‡ï¼Œ0ä»£è¡¨ç©ºæ ¼\nvoid Sudoku::scan_maze()&#123;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 0;            else maze[i][j] = temp -&#x27;0&#x27;;        &#125;    &#125;&#125;\næœ‰äº†å¥½çš„è¼¸å‡ºå¯ä»¥è®“çœ¼ç›æ¯”è¼ƒè¼•é¬†ä¸€é»Q\næª¢æŸ¥å“ªäº›æ•¸å­—å¯ä»¥è©¦è©¦é€™ä¸€å€‹å‡½å¼ä¸»è¦æ˜¯å¯¦ç¾ä¸Šé¢çš„ç¬¬ä¸‰é»ï¼ŒæŠŠæ˜é¡¯ä¸è¡Œï¼ˆåœ¨åŒä¸€è¡Œã€åˆ—ã€æ–¹æ ¼ï¼‰å‡ºç¾éçš„æ•¸å­—å‰”é™¤\nvector&lt;int&gt; Sudoku::select(int r, int c)&#123;    bool box[9]=&#123;0&#125;;//æŠŠå‡ºç¾éçš„æ•¸å­—ç´€éŒ„ä¸‹ä¾†        for(int i=0;i&lt;9;i++)&#123;        if(maze[i][c]&gt;0)box[maze[i][c]-1] = 1;//åŒä¸€åˆ—        if(maze[r][i]&gt;0)box[maze[r][i]-1] = 1;//åŒä¸€è¡Œ    &#125;    int row_start = 3*(r/3),col_start = 3*(c/3);//æ–¹æ ¼èµ·å§‹ä½ç½®    for(int i=0;i&lt;3;i++)&#123;//åŒä¸€æ–¹æ ¼        for(int j=0;j&lt;3;j++)&#123;            if(maze[row_start+i][col_start+j]&gt;0)                box[maze[row_start+i][col_start+j]-1] = 1;        &#125;    &#125;    vector&lt;int&gt; ans;    for(int i=0;i&lt;9;i++)        if(!box[i])ans.push_back(i+1);    return ans;//æŠŠå¯ä»¥è©¦è©¦çœ‹å¾—æ•¸å­—pushé€²vectorå¾Œå›å‚³&#125;\nåœ¨éè¿´çš„æ™‚å€™å¾ˆéœ€è¦çŸ¥é“ä¸‹ä¸€å€‹è¦å¡«ç©ºçš„ä½ç½®åœ¨å“ªè£ï¼Œåˆé¡Œç›®è¦æ±‚å¦‚æœæœ‰å¤šçµ„è§£è¦è¼¸å‡ºå­—å…¸åºæœ€å°çš„è§£ï¼Œæ‰€ä»¥è¦å¾å·¦è€Œå³å†ç”±ä¸Šè€Œä¸‹é–‹å§‹æ‰¾\nint Sudoku::next_empty(int row, int col)&#123;    int ind = col;    for(int i=row;i&lt;9;i++)&#123;        while(ind&lt;9)&#123;            if(maze[i][ind]==0)&#123;//æ‰¾åˆ°0å°±åœæ­¢                int pos = i*9+ind;                return pos;            &#125;            ind++;        &#125;        ind = 0;    &#125;    return -1;//æ‰¾ä¸æª”ä»»ä½•ç©ºæ ¼ï¼Œå·²ç¶“å¡«æ»¿&#125;\né–‹å§‹éè¿´DFS!è·Ÿå…«çš‡åå•é¡Œå¾ˆåƒï¼Œéƒ½åªä¸éå…«çš‡åå•é¡Œåªæœ‰æ”¾è·Ÿä¸æ”¾çš„å•é¡Œï¼Œè€Œæ•¸ç¨æ˜¯è¦æ±ºå®šæ”¾ä»€éº¼é€²å»é¦–å…ˆï¼Œæ‰¾åˆ°ç¬¬ä¸€å€‹ç©ºæ ¼ä¹‹å¾ŒDFSï¼Œåœ¨DFSçµæŸå¾Œè¨˜å¾—è¦ç¢ºèªæ•¸ç¨çµæœæœ‰æ²’æœ‰ç¬¦åˆæ•¸ç¨åŸæœ¬çš„å®šç¾©(è¦ä¸ç„¶åªæœƒå°ç¬¬ä¸€å€‹å­é¡ŒQQ)\n            Q: æ˜æ˜ç©ºæ ¼æ˜¯ä¸€å€‹ä¸€å€‹å¡«ä¸Šå»ï¼Œç‚ºå•¥é‚„è¦å†æª¢æŸ¥ä¸€æ¬¡ï¼ŸA: ç¶“éä¸€å°æ™‚çš„debug ä¹‹å¾Œç™¼ç¾ï¼Œä»–çµ¦çš„æ¸¬è³‡ä¸ä¸€å®šåˆæ³•å‘€ï¼å¯èƒ½æ¸¬è³‡åªæœ‰ç¬¬ä¸€è¡Œç¬¬ä¸€æ ¼ä¸€ç©ºæ ¼ï¼Œå¾ˆé«˜èˆˆå¡«ä¸Šå»ç„¶å¾Œèªª YA!è§£å®Œäº†ï¼Œä½†å…¶å¯¦åœ¨ç¬¬ä¹è¡Œç¬¬ä¹æ ¼å‡ºç¾äº†é‡è¤‡æ•¸å­—?!æ ¹æœ¬ä¸æœƒæª¢æŸ¥åˆ°å•Šï¼Œä½†å°ç¬¬ä¸€è¡Œç¬¬ä¸€æ ¼ä¸€ç©ºæ ¼ä¾†èªªï¼Œä¸€åˆ‡éƒ½ç¬¦åˆè¦å‰‡ã€å¾ˆç¾å¥½\n          \nvoid Sudoku::solving()&#123;    int first_empty = next_empty(0, 0),nr,nc;    nr = first_empty/9; nc = first_empty%9;//æ‰¾åˆ°å‡ºç™¼é»    dfs(nr, nc);//dfsä¸‹å»    bool f = false;    for(int i=0;i&lt;9;i++)&#123;//81å€‹æ•¸å­—å†checkä¸€æ¬¡        for(int j=0;j&lt;9;j++)&#123;            vector&lt;int&gt; v = select(i,j);            if(v.size()&gt;0)f = true;//DFSå®Œæ­£å¸¸å¤§å°è¦æ˜¯0        &#125;    &#125;    if(!flag || f)cout&lt;&lt;&quot;No solution.&quot;&lt;&lt;endl;//ç„¡è§£    else print(&quot;solved&quot;);//å°å‡ºè§£    flag = false;&#125;\nå°æ¯ä¸€ç¨®å¯èƒ½é€²è¡Œéè¿´ï¼š\nvoid Sudoku::dfs(int row, int col )&#123;    int pos = next_empty(row, col),nr,nc;    if(pos == -1)&#123;        flag = true;//æœ‰ä¸€çµ„è§£äº†        return;    &#125;    vector&lt;int&gt; candidate = select(row, col);    int len = candidate.size();        for(int i=0;i&lt;len;i++)&#123;        maze[row][col] = candidate[i];        pos = next_empty(row, col);        nr = pos/9; nc = pos%9;        dfs(nr, nc);        if(flag)return;//å¦‚æœè¦è¼¸å‡ºå¾ˆå¤šçµ„è§£çš„è©±å¯ä»¥åˆªæ‰é€™è¡Œ    &#125;    maze[row][col] = 0;&#125;\n\né€™ä»½ç¨‹å¼ç¢¼åªæ˜¯ç‚ºäº†ä¸Šå‚³ojï¼Œæ‰€ä»¥åªéœ€è¦ä¸€ç¨®æƒ…æ³å°±å¥½å®Œæ•´ç¨‹å¼ç¢¼åœ¨é€™ä¸éï¼Œä¹Ÿå¯ä»¥ç”¨ç¨‹å¼æŠŠæ¯ä¸€ç¨®æ–¹æ³•éƒ½åˆ—å‡ºä¾†ï¼Œæ•¸é‡å¯ä»¥å¤šåˆ°ä¸å¯æƒ³åƒï¼(æˆ‘ç”¨ç¨‹å¼è·‘äº†ä¸€ä¸‹ï¼Œçµæœç›´æ¥å®ƒç›´æ¥ä¸ç†æˆ‘ï¼Œä¸Šç¶²æŸ¥æ‰ç™¼ç¾ $5\\times 10^{27}$ä¹‹å¤šï¼Œå¤©è’åœ°è€ä¹Ÿç®—ä¸å®Œï¼ï¼‰\né€™æ˜¯æ¸¬è©¦ç”¨çš„æ•¸ç¨ï¼š\né€™æ˜¯ç”¨ç·šä¸Šè§£æ•¸ç¨çš„è»Ÿé¡Œè·‘å‡ºä¾†çš„çµæœï¼šé€™æ˜¯ç¨‹å¼å¯¦æ¸¬è·‘å‡ºä¾†çš„çµæœï¼Œéƒ½å»åˆï¼š\nç›¸é—œå»¶ä¼¸ï¼šå…«çš‡åå•é¡Œé¡Œç›®é€£çµé€™ä¸€ä»½ç¨‹å¼ç¢¼æ˜¯leetcodeå…«çš‡åå•é¡Œçš„è§£ã€‚åƒä¸‹é¢é€™ä¸€å¼µåœ–å°±æ˜¯ä¸€çµ„åˆæ³•çš„è§£ï¼Œé€ééè¿´å¯ä»¥æ‰¾å‡ºæ¯ä¸€çµ„è§£ã€‚\n\nç¶²è·¯ä¸Šçš„è³‡æ–™æŒ‡å‡ºé€™æ˜¯ä¸€å€‹$NP-Complete$çš„å•é¡Œï¼Œè¡¨ç¤ºä¸¦æ²’æœ‰å¤šé …å¼æ™‚é–“çš„è§£æ³•ã€‚é€é2å€‹ç°¡å–®çš„å‡½æ•¸ï¼ˆæ˜¯å¦å¯è¡Œã€éè¿´å‡½æ•¸ï¼‰å³å¯å¯¦ä½œå‡ºä¾†ã€‚ä»¥ä¸‹è¡¨æ ¼çµ¦å‡ºnç‚º1åˆ°11çš„åˆæ³•è§£å€‹æ•¸ï¼š\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n\n1\n0\n0\n2\n10\n4\n40\n92\n352\n724\n2680\n\n\n\n\nå¯ä»¥åˆ©ç”¨é€™å€‹è§£ç›´æ¥ä¸ŸåŸæœ¬çš„é¡Œç›®ï¼Œå°±å¯ä»¥è´é78.93%çš„Submissionï¼ˆé‚„æ˜¯ä¹–ä¹–ç”¨éè¿´å¯«å•¦ï¼‰ XD\nä»¥ä¸‹æ˜¯ç”¨éè¿´å¯«çš„ç¨‹å¼ç¢¼ï¼š\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; temp;    int ans = 0;    void turn_zero(int n)&#123;        vector&lt;int&gt; vec(n,0);        for(int i=0;i&lt;n;i++)&#123;            temp.push_back(vec);        &#125;    &#125;        bool isSafe(int x,int y,int n)&#123;        for(int i=0;i&lt;n;i++)&#123;            for(int k=0;k&lt;n;k++)&#123;                if(x==i &amp;&amp; y==k)continue;                if(temp[i][k])                    if(abs(i-x)==abs(k-y)||y==k)                        return false;            &#125;        &#125;        return true;    &#125;        void Queen_Problem(int n)&#123;        for(int i=0;i&lt;n;i++)&#123;            temp[0][i] = 1;            DFS(1,n);            temp[0][i] = 0;         &#125;    &#125;    void DFS(int row,int n)&#123;        if(row==n)&#123;            ans++;            return;        &#125;        for(int i=0;i&lt;n;i++)&#123;            if(isSafe(row,i,n))&#123;                temp[row][i] = 1;                DFS(row+1,n);                temp[row][i] = 0;            &#125;        &#125;    &#125;    int totalNQueens(int n) &#123;        turn_zero(n);        Queen_Problem(n);        return ans;    &#125;&#125;;\n","categories":["C++åŸºç¤ä¸»é¡Œ","æšèˆ‰"],"tags":["æ•¸å­¸","æ•¸ç¨","DFS"]},{"title":"[é¡Œè§£]åŸå¸‚æ—…éŠ","url":"/a051/","content":"a051. åŸå¸‚æ—…éŠ\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 1000using namespace std;int n,m;bool visit[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    visit[cur] = 1;    for(auto i:edge[cur])&#123;        if(visit[i])continue;        dfs(i);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    for(int i=0;i&lt;=n+100;i++)edge[i].clear();        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);    &#125;    int from,to;cin&gt;&gt;from&gt;&gt;to;    dfs(from);    if(visit[to])cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æˆç¸¾æŒ‡æ¨™","url":"/a064/","content":"a064/ æˆç¸¾æŒ‡æ¨™\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;void solve()&#123;    int n,arr[25];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    cout&lt;&lt;arr[0];    for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;arr[i];    cout&lt;&lt;endl;        if(arr[0]&gt;=60)cout&lt;&lt;&quot;best case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60)-1)&lt;&lt;endl;        if(arr[n-1]&lt;60)cout&lt;&lt;&quot;worst case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60))&lt;&lt;endl;    &#125;signed main()&#123;    int t;    t = 1;//    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ç§˜å¯†å·®","url":"/a065/","content":"a065. ç§˜å¯†å·®\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        int ans = 0,len = s.size(),p=1;        for(int i=0;i&lt;len;i++)&#123;            ans+=(s[i]-&#x27;0&#x27;)*p;            p *=-1;        &#125;        cout&lt;&lt;abs(ans)&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ROT13","url":"/a067/","content":"a067. ROT13\n#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    string s;    getline(cin,s);    for(auto p:s)&#123;        if(isalpha(p))&#123;            if(isupper(p))                cout&lt;&lt;(char)((p-&#x27;A&#x27;+13)%26+&#x27;A&#x27;);            else                cout&lt;&lt;(char)((p-&#x27;a&#x27;+13)%26+&#x27;a&#x27;);        &#125;        else&#123;            cout&lt;&lt;p;        &#125;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ’éšŠè²·é£²æ–™","url":"/a071/","content":"a071. æ’éšŠè²·é£²æ–™\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;&gt;&gt;pq;        cin&gt;&gt;n&gt;&gt;m;    int ans=0,time=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;time;        if(i&gt;m)&#123;            time+=pq.top();            pq.pop();        &#125;        pq.push(time);        ans = max(ans,time);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é†œæ•¸","url":"/a075/","content":"a075. é†œæ•¸\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n;signed main()&#123;    Orz;    cin&gt;&gt;n;    vector&lt;int&gt; vec;    vec.push_back(1);    int id2 = 0,id3 = 0,id5 = 0;    //ç”¨å‰é¢çš„é†œæ•¸æ¨å¾Œé¢çš„ï¼Œä¸æœƒæœ‰å…¶ä»–è³ªæ¨¹    for(int i=1;i&lt;n;i++)&#123;        int ugly = min(vec[id2]*2,min(vec[id3]*3,vec[id5]*5));        vec.push_back(ugly);        if(vec[i]==vec[id2]*2)id2+=1;        if(vec[i]==vec[id3]*3)id3+=1;        if(vec[i]==vec[id5]*5)id5+=1;    &#125;    cout&lt;&lt;vec[n-1]&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]äºŒå…ƒæœå°‹æ¨¹é«˜åº¦","url":"/a076/","content":"a076. äºŒå…ƒæœå°‹æ¨¹é«˜åº¦\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];bool used[3000];int main()&#123;    ios;    string s;    memset(used,0,sizeof(used));    memset(tree,0,sizeof(tree));        getline(cin,s);    stringstream ss(s);    int ans = 0,temp;    while(ss&gt;&gt;temp)&#123;        int cur = 1,height = 1;        while(used[cur])&#123;            if(temp&lt;tree[cur])cur = cur*2;            else cur = cur*2+1;            height++;        &#125;        tree[cur] = temp;        used[cur] = 1;        ans = max(ans,height);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]Dropping Balls","url":"/a077/","content":"a077. Dropping Balls\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];int drop(int id)&#123;    if(id&gt;=(1&lt;&lt;(n-1)))return id;        tree[id]=!tree[id];    if(!tree[id])return drop(2*id+1);    else return drop(2*id);&#125;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        int ans = 0;cin&gt;&gt;n&gt;&gt;m;        memset(tree,0,sizeof(tree));        for(int i=0;i&lt;m;i++)&#123;            ans = drop(1);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æœ€å¤§ä¹˜ç©","url":"/a088/","content":"a088. æœ€å¤§ä¹˜ç©\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 20#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    int c = 0;    while(cin&gt;&gt;n)&#123;        c++;        int dp[N][N];memset(dp,0,sizeof(dp));        int ans = 0;        FOR(i,n)&#123;            int temp;cin&gt;&gt;temp;            dp[i][i] = temp;            ans = max(ans,temp);        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                dp[i][j] = dp[i][j-1]*dp[j][j];                ans = max(dp[i][j],ans);            &#125;        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;c&lt;&lt;&quot;: The maximum product is &quot;&lt;&lt;max(ans,(ll)0)&lt;&lt;&quot;.&quot;&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è˜‡ä¸¹ç‹ä½ç¹¼æ‰¿è€…","url":"/a089/","content":"a089. è˜‡ä¸¹ç‹ä½ç¹¼æ‰¿è€…\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,chess[N][N],Q[N],ans=0;bool check(int row,int col)&#123;    for(int i=1;i&lt;row;i++)&#123;        if(col == Q[i]||abs(row-i)==abs(col-Q[i]))return 0;    &#125;    return 1;&#125;void Queen(int row)&#123;    if(row&gt;8)&#123;        int sum = 0;        rep(i,1,8)sum += chess[i][Q[i]];        ans = max(ans,sum);        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(row,i))&#123;            Q[row] = i;            Queen(row+1);        &#125;    &#125;&#125;void solve()&#123;    memset(chess,0,sizeof(chess));    memset(Q,0,sizeof(Q));    ans = 0;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            cin&gt;&gt;chess[i][j];        &#125;    &#125;    Queen(1);    cout&lt;&lt;right&lt;&lt;setw(5)&lt;&lt;ans&lt;&lt;endl;    &#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è³ªæ•¸ç’°","url":"/a090/","content":"a090. è³ªæ•¸ç’°\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 20#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,prime[105],ans[N],cnt = 0;bool visit[N];void init()&#123;    rep(i,0,100)prime[i] = 1;    prime[1] = 0;    for(int i=2;i&lt;=100;i++)&#123;        if(prime[i]==0)continue;        for(int j=2*i;j&lt;=100;j+=i)&#123;            prime[j] = 0;        &#125;    &#125;&#125;void dfs(int id,int val)&#123;    ans[id] = val;    if(id&gt;=n-1)&#123;        if(!prime[val+1])return;        for(int i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;        return;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        if(visit[i])continue;        if(prime[val+i]==0)continue;        visit[i] = 1;        dfs(id+1,i);        visit[i] = 0;    &#125;&#125;signed main()&#123;    Orz;    init();    while(cin&gt;&gt;n)&#123;        cnt+=1;        memset(ans,0,sizeof(ans));        memset(visit,0,sizeof(visit));        cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt&lt;&lt;&quot;:&quot;&lt;&lt;endl;        dfs(0,1);    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]Add All","url":"/a091/","content":"a091. Add All\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            pq.push(temp);        &#125;        int ans = 0;        while(pq.size()!=1)&#123;            int cur = pq.top();            pq.pop();            cur += pq.top();            pq.pop();            ans+=cur;            pq.push(cur);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ™‚é–“å·®è¨ˆç®—","url":"/a096/","content":"a096/ æ™‚é–“å·®è¨ˆç®—\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    int a1,b1,c1,a2,b2,c2;    scanf(&quot;%d:%d:%d&quot;,&amp;a1,&amp;b1,&amp;c1);    scanf(&quot;%d:%d:%d&quot;,&amp;a2,&amp;b2,&amp;c2);    int a = a1*3600+b1*60+c1,b = a2*3600+b2*60+c2;        if(b-a&gt;=0)&#123;        int temp = b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;    else&#123;        int temp = 86400+b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ²¹ç”°","url":"/a102/","content":"a102. æ²¹ç”°\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 105using namespace std;int n,m,ans = 0;int dx[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;;int dy[8] = &#123;1,0,-1,-1,-1,0,1,1&#125;;bool visit[N][N],maze[N][N];void dfs(int x,int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;8;i++)&#123;        int nx = x+dx[i],ny = y+dy[i];        if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;        if(visit[nx][ny])continue;        if(maze[nx][ny]==1)dfs(nx,ny);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    memset(maze,0,sizeof(maze));    ans = 0;        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;@&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                dfs(i,j);                ans+=1;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n&amp;&amp; m)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å°ç¾¤é«”","url":"/a103/","content":"a103. å°ç¾¤é«”\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 50005using namespace std;signed main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];    &#125;    bool used[N];    int ans = 0;    memset(used,0,sizeof(used));        for(int i=0;i&lt;n;i++)&#123;        if(used[i])continue;        int cur = arr[i];        used[cur] = 1;        while(cur!=i)&#123;            cur = arr[cur];            used[cur] = 1;        &#125;        ans++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é›ªèŠ±ç‰‡ç‰‡","url":"/a104/","content":"a104/ é›ªèŠ±ç‰‡ç‰‡\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;int n,product[100];void solve()&#123;    memset(product,0,sizeof(product));    product[0] = 1;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;80;j++)&#123;            product[j]=product[j]*4;        &#125;        for(int j=0;j&lt;80;j++)&#123;            if(product[j]&gt;=10)&#123;                product[j+1] += product[j]/10;                product[j] %=10;            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    product[0]-=1;    int temp=0;    for(int i=80;i&gt;=0;i--)&#123;        product[i] += temp*10;        temp = product[i]%3;        product[i] /= 3;    &#125;        int start = 80;    for(int i=80;i&gt;=0;i--)        if(product[i]!=0)&#123;            start = i;            break;        &#125;    for(int i=start;i&gt;=0;i--)cout&lt;&lt;product[i];    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è³“æœéŠæˆ²","url":"/a106/","content":"a106. è³“æœéŠæˆ²\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;char name[N],line[N][10];pair&lt;int,int&gt; mp[N][N];bool check(int people,int number)&#123;    int r = mp[people][number].first,c = mp[people][number].second;    line[people][r]+=1;    line[people][c+4]+=1;    if(line[people][r]==4)return 1;    if(line[people][c+4]==4)return 1;        if(r+c==3)&#123;        line[people][8]+=1;        if(line[people][8]==4)return 1;    &#125;    if(r==c)&#123;        line[people][9]+=1;        if(line[people][9]==4)return 1;    &#125;    return 0;&#125;signed main()&#123;    ios;    int n;    char cha;    cin&gt;&gt;cha&gt;&gt;n;    memset(line,0,sizeof(line));        for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;name[i];        for(int j=0;j&lt;16;j++)&#123;            int temp;cin&gt;&gt;temp;            mp[i][temp].first = j/4;            mp[i][temp].second = j%4;        &#125;    &#125;    int cnt = 16,flag = 0;    cin&gt;&gt;cha;    while(cnt--)&#123;        int temp;cin&gt;&gt;temp;        cout&lt;&lt;temp&lt;&lt;&quot; &quot;;        for(int i=0;i&lt;n;i++)&#123;            if(check(i,temp))&#123;                cout&lt;&lt;name[i]&lt;&lt;&quot; &quot;;                flag = 1;            &#125;        &#125;        if(flag)break;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]çˆºçˆºç¨®æ¨¹","url":"/a105/","content":"a105. çˆºçˆºç¨®æ¨¹\n#include &lt;bits/stdc++.h&gt;#define N 505#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n,m,t;cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;    bool arr[N][N];    memset(arr,0,sizeof(arr));        while(t--)&#123;        int r1,r2,c1,c2;cin&gt;&gt;r1&gt;&gt;c1&gt;&gt;r2&gt;&gt;c2;        int dr = r2-r1,dc = c2-c1;        if(dr&gt;0)dr = 1;else dr = -1;        if(dc&gt;0)dc = 1;else dc = -1;                if(r1==r2)&#123;            for(int i=c1;i!=c2;i+=dc)arr[r1][i] = 1;            arr[r1][c2] = 1;        &#125;        else if(c1==c2)&#123;            for(int i=r1;i!=r2;i+=dr)arr[i][c1] = 1;            arr[r2][c1] = 1;        &#125;        else&#123;            for(int i=r1,j=c1;i!=r2;i+=dr,j+=dc)&#123;                arr[i][j] = 1;                arr[r2][c2] = 1;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(arr[i][j])ans+=1;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è¨ˆç®—å­—ä¸²é–“éš”è·é›¢","url":"/a108/","content":"a108. è¨ˆç®—å­—ä¸²é–“éš”è·é›¢\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//åœ°é»ã€å‹•ç‰©åã€æ•¸é‡int main()&#123;    string s;    char ch;    cin&gt;&gt;s&gt;&gt;ch;    ch = tolower(ch);    int len = s.size(),a1;    for(int i=0;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a1 = i;            break;        &#125;    &#125;    int a2;    for(int i=a1+1;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a2 = i;            cout&lt;&lt;a2-a1&lt;&lt;&quot; &quot;;            a1 = a2;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]åŠ å¯†è§£å¯†","url":"/a107/","content":"a107. åŠ å¯†è§£å¯†\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;string a = &quot;abcdefghijklmnoprstuvwxyz&quot;;string b = &quot;EXAMPLBCDFGHIJKNORSTUVWYZ&quot;;signed main()&#123;    ios;    int n;string s;    cin&gt;&gt;n;cin.ignore();    getline(cin,s);    reverse(s.begin(),s.end());    string origin = b ,key = a;    if(s[0]&gt;=&#x27;a&#x27;&amp;&amp; s[0]&lt;=&#x27;z&#x27;)swap(origin,key);        for(int i=0;i&lt;n;i+=2)&#123;        int p1 = origin.find(s[i]),p2 = origin.find(s[i+1]);        cout&lt;&lt;key[5*(p1/5)+(p2%5)]&lt;&lt;key[5*(p2/5)+(p1%5)];    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è·‘é•·ç·¨ç¢¼èˆ‡è³‡æ–™å£“ç¸®","url":"/a109/","content":"a109. è·‘é•·ç·¨ç¢¼èˆ‡è³‡æ–™å£“ç¸®\n#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    int n,origin,after,times;    string s,t,binary[8]=&#123;&quot;000&quot;,&quot;001&quot;,&quot;010&quot;,&quot;011&quot;,&quot;100&quot;,&quot;101&quot;,&quot;110&quot;,&quot;111&quot;&#125;;    char ch;    cin&gt;&gt;n;    cin.ignore();    while(n--)&#123;        getline(cin,s);        t=&quot;&quot;;        origin = s.size();        after = 0;        ch = s[0];        times = 1;        int len = s.size();        for(int i=1;i&lt;=len;i++)&#123;            if(i!=len &amp;&amp; s[i]!=&#x27;0&#x27;&amp;&amp;s[i]!=&#x27;1&#x27;)&#123;                after = -1;                break;            &#125;            if(s[i]!=ch)&#123;                t+=ch;                t+=binary[times];                t+=&quot; &quot;;                times=1;                ch = s[i];                after+=4;            &#125;            else&#123;                times++;                if(times==7)&#123;                    t+=ch;                    t+=binary[7];                    t+=&quot; &quot;;                    times=1;                    after +=4;                    ch = s[i+1];                    i++;                &#125;            &#125;        &#125;        if(after==-1)cout&lt;&lt;after&lt;&lt;endl;        else cout&lt;&lt;t&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;(double)after*100/origin&lt;&lt;&quot;%&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å‹•ç‰©æ•¸é‡çµ±è¨ˆ","url":"/a112/","content":"a112. å‹•ç‰©æ•¸é‡çµ±è¨ˆ\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//åœ°é»ã€å‹•ç‰©åã€æ•¸é‡int main()&#123;    int n;cin&gt;&gt;n;    vector&lt;string&gt; p;    while(n--)&#123;        string animal,pos;        int qu,ind;        cin&gt;&gt;animal&gt;&gt;qu&gt;&gt;pos;        ind = find(p.begin(),p.end(),pos)-p.begin();        if(ind==p.size())p.push_back(pos);        mp[pos].push(&#123;animal,qu&#125;);    &#125;    for(auto i:p)&#123;        cout&lt;&lt;i&lt;&lt;&quot;:&quot;;        map&lt;string,int&gt; sta;        vector&lt;string&gt; almp;        while(!mp[i].empty())&#123;            string an = mp[i].front().first;            int qu = mp[i].front().second;            mp[i].pop();            int ind = find(almp.begin(),almp.end(),an)-almp.begin();            if(ind==almp.size())almp.push_back(an);            sta[an]+=qu;        &#125;        bool c = 0;        for(auto j:almp)&#123;            if(c)cout&lt;&lt;&quot;,&quot;;            cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;sta[j];            c = 1;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ£’çƒéŠæˆ²","url":"/a110/","content":"a110. æ£’çƒéŠæˆ²\n#include &lt;bits/stdc++.h&gt;using namespace std;int num_of_out,d[3] = &#123;0&#125;;int transfer(string a)&#123;    if(a==&quot;SO&quot;||a==&quot;FO&quot;||a==&quot;GO&quot;)return 0;    else if(a==&quot;1B&quot;)return 1;    else if(a==&quot;2B&quot;)return 2;    else if(a==&quot;3B&quot;)return 3;    else return 4;&#125;int win(int c)&#123;    int s = 0;    if(c!=4)&#123;        for(int i=0;i&lt;c;i++)&#123;            if(d[2-i])s++;        &#125;        for(int i=0;i&lt;3-c;i++)&#123;            d[2-i] = d[2-c-i];        &#125;    &#125;    if(c==4)&#123;        for(int i=0;i&lt;3;i++)if(d[i])s++;        s++;    &#125;    else d[c-1] = 1;    for(int i=0;i&lt;c-1;i++)d[i] = 0;    return s;&#125;int main()&#123;    int data[9][5];    for(int i=0;i&lt;9;i++)&#123;        int temp;        cin&gt;&gt;temp;        for(int k=0;k&lt;temp;k++)&#123;            string a;            cin&gt;&gt;a;            data[i][k] = transfer(a);        &#125;    &#125;    cin&gt;&gt;num_of_out;    int now_out = 0,ans = 0;    for(int k=0;k&lt;5;k++)&#123;        for(int i=0;i&lt;9;i++)&#123;            if(now_out&gt;=num_of_out)break;            if(data[i][k])&#123;                ans+=win(data[i][k]);            &#125;            else&#123;                now_out++;                if(now_out%3==0)&#123;                    for(int i =0;i&lt;3;i++)d[i] = 0;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ’éšŠ","url":"/a111/","content":"a111. æ’éšŠ\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    int t[1005][3],line=0,ans=0,cur=0;        cin&gt;&gt;t[0][0]&gt;&gt;t[0][1];    t[0][2] = t[0][0]+t[0][1];    for(int i=1;i&lt;n;i++)&#123;        cin&gt;&gt;t[i][0]&gt;&gt;t[i][1];        if(t[i][0]&lt;t[i-1][2])t[i][2] = t[i-1][2]+t[i][1];        else t[i][2] = t[i][0]+t[i][1];                if(t[i][0]&gt;=t[cur][2])&#123;            ans = max(ans,line);            while(t[i][0]&gt;=t[cur][2])&#123;                if(cur==i)break;                line--;                cur++;            &#125;        &#125;        if(t[i][0]&lt;t[cur][2])line++;    &#125;    ans = max(ans,line);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]99éŠæˆ²","url":"/a113/","content":"a113. 99éŠæˆ²\n#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int,queue&lt;string&gt;&gt; mp;int main()&#123;    for(int i=0;i&lt;4;i++)&#123;        char ch;cin&gt;&gt;ch;        for(int j=0;j&lt;13;j++)&#123;            string s;cin&gt;&gt;s;            mp[ch-&#x27;A&#x27;].push(s);        &#125;    &#125;    int id = 0,dir=1,sum=0;    while(sum&lt;=99)&#123;        string card = mp[id].front();        if(card==&quot;A&quot;)sum=0;        else if(card==&quot;4&quot;)dir*=-1;        else if(card==&quot;5&quot;);        else if(card==&quot;10&quot;)&#123;            sum+=10;            if(sum&gt;99)sum-=20;        &#125;        else if(card==&quot;J&quot;);        else if(card==&quot;Q&quot;)&#123;            sum+=20;            if(sum&gt;99)sum-=40;        &#125;        else if(card==&quot;K&quot;)sum=99;        else&#123;            sum+=(card[0]-&#x27;0&#x27;);            if(sum&gt;99)&#123;                cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;mp[id].size()-1&lt;&lt;endl;                break;            &#125;        &#125;        mp[id].pop();        if(mp[id].empty())&#123;            cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;            break;        &#125;        id = (id+dir+4)%4;//        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ‰¾å‡ºæœ€å°çš„å®Œå…¨å¹³æ–¹æ•¸","url":"/a114/","content":"a114/ æ‰¾å‡ºæœ€å°çš„å®Œå…¨å¹³æ–¹æ•¸\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;void solve()&#123;    int k;cin&gt;&gt;k;    int a = ceil(sqrt(pow(10,(k-1))));    for(int i=a;;i++)&#123;        string s = to_string(i*i);        int len = s.size(),flag = 0;        for(int i=0;i&lt;len;i++)&#123;            if((s[i]-&#x27;0&#x27;)%2!=0)&#123;                flag = 1;                break;            &#125;        &#125;        if(flag==0)&#123;            cout&lt;&lt;i*i&lt;&lt;endl;            break;        &#125;    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è³“æœéŠæˆ²","url":"/a115/","content":"a115/ è³“æœéŠæˆ²\n#include &lt;bits/stdc++.h&gt;//#define int ll//#define ll long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int maze[10][10],cur[10][10],n;    for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            cin&gt;&gt;maze[i][j];            cur[i][j] = maze[i][j];        &#125;    &#125;    while(cin&gt;&gt;n &amp;&amp; n!= -1)&#123;        for(int i=0;i&lt;5;i++)&#123;            for(int j=0;j&lt;5;j++)&#123;                if(maze[i][j]==n)maze[i][j] = 0;            &#125;        &#125;    &#125;        int ind = 1,num = -1;        for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            if(maze[i][j]!=0)&#123;                maze[i][j] = 0;                int k,ans = 0;                for(k=0;k&lt;5;k++)if(maze[k][j]!=0)break;                if(k==5)ans+=1;                for(k=0;k&lt;5;k++)if(maze[i][k]!=0)break;                if(k==5)ans+=1;                                if(i==j)&#123;                    for(k=0;k&lt;5;k++)if(maze[k][k]!=0)break;                    if(k==5)ans+=1;                &#125;                if(i+j==4)&#123;                    int x = 4,y = 0;                    for(k=0;k&lt;5;k++)&#123;                        if(maze[x][y]!=0)break;                        else&#123;                            x--;y++;                        &#125;                    &#125;                    if(k==5)ans++;                &#125;                if(ans&gt;num)&#123;                    num = ans;                    ind = cur[i][j];                &#125;                else if(ans==num &amp;&amp; ind&gt;cur[i][j])ind = cur[i][j];                maze[i][j] = cur[i][j];            &#125;        &#125;    &#125;    cout&lt;&lt;ind&lt;&lt;endl;&#125;signed main()&#123;    ios;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ä¸‰è‰²æ²³å…§å¡”","url":"/a117/","content":"a117/ ä¸‰è‰²æ²³å…§å¡”\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void move(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    move(n-1,by,to,from);&#125;void honai(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    honai(n-2,by,from,to);&#125;signed main()&#123;    ios;    int n;cin&gt;&gt;n;    t = 0;    honai(n,&#x27;A&#x27;,&#x27;C&#x27;,&#x27;B&#x27;);    cout&lt;&lt;&quot;å…±éœ€&quot;&lt;&lt;t&lt;&lt;&quot;å€‹ç§»å‹•&quot;&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ä¸€èµ·å›å®¶çš„æ—¥å­","url":"/a116/","content":"a116/ ä¸€èµ·å›å®¶çš„æ—¥å­\n#include &lt;bits/stdc++.h&gt;//#define ll long long//#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;int gcd(int a,int b)&#123;    if(a==b)return a;        if(a&lt;b)swap(a,b);    while(b!=0)&#123;        int c = a%b;        a = b;        b = c;    &#125;    return a;&#125;bool leap(int a)&#123;    if((a%100!=0||a%400==0)&amp;&amp;(a%4==0))return 1;    else return 0;&#125;void solve()&#123;    int n,arr[100];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int ans = arr[0];    for(int i=1;i&lt;n;i++)ans=(ans*arr[i])/gcd(ans,arr[i]);        int y,m,d;    scanf(&quot;%d/%d/%d&quot;,&amp;y,&amp;m,&amp;d);        int month[15] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    d+=ans;        while(d&gt;month[m])&#123;        d-=month[m];        if(m==12)&#123;            y++;            m = 1;        &#125;        else&#123;            if(leap(y)&amp;&amp;m==2)&#123;                d--;            &#125;            m++;        &#125;    &#125;    printf(&quot;%04d/%02d/%02d\\n&quot;,y,m,d);&#125;signed main()&#123;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æŒ‡æ•¸2^kçš„å››å€‹è‡ªç„¶æ•¸å¹³æ–¹å’Œä¹‹æ‰€æœ‰è¡¨ç¤ºæ³•","url":"/a118/","content":"a118/ æŒ‡æ•¸2^kçš„å››å€‹è‡ªç„¶æ•¸å¹³æ–¹å’Œä¹‹æ‰€æœ‰è¡¨ç¤ºæ³•\n#include &lt;bits/stdc++.h&gt;#define N 64000#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int num[5],sqr[N];int solution = 0,n;void init()&#123;    for(int i=0;i&lt;N;i++)sqr[i] = i*i;&#125;void pick(int remain,int id)&#123;    if(id==4)&#123;        int r = sqrt(remain);        if(sqr[r]==remain)&#123;            cout&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;&quot; &quot;&lt;&lt;num[3]&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;            solution++;        &#125;        return;    &#125;    int lower = max(1,num[id-1]),upper = sqrt(remain/(5-id));        for(int i=lower;i&lt;=upper;i++)&#123;        num[id]= i;        pick(remain-sqr[i],id+1);    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    pick(1&lt;&lt;n,1);    if(solution==0)cout&lt;&lt;0&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ‹¬è™Ÿå•é¡Œ","url":"/a119/","content":"a119. æ‹¬è™Ÿå•é¡Œ\n#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; stk;int main()&#123;    string s;    getline(cin,s);    int len = s.size(),ans = 0,f=1;    for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)stk.push(1);        else if(s[i]==&#x27;)&#x27;)&#123;            if(!stk.empty())&#123;                stk.pop();                ans++;            &#125;            else f = 0;        &#125;    &#125;    if(!stk.empty())f= 0;        if(f)cout&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;0&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ä¸­ç½®å¼è½‰å¾Œç½®å¼","url":"/a120/","content":"a120. ä¸­ç½®å¼è½‰å¾Œç½®å¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    map&lt;char,int&gt; mp&#123;&#123;&#x27;+&#x27;,1&#125;,&#123;&#x27;-&#x27;,1&#125;,&#123;&#x27;*&#x27;,2&#125;,&#123;&#x27;/&#x27;,2&#125;,&#123;&#x27;(&#x27;,0&#125;&#125;;    string s;cin&gt;&gt;s;    stack&lt;char&gt; st;    int len = s.size();        for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)st.push(&#x27;(&#x27;);        else if(s[i]==&#x27;)&#x27;)&#123;            while(!st.empty()&amp;&amp;st.top()!=&#x27;(&#x27;)&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.pop();        &#125;        else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;            while(!st.empty() &amp;&amp; mp[st.top()]&gt;=mp[s[i]])&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.push(s[i]);        &#125;        else cout&lt;&lt;s[i];    &#125;    while(!st.empty())&#123;        cout&lt;&lt;st.top();        st.pop();    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é›»è…¦ç®—è¡“é‹ç®—","url":"/a121/","content":"a121. é›»è…¦ç®—è¡“é‹ç®—\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    string s;    while(n--)&#123;        cin&gt;&gt;s;        stack&lt;int&gt; stk;        bool legal = 1;                for(int i=0;i&lt;s.size();i++)&#123;            if(s[i]==&#x27;)&#x27;||s[i]==&#x27;,&#x27;||s[i]==&#x27;(&#x27;);            else if(isdigit(s[i]))&#123;                int sum = s[i]-&#x27;0&#x27;;                while(isdigit(s[++i]))&#123;                    sum=sum*10+(s[i]-&#x27;0&#x27;);                &#125;                stk.push(sum);                i--;            &#125;            else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;                if(s[i+1]!=&#x27;)&#x27;)&#123;                    legal = 0;                    break;                &#125;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;&amp;&amp; a==0)&#123;                    legal = 0;                    break;                &#125;                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);            &#125;            else&#123;                legal = 0;                break;            &#125;        &#125;        if(legal==0)cout&lt;&lt;-1&lt;&lt;endl;        else if(stk.size()==1)cout&lt;&lt;stk.top()&lt;&lt;endl;        else cout&lt;&lt;-1&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ¨¹ç‹€åœ–åˆ†æ","url":"/a123/","content":"a123. æ¨¹ç‹€åœ–åˆ†æ\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,father[N],h[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    int maxn = 0;    for(auto next:edge[cur])&#123;        dfs(next);        maxn = max(maxn,h[next]+1);    &#125;    h[cur] = maxn;&#125;signed main()&#123;    ios;    memset(h,0,sizeof(h));    memset(father,0,sizeof(father));        cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int k;cin&gt;&gt;k;        for(int j=0;j&lt;k;j++)&#123;            int temp;cin&gt;&gt;temp;            edge[i].push_back(temp);            father[temp] = i;        &#125;    &#125;    int root = 1;    while(father[root]!=0)root++;        dfs(root);        lld ans = 0;    for(int i=1;i&lt;=n;i++)ans += h[i];        cout&lt;&lt;root&lt;&lt;endl&lt;&lt;ans&lt;&lt;endl;&#125;//O(N)çš„ä½œæ³•#include &lt;bits/stdc++.h&gt;#define lld long longusing namespace std;lld n,m;int main()&#123;    int t;scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        int n,m,ans = 1;scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        m--;    //å¾0é–‹å§‹        for(int i=1;i&lt;n;i++)&#123;         //å…±n-1æ­¥è¦èµ°            if(m&amp;1)ans = ans*2+1;     //å¾€å³é‚Šèµ°            else ans = ans*2;            m = m&gt;&gt;1;                 //ç”±ä½bitåˆ°é«˜bitæ±ºå®šæ¯ä¸€æ­¥è¦æ€éº¼èµ°        &#125;        printf(&quot;%lld\\n&quot;,ans);    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]äºŒåˆ†åœ–","url":"/a124/","content":"a124. äºŒåˆ†åœ–\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,m,ans = 0,cnt[2];vector&lt;int&gt; edge[N];int color[N];bool dfs(int cur,int c)&#123;    color[cur] = c;    cnt[c]+=1;    bool flag = 1;    for(auto i:edge[cur])&#123;        if(color[i]==color[cur])return 0;        if(color[i]==-1)flag = (flag &amp;&amp; dfs(i,!c));    &#125;    return flag;&#125;void solve()&#123;    memset(color,0,sizeof(color));        for(int i=0;i&lt;n;i++)color[i] = -1;        for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;a--;b--;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(color[i]==-1)&#123;            cnt[0] = 0;cnt[1] = 0;            if(!dfs(i,0))&#123;                cout&lt;&lt;0&lt;&lt;endl;                return;            &#125;            ans += min(cnt[0],cnt[1]);            //æœ‰å¯èƒ½æ˜¯éé€£é€šåœ–ï¼Œç”¨+=        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    solve();&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é€£è™Ÿæˆ–ä¸é€£è™Ÿ","url":"/a127/","content":"a127. é€£è™Ÿæˆ–ä¸é€£è™Ÿ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int n;int main()&#123;    while(cin&gt;&gt;n)&#123;        set&lt;int&gt;s;        for(int i=0;i&lt;n;i++)&#123;            int x;cin&gt;&gt;x;            s.insert(x);        &#125;        int maxn = *(--s.end());        int minn = *s.begin();        if(s.size()==maxn-minn+1)cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; yes&quot;&lt;&lt;endl;        else cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; no&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è¡€ç·£é—œä¿‚","url":"/a122/","content":"a122. è¡€ç·£é—œä¿‚\n#include &lt;bits/stdc++.h&gt;#define N 100005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,start,dis[N];bool visit[N];vector&lt;int&gt;edge[N];int dfs(int id,int cur_dis)&#123;  //å°‹æ‰¾é»idçš„æœ€é é»è·é›¢    if(visit[id])return 0;    visit[id] = 1;    int len = edge[id].size(),max_len=0;    for(int i=0;i&lt;len;i++)&#123;        int next = edge[id][i];        if(visit[next])continue;        dis[next] = cur_dis+1;        int temp = dfs(next,cur_dis+1);        max_len = max(max_len,temp);    &#125;    return max_len+1;&#125;int main()&#123;    ios;    cin&gt;&gt;n;    for(int i=0;i&lt;n-1;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    start = 0;    memset(visit,0,sizeof(visit));    int distance = dfs(2,0);distance--;    for(int i=0;i&lt;n;i++)&#123;        if(dis[i]==distance)&#123;            start = i;            break;        &#125;    &#125;    memset(visit,0,sizeof(visit));    cout&lt;&lt;dfs(start,0)-1&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]Agar.io","url":"/a128/","content":"a128. Agar.io\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,full[N];set&lt;int&gt; s[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    fill(full,full+n+1,10);    for(int i=1;i&lt;=n;i++)s[i].insert(i);        while(m--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(full[b]&gt;full[a])swap(a,b);        full[a] += full[b];        full[b] = 0;        for(auto p:s[b])s[a].insert(p);        s[b].clear();    &#125;    int ans = max_element(full,full+n+1)-full;    cout&lt;&lt;ans&lt;&lt;endl;    for(auto p:s[ans])cout&lt;&lt;p&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é£›å¤©æ¡‘å¦®","url":"/a129/","content":"a129. é£›å¤©æ¡‘å¦®\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;vector&lt;pii&gt; vec;bool cmp(pii a,pii b)&#123;    if(a.first==b.first)return a.second&gt;b.second;    return a.first&lt;b.first;&#125;int main()&#123;    int n,x,y,h;cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;h;        vec.push_back(&#123;x*x+y*y,h&#125;);    &#125;    sort(vec.begin(),vec.end(),cmp);    int ans  = 0,maxh = 0;    for(int i=0;i&lt;n;i++)&#123;        maxh = max(maxh,vec[i].second);        ans = max(ans,maxh-vec[i].second);    &#125;//ç¶­è­·æœ€é«˜çš„æ¨¹    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]äººå“¡èª¿å‹•","url":"/a130/","content":"a130. äººå“¡èª¿å‹•\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    int wait[N][N];memset(wait,0,sizeof(wait));        int m,ans = 0;cin&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(wait[b][a]&gt;0)&#123;            ans++;wait[b][a]--;        &#125;        else wait[a][b]++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å¤§é»‘é¦¬","url":"/a131/","content":"a131. å¤§é»‘é¦¬\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int k,n;int normal[N][N],lower[N][N],upper[N][N];bool win(int a,int b,int is_normal)&#123;    for(int i=0;i&lt;k+1;i++)&#123;        if(is_normal==0)&#123;            if(normal[a][i]&lt;=normal[b][k+i])return 0;        &#125;        else&#123;            if(upper[a][i]&lt;=lower[b][k+i])return 0;        &#125;    &#125;    return 1;&#125;int main()&#123;    cin&gt;&gt;k&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int s;cin&gt;&gt;s;        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;normal[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;upper[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;lower[s][j];    &#125;    for(int p=0;p&lt;=1;p++)&#123;        for(int i=n;i&gt;0;i--)&#123;    //å¾ç¨®å­åºè¼ƒå°çš„é–‹å§‹            bool f = 1;            for(int j=1;j&lt;=n;j++)&#123;                if(!win(i,j,p))&#123;                    f = 0;                    break;                &#125;            &#125;            if(f)&#123;                cout&lt;&lt;i&lt;&lt;&quot; &quot;;                break;            &#125;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ä¸»æ©Ÿæ’ç¨‹","url":"/a132/","content":"a132. ä¸»æ©Ÿæ’ç¨‹\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define max_ele(a) max_element(a,a+dh)using namespace std;int n,dh;void solve()&#123;    int s;cin&gt;&gt;s;    int arr[N]=&#123;0&#125;,brr[N]=&#123;0&#125;,crr[N]=&#123;0&#125;;    while(s--)&#123;        int a,b,c,d,e,f;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;        int start = (a-1)*24+b;        for(int j=0;j&lt;c;j++)&#123;            arr[(start+j)%dh]+=d;            brr[(start+j)%dh]+=e;            crr[(start+j)%dh]+=f;        &#125;    &#125;    cout&lt;&lt;*max_ele(arr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(brr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(crr)&lt;&lt;endl;    cin&gt;&gt;s;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;dh;    dh = dh*24;    while(n--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ¡è˜‘è‡æ”»ç•¥å•é¡Œ","url":"/a133/","content":"a133. æ¡è˜‘è‡æ”»ç•¥å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    cin&gt;&gt;n;    int ans = 0,dp[N][N];    memset(dp,0,sizeof(dp));        FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        dp[i][i] = temp;        ans = max(ans,temp);    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            dp[i][j] = dp[i][j-1]+dp[j][j];            ans = max(ans,dp[i][j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å›æ–‡æ—¥æœŸå•é¡Œ","url":"/a134/","content":"a134. å›æ–‡æ—¥æœŸå•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;vector&lt;int&gt;ans;bool leap(int temp)&#123;    return (((temp%4)==0 &amp;&amp;(temp%100)!=0)||(temp%400)==0);&#125;void check(string s)&#123;    string temp = s;    reverse(temp.begin(),temp.end());    if(temp==s)ans.push_back(stoi(s));&#125;void solve()&#123;    cin&gt;&gt;n;    ans.clear();    int month[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    month[2]+=((leap(n))?1:0);    for(int i=1;i&lt;=12;i++)&#123;        for(int j=1;j&lt;=month[i];j++)&#123;            check(to_string(n)+to_string(i)+to_string(j));            if(i&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+to_string(j));            if(j&lt;10)check(to_string(n)+to_string(i)+&quot;0&quot;+to_string(j));            if(i&lt;10 &amp;&amp; j&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+&quot;0&quot;+to_string(j));        &#125;    &#125;    sort(ans.begin(),ans.end());    cout&lt;&lt;ans.size();    for(auto i:ans)cout&lt;&lt;&quot; &quot;&lt;&lt;i;    cout&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å·§å…‹åŠ›æ“ºç›’","url":"/a135/","content":"a135. å·§å…‹åŠ›æ“ºç›’\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,k;int r[9],box[9];;bool cmp(vector&lt;int&gt; r)&#123;    for(int i=0;i&lt;9;i+=3)&#123;        if(r.size()==3)&#123;            if((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1])&amp;&amp;(r[2]&amp;box[i+2]))&#123;                return true;            &#125;            //å°æ–¼é€™ä¸€è¡Œçš„æŒ‡å®šæ˜¯æœ‰æ»¿è¶³çš„ï¼Œå›å‚³æ­£ç¢ºï¼ˆä¸‹ä¸€å€‹è¦æ±‚ç¹¼çºŒå†å‘¼å«ä¸€æ¬¡ï¼‰        &#125;        else if(((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1]))||((r[0]&amp;box[i+1])&amp;&amp;(r[1]&amp;box[i+2])))&#123;            return true;        &#125;    &#125;    return false;&#125;vector&lt;int&gt; rule;vector&lt;vector&lt;int&gt;&gt; rule_list;void solve()&#123;    for(int i=0;i&lt;9;i++)&#123;        int temp=1;temp = temp&lt;&lt;i;        r[i] = temp;        box[i] = temp;    &#125;    map&lt;string,int&gt; mp = &#123;        &#123;&quot;PS&quot;,r[0]&#125;,        &#123;&quot;PC&quot;,r[1]&#125;,        &#123;&quot;PT&quot;,r[2]&#125;,        &#123;&quot;P?&quot;,r[0]|r[1]|r[2]&#125;,        &#123;&quot;BS&quot;,r[3]&#125;,        &#123;&quot;BC&quot;,r[4]&#125;,        &#123;&quot;BT&quot;,r[5]&#125;,        &#123;&quot;B?&quot;,r[3]|r[4]|r[5]&#125;,        &#123;&quot;YS&quot;,r[6]&#125;,        &#123;&quot;YC&quot;,r[7]&#125;,        &#123;&quot;YT&quot;,r[8]&#125;,        &#123;&quot;Y?&quot;,r[6]|r[7]|r[8]&#125;,        &#123;&quot;?S&quot;,r[0]|r[3]|r[6]&#125;,        &#123;&quot;?C&quot;,r[1]|r[4]|r[7]&#125;,        &#123;&quot;?T&quot;,r[2]|r[5]|r[8]&#125;,        &#123;&quot;??&quot;,511&#125;,    &#125;;    cin&gt;&gt;n;    while(n--)&#123;        cin&gt;&gt;k;        rule.resize(k);        for(int i=0;i&lt;k;i++)&#123;            char temp[3];cin&gt;&gt;temp[0]&gt;&gt;temp[1];            rule[i] = (mp[temp]);        &#125;        rule_list.push_back(rule);    &#125;    int ans = 0;    do&#123;        ans += all_of(rule_list.begin(),rule_list.end(),cmp);            &#125;while(next_permutation(box,box+9));        cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å…ƒä»¶æ¸¬è©¦æ’ç¨‹å•é¡Œ","url":"/a136/","content":"a136. å…ƒä»¶æ¸¬è©¦æ’ç¨‹å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 30#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,ans[N];;bool edge[N][N],is_root[N];bool is_front(int u, int v)&#123;    if(edge[u][v])return true;    for(int i=0;i&lt;n;i++)&#123;        if(edge[u][i] &amp;&amp; is_front(i,v))            return true;    &#125;    return false;&#125;bool togological()&#123;    int deg[N],sum = 0,ind = 0;    memset(deg,0,sizeof(deg));    rep(i,0,n-1)&#123;        rep(j,0,n-1)&#123;            if(edge[i][j])deg[j] += 1;        &#125;    &#125;    queue&lt;int&gt; que;    rep(i,0,n-1)if(deg[i]==0)&#123;        if(sum == 1)return false;        sum += 1;        que.push(i);    &#125;    while(!que.empty())&#123;        int cur = que.front();sum = 0;        ans[ind++] = cur;        que.pop();        for(int i=0;i&lt;n;i++)&#123;            if(edge[cur][i])&#123;                deg[i]--;                if(deg[i] == 0)&#123;                    if(sum == 1)return false;                    sum += 1;                    que.push(i);                &#125;            &#125;        &#125;    &#125;    if(ind &lt; n)return false;    return true;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    bool flag = 1;    memset(edge,0,sizeof(edge));    fill(is_root,is_root+N,1);    for(int i=1;i&lt;=m;i++)&#123;        char a,b;cin&gt;&gt;a&gt;&gt;b;        int from = a-&#x27;A&#x27;,to = b-&#x27;A&#x27;;        is_root[to] = 0;        edge[from][to] = 1;        if(is_front(to,from))&#123;            flag = 0;            cout&lt;&lt;&quot;Order conflict after getting pair &quot;&lt;&lt;i&lt;&lt;endl;            break;        &#125;        else if(togological())&#123;            flag = 0;            cout&lt;&lt;&quot;Determine the testing sequence after getting pair &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;;            for(int i=0;i&lt;n;i++)cout&lt;&lt;(char)(ans[i]+&#x27;A&#x27;);            cout&lt;&lt;endl;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;No answer&quot;&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å‹‡è€…å†’éšª","url":"/a137/","content":"a137. å‹‡è€…å†’éšª\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,0,sizeof(mp));    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return 0;            &#125;            if(mp[nx][ny] == 0)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;    return 0;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]èƒŒåŒ…ç½®ç‰©å•é¡Œ","url":"/a139/","content":"a139. èƒŒåŒ…ç½®ç‰©å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,k;vector&lt;int&gt; vec,p;signed main()&#123;    cin&gt;&gt;n;    vec.assign(1,-1);    cin.ignore();    string s;getline(cin,s);    stringstream ss(s);    int temp;    while(ss&gt;&gt;temp)vec.push_back(temp);    cin&gt;&gt;k;        int ans = 0,len = vec.size();    for(int i=1;i&lt;=len-1;i++)&#123;        if(find(p.begin(),p.end(),vec[i])!=p.end())continue;        else if(p.size()&lt;k)&#123;            p.push_back(vec[i]);            continue;        &#125;        int index = 0, dis = 0, max_dis=0;                for(int j=0;j&lt;p.size();j++)&#123;            dis = 0;            for(int q=i+1;q&lt;=len;q++)&#123;                if(vec[q]==p[j])break;                dis += 1;            &#125;            if(max_dis &lt; dis)&#123;                max_dis = dis;                index = j;            &#125;        &#125;//        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;index&lt;&lt;endl;        p[index] = vec[i];        ans += 1;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ç‰©å“å †ç–Š","url":"/a140/","content":"a140. ç‰©å“å †ç–Š\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii p[N];bool cmp(pii a, pii b)&#123;    return a.x*b.y &lt; a.y*b.x;    //p[1~n]è®Šæˆå¾ä¸Šåˆ°ä¸‹&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,0,n-1)cin&gt;&gt;p[i].x;    rep(i,0,n-1)cin&gt;&gt;p[i].y;    sort(p,p+n,cmp);    int weight = 0,ans = 0;    for(int i=0;i&lt;n-1;i++)&#123;        weight += p[i].x;        ans += weight*p[i+1].y;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]åŸºåœ°å°","url":"/a141/","content":"a141. åŸºåœ°å°\n#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 50005using namespace std;int n,k,arr[N];//ç¢ºèªç›´å¾‘å¯å¦è¦†è“‹å…¨éƒ¨ï¼ˆgreedyï¼‰bool check(int sum)&#123;    int max_cover = arr[0]+sum;    int cnt=1;    for(int i=1;i&lt;n;i++)&#123;        if(max_cover &lt; arr[i])&#123;            max_cover = arr[i]+sum;            cnt++;        &#125;    &#125;    return (cnt&lt;=k);&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    int l = 1,r = ceil((arr[n-1]-arr[0])/k);    //å€é–“[l,r]äºŒåˆ†æœå°‹ç›´å¾‘    while(l&lt;r)&#123;        int mid = (l+r)/2;        if(check(mid))r = mid;        else l = mid+1;    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ç„¡åˆ»åº¦å®¹å™¨å€’æ°´å•é¡Œ","url":"/a142/","content":"a142. ç„¡åˆ»åº¦å®¹å™¨å€’æ°´å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define double long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int x,y,z;int a[N][N];bool visit[N][N];void solve()&#123;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;    memset(a,0x3f3f3f3f,sizeof(a));memset(visit,0,sizeof(visit));    a[0][0] = 0;    queue&lt;pii&gt;que;    que.push(&#123;0,0&#125;);    visit[0][0] = 1;        bool f = 0;    while(!que.empty())&#123;        pii cur = que.front();        que.pop();        int mmin = cur.x,mmax = cur.y;        int dx[6] = &#123;max(0,mmax-(y-mmin)),min(mmax+mmin,x),x,mmin,0,mmin&#125;;        int dy[6] = &#123;min(y,mmax+mmin),max(0,mmax-(x-mmin)),mmax,y,mmax,0&#125;;                for(int i=0;i&lt;6;i++)&#123;            int nx = dx[i],ny = dy[i];            if(nx==z||ny==z)&#123;                f = 1;                cout&lt;&lt;a[mmin][mmax]+1&lt;&lt;endl;                return;            &#125;            if(visit[nx][ny])continue;            a[nx][ny] = a[mmin][mmax]+1;            visit[nx][ny] = 1;            que.push(&#123;nx,ny&#125;);        &#125;    &#125;    if(!f)cout&lt;&lt;-1&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é—œéµå­—æœå°‹æ¨¡æ“¬","url":"/a143/","content":"a143. é—œéµå­—æœå°‹æ¨¡æ“¬\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,num_key = 0;string key[N];vector&lt;pif&gt; ans;int com_string(string s1, string s2)&#123;    s1 = &quot;0&quot;+s1;s2 = &quot;0&quot;+s2;    int ans = 0,com[N][N];memset(com,0,sizeof(com));    int len1 = s1.size(),len2 = s2.size();    for(int i=1;i&lt;len1;i++)&#123;        for(int j=1;j&lt;len2;j++)&#123;            if(s1[i] == s2[j])&#123;                com[i][j] = com[i-1][j-1]+1;                ans = max(ans,com[i][j]);            &#125;        &#125;    &#125;    return ans;&#125;bool cmp(pif a,pif b)&#123;    if(a.y == b.y)return a.x &lt; b.x;    return a.y &gt; b.y;&#125;float max_num(string s)&#123;    float ans = 0.0;    for(int i=0;i&lt;num_key;i++)&#123;        ans = max(ans,(float)com_string(s,key[i])/key[i].size());    &#125;    return ans;&#125;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);    while(ss&gt;&gt;key[num_key++]);    cin&gt;&gt;n;cin.ignore();    while(n--)&#123;        int doc_num;        getline(cin,s);        stringstream ss2(s);        ss2&gt;&gt;doc_num;        float score = 0.0;        while(ss2 &gt;&gt; s)score += max_num(s);                score = round(score*100)/100;        ans.push_back(&#123;doc_num,score&#125;);    &#125;    sort(ans.begin(),ans.end(),cmp);    if(ans[0].y &lt;= 0)cout&lt;&lt;&quot;FALSE&quot;&lt;&lt;endl;    else for(auto i: ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è¾²ä½œç‰©æ¡æ”¶å•é¡Œ","url":"/a144/","content":"a144. è¾²ä½œç‰©æ¡æ”¶å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 25#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,num[N][N],dp[N][N];void init()&#123;    memset(num,0,sizeof(num));    memset(dp,0,sizeof(dp));&#125;signed main()&#123;    init();    cin&gt;&gt;n;    rep(i,1,n)rep(j,1,n)cin&gt;&gt;num[i][j];        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];        &#125;    &#125;    int ans = 0;        //å·¦ä¸Š(a,b)å³ä¸‹(x,y)    rep(i,1,n)rep(j,1,n)rep(a,1,i)rep(b,1,j)    ans = max(ans,num[i][j]-num[a-1][j]-num[i][b-1]+num[a-1][b-1]);        cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æ¬å®¶è¦ç•«å•é¡Œ","url":"/a145/","content":"a145. æ¬å®¶è¦ç•«å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);        int w[N],v[N],ind=0;    while(ss&gt;&gt;w[ind++]);    ind--;    for(int i=0;i&lt;ind;i++)cin&gt;&gt;v[i];    int c;cin&gt;&gt;c;    int dp[c+5];    memset(dp,0,sizeof(dp));    for(int i=0;i&lt;ind;i++)&#123;        for(int j=c;j&gt;=w[i];j--)&#123;            dp[j] = max(dp[j],dp[j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[c]&lt;&lt;endl;    &#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ä¿ƒéŠ·æ´»å‹•","url":"/a147/","content":"a147/ ä¿ƒéŠ·æ´»å‹•\n#include &lt;iostream&gt;using namespace std;void discount(double &amp;a,double &amp;b)&#123;    if(a==b)&#123;        b = 0.5*b;    &#125;&#125;int main()&#123;    double p1, p2;    cout &lt;&lt; &quot;Original price:&quot; &lt;&lt; endl;    cin &gt;&gt; p1 &gt;&gt; p2;    discount(p1,p2);    cout &lt;&lt; &quot;Price after discount:&quot; &lt;&lt; endl;    cout &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; endl;    return 0;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å­—å…ƒé »ç‡","url":"/a148/","content":"a148. å­—å…ƒé »ç‡\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;bool cmp(pii a,pii b)&#123;    if(a.second==b.second)return a.first&gt;b.first;    else return a.second&lt; b.second;&#125;int main()&#123;    string s;    while(getline(cin,s))&#123;        map&lt;int,int&gt; mp;    //asciã€å‡ºç¾æ¬¡æ•¸        for(auto temp:s)mp[temp]+=1;        vector&lt;pii&gt;vec;        for(auto p:mp)&#123;            vec.push_back(p);        &#125;        sort(vec.begin(),vec.end(),cmp);        for(auto i:vec)&#123;            cout&lt;&lt;i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second&lt;&lt;endl;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å¤šé‚Šå½¢é¢ç©","url":"/a150/","content":"a150. å¤šé‚Šå½¢é¢ç©\n#include &lt;bits/stdc++.h&gt;using namespace std;struct point&#123;    double x;    double y;&#125;;int main()&#123;    int n;    cin&gt;&gt;n;    point p[n];        for(int i=0;i&lt;n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    double a = 0.0;    for(int i=0;i&lt;n;i++)&#123;        if(i==n-1)&#123;            a+=(p[i].x)*(p[0].y)-(p[0].x)*(p[i].y);        &#125;        else&#123;            a+=(p[i].x)*(p[i+1].y)-(p[i+1].x)*(p[i].y);        &#125;    &#125;    a = abs(a/2);    cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å¾Œåºå¼æ±‚å€¼","url":"/a151/","content":"a151. å¾Œåºå¼æ±‚å€¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        stack&lt;int&gt; stk;        for(int i=0;i&lt;s.size();i++)&#123;            if(isdigit(s[i]))stk.push(s[i]-&#x27;0&#x27;);            else&#123;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);                else if(s[i]==&#x27;%&#x27;)stk.push(b%a);            &#125;        &#125;        cout&lt;&lt;stk.top()&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]äºŒåˆ†æœå°‹","url":"/a152/","content":"a152. äºŒåˆ†æœå°‹\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int t;cin&gt;&gt;t;        int pos = 0,ans = 0,find = 0,l = 0,r = n-1;    //[l,r]        while(l&lt;=r)&#123;        int mid = (l+r)/2;        ans++;        if(arr[mid]==t)&#123;            pos = mid;find = 1;break;        &#125;        else if(arr[mid]&gt;t)r = mid-1;        else l = mid+1;    &#125;    if(find)cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;&quot;not found &quot;&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]äºŒåˆ†æ³•æ±‚è§£","url":"/a153/","content":"a153. äºŒåˆ†æ³•æ±‚è§£\n#include &lt;bits/stdc++.h&gt;int main()&#123;  std::cout&lt;&lt;std::fixed&lt;&lt;std::setprecision(6)&lt;&lt;log(2)&lt;&lt;std::endl;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é™¤æ³•","url":"/a154/","content":"a154. é™¤æ³•\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;bool used[10],f;bool check(int t)&#123;    bool cur_used[10]=&#123;0&#125;;    if(t&lt;10000&amp;&amp;used[0]==1)return 0;    else if(t&lt;10000)cur_used[0] = 1;        while(t&gt;0)&#123;        int d = t%10;        if(cur_used[d])return 0;        else if(used[d])return 0;        cur_used[d] = 1;        t /= 10;    &#125;    return 1;&#125;void dfs(int first,int id)&#123;    if(id&gt;=5)&#123;        if(first%n!=0)return;        int second = first/n;        if(second&lt;1234)return;        if(check(second))&#123;            f = 1;            cout&lt;&lt;first&lt;&lt;&quot; / &quot;;            if(second&lt;10000)cout&lt;&lt;0;            cout&lt;&lt;second&lt;&lt;&quot; = &quot;&lt;&lt;n&lt;&lt;endl;            return;        &#125;    &#125;    for(int i=0;i&lt;10;i++)&#123;        if(used[i])continue;        used[i] = 1;        dfs(first*10+i,id+1);        used[i] = 0;    &#125;&#125;void solve()&#123;    while(cin&gt;&gt;n)&#123;        if(n==0)return;        memset(used,0,sizeof(used));        f=0;        dfs(0,0);        if(f==0)cout&lt;&lt;&quot;There are no solutions for &quot;&lt;&lt;n&lt;&lt;&quot;.&quot;&lt;&lt;endl;        cout&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]é›™å­æ˜Ÿå¡”","url":"/a155/","content":"a155. é›™å­æ˜Ÿå¡”\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,dp[N][N],a[N],b[N],cnt = 0;signed main()&#123;        while(cin&gt;&gt;n&gt;&gt;m)&#123;        if(!n &amp;&amp; !m)break;        cnt+=1;        cout&lt;&lt;&quot;Twin Towers #&quot;&lt;&lt;cnt&lt;&lt;endl;        memset(dp,0,sizeof(dp));        rep(i,1,n)cin&gt;&gt;a[i];        rep(i,1,m)cin&gt;&gt;b[i];                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=m;j++)&#123;                if(a[i]==b[j])&#123;                    dp[i][j] = dp[i-1][j-1]+1;                &#125;                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            &#125;        &#125;        cout&lt;&lt;&quot;Number of Tiles : &quot;;        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]è²»æ³¢é‚£å¥‘æ•¸åˆ—","url":"/a157/","content":"a157/ è²»æ³¢é‚£å¥‘æ•¸åˆ—\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]F91","url":"/a158/","content":"a158/ F91\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]éŒ¯èª¤æ›´æ­£","url":"/a159/","content":"a159/ éŒ¯èª¤æ›´æ­£\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        int row_sum[N],col_sum[N],arr[N][N];        memset(row_sum,0,sizeof(row_sum));        memset(col_sum,0,sizeof(col_sum));        memset(arr,0,sizeof(arr));                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                cin&gt;&gt;arr[i][j];                row_sum[i]+=arr[i][j];                col_sum[j]+=arr[i][j];            &#125;        &#125;        int rcnt = 0,ccnt = 0;        int rind = 0,cind = 0;                for(int i=1;i&lt;=n;i++)&#123;            if(row_sum[i]%2)&#123;                rcnt += 1;                rind = i;            &#125;            if(col_sum[i]%2)&#123;                ccnt += 1;                cind = i;            &#125;        &#125;        if(rcnt==0 &amp;&amp; ccnt==0)cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;        else if(rcnt==1 &amp;&amp; ccnt==1)cout&lt;&lt;&quot;Change bit (&quot;&lt;&lt;rind&lt;&lt;&quot;,&quot;&lt;&lt;cind&lt;&lt;&quot;)&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]ç·šæ®µè¦†è“‹é•·åº¦","url":"/a160/","content":"a160. ç·šæ®µè¦†è“‹é•·åº¦\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii a[N];signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;        sort(a,a+n);                int sum = a[0].y - a[0].x,R = a[0].y;        for(int i=1;i&lt;n;i++)&#123;            if(a[i].y &gt; R)&#123;                sum += (a[i].y-a[i].x)-(R-a[i].x)*((R-a[i].x)&gt;0);                R = a[i].y;            &#125;        &#125;        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]å°è¡¨æ©Ÿä½‡åˆ—","url":"/a163/","content":"a163. å°è¡¨æ©Ÿä½‡åˆ—\n#include &lt;bits/stdc++.h&gt;using namespace std;bool Can(int now_priority,int *p)&#123;    for(int i=now_priority+1;i&lt;=9;i++)&#123;        if(p[i]&gt;=1)return 0;    &#125;    return 1;&#125;void solve()&#123;    int n,m,pri[105];cin&gt;&gt;n&gt;&gt;m;    queue&lt;pair&lt;bool,int&gt;&gt; que;    memset(pri,0,sizeof(pri));    for(int i=0;i&lt;n;i++)&#123;        int p;cin&gt;&gt;p;        if(i==m)que.push(&#123;1,p&#125;);        else que.push(&#123;0,p&#125;);        pri[p]++;    &#125;        int ans = 0;    while(!que.empty())&#123;        auto cur = que.front();        que.pop();        if(Can(cur.second,pri))&#123;            //å¯ä»¥å°çš„è©±            ans++;            pri[cur.second]--;            if(cur.first==1)break;        &#125;        else que.push(cur);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]åœ˜é«”ä½‡åˆ—","url":"/a164/","content":"a164. åœ˜é«”ä½‡åˆ—\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int main()&#123;    ios;    int t,c=0;    while(cin&gt;&gt;t &amp;&amp; t)&#123;        c++;        map&lt;int,int&gt; mp;//[æˆå“¡ã€åœ˜é«”ç·¨è™Ÿ]        for(int i=0;i&lt;t;i++)&#123;            int n;cin&gt;&gt;n;            while(n--)&#123;                int x;cin&gt;&gt;x;                mp[x] = i;            &#125;        &#125;        queue&lt;int&gt; Q,que[1005];//åœ˜é«”é †åºã€åœ˜é«”å…§é †åº        cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;c&lt;&lt;endl;        string temp;                while(cin&gt;&gt;temp)&#123;            if(temp[0]==&#x27;E&#x27;)&#123;                int x;cin&gt;&gt;x;                if(que[mp[x]].empty())Q.push(mp[x]);                que[mp[x]].push(x);            &#125;            else if(temp[0]==&#x27;D&#x27;)&#123;                int team = Q.front();                cout&lt;&lt;que[team].front()&lt;&lt;endl;                que[team].pop();                if(que[team].empty())Q.pop();            &#125;            else if(temp[0]==&#x27;S&#x27;)&#123;                cout&lt;&lt;endl;                break;            &#125;        &#125;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"[é¡Œè§£]æœ€è¿‘é»å°å•é¡Œ","url":"/a165/","content":"a165. æœ€è¿‘é»å°å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 10002#define INF 5e18#define FOR(i,n) for(int i=0;i&lt;n;i++)#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;#define pdd pair&lt;double,double&gt;using namespace std;int n;vector&lt;pii&gt; p,temp;void init()&#123;    cout&lt;&lt;fixed&lt;&lt;setprecision(4);    temp.clear();    p.assign(n,&#123;0,0&#125;);&#125;bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125;double dis(pii a,pii b)&#123;    double x1 = a.x-b.x,y1 = a.y-b.y;    return sqrt(x1 * x1 + y1 * y1);&#125;//å€é–“[l,r]double solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l+r)/2,mid_pos = p[mid].x;;    double ans = min(solve(l,mid),solve(mid+1,r));        temp.assign((r-l+1),&#123;0,0&#125;);    merge(        p.begin() + l, p.begin() + mid + 1,        p.begin() + mid + 1, p.begin() + r + 1,        temp.begin(), cmp    );    rep(i, l, r)p[i] = temp[i-l];    temp.clear();    rep(i, l, r)&#123;        if(abs(p[i].x - mid_pos) &lt;= ans)            temp.push_back(p[i]);    &#125;    int len = temp.size();    rep(i, 0, len-1)&#123;        rep(j, i+1, len-1)&#123;            ans = min(ans, dis(temp[i],temp[j]));            if(abs(temp[i].y-temp[j].y) &gt; ans)                break;        &#125;    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        init();        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        double ans = solve(0,n-1);        if(ans &gt; 10000)cout&lt;&lt;&quot;INFINITY&quot;&lt;&lt;endl;        else cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["APCS CLASS"],"tags":["APCS","é¡Œè§£"]},{"title":"APCS CLASS PART 1","url":"/apcs1/","content":"é€™æ˜¯2021å¹´æš‘æœŸAPCSèª²ç¨‹çš„æ‰€æœ‰é¡Œç›®åƒè€ƒè§£ç­”ï¼Œå…±æœ‰34é¡Œã€‚\nA. [åŸºç¤ç¨‹å¼è¨­è¨ˆ] åŸºç¤C++ç¨‹å¼è¨­è¨ˆè¤‡ç¿’a064/ æˆç¸¾æŒ‡æ¨™\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;void solve()&#123;    int n,arr[25];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    cout&lt;&lt;arr[0];    for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;arr[i];    cout&lt;&lt;endl;        if(arr[0]&gt;=60)cout&lt;&lt;&quot;best case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60)-1)&lt;&lt;endl;        if(arr[n-1]&lt;60)cout&lt;&lt;&quot;worst case&quot;&lt;&lt;endl;    else cout&lt;&lt;*(lower_bound(arr,arr+n,60))&lt;&lt;endl;    &#125;signed main()&#123;    int t;    t = 1;//    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na096/ æ™‚é–“å·®è¨ˆç®—#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    int a1,b1,c1,a2,b2,c2;    scanf(&quot;%d:%d:%d&quot;,&amp;a1,&amp;b1,&amp;c1);    scanf(&quot;%d:%d:%d&quot;,&amp;a2,&amp;b2,&amp;c2);    int a = a1*3600+b1*60+c1,b = a2*3600+b2*60+c2;        if(b-a&gt;=0)&#123;        int temp = b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;    else&#123;        int temp = 86400+b-a;        printf(&quot;%02d:%02d:%02d&quot;,temp/3600,(temp%3600)/60,temp%60);    &#125;&#125;\na104/ é›ªèŠ±ç‰‡ç‰‡#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0)using namespace std;int n,product[100];void solve()&#123;    memset(product,0,sizeof(product));    product[0] = 1;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;80;j++)&#123;            product[j]=product[j]*4;        &#125;        for(int j=0;j&lt;80;j++)&#123;            if(product[j]&gt;=10)&#123;                product[j+1] += product[j]/10;                product[j] %=10;            &#125;        &#125;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    product[0]-=1;    int temp=0;    for(int i=80;i&gt;=0;i--)&#123;        product[i] += temp*10;        temp = product[i]%3;        product[i] /= 3;    &#125;        int start = 80;    for(int i=80;i&gt;=0;i--)        if(product[i]!=0)&#123;            start = i;            break;        &#125;    for(int i=start;i&gt;=0;i--)cout&lt;&lt;product[i];    cout&lt;&lt;endl;&#125;\nB. [å‡½å¼] å…¬ç”¨å‡½å¼ã€è‡ªå®šå‡½å¼a114/ æ‰¾å‡ºæœ€å°çš„å®Œå…¨å¹³æ–¹æ•¸#include &lt;bits/stdc++.h&gt;#define ll long long#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;void solve()&#123;    int k;cin&gt;&gt;k;    int a = ceil(sqrt(pow(10,(k-1))));    for(int i=a;;i++)&#123;        string s = to_string(i*i);        int len = s.size(),flag = 0;        for(int i=0;i&lt;len;i++)&#123;            if((s[i]-&#x27;0&#x27;)%2!=0)&#123;                flag = 1;                break;            &#125;        &#125;        if(flag==0)&#123;            cout&lt;&lt;i*i&lt;&lt;endl;            break;        &#125;    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na115/ è³“æœéŠæˆ²#include &lt;bits/stdc++.h&gt;//#define int ll//#define ll long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int maze[10][10],cur[10][10],n;    for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            cin&gt;&gt;maze[i][j];            cur[i][j] = maze[i][j];        &#125;    &#125;    while(cin&gt;&gt;n &amp;&amp; n!= -1)&#123;        for(int i=0;i&lt;5;i++)&#123;            for(int j=0;j&lt;5;j++)&#123;                if(maze[i][j]==n)maze[i][j] = 0;            &#125;        &#125;    &#125;        int ind = 1,num = -1;        for(int i=0;i&lt;5;i++)&#123;        for(int j=0;j&lt;5;j++)&#123;            if(maze[i][j]!=0)&#123;                maze[i][j] = 0;                int k,ans = 0;                for(k=0;k&lt;5;k++)if(maze[k][j]!=0)break;                if(k==5)ans+=1;                for(k=0;k&lt;5;k++)if(maze[i][k]!=0)break;                if(k==5)ans+=1;                                if(i==j)&#123;                    for(k=0;k&lt;5;k++)if(maze[k][k]!=0)break;                    if(k==5)ans+=1;                &#125;                if(i+j==4)&#123;                    int x = 4,y = 0;                    for(k=0;k&lt;5;k++)&#123;                        if(maze[x][y]!=0)break;                        else&#123;                            x--;y++;                        &#125;                    &#125;                    if(k==5)ans++;                &#125;                if(ans&gt;num)&#123;                    num = ans;                    ind = cur[i][j];                &#125;                else if(ans==num &amp;&amp; ind&gt;cur[i][j])ind = cur[i][j];                maze[i][j] = cur[i][j];            &#125;        &#125;    &#125;    cout&lt;&lt;ind&lt;&lt;endl;&#125;signed main()&#123;    ios;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\na116/ ä¸€èµ·å›å®¶çš„æ—¥å­#include &lt;bits/stdc++.h&gt;//#define ll long long//#define int ll#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t;int gcd(int a,int b)&#123;    if(a==b)return a;        if(a&lt;b)swap(a,b);    while(b!=0)&#123;        int c = a%b;        a = b;        b = c;    &#125;    return a;&#125;bool leap(int a)&#123;    if((a%100!=0||a%400==0)&amp;&amp;(a%4==0))return 1;    else return 0;&#125;void solve()&#123;    int n,arr[100];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int ans = arr[0];    for(int i=1;i&lt;n;i++)ans=(ans*arr[i])/gcd(ans,arr[i]);        int y,m,d;    scanf(&quot;%d/%d/%d&quot;,&amp;y,&amp;m,&amp;d);        int month[15] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    d+=ans;        while(d&gt;month[m])&#123;        d-=month[m];        if(m==12)&#123;            y++;            m = 1;        &#125;        else&#123;            if(leap(y)&amp;&amp;m==2)&#123;                d--;            &#125;            m++;        &#125;    &#125;    printf(&quot;%04d/%02d/%02d\\n&quot;,y,m,d);&#125;signed main()&#123;    t = 1;    while(t--)&#123;        solve();    &#125;&#125;\nC. [å‡½å¼] éè¿´å‡½å¼a117/ ä¸‰è‰²æ²³å…§å¡”#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void move(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    move(n-1,by,to,from);&#125;void honai(int n,char from,char to,char by)&#123;    if(n&lt;1)return;    move(n-1,from,by,to);    cout&lt;&lt;&quot; ring &quot;&lt;&lt;n&lt;&lt;&quot; : &quot;&lt;&lt;from&lt;&lt;&quot; =&gt; &quot;&lt;&lt;to&lt;&lt;endl;t++;    honai(n-2,by,from,to);&#125;signed main()&#123;    ios;    int n;cin&gt;&gt;n;    t = 0;    honai(n,&#x27;A&#x27;,&#x27;C&#x27;,&#x27;B&#x27;);    cout&lt;&lt;&quot;å…±éœ€&quot;&lt;&lt;t&lt;&lt;&quot;å€‹ç§»å‹•&quot;&lt;&lt;endl;&#125;\na118/ æŒ‡æ•¸2^kçš„å››å€‹è‡ªç„¶æ•¸å¹³æ–¹å’Œä¹‹æ‰€æœ‰è¡¨ç¤ºæ³•#include &lt;bits/stdc++.h&gt;#define N 64000#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int num[5],sqr[N];int solution = 0,n;void init()&#123;    for(int i=0;i&lt;N;i++)sqr[i] = i*i;&#125;void pick(int remain,int id)&#123;    if(id==4)&#123;        int r = sqrt(remain);        if(sqr[r]==remain)&#123;            cout&lt;&lt;num[1]&lt;&lt;&quot; &quot;&lt;&lt;num[2]&lt;&lt;&quot; &quot;&lt;&lt;num[3]&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl;            solution++;        &#125;        return;    &#125;    int lower = max(1,num[id-1]),upper = sqrt(remain/(5-id));        for(int i=lower;i&lt;=upper;i++)&#123;        num[id]= i;        pick(remain-sqr[i],id+1);    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    pick(1&lt;&lt;n,1);    if(solution==0)cout&lt;&lt;0&lt;&lt;endl;&#125;\na157/ è²»æ³¢é‚£å¥‘æ•¸åˆ—#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\na158/ F91#include &lt;bits/stdc++.h&gt;#define int long long#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;signed main()&#123;    ios;    int arr[40];arr[1] = 1;arr[2] = 1;    for(int i=3;i&lt;=30;i++)&#123;        arr[i] = arr[i-1]+arr[i-2];    &#125;    int n;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;arr[n]&lt;&lt;endl;    &#125;&#125;\nD. [åŸºæœ¬è³‡æ–™å‹æ…‹] æŒ‡æ¨™ã€å¤šç¶­é™£åˆ—a105. çˆºçˆºç¨®æ¨¹#include &lt;bits/stdc++.h&gt;#define N 505#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n,m,t;cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;    bool arr[N][N];    memset(arr,0,sizeof(arr));        while(t--)&#123;        int r1,r2,c1,c2;cin&gt;&gt;r1&gt;&gt;c1&gt;&gt;r2&gt;&gt;c2;        int dr = r2-r1,dc = c2-c1;        if(dr&gt;0)dr = 1;else dr = -1;        if(dc&gt;0)dc = 1;else dc = -1;                if(r1==r2)&#123;            for(int i=c1;i!=c2;i+=dc)arr[r1][i] = 1;            arr[r1][c2] = 1;        &#125;        else if(c1==c2)&#123;            for(int i=r1;i!=r2;i+=dr)arr[i][c1] = 1;            arr[r2][c1] = 1;        &#125;        else&#123;            for(int i=r1,j=c1;i!=r2;i+=dr,j+=dc)&#123;                arr[i][j] = 1;                arr[r2][c2] = 1;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(arr[i][j])ans+=1;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na106. è³“æœéŠæˆ²#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;char name[N],line[N][10];pair&lt;int,int&gt; mp[N][N];bool check(int people,int number)&#123;    int r = mp[people][number].first,c = mp[people][number].second;    line[people][r]+=1;    line[people][c+4]+=1;    if(line[people][r]==4)return 1;    if(line[people][c+4]==4)return 1;        if(r+c==3)&#123;        line[people][8]+=1;        if(line[people][8]==4)return 1;    &#125;    if(r==c)&#123;        line[people][9]+=1;        if(line[people][9]==4)return 1;    &#125;    return 0;&#125;signed main()&#123;    ios;    int n;    char cha;    cin&gt;&gt;cha&gt;&gt;n;    memset(line,0,sizeof(line));        for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;name[i];        for(int j=0;j&lt;16;j++)&#123;            int temp;cin&gt;&gt;temp;            mp[i][temp].first = j/4;            mp[i][temp].second = j%4;        &#125;    &#125;    int cnt = 16,flag = 0;    cin&gt;&gt;cha;    while(cnt--)&#123;        int temp;cin&gt;&gt;temp;        cout&lt;&lt;temp&lt;&lt;&quot; &quot;;        for(int i=0;i&lt;n;i++)&#123;            if(check(i,temp))&#123;                cout&lt;&lt;name[i]&lt;&lt;&quot; &quot;;                flag = 1;            &#125;        &#125;        if(flag)break;    &#125;&#125;\na107. åŠ å¯†è§£å¯†#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;string a = &quot;abcdefghijklmnoprstuvwxyz&quot;;string b = &quot;EXAMPLBCDFGHIJKNORSTUVWYZ&quot;;signed main()&#123;    ios;    int n;string s;    cin&gt;&gt;n;cin.ignore();    getline(cin,s);    reverse(s.begin(),s.end());    string origin = b ,key = a;    if(s[0]&gt;=&#x27;a&#x27;&amp;&amp; s[0]&lt;=&#x27;z&#x27;)swap(origin,key);        for(int i=0;i&lt;n;i+=2)&#123;        int p1 = origin.find(s[i]),p2 = origin.find(s[i+1]);        cout&lt;&lt;key[5*(p1/5)+(p2%5)]&lt;&lt;key[5*(p2/5)+(p1%5)];    &#125;    cout&lt;&lt;endl;&#125;\na147/ ä¿ƒéŠ·æ´»å‹•#include &lt;iostream&gt;using namespace std;void discount(double &amp;a,double &amp;b)&#123;    if(a==b)&#123;        b = 0.5*b;    &#125;&#125;int main()&#123;    double p1, p2;    cout &lt;&lt; &quot;Original price:&quot; &lt;&lt; endl;    cin &gt;&gt; p1 &gt;&gt; p2;    discount(p1,p2);    cout &lt;&lt; &quot;Price after discount:&quot; &lt;&lt; endl;    cout &lt;&lt; p1 &lt;&lt; &quot; &quot; &lt;&lt; p2 &lt;&lt; endl;    return 0;&#125;\na159/ éŒ¯èª¤æ›´æ­£#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;signed main()&#123;    ios;    int n;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        int row_sum[N],col_sum[N],arr[N][N];        memset(row_sum,0,sizeof(row_sum));        memset(col_sum,0,sizeof(col_sum));        memset(arr,0,sizeof(arr));                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=n;j++)&#123;                cin&gt;&gt;arr[i][j];                row_sum[i]+=arr[i][j];                col_sum[j]+=arr[i][j];            &#125;        &#125;        int rcnt = 0,ccnt = 0;        int rind = 0,cind = 0;                for(int i=1;i&lt;=n;i++)&#123;            if(row_sum[i]%2)&#123;                rcnt += 1;                rind = i;            &#125;            if(col_sum[i]%2)&#123;                ccnt += 1;                cind = i;            &#125;        &#125;        if(rcnt==0 &amp;&amp; ccnt==0)cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl;        else if(rcnt==1 &amp;&amp; ccnt==1)cout&lt;&lt;&quot;Change bit (&quot;&lt;&lt;rind&lt;&lt;&quot;,&quot;&lt;&lt;cind&lt;&lt;&quot;)&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;Corrupt&quot;&lt;&lt;endl;    &#125;&#125;\nE. [åŸºæœ¬è³‡æ–™å‹æ…‹] å­—ä¸²a065. ç§˜å¯†å·®#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        int ans = 0,len = s.size(),p=1;        for(int i=0;i&lt;len;i++)&#123;            ans+=(s[i]-&#x27;0&#x27;)*p;            p *=-1;        &#125;        cout&lt;&lt;abs(ans)&lt;&lt;endl;    &#125;&#125;\na067. ROT13#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    string s;    getline(cin,s);    for(auto p:s)&#123;        if(isalpha(p))&#123;            if(isupper(p))                cout&lt;&lt;(char)((p-&#x27;A&#x27;+13)%26+&#x27;A&#x27;);            else                cout&lt;&lt;(char)((p-&#x27;a&#x27;+13)%26+&#x27;a&#x27;);        &#125;        else&#123;            cout&lt;&lt;p;        &#125;    &#125;&#125;\na108. è¨ˆç®—å­—ä¸²é–“éš”è·é›¢#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//åœ°é»ã€å‹•ç‰©åã€æ•¸é‡int main()&#123;    string s;    char ch;    cin&gt;&gt;s&gt;&gt;ch;    ch = tolower(ch);    int len = s.size(),a1;    for(int i=0;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a1 = i;            break;        &#125;    &#125;    int a2;    for(int i=a1+1;i&lt;len;i++)&#123;        if(tolower(s[i])==ch)&#123;            a2 = i;            cout&lt;&lt;a2-a1&lt;&lt;&quot; &quot;;            a1 = a2;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\na109. è·‘é•·ç·¨ç¢¼èˆ‡è³‡æ–™å£“ç¸®#include &lt;bits/stdc++.h&gt;#define ld long doubleusing namespace std;int main()&#123;    int n,origin,after,times;    string s,t,binary[8]=&#123;&quot;000&quot;,&quot;001&quot;,&quot;010&quot;,&quot;011&quot;,&quot;100&quot;,&quot;101&quot;,&quot;110&quot;,&quot;111&quot;&#125;;    char ch;    cin&gt;&gt;n;    cin.ignore();    while(n--)&#123;        getline(cin,s);        t=&quot;&quot;;        origin = s.size();        after = 0;        ch = s[0];        times = 1;        int len = s.size();        for(int i=1;i&lt;=len;i++)&#123;            if(i!=len &amp;&amp; s[i]!=&#x27;0&#x27;&amp;&amp;s[i]!=&#x27;1&#x27;)&#123;                after = -1;                break;            &#125;            if(s[i]!=ch)&#123;                t+=ch;                t+=binary[times];                t+=&quot; &quot;;                times=1;                ch = s[i];                after+=4;            &#125;            else&#123;                times++;                if(times==7)&#123;                    t+=ch;                    t+=binary[7];                    t+=&quot; &quot;;                    times=1;                    after +=4;                    ch = s[i+1];                    i++;                &#125;            &#125;        &#125;        if(after==-1)cout&lt;&lt;after&lt;&lt;endl;        else cout&lt;&lt;t&lt;&lt;fixed&lt;&lt;setprecision(0)&lt;&lt;(double)after*100/origin&lt;&lt;&quot;%&quot;&lt;&lt;endl;    &#125;&#125;\na110. æ£’çƒéŠæˆ²#include &lt;bits/stdc++.h&gt;using namespace std;int num_of_out,d[3] = &#123;0&#125;;int transfer(string a)&#123;    if(a==&quot;SO&quot;||a==&quot;FO&quot;||a==&quot;GO&quot;)return 0;    else if(a==&quot;1B&quot;)return 1;    else if(a==&quot;2B&quot;)return 2;    else if(a==&quot;3B&quot;)return 3;    else return 4;&#125;int win(int c)&#123;    int s = 0;    if(c!=4)&#123;        for(int i=0;i&lt;c;i++)&#123;            if(d[2-i])s++;        &#125;        for(int i=0;i&lt;3-c;i++)&#123;            d[2-i] = d[2-c-i];        &#125;    &#125;    if(c==4)&#123;        for(int i=0;i&lt;3;i++)if(d[i])s++;        s++;    &#125;    else d[c-1] = 1;    for(int i=0;i&lt;c-1;i++)d[i] = 0;    return s;&#125;int main()&#123;    int data[9][5];    for(int i=0;i&lt;9;i++)&#123;        int temp;        cin&gt;&gt;temp;        for(int k=0;k&lt;temp;k++)&#123;            string a;            cin&gt;&gt;a;            data[i][k] = transfer(a);        &#125;    &#125;    cin&gt;&gt;num_of_out;    int now_out = 0,ans = 0;    for(int k=0;k&lt;5;k++)&#123;        for(int i=0;i&lt;9;i++)&#123;            if(now_out&gt;=num_of_out)break;            if(data[i][k])&#123;                ans+=win(data[i][k]);            &#125;            else&#123;                now_out++;                if(now_out%3==0)&#123;                    for(int i =0;i&lt;3;i++)d[i] = 0;                &#125;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nF. [åŸºæœ¬è³‡æ–™å‹æ…‹] çµæ§‹a111. æ’éšŠ#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    int t[1005][3],line=0,ans=0,cur=0;        cin&gt;&gt;t[0][0]&gt;&gt;t[0][1];    t[0][2] = t[0][0]+t[0][1];    for(int i=1;i&lt;n;i++)&#123;        cin&gt;&gt;t[i][0]&gt;&gt;t[i][1];        if(t[i][0]&lt;t[i-1][2])t[i][2] = t[i-1][2]+t[i][1];        else t[i][2] = t[i][0]+t[i][1];                if(t[i][0]&gt;=t[cur][2])&#123;            ans = max(ans,line);            while(t[i][0]&gt;=t[cur][2])&#123;                if(cur==i)break;                line--;                cur++;            &#125;        &#125;        if(t[i][0]&lt;t[cur][2])line++;    &#125;    ans = max(ans,line);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na112. å‹•ç‰©æ•¸é‡çµ±è¨ˆ#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;string,queue&lt;pair&lt;string,int&gt;&gt;&gt; mp;//åœ°é»ã€å‹•ç‰©åã€æ•¸é‡int main()&#123;    int n;cin&gt;&gt;n;    vector&lt;string&gt; p;    while(n--)&#123;        string animal,pos;        int qu,ind;        cin&gt;&gt;animal&gt;&gt;qu&gt;&gt;pos;        ind = find(p.begin(),p.end(),pos)-p.begin();        if(ind==p.size())p.push_back(pos);        mp[pos].push(&#123;animal,qu&#125;);    &#125;    for(auto i:p)&#123;        cout&lt;&lt;i&lt;&lt;&quot;:&quot;;        map&lt;string,int&gt; sta;        vector&lt;string&gt; almp;        while(!mp[i].empty())&#123;            string an = mp[i].front().first;            int qu = mp[i].front().second;            mp[i].pop();            int ind = find(almp.begin(),almp.end(),an)-almp.begin();            if(ind==almp.size())almp.push_back(an);            sta[an]+=qu;        &#125;        bool c = 0;        for(auto j:almp)&#123;            if(c)cout&lt;&lt;&quot;,&quot;;            cout&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;sta[j];            c = 1;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\na113. 99éŠæˆ²#include &lt;bits/stdc++.h&gt;using namespace std;map&lt;int,queue&lt;string&gt;&gt; mp;int main()&#123;    for(int i=0;i&lt;4;i++)&#123;        char ch;cin&gt;&gt;ch;        for(int j=0;j&lt;13;j++)&#123;            string s;cin&gt;&gt;s;            mp[ch-&#x27;A&#x27;].push(s);        &#125;    &#125;    int id = 0,dir=1,sum=0;    while(sum&lt;=99)&#123;        string card = mp[id].front();        if(card==&quot;A&quot;)sum=0;        else if(card==&quot;4&quot;)dir*=-1;        else if(card==&quot;5&quot;);        else if(card==&quot;10&quot;)&#123;            sum+=10;            if(sum&gt;99)sum-=20;        &#125;        else if(card==&quot;J&quot;);        else if(card==&quot;Q&quot;)&#123;            sum+=20;            if(sum&gt;99)sum-=40;        &#125;        else if(card==&quot;K&quot;)sum=99;        else&#123;            sum+=(card[0]-&#x27;0&#x27;);            if(sum&gt;99)&#123;                cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;mp[id].size()-1&lt;&lt;endl;                break;            &#125;        &#125;        mp[id].pop();        if(mp[id].empty())&#123;            cout&lt;&lt;char(&#x27;A&#x27;+id)&lt;&lt;endl&lt;&lt;sum&lt;&lt;endl;            break;        &#125;        id = (id+dir+4)%4;//        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\na150. å¤šé‚Šå½¢é¢ç©#include &lt;bits/stdc++.h&gt;using namespace std;struct point&#123;    double x;    double y;&#125;;int main()&#123;    int n;    cin&gt;&gt;n;    point p[n];        for(int i=0;i&lt;n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    double a = 0.0;    for(int i=0;i&lt;n;i++)&#123;        if(i==n-1)&#123;            a+=(p[i].x)*(p[0].y)-(p[0].x)*(p[i].y);        &#125;        else&#123;            a+=(p[i].x)*(p[i+1].y)-(p[i+1].x)*(p[i].y);        &#125;    &#125;    a = abs(a/2);    cout&lt;&lt;fixed&lt;&lt;setprecision(2)&lt;&lt;a&lt;&lt;endl;&#125;\n","categories":["APCSæª¢å®š"],"tags":["APCS","ç«¶è³½ç­†è¨˜"]},{"title":"[é¡Œè§£]APCSè³¼è²·åŠ›","url":"/apcs2101-1/","content":"110/01 å¯¦ä½œé¡Œç¬¬ä¸€é¡Œ è³¼è²·åŠ›\nAPCSçš„ç¬¬ä¸€é¡Œéƒ½æ˜¯æ‡‰è©²è¦ç§’æ®ºçš„ï¼Œä¹Ÿé †åˆ©æ‹¿åˆ°100åˆ†\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,d,cost = 0,total = 0;signed main()&#123;     ios;    cin&gt;&gt;n&gt;&gt;d;    int arr[3];    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[0]&gt;&gt;arr[1]&gt;&gt;arr[2];        sort(arr, arr+3);        if(arr[2]-arr[0]&gt;=d)&#123;            total++;            cost +=((arr[0]+arr[1]+arr[2])/3);        &#125;    &#125;    cout&lt;&lt;total&lt;&lt;&quot; &quot;&lt;&lt;cost&lt;&lt;endl;&#125;\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSæµé‡","url":"/apcs2101-2/","content":"110/01 å¯¦ä½œé¡Œç¬¬äºŒé¡Œ æµé‡\né€™ä¸€é¡Œçš„é¡Œåºæœ‰é»è¤‡é›œï¼Œçœ‹äº†å¹¾æ¬¡ä¹‹å¾Œæ‰çœ‹æ‡‚ã€‚ä½†é‡é»æ˜¯åœ¨è€ƒè©¦çš„æ™‚å€™æ²’æœ‰æƒ³åˆ°è¦æ€éº¼åˆä½µæµé‡ï¼Œæ‰€ä»¥åªç”¨äº†ä¸€ç¶­é™£åˆ—è¨ˆç®—æœ€å°å€¼ï¼Œå› æ­¤åªæœ‰æ‹¿åˆ°50åˆ†â€¦é€™æ˜¯å®Œæ•´ç‰ˆçš„ç¨‹å¼ç¢¼ï¼Œä¸»è¦æ˜¯é€éå‰µå»ºä¸€å€‹é™£åˆ—r[i][j]ï¼Œè¡¨ç¤ºå¾åŸå¸‚iå‡ºç™¼åˆ°åŸå¸‚jçš„ç¸½æµé‡ï¼Œå†åˆ©ç”¨é™£åˆ—rè¨ˆç®—è²»ç”¨ã€‚\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int N,M,K,s[50][50],r[50][50];signed main()&#123;    ios;    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;    for(int i=0;i&lt;N;i++)&#123;        for(int j=0;j&lt;M;j++)&#123;            cin&gt;&gt;s[i][j];        &#125;    &#125;    int ans = 1e8;        for(int k=0;k&lt;K;k++)&#123;        memset(r, 0, sizeof(r));                for(int q=0;q&lt;N;q++)&#123;            int p;//ç¬¬iå€‹ä¼ºæœå™¨æ¶è¨­åœ¨påŸå¸‚            cin&gt;&gt;p;            for(int j=0;j&lt;M;j++)r[p][j]+=s[q][j];        &#125;        //å¦‚æœç¬¬0å€‹è·Ÿç¬¬1å€‹ä¼ºæœå™¨éƒ½æ¶è¨­åœ¨1çš„ä½ç½®ï¼Œå‰‡å°‡æµé‡ç›¸åŠ ï¼Œå¾—åˆ°é™£åˆ—r        int sum = 0;        for(int q=0;q&lt;M;q++)&#123;//0&lt;p&lt;M            for(int j=0;j&lt;M;j++)&#123;                if(q==j)sum+=r[q][j];                else if(r[q][j]&lt;=1000)sum+=3*r[q][j];                else sum+=(r[q][j]-1000)*2+3000;            &#125;        &#125;        ans = min(ans,sum);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"APCS CLASS PART 2","url":"/apcs2/","content":"APCS Classé¡Œç›®ç¬¬äºŒéƒ¨åˆ†ï¼\nG. [åŸºç¤è³‡æ–™çµæ§‹ I ] å †ç–Šã€ä½‡åˆ—a119. æ‹¬è™Ÿå•é¡Œ\n#include &lt;bits/stdc++.h&gt;using namespace std;stack&lt;int&gt; stk;int main()&#123;    string s;    getline(cin,s);    int len = s.size(),ans = 0,f=1;    for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)stk.push(1);        else if(s[i]==&#x27;)&#x27;)&#123;            if(!stk.empty())&#123;                stk.pop();                ans++;            &#125;            else f = 0;        &#125;    &#125;    if(!stk.empty())f= 0;        if(f)cout&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;0&lt;&lt;endl;&#125;\na120. ä¸­ç½®å¼è½‰å¾Œç½®å¼#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    map&lt;char,int&gt; mp&#123;&#123;&#x27;+&#x27;,1&#125;,&#123;&#x27;-&#x27;,1&#125;,&#123;&#x27;*&#x27;,2&#125;,&#123;&#x27;/&#x27;,2&#125;,&#123;&#x27;(&#x27;,0&#125;&#125;;    string s;cin&gt;&gt;s;    stack&lt;char&gt; st;    int len = s.size();        for(int i=0;i&lt;len;i++)&#123;        if(s[i]==&#x27;(&#x27;)st.push(&#x27;(&#x27;);        else if(s[i]==&#x27;)&#x27;)&#123;            while(!st.empty()&amp;&amp;st.top()!=&#x27;(&#x27;)&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.pop();        &#125;        else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;            while(!st.empty() &amp;&amp; mp[st.top()]&gt;=mp[s[i]])&#123;                cout&lt;&lt;st.top();                st.pop();            &#125;            st.push(s[i]);        &#125;        else cout&lt;&lt;s[i];    &#125;    while(!st.empty())&#123;        cout&lt;&lt;st.top();        st.pop();    &#125;    cout&lt;&lt;endl;&#125;\na121. é›»è…¦ç®—è¡“é‹ç®—#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;cin&gt;&gt;n;    string s;    while(n--)&#123;        cin&gt;&gt;s;        stack&lt;int&gt; stk;        bool legal = 1;                for(int i=0;i&lt;s.size();i++)&#123;            if(s[i]==&#x27;)&#x27;||s[i]==&#x27;,&#x27;||s[i]==&#x27;(&#x27;);            else if(isdigit(s[i]))&#123;                int sum = s[i]-&#x27;0&#x27;;                while(isdigit(s[++i]))&#123;                    sum=sum*10+(s[i]-&#x27;0&#x27;);                &#125;                stk.push(sum);                i--;            &#125;            else if(s[i]==&#x27;+&#x27;||s[i]==&#x27;-&#x27;||s[i]==&#x27;*&#x27;||s[i]==&#x27;/&#x27;)&#123;                if(s[i+1]!=&#x27;)&#x27;)&#123;                    legal = 0;                    break;                &#125;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;&amp;&amp; a==0)&#123;                    legal = 0;                    break;                &#125;                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);            &#125;            else&#123;                legal = 0;                break;            &#125;        &#125;        if(legal==0)cout&lt;&lt;-1&lt;&lt;endl;        else if(stk.size()==1)cout&lt;&lt;stk.top()&lt;&lt;endl;        else cout&lt;&lt;-1&lt;&lt;endl;    &#125;&#125;\na151. å¾Œåºå¼æ±‚å€¼#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string s;    while(cin&gt;&gt;s)&#123;        stack&lt;int&gt; stk;        for(int i=0;i&lt;s.size();i++)&#123;            if(isdigit(s[i]))stk.push(s[i]-&#x27;0&#x27;);            else&#123;                int a = stk.top();                stk.pop();                int b = stk.top();                stk.pop();                if(s[i]==&#x27;+&#x27;)stk.push(a+b);                else if(s[i]==&#x27;-&#x27;)stk.push(b-a);                else if(s[i]==&#x27;*&#x27;)stk.push(a*b);                else if(s[i]==&#x27;/&#x27;)stk.push(b/a);                else if(s[i]==&#x27;%&#x27;)stk.push(b%a);            &#125;        &#125;        cout&lt;&lt;stk.top()&lt;&lt;endl;    &#125;&#125;\na163. å°è¡¨æ©Ÿä½‡åˆ—#include &lt;bits/stdc++.h&gt;using namespace std;bool Can(int now_priority,int *p)&#123;    for(int i=now_priority+1;i&lt;=9;i++)&#123;        if(p[i]&gt;=1)return 0;    &#125;    return 1;&#125;void solve()&#123;    int n,m,pri[105];cin&gt;&gt;n&gt;&gt;m;    queue&lt;pair&lt;bool,int&gt;&gt; que;    memset(pri,0,sizeof(pri));    for(int i=0;i&lt;n;i++)&#123;        int p;cin&gt;&gt;p;        if(i==m)que.push(&#123;1,p&#125;);        else que.push(&#123;0,p&#125;);        pri[p]++;    &#125;        int ans = 0;    while(!que.empty())&#123;        auto cur = que.front();        que.pop();        if(Can(cur.second,pri))&#123;            //å¯ä»¥å°çš„è©±            ans++;            pri[cur.second]--;            if(cur.first==1)break;        &#125;        else que.push(cur);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na164. åœ˜é«”ä½‡åˆ—#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int main()&#123;    ios;    int t,c=0;    while(cin&gt;&gt;t &amp;&amp; t)&#123;        c++;        map&lt;int,int&gt; mp;//[æˆå“¡ã€åœ˜é«”ç·¨è™Ÿ]        for(int i=0;i&lt;t;i++)&#123;            int n;cin&gt;&gt;n;            while(n--)&#123;                int x;cin&gt;&gt;x;                mp[x] = i;            &#125;        &#125;        queue&lt;int&gt; Q,que[1005];//åœ˜é«”é †åºã€åœ˜é«”å…§é †åº        cout&lt;&lt;&quot;Scenario #&quot;&lt;&lt;c&lt;&lt;endl;        string temp;                while(cin&gt;&gt;temp)&#123;            if(temp[0]==&#x27;E&#x27;)&#123;                int x;cin&gt;&gt;x;                if(que[mp[x]].empty())Q.push(mp[x]);                que[mp[x]].push(x);            &#125;            else if(temp[0]==&#x27;D&#x27;)&#123;                int team = Q.front();                cout&lt;&lt;que[team].front()&lt;&lt;endl;                que[team].pop();                if(que[team].empty())Q.pop();            &#125;            else if(temp[0]==&#x27;S&#x27;)&#123;                cout&lt;&lt;endl;                break;            &#125;        &#125;    &#125;&#125;\nH. [åŸºç¤è³‡æ–™çµæ§‹ I ] æ¨¹ç‹€çµæ§‹a076. äºŒå…ƒæœå°‹æ¨¹é«˜åº¦#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];bool used[3000];int main()&#123;    ios;    string s;    memset(used,0,sizeof(used));    memset(tree,0,sizeof(tree));        getline(cin,s);    stringstream ss(s);    int ans = 0,temp;    while(ss&gt;&gt;temp)&#123;        int cur = 1,height = 1;        while(used[cur])&#123;            if(temp&lt;tree[cur])cur = cur*2;            else cur = cur*2+1;            height++;        &#125;        tree[cur] = temp;        used[cur] = 1;        ans = max(ans,height);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na077. Dropping Balls#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,tree[3000];int drop(int id)&#123;    if(id&gt;=(1&lt;&lt;(n-1)))return id;        tree[id]=!tree[id];    if(!tree[id])return drop(2*id+1);    else return drop(2*id);&#125;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        int ans = 0;cin&gt;&gt;n&gt;&gt;m;        memset(tree,0,sizeof(tree));        for(int i=0;i&lt;m;i++)&#123;            ans = drop(1);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\na122. è¡€ç·£é—œä¿‚#include &lt;bits/stdc++.h&gt;#define N 100005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,start,dis[N];bool visit[N];vector&lt;int&gt;edge[N];int dfs(int id,int cur_dis)&#123;  //å°‹æ‰¾é»idçš„æœ€é é»è·é›¢    if(visit[id])return 0;    visit[id] = 1;    int len = edge[id].size(),max_len=0;    for(int i=0;i&lt;len;i++)&#123;        int next = edge[id][i];        if(visit[next])continue;        dis[next] = cur_dis+1;        int temp = dfs(next,cur_dis+1);        max_len = max(max_len,temp);    &#125;    return max_len+1;&#125;int main()&#123;    ios;    cin&gt;&gt;n;    for(int i=0;i&lt;n-1;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    start = 0;    memset(visit,0,sizeof(visit));    int distance = dfs(2,0);distance--;    for(int i=0;i&lt;n;i++)&#123;        if(dis[i]==distance)&#123;            start = i;            break;        &#125;    &#125;    memset(visit,0,sizeof(visit));    cout&lt;&lt;dfs(start,0)-1&lt;&lt;endl;&#125;\na123. æ¨¹ç‹€åœ–åˆ†æ#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,father[N],h[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    int maxn = 0;    for(auto next:edge[cur])&#123;        dfs(next);        maxn = max(maxn,h[next]+1);    &#125;    h[cur] = maxn;&#125;signed main()&#123;    ios;    memset(h,0,sizeof(h));    memset(father,0,sizeof(father));        cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        int k;cin&gt;&gt;k;        for(int j=0;j&lt;k;j++)&#123;            int temp;cin&gt;&gt;temp;            edge[i].push_back(temp);            father[temp] = i;        &#125;    &#125;    int root = 1;    while(father[root]!=0)root++;        dfs(root);        lld ans = 0;    for(int i=1;i&lt;=n;i++)ans += h[i];        cout&lt;&lt;root&lt;&lt;endl&lt;&lt;ans&lt;&lt;endl;&#125;//O(N)çš„ä½œæ³•#include &lt;bits/stdc++.h&gt;#define lld long longusing namespace std;lld n,m;int main()&#123;    int t;scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        int n,m,ans = 1;scanf(&quot;%d %d&quot;,&amp;n,&amp;m);        m--;    //å¾0é–‹å§‹        for(int i=1;i&lt;n;i++)&#123;         //å…±n-1æ­¥è¦èµ°            if(m&amp;1)ans = ans*2+1;     //å¾€å³é‚Šèµ°            else ans = ans*2;            m = m&gt;&gt;1;                 //ç”±ä½bitåˆ°é«˜bitæ±ºå®šæ¯ä¸€æ­¥è¦æ€éº¼èµ°        &#125;        printf(&quot;%lld\\n&quot;,ans);    &#125;&#125;\nI. [åŸºç¤è³‡æ–™çµæ§‹ I ] åœ–å½¢çµæ§‹a051. åŸå¸‚æ—…éŠ#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 1000using namespace std;int n,m;bool visit[N];vector&lt;int&gt;edge[N];void dfs(int cur)&#123;    visit[cur] = 1;    for(auto i:edge[cur])&#123;        if(visit[i])continue;        dfs(i);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    for(int i=0;i&lt;=n+100;i++)edge[i].clear();        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);    &#125;    int from,to;cin&gt;&gt;from&gt;&gt;to;    dfs(from);    if(visit[to])cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m)&#123;        solve();    &#125;&#125;\na102. æ²¹ç”°#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 105using namespace std;int n,m,ans = 0;int dx[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;;int dy[8] = &#123;1,0,-1,-1,-1,0,1,1&#125;;bool visit[N][N],maze[N][N];void dfs(int x,int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;8;i++)&#123;        int nx = x+dx[i],ny = y+dy[i];        if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;        if(visit[nx][ny])continue;        if(maze[nx][ny]==1)dfs(nx,ny);    &#125;&#125;void solve()&#123;    memset(visit,0,sizeof(visit));    memset(maze,0,sizeof(maze));    ans = 0;        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;@&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                dfs(i,j);                ans+=1;            &#125;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n&amp;&amp; m)&#123;        solve();    &#125;&#125;\na103. å°ç¾¤é«”#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 50005using namespace std;signed main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];    &#125;    bool used[N];    int ans = 0;    memset(used,0,sizeof(used));        for(int i=0;i&lt;n;i++)&#123;        if(used[i])continue;        int cur = arr[i];        used[cur] = 1;        while(cur!=i)&#123;            cur = arr[cur];            used[cur] = 1;        &#125;        ans++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na124. äºŒåˆ†åœ–#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define lld long long#define N 100005using namespace std;int n,m,ans = 0,cnt[2];vector&lt;int&gt; edge[N];int color[N];bool dfs(int cur,int c)&#123;    color[cur] = c;    cnt[c]+=1;    bool flag = 1;    for(auto i:edge[cur])&#123;        if(color[i]==color[cur])return 0;        if(color[i]==-1)flag = (flag &amp;&amp; dfs(i,!c));    &#125;    return flag;&#125;void solve()&#123;    memset(color,0,sizeof(color));        for(int i=0;i&lt;n;i++)color[i] = -1;        for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;a--;b--;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(color[i]==-1)&#123;            cnt[0] = 0;cnt[1] = 0;            if(!dfs(i,0))&#123;                cout&lt;&lt;0&lt;&lt;endl;                return;            &#125;            ans += min(cnt[0],cnt[1]);            //æœ‰å¯èƒ½æ˜¯éé€£é€šåœ–ï¼Œç”¨+=        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    solve();&#125;\nJ. [åŸºç¤æ¼”ç®—æ³• I ] è¤‡é›œåº¦åˆ†æã€æ’åºa127. é€£è™Ÿæˆ–ä¸é€£è™Ÿ#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int n;int main()&#123;    while(cin&gt;&gt;n)&#123;        set&lt;int&gt;s;        for(int i=0;i&lt;n;i++)&#123;            int x;cin&gt;&gt;x;            s.insert(x);        &#125;        int maxn = *(--s.end());        int minn = *s.begin();        if(s.size()==maxn-minn+1)cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; yes&quot;&lt;&lt;endl;        else cout&lt;&lt;minn&lt;&lt;&quot; &quot;&lt;&lt;maxn&lt;&lt;&quot; no&quot;&lt;&lt;endl;    &#125;&#125;\na128. Agar.io#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,full[N];set&lt;int&gt; s[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    fill(full,full+n+1,10);    for(int i=1;i&lt;=n;i++)s[i].insert(i);        while(m--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(full[b]&gt;full[a])swap(a,b);        full[a] += full[b];        full[b] = 0;        for(auto p:s[b])s[a].insert(p);        s[b].clear();    &#125;    int ans = max_element(full,full+n+1)-full;    cout&lt;&lt;ans&lt;&lt;endl;    for(auto p:s[ans])cout&lt;&lt;p&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\na129. é£›å¤©æ¡‘å¦®#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;vector&lt;pii&gt; vec;bool cmp(pii a,pii b)&#123;    if(a.first==b.first)return a.second&gt;b.second;    return a.first&lt;b.first;&#125;int main()&#123;    int n,x,y,h;cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;x&gt;&gt;y&gt;&gt;h;        vec.push_back(&#123;x*x+y*y,h&#125;);    &#125;    sort(vec.begin(),vec.end(),cmp);    int ans  = 0,maxh = 0;    for(int i=0;i&lt;n;i++)&#123;        maxh = max(maxh,vec[i].second);        ans = max(ans,maxh-vec[i].second);    &#125;//ç¶­è­·æœ€é«˜çš„æ¨¹    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na148. å­—å…ƒé »ç‡#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 24#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;bool cmp(pii a,pii b)&#123;    if(a.second==b.second)return a.first&gt;b.first;    else return a.second&lt; b.second;&#125;int main()&#123;    string s;    while(getline(cin,s))&#123;        map&lt;int,int&gt; mp;    //asciã€å‡ºç¾æ¬¡æ•¸        for(auto temp:s)mp[temp]+=1;        vector&lt;pii&gt;vec;        for(auto p:mp)&#123;            vec.push_back(p);        &#125;        sort(vec.begin(),vec.end(),cmp);        for(auto i:vec)&#123;            cout&lt;&lt;i.first&lt;&lt;&quot; &quot;&lt;&lt;i.second&lt;&lt;endl;        &#125;        cout&lt;&lt;endl;    &#125;&#125;\nK. [åŸºç¤æ¼”ç®—æ³• I ] æ’åºèˆ‡æœå°‹a130. äººå“¡èª¿å‹•#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    int wait[N][N];memset(wait,0,sizeof(wait));        int m,ans = 0;cin&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(wait[b][a]&gt;0)&#123;            ans++;wait[b][a]--;        &#125;        else wait[a][b]++;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na131. å¤§é»‘é¦¬#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int k,n;int normal[N][N],lower[N][N],upper[N][N];bool win(int a,int b,int is_normal)&#123;    for(int i=0;i&lt;k+1;i++)&#123;        if(is_normal==0)&#123;            if(normal[a][i]&lt;=normal[b][k+i])return 0;        &#125;        else&#123;            if(upper[a][i]&lt;=lower[b][k+i])return 0;        &#125;    &#125;    return 1;&#125;int main()&#123;    cin&gt;&gt;k&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int s;cin&gt;&gt;s;        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;normal[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;upper[s][j];        for(int j=0;j&lt;2*k+1;j++)cin&gt;&gt;lower[s][j];    &#125;    for(int p=0;p&lt;=1;p++)&#123;        for(int i=n;i&gt;0;i--)&#123;    //å¾ç¨®å­åºè¼ƒå°çš„é–‹å§‹            bool f = 1;            for(int j=1;j&lt;=n;j++)&#123;                if(!win(i,j,p))&#123;                    f = 0;                    break;                &#125;            &#125;            if(f)&#123;                cout&lt;&lt;i&lt;&lt;&quot; &quot;;                break;            &#125;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\na132. ä¸»æ©Ÿæ’ç¨‹#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define max_ele(a) max_element(a,a+dh)using namespace std;int n,dh;void solve()&#123;    int s;cin&gt;&gt;s;    int arr[N]=&#123;0&#125;,brr[N]=&#123;0&#125;,crr[N]=&#123;0&#125;;    while(s--)&#123;        int a,b,c,d,e,f;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f;        int start = (a-1)*24+b;        for(int j=0;j&lt;c;j++)&#123;            arr[(start+j)%dh]+=d;            brr[(start+j)%dh]+=e;            crr[(start+j)%dh]+=f;        &#125;    &#125;    cout&lt;&lt;*max_ele(arr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(brr)&lt;&lt;&quot; &quot;&lt;&lt;*max_ele(crr)&lt;&lt;endl;    cin&gt;&gt;s;&#125;int main()&#123;    cin&gt;&gt;n&gt;&gt;dh;    dh = dh*24;    while(n--)&#123;        solve();    &#125;&#125;\na152. äºŒåˆ†æœå°‹#include &lt;bits/stdc++.h&gt;#define ll long long#define ld  long double#define N 1005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int main()&#123;    int n,arr[N];cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    int t;cin&gt;&gt;t;        int pos = 0,ans = 0,find = 0,l = 0,r = n-1;    //[l,r]        while(l&lt;=r)&#123;        int mid = (l+r)/2;        ans++;        if(arr[mid]==t)&#123;            pos = mid;find = 1;break;        &#125;        else if(arr[mid]&gt;t)r = mid-1;        else l = mid+1;    &#125;    if(find)cout&lt;&lt;pos&lt;&lt;&quot; &quot;&lt;&lt;ans&lt;&lt;endl;    else cout&lt;&lt;&quot;not found &quot;&lt;&lt;ans&lt;&lt;endl;&#125;\na153. äºŒåˆ†æ³•æ±‚è§£#include &lt;bits/stdc++.h&gt;int main()&#123;  std::cout&lt;&lt;std::fixed&lt;&lt;std::setprecision(6)&lt;&lt;log(2)&lt;&lt;std::endl;&#125;\nL. [åŸºç¤æ¼”ç®—æ³• I ] çª®èˆ‰æ³•a088. æœ€å¤§ä¹˜ç©#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 20#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    int c = 0;    while(cin&gt;&gt;n)&#123;        c++;        int dp[N][N];memset(dp,0,sizeof(dp));        int ans = 0;        FOR(i,n)&#123;            int temp;cin&gt;&gt;temp;            dp[i][i] = temp;            ans = max(ans,temp);        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=i+1;j&lt;n;j++)&#123;                dp[i][j] = dp[i][j-1]*dp[j][j];                ans = max(dp[i][j],ans);            &#125;        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;c&lt;&lt;&quot;: The maximum product is &quot;&lt;&lt;max(ans,(ll)0)&lt;&lt;&quot;.&quot;&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\na133. æ¡è˜‘è‡æ”»ç•¥å•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    cin&gt;&gt;n;    int ans = 0,dp[N][N];    memset(dp,0,sizeof(dp));        FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        dp[i][i] = temp;        ans = max(ans,temp);    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            dp[i][j] = dp[i][j-1]+dp[j][j];            ans = max(ans,dp[i][j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\na134. å›æ–‡æ—¥æœŸå•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;vector&lt;int&gt;ans;bool leap(int temp)&#123;    return (((temp%4)==0 &amp;&amp;(temp%100)!=0)||(temp%400)==0);&#125;void check(string s)&#123;    string temp = s;    reverse(temp.begin(),temp.end());    if(temp==s)ans.push_back(stoi(s));&#125;void solve()&#123;    cin&gt;&gt;n;    ans.clear();    int month[13] = &#123;0,31,28,31,30,31,30,31,31,30,31,30,31&#125;;    month[2]+=((leap(n))?1:0);    for(int i=1;i&lt;=12;i++)&#123;        for(int j=1;j&lt;=month[i];j++)&#123;            check(to_string(n)+to_string(i)+to_string(j));            if(i&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+to_string(j));            if(j&lt;10)check(to_string(n)+to_string(i)+&quot;0&quot;+to_string(j));            if(i&lt;10 &amp;&amp; j&lt;10)check(to_string(n)+&quot;0&quot;+to_string(i)+&quot;0&quot;+to_string(j));        &#125;    &#125;    sort(ans.begin(),ans.end());    cout&lt;&lt;ans.size();    for(auto i:ans)cout&lt;&lt;&quot; &quot;&lt;&lt;i;    cout&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na135. å·§å…‹åŠ›æ“ºç›’#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,k;int r[9],box[9];;bool cmp(vector&lt;int&gt; r)&#123;    for(int i=0;i&lt;9;i+=3)&#123;        if(r.size()==3)&#123;            if((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1])&amp;&amp;(r[2]&amp;box[i+2]))&#123;                return true;            &#125;            //å°æ–¼é€™ä¸€è¡Œçš„æŒ‡å®šæ˜¯æœ‰æ»¿è¶³çš„ï¼Œå›å‚³æ­£ç¢ºï¼ˆä¸‹ä¸€å€‹è¦æ±‚ç¹¼çºŒå†å‘¼å«ä¸€æ¬¡ï¼‰        &#125;        else if(((r[0]&amp;box[i])&amp;&amp;(r[1]&amp;box[i+1]))||((r[0]&amp;box[i+1])&amp;&amp;(r[1]&amp;box[i+2])))&#123;            return true;        &#125;    &#125;    return false;&#125;vector&lt;int&gt; rule;vector&lt;vector&lt;int&gt;&gt; rule_list;void solve()&#123;    for(int i=0;i&lt;9;i++)&#123;        int temp=1;temp = temp&lt;&lt;i;        r[i] = temp;        box[i] = temp;    &#125;    map&lt;string,int&gt; mp = &#123;        &#123;&quot;PS&quot;,r[0]&#125;,        &#123;&quot;PC&quot;,r[1]&#125;,        &#123;&quot;PT&quot;,r[2]&#125;,        &#123;&quot;P?&quot;,r[0]|r[1]|r[2]&#125;,        &#123;&quot;BS&quot;,r[3]&#125;,        &#123;&quot;BC&quot;,r[4]&#125;,        &#123;&quot;BT&quot;,r[5]&#125;,        &#123;&quot;B?&quot;,r[3]|r[4]|r[5]&#125;,        &#123;&quot;YS&quot;,r[6]&#125;,        &#123;&quot;YC&quot;,r[7]&#125;,        &#123;&quot;YT&quot;,r[8]&#125;,        &#123;&quot;Y?&quot;,r[6]|r[7]|r[8]&#125;,        &#123;&quot;?S&quot;,r[0]|r[3]|r[6]&#125;,        &#123;&quot;?C&quot;,r[1]|r[4]|r[7]&#125;,        &#123;&quot;?T&quot;,r[2]|r[5]|r[8]&#125;,        &#123;&quot;??&quot;,511&#125;,    &#125;;    cin&gt;&gt;n;    while(n--)&#123;        cin&gt;&gt;k;        rule.resize(k);        for(int i=0;i&lt;k;i++)&#123;            char temp[3];cin&gt;&gt;temp[0]&gt;&gt;temp[1];            rule[i] = (mp[temp]);        &#125;        rule_list.push_back(rule);    &#125;    int ans = 0;    do&#123;        ans += all_of(rule_list.begin(),rule_list.end(),cmp);            &#125;while(next_permutation(box,box+9));        cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\na154. é™¤æ³•#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;bool used[10],f;bool check(int t)&#123;    bool cur_used[10]=&#123;0&#125;;    if(t&lt;10000&amp;&amp;used[0]==1)return 0;    else if(t&lt;10000)cur_used[0] = 1;        while(t&gt;0)&#123;        int d = t%10;        if(cur_used[d])return 0;        else if(used[d])return 0;        cur_used[d] = 1;        t /= 10;    &#125;    return 1;&#125;void dfs(int first,int id)&#123;    if(id&gt;=5)&#123;        if(first%n!=0)return;        int second = first/n;        if(second&lt;1234)return;        if(check(second))&#123;            f = 1;            cout&lt;&lt;first&lt;&lt;&quot; / &quot;;            if(second&lt;10000)cout&lt;&lt;0;            cout&lt;&lt;second&lt;&lt;&quot; = &quot;&lt;&lt;n&lt;&lt;endl;            return;        &#125;    &#125;    for(int i=0;i&lt;10;i++)&#123;        if(used[i])continue;        used[i] = 1;        dfs(first*10+i,id+1);        used[i] = 0;    &#125;&#125;void solve()&#123;    while(cin&gt;&gt;n)&#123;        if(n==0)return;        memset(used,0,sizeof(used));        f=0;        dfs(0,0);        if(f==0)cout&lt;&lt;&quot;There are no solutions for &quot;&lt;&lt;n&lt;&lt;&quot;.&quot;&lt;&lt;endl;        cout&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["APCSæª¢å®š"],"tags":["APCS","ç«¶è³½ç­†è¨˜"]},{"title":"[é¡Œè§£]APCSåˆ‡å‰²è²»ç”¨","url":"/apcs2101-3/","content":"110/01 å¯¦ä½œé¡Œç¬¬ä¸‰é¡Œ åˆ‡å‰²è²»ç”¨\né€™ä¸€é¡Œé›–ç„¶åœ¨è€ƒè©¦ä¸­æœ‰æƒ³åˆ°åˆ©ç”¨äºŒå…ƒæ¨¹çš„æ–¹æ³•ï¼Œæ–¼æ˜¯é–‹äº†ä¸€å€‹é™£åˆ—å„²å­˜æ¨¹çš„ç¯€é»ï¼ˆå‰æ®µæ™‚é–“å¯«äº†ä¸€äº›ç·šæ®µæ¨¹ï¼Œæ‰€ä»¥ç”¨äº†é€™å€‹æ–¹æ³•ï¼ï¼‰ä½†æˆ‘æ²’æœ‰æ³¨æ„åˆ°é€™ä¸æ˜¯ä¸€æ£µå®Œæ»¿äºŒå…ƒæ¨¹ï¼Œä¸æœƒå¹³è¡¡å•Šï¼æŠŠç¯„ä¾‹æ¸¬è³‡ä¸Ÿä¸Šå»å°äº†ï¼ŒçµæœåŠåˆ†éƒ½æ²’æœ‰æ‹¿åˆ°:cry:ï¼Œä»¥å¾Œå¿…é ˆæ³¨æ„ï¼ç”¨std::setæ­é… next(),prev() æŒ‡æ¨™ï¼Œæ‰¾å‡ºé„°è¿‘çš„åˆ‡å‰²é»ä¹‹å·®ï¼Œå°±å¯ä»¥ACäº†ï¼\n\n            åœ¨ set ä¸­ä½¿ç”¨insert() å‡½å¼æœƒå›å‚³pair åœ¨ä½¿ç”¨çš„æ™‚å€™è¦è®Šæˆï¼šauto pos = s.insert(arr[i]).first;\n          \né€™æ˜¯è€ƒè©¦é€å‡ºçš„0åˆ†ç¨‹å¼ç¢¼\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,L,ans = 0;int seg[1000000] = &#123;0&#125;;void build(int val,int cur)&#123;    if(seg[cur]==0)&#123;        seg[cur] = val;        return;    &#125;    if(val&gt;seg[cur])build(val, 2*cur+2);    else build(val, 2*cur+1);&#125;//å»ºç«‹ä¸€å€‹æœƒçˆ†æ‰çš„äºŒå…ƒæ¨¹void func(int val,int cur)&#123;    int up = L,low = 0;    if(seg[cur]==val)&#123;        ans+=up-low;        return;    &#125;    while(seg[cur]!=val)&#123;        if(val&gt;seg[cur])&#123;            low = seg[cur];            cur = 2*cur+2;        &#125;        else&#123;            up = seg[cur];            cur = 2*cur+1;        &#125;    &#125;    ans+=up-low;&#125;signed main()&#123;    ios;        cin&gt;&gt;n&gt;&gt;L;    int arr[n];    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        arr[b-1] = a;    &#125;    for(int i=0;i&lt;n;i++)build(arr[i], 0);    for(int i=0;i&lt;n;i++)func(arr[i], 0);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\né€™æ˜¯æ­£è§£ï¼š\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,l,arr[200000];signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;l;    set&lt;int&gt; s = &#123;0,l&#125;;    for(int i=0;i&lt;n;i++)&#123;        int ind,pos;cin&gt;&gt;pos&gt;&gt;ind;        arr[ind-1] = pos;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        auto pos = s.insert(arr[i]).first;        ans+= *next(pos)- *prev(pos);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSé£›é»ƒé¨°é”","url":"/apcs2101-4/","content":"110/01 å¯¦ä½œé¡Œç¬¬å››é¡Œ é£›é»ƒé¨°é”\né€™æ˜¯ä¸€é¡Œæˆ‘åœ¨è€ƒè©¦ä¸­æ ¹æœ¬æ²’æœ‰ç¢°çš„é¡Œç›®ï¼ˆèƒ½åŠ›ä¸è¶³ï¼‰ï¼Œè½åˆ°åˆ¥äººæ˜¯èªªé€™æ˜¯ä¸€é¡Œç¶“å…¸çš„LISï¼Œæ‰€ä»¥å¯’å‡å°±é–‹å§‹äº†è§£å‹•æ…‹è¦åŠƒçš„é¡Œç›®ã€‚é€™ä¸€é¡Œé—œéµæ˜¯å…ˆæŠŠxåº§æ¨™æ’åˆ—å¥½ï¼ˆå¯ä»¥æƒ³æˆæ˜¯LISä¸­çš„æ•¸åˆ—é †åºï¼‰ï¼Œç„¶å¾Œä¾ç…§yåº§æ¨™åšLISã€‚\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios;    cin&gt;&gt;n;    pair&lt;int, int&gt; P[n];    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        P[i] = make_pair(x, y);    &#125;    sort(P, P+n);//åˆ©ç”¨pairæ’åºï¼Œæœƒå…ˆä¾ç…§xæ’åºï¼Œå¦‚æœxç›¸åŒï¼Œå‰‡ç…§yæ’åº    vector&lt;int&gt;ans;//å„²å­˜LIS    ans.push_back(P[0].second);    for(int i=1;i&lt;n;i++)&#123;        int now = P[i].second;        if(now&gt;=ans.back())ans.push_back(now);        else&#123;            int ind = upper_bound(ans.begin(),ans.end(),now)-ans.begin();            ans[ind] = now;        &#125;    &#125;    cout&lt;&lt;ans.size()&lt;&lt;endl;&#125;\n\n            é€™è£¡æœ‰ä¸€é»è·ŸLISä¸ä¸€æ¨£ï¼Œå®ƒä¸éœ€è¦åš´æ ¼éå¢ï¼Œå› æ­¤åœ¨ç¬¬20ä½¿ç”¨ &gt;= ï¼Œé‚„æœ‰ç¬¬22è¡Œä½¿ç”¨upper_boundä¹Ÿæ˜¯å› ç‚ºä¸éœ€è¦åš´æ ¼éå¢ï¼ˆå¦‚æœè¦æ’å…¥çš„å€¼åœ¨LISè£¡é¢å°±å·²ç¶“æœ‰äº†ï¼Œå…©è€…éƒ½å¯ä»¥ä¿ç•™ï¼Œæ‰€ä»¥ç”¨upper_boundï¼Œå–ç¬¬ä¸€å€‹å¤§æ–¼å®ƒçš„æ•¸å€¼æ›´æ”¹æ‰ã€‚\n          \n\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"APCSé¡Œè§£ï¼š2021å¹´1æœˆ","url":"/apcs2101/","content":"ç¬¬ä¸€æ¬¡è€ƒAPCSï¼Œæ‹¿åˆ°è§€å¿µ4ç´šã€å¯¦ä½œ3ç´šï¼Œå¸Œæœ›åœ¨ä¸‹ä¸€æ¬¡å¯ä»¥æ›´é€²æ­¥ï¼ï¼ˆæˆ‘æ˜¯å¤§å»¢å»¢\n110/01 å¯¦ä½œé¡Œç¬¬ä¸€é¡Œ è³¼è²·åŠ›APCSçš„ç¬¬ä¸€é¡Œéƒ½æ˜¯æ‡‰è©²è¦ç§’æ®ºçš„ï¼Œä¹Ÿé †åˆ©æ‹¿åˆ°100åˆ†\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,d,cost = 0,total = 0;signed main()&#123;     ios;    cin&gt;&gt;n&gt;&gt;d;    int arr[3];    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[0]&gt;&gt;arr[1]&gt;&gt;arr[2];        sort(arr, arr+3);        if(arr[2]-arr[0]&gt;=d)&#123;            total++;            cost +=((arr[0]+arr[1]+arr[2])/3);        &#125;    &#125;    cout&lt;&lt;total&lt;&lt;&quot; &quot;&lt;&lt;cost&lt;&lt;endl;&#125;\n110/01 å¯¦ä½œé¡Œç¬¬äºŒé¡Œ æµé‡é€™ä¸€é¡Œçš„é¡Œåºæœ‰é»è¤‡é›œï¼Œçœ‹äº†å¹¾æ¬¡ä¹‹å¾Œæ‰çœ‹æ‡‚ã€‚ä½†é‡é»æ˜¯åœ¨è€ƒè©¦çš„æ™‚å€™æ²’æœ‰æƒ³åˆ°è¦æ€éº¼åˆä½µæµé‡ï¼Œæ‰€ä»¥åªç”¨äº†ä¸€ç¶­é™£åˆ—è¨ˆç®—æœ€å°å€¼ï¼Œå› æ­¤åªæœ‰æ‹¿åˆ°50åˆ†â€¦é€™æ˜¯å®Œæ•´ç‰ˆçš„ç¨‹å¼ç¢¼ï¼Œä¸»è¦æ˜¯é€éå‰µå»ºä¸€å€‹é™£åˆ—r[i][j]ï¼Œè¡¨ç¤ºå¾åŸå¸‚iå‡ºç™¼åˆ°åŸå¸‚jçš„ç¸½æµé‡ï¼Œå†åˆ©ç”¨é™£åˆ—rè¨ˆç®—è²»ç”¨ã€‚\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int N,M,K,s[50][50],r[50][50];signed main()&#123;    ios;    cin&gt;&gt;N&gt;&gt;M&gt;&gt;K;    for(int i=0;i&lt;N;i++)&#123;        for(int j=0;j&lt;M;j++)&#123;            cin&gt;&gt;s[i][j];        &#125;    &#125;    int ans = 1e8;        for(int k=0;k&lt;K;k++)&#123;        memset(r, 0, sizeof(r));                for(int q=0;q&lt;N;q++)&#123;            int p;//ç¬¬iå€‹ä¼ºæœå™¨æ¶è¨­åœ¨påŸå¸‚            cin&gt;&gt;p;            for(int j=0;j&lt;M;j++)r[p][j]+=s[q][j];        &#125;        //å¦‚æœç¬¬0å€‹è·Ÿç¬¬1å€‹ä¼ºæœå™¨éƒ½æ¶è¨­åœ¨1çš„ä½ç½®ï¼Œå‰‡å°‡æµé‡ç›¸åŠ ï¼Œå¾—åˆ°é™£åˆ—r        int sum = 0;        for(int q=0;q&lt;M;q++)&#123;//0&lt;p&lt;M            for(int j=0;j&lt;M;j++)&#123;                if(q==j)sum+=r[q][j];                else if(r[q][j]&lt;=1000)sum+=3*r[q][j];                else sum+=(r[q][j]-1000)*2+3000;            &#125;        &#125;        ans = min(ans,sum);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n110/01 å¯¦ä½œé¡Œç¬¬ä¸‰é¡Œ åˆ‡å‰²è²»ç”¨é€™ä¸€é¡Œé›–ç„¶åœ¨è€ƒè©¦ä¸­æœ‰æƒ³åˆ°åˆ©ç”¨äºŒå…ƒæ¨¹çš„æ–¹æ³•ï¼Œæ–¼æ˜¯é–‹äº†ä¸€å€‹é™£åˆ—å„²å­˜æ¨¹çš„ç¯€é»ï¼ˆå‰æ®µæ™‚é–“å¯«äº†ä¸€äº›ç·šæ®µæ¨¹ï¼Œæ‰€ä»¥ç”¨äº†é€™å€‹æ–¹æ³•ï¼ï¼‰ä½†æˆ‘æ²’æœ‰æ³¨æ„åˆ°é€™ä¸æ˜¯ä¸€æ£µå®Œæ»¿äºŒå…ƒæ¨¹ï¼Œä¸æœƒå¹³è¡¡å•Šï¼æŠŠç¯„ä¾‹æ¸¬è³‡ä¸Ÿä¸Šå»å°äº†ï¼ŒçµæœåŠåˆ†éƒ½æ²’æœ‰æ‹¿åˆ°:cry:ï¼Œä»¥å¾Œå¿…é ˆæ³¨æ„ï¼ç”¨std::setæ­é… next(),prev() æŒ‡æ¨™ï¼Œæ‰¾å‡ºé„°è¿‘çš„åˆ‡å‰²é»ä¹‹å·®ï¼Œå°±å¯ä»¥ACäº†ï¼\n\n            åœ¨ set ä¸­ä½¿ç”¨insert() å‡½å¼æœƒå›å‚³pair åœ¨ä½¿ç”¨çš„æ™‚å€™è¦è®Šæˆï¼šauto pos = s.insert(arr[i]).first;\n          \né€™æ˜¯è€ƒè©¦é€å‡ºçš„0åˆ†ç¨‹å¼ç¢¼\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,L,ans = 0;int seg[1000000] = &#123;0&#125;;void build(int val,int cur)&#123;    if(seg[cur]==0)&#123;        seg[cur] = val;        return;    &#125;    if(val&gt;seg[cur])build(val, 2*cur+2);    else build(val, 2*cur+1);&#125;//å»ºç«‹ä¸€å€‹æœƒçˆ†æ‰çš„äºŒå…ƒæ¨¹void func(int val,int cur)&#123;    int up = L,low = 0;    if(seg[cur]==val)&#123;        ans+=up-low;        return;    &#125;    while(seg[cur]!=val)&#123;        if(val&gt;seg[cur])&#123;            low = seg[cur];            cur = 2*cur+2;        &#125;        else&#123;            up = seg[cur];            cur = 2*cur+1;        &#125;    &#125;    ans+=up-low;&#125;signed main()&#123;    ios;        cin&gt;&gt;n&gt;&gt;L;    int arr[n];    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        arr[b-1] = a;    &#125;    for(int i=0;i&lt;n;i++)build(arr[i], 0);    for(int i=0;i&lt;n;i++)func(arr[i], 0);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\né€™æ˜¯æ­£è§£ï¼š\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,l,arr[200000];signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;l;    set&lt;int&gt; s = &#123;0,l&#125;;    for(int i=0;i&lt;n;i++)&#123;        int ind,pos;cin&gt;&gt;pos&gt;&gt;ind;        arr[ind-1] = pos;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        auto pos = s.insert(arr[i]).first;        ans+= *next(pos)- *prev(pos);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n110/01 å¯¦ä½œé¡Œç¬¬å››é¡Œ é£›é»ƒé¨°é”é€™æ˜¯ä¸€é¡Œæˆ‘åœ¨è€ƒè©¦ä¸­æ ¹æœ¬æ²’æœ‰ç¢°çš„é¡Œç›®ï¼ˆèƒ½åŠ›ä¸è¶³ï¼‰ï¼Œè½åˆ°åˆ¥äººæ˜¯èªªé€™æ˜¯ä¸€é¡Œç¶“å…¸çš„LISï¼Œæ‰€ä»¥å¯’å‡å°±é–‹å§‹äº†è§£å‹•æ…‹è¦åŠƒçš„é¡Œç›®ã€‚é€™ä¸€é¡Œé—œéµæ˜¯å…ˆæŠŠxåº§æ¨™æ’åˆ—å¥½ï¼ˆå¯ä»¥æƒ³æˆæ˜¯LISä¸­çš„æ•¸åˆ—é †åºï¼‰ï¼Œç„¶å¾Œä¾ç…§yåº§æ¨™åšLISã€‚\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios;    cin&gt;&gt;n;    pair&lt;int, int&gt; P[n];    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        P[i] = make_pair(x, y);    &#125;    sort(P, P+n);//åˆ©ç”¨pairæ’åºï¼Œæœƒå…ˆä¾ç…§xæ’åºï¼Œå¦‚æœxç›¸åŒï¼Œå‰‡ç…§yæ’åº    vector&lt;int&gt;ans;//å„²å­˜LIS    ans.push_back(P[0].second);    for(int i=1;i&lt;n;i++)&#123;        int now = P[i].second;        if(now&gt;=ans.back())ans.push_back(now);        else&#123;            int ind = upper_bound(ans.begin(),ans.end(),now)-ans.begin();            ans[ind] = now;        &#125;    &#125;    cout&lt;&lt;ans.size()&lt;&lt;endl;&#125;\n\n            é€™è£¡æœ‰ä¸€é»è·ŸLISä¸ä¸€æ¨£ï¼Œå®ƒä¸éœ€è¦åš´æ ¼éå¢ï¼Œå› æ­¤åœ¨ç¬¬20ä½¿ç”¨ &gt;= ï¼Œé‚„æœ‰ç¬¬22è¡Œä½¿ç”¨upper_boundä¹Ÿæ˜¯å› ç‚ºä¸éœ€è¦åš´æ ¼éå¢ï¼ˆå¦‚æœè¦æ’å…¥çš„å€¼åœ¨LISè£¡é¢å°±å·²ç¶“æœ‰äº†ï¼Œå…©è€…éƒ½å¯ä»¥ä¿ç•™ï¼Œæ‰€ä»¥ç”¨upper_boundï¼Œå–ç¬¬ä¸€å€‹å¤§æ–¼å®ƒçš„æ•¸å€¼æ›´æ”¹æ‰ã€‚\n          \n\nå¿ƒå¾—ç¬¬ä¸€æ¬¡åƒåŠ APCSæ‹¿åˆ°4,3çš„æˆç¸¾ï¼Œé›–ç„¶æ²’æœ‰å¾ˆå¥½ï¼ˆé€™ä¸€æ¬¡é‚„æ˜¯æ¯”è¼ƒç°¡å–®çš„é¡Œç›®ï¼ï¼‰ï¼Œä½†é‚„æ˜¯åœ¨é æœŸä¹‹å…§ã€‚å¸Œæœ›é€æœè£œè¶³ä¸€äº›ä¸è¶³çš„åœ°æ–¹ï¼Œä¸‹ä¸€æ¬¡æœƒæœ‰æ›´å¥½çš„æˆç¸¾ï¼\n\nIDEç’°å¢ƒä¸ç†Ÿæ‚‰ å¹³å¸¸éƒ½æ˜¯åœ¨macä¸Šæ‰“ç¨‹å¼ï¼Œè€Œæ‰€æœ‰çš„æ¯”è³½éƒ½åªæœ‰windowsçš„codeblocksï¼Œæœ‰æ™‚å€™debugçš„å…§å®¹ä¸å°è¢«æˆ‘é—œæ‰å°±å«ä¸å‡ºä¾†ï¼Œè€—è²»è¨±å¤šæ™‚é–“ã€‚ è§£æ±ºæ–¹æ³•ï¼šä¸‹è¼‰codeblocksä¾†å¥½å¥½ç†Ÿæ‚‰ä¸€ä¸‹\né¡Œç›®ç·´ç¿’ä¸å¤ å¤šåœ¨è€ƒè©¦ä¹‹å‰å¤§å¤šæ˜¯è½åˆ¥äººè¬›æ€éº¼åšï¼Œå¯¦éš›ç·´ç¿’é¡Œç›®çš„é‡å¤ªå°‘ï¼Œæ‰€ä»¥åœ¨å¯¦éš›çš„ç«¶è³½ä¸­å°±å¯«ä¸å‡ºæ±è¥¿ã€‚è§£æ±ºæ–¹æ³•ï¼šæ¯é€±å›ºå®šå¯«ä¸€å€‹ä¸»é¡Œçš„é¡Œç›®ï¼Œåè¦†ç·´ç¿’è®“è‡ªå·±å°é€™å€‹ä¸»é¡Œæ›´ç†Ÿæ‚‰+å¯«APCSè€ƒå¤é¡Œã€‚\næ‡‚å¾—æ±è¥¿å¤ªå°‘ æœ¬æ¬¡ç¬¬ä¸‰é¡Œå°±æ˜¯å¾ˆå¥½çš„ä¾‹å­ï¼Œè‡ªå·±å¯«äºŒå…ƒæ¨¹å‡ºä¸€å †å•é¡Œï¼Œä¸å¦‚ç”¨stdå…§å»ºçš„seté‚„æ¯”è¼ƒå¿«ï¼é›–ç„¶ä¸€ç›´éƒ½çŸ¥é“setçš„å­˜åœ¨ï¼Œä½†å¯¦éš›çš„ç«¶è³½ä¸­å°±ä¸çŸ¥é“æ€éº¼ç”¨ã€‚ è§£æ±ºæ–¹æ³•ï¼šè³‡è¨Šä¹‹èŠ½å¥½å¥½å­¸ï¼\nå¯¦æˆ°ç¶“é©—ä¸è¶³ é€™æ‡‰è©²æ˜¯åƒåŠ éçš„ç¬¬ä¸‰å ´æ­£å¼çš„ç«¶è³½ï¼ˆæˆ–æª¢å®šï¼‰ï¼Œä»¥å¾Œå°±æ…¢æ…¢ç´¯ç©æ¯”è³½çš„ç¶“é©— è§£æ±ºæ–¹æ³•ï¼šåƒåŠ ç·šä¸Šç¨‹å¼ç«¶è³½ï¼Œç·´æ‰‹æ„Ÿã€‚\næ‰“å­—é€Ÿåº¦å¤ªæ…¢ æ‰“å­—é€Ÿåº¦æ…¢å°±æ‹–æ…¢æ•´é«”çš„å¯«æ‰£æ™‚é–“ï¼Œå¿…é ˆåŠ å¼·ï¼ è§£æ±ºæ–¹æ³•ï¼šæ¯å¤©èŠ±10åˆ†é˜ç¢°ç¢°éµç›¤ï¼Œåˆ©ç”¨ç¶²è·¯ä¸Šæ‰“å­—ç·´ç¿’åŠ å¿«æ‰“å­—é€Ÿåº¦ã€‚\n\n","categories":["APCSæª¢å®š"],"tags":["APCS","ç«¶è³½ç­†è¨˜"]},{"title":"[é¡Œè§£]APCSä¸ƒè¨€å°è¯","url":"/apcs2109-1/","content":"P1 ä¸ƒè¨€å°è¯\né¡Œç›®é€£çµ\nç¸½å…±æœ‰ABCä¸‰ç¨®è¦å‰‡ï¼Œå°±æ¯ä¸€ç¨®éƒ½æ¯”å°ä¸€æ¬¡å°±å¯ä»¥äº†ï¼\næ™‚é–“è¤‡é›œåº¦ï¼š å…±æœ‰ $n$ çµ„å°è¯ï¼Œæ¯ä¸€çµ„éƒ½ $O(1)$ æª¢æŸ¥ï¼Œæ™‚é–“ $O(n)$ ã€‚ï¼ˆä¸énæœ€å¤§ä¹Ÿæ‰50ï¼Œä¸è«–ä»€éº¼è¤‡é›œåº¦éƒ½å¯ä»¥å§ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 50#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;bool a[N],b[N],f = 1;signed main()&#123;    Orz;    cin&gt;&gt;n;    while(n--)&#123;        rep(i,1,7)cin&gt;&gt;a[i];        rep(i,1,7)cin&gt;&gt;b[i];        f = 1;        if(a[2]==a[4]||a[2]!=a[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        else if(b[2]==b[4]||b[2]!=b[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        if(a[7]!=1 || b[7]!=0)&#123;                cout&lt;&lt;&quot;B&quot;;f = 0;        &#125;        if(a[2]==b[2]||a[4]==b[4]||a[6]==b[6])&#123;                cout&lt;&lt;&quot;C&quot;;f = 0;        &#125;        if(f)cout&lt;&lt;&quot;None&quot;&lt;&lt;endl;        else cout&lt;&lt;endl;    &#125;&#125;\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSé­”ç‹è¿·å®®","url":"/apcs2109-2/","content":"P2 é­”ç‹è¿·å®®\né¡Œç›®é€£çµ\né€™ä¸€é¡Œæˆ‘å¥½åƒå¤ªæ—©å¯«äº†ï¼Œé¡Œç›®é‚„åœ¨æ•´ä¿®éšæ®µï¼Œä¸Ÿä¸Šå»TLEï¼Œç™¼ç¾é¡Œç›®æ•˜è¿°åˆæ”¹äº†XDï¼Œå¾é­”ç‹è¸©åˆ°ç‚¸å½ˆçˆ†ç‚¸å¾Œï¼Œã€Œç‚¸å½ˆä¸æœƒæ¶ˆå¤±ã€ï¼Œåˆ°ã€Œç‚¸å½ˆæœƒæ¶ˆå¤±ã€ï¼Œé‚„æœ‰ç¯„æ¸¬ä¹Ÿæœ‰æ”¹è®Šã€‚\né€™ä¸€é¡Œæ˜¯å»æ¨¡æ“¬æ¯ä¸€å€‹é­”ç‹ç§»å‹•çš„ç‹€æ³ï¼Œè¦ç‰¹åˆ¥æ³¨æ„æ¯ä¸€è¼ªçš„åœ‹ç‹æ˜¯åŒæ™‚ç§»å‹•çš„ï¼Œæ²’æœ‰å…ˆå¾Œé †åºï¼Œä¹Ÿå°±æ˜¯èªªä¸€é¡†ç‚¸å½ˆå¯ä»¥ç‚¸æ‰ä¸åªä¸€ä½é­”ç‹ï¼Œå¦‚æœæœ‰å¤šå€‹é­”ç‹ç§»å‹•åˆ°åŒä¸€å€‹æ ¼å­ï¼Œå‰‡ä»–å€‘æœƒä¸€èµ·è¢«ç‚¸æ‰ã€‚\næ™‚é–“è¤‡é›œåº¦ï¼š æœ‰é»é›£ä¼°è¨ˆï¼Œå› ç‚ºå¾ˆé›£ç¢ºå®šæ¯ä¸€å€‹é­”ç‹çš„ç§»å‹•ç‹€æ³æ¬¡æ•¸ï¼Œä¸éç”±æ–¼æ•¸å­—ç¯„åœä¸å¤§ï¼Œä¸” $k$ åªæœ‰åˆ°500ï¼Œå› æ­¤ç›´æ¥åšè¤‡é›œåº¦æ˜¯å¯è¡Œçš„ã€‚\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,k;bool maze[N][N],bomb[N][N];struct node&#123;    int x,y,s,t;    bool alive;&#125;mp[505];signed main()&#123;    Orz;    memset(maze,0,sizeof(maze));    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    rep(i,0,k-1)&#123;        cin&gt;&gt;mp[i].x&gt;&gt;mp[i].y;        cin&gt;&gt;mp[i].s&gt;&gt;mp[i].t;        mp[i].alive = 1;    &#125;        int now_alive = k;    while(now_alive)&#123;        memset(bomb,0,sizeof(bomb));        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            maze[i][j] = 1;        &#125;        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            int nx = i + mp[p].s;            int ny = j + mp[p].t;            if(nx &gt;= n || nx &lt; 0 || ny &gt;= m ||ny &lt; 0)&#123;                now_alive--;                mp[p].alive = 0;            &#125;            else if(maze[nx][ny])&#123;                now_alive--;                mp[p].alive = 0;                bomb[nx][ny] = 1;            &#125;            else&#123;                mp[p].x = nx;                mp[p].y = ny;            &#125;        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                if(bomb[i][j] == 1)                    maze[i][j] = 0;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            if(maze[i][j])ans++;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSå¹¸é‹æ•¸å­—","url":"/apcs2109-3/","content":"P3 å¹¸é‹æ•¸å­—\né¡Œç›®é€£çµ\nä»¥å€é–“æœ€å°å€¼ä½œç‚ºå€åˆ†é»å°‡æ•¸åˆ—åˆ†æˆå…©åŠï¼Œå¯ä»¥åˆ©ç”¨ç·šæ®µæ¨¹æ‰¾å€é–“æœ€å°å€¼ï¼Œåˆ©ç”¨è¿´åœˆæ¨¡æ“¬æ¯ä¸€æ¬¡ç¯„åœç¸®å°çš„æƒ…æ³ã€‚\nä¸éé€™ä¸€é¡Œæ¯”è¼ƒç‰¹åˆ¥ï¼Œä»–çš„å€é–“ç¯„åœä¸€å®šæœƒè¶Šä¾†è¶Šå°ï¼Œä¸”å€é–“å¤–çš„æ•¸å­—ä¹Ÿå°±ä¸éœ€è¦ä½¿ç”¨åˆ°ï¼Œå› æ­¤å¯ä»¥å°‡æ•¸åˆ—åšä¸€æ¬¡æ’åºï¼Œå¾é ­é–‹å§‹æ‰¾å¦‚æœé‡ä¸Šå€é–“å¤–çš„æ•¸å­—å‰‡ä¸ç†ä»–ï¼Œå¦å‰‡ä½¿ç”¨å®ƒç•¶ä½œå€é–“çš„åˆ†éš”é»ï¼ˆé€™ä¸€å®šæœƒæ˜¯æœ€å°å€¼ï¼Œå› ç‚ºç”±å°åˆ°å¤§æ’åºï¼‰ï¼Œå°‡å€é–“ç¯„åœç¸®å°ã€‚\nè‡³æ–¼æŒ‘é¸å·¦å³å€é–“çš„å€é–“å’Œï¼Œå‰‡å¯ä»¥é€éå‰ç¶´å’Œ $O(1)$ ç®—å‡ºç­”æ¡ˆã€‚\næ™‚é–“è¤‡é›œåº¦ï¼š å¦‚æœæ˜¯ä¸€å€‹éå¢æˆ–éæ¸›çš„åºåˆ—ï¼Œå‰‡æ¯ä¸€æ¬¡å€é–“å¤§å°åªæœƒç¸®æ¸›1ï¼Œæ­¤æ™‚è¤‡é›œåº¦ç‚º $O(n)$ï¼ŒåŠ ä¸Šæœ€ä¸€é–‹å§‹çš„æ’åºæ˜¯ $O(n\\log n)$ï¼Œç¸½å…±ç‚º $O(n\\log n)$ã€‚\næ’åºä½œæ³•#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii sorted[N];signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;sorted[i-1].x;        arr[i] = sorted[i-1].x;        sorted[i-1].y = i;        pref[i] = pref[i-1]+arr[i];    &#125;    sort(sorted,sorted+n);    int ind = 0,l = 1,r = n;    while(r&gt;l)&#123;        while(sorted[ind].y &gt; r || sorted[ind].y &lt; l)ind++;        int left = pref[sorted[ind].y-1]-pref[l-1];        int right = pref[r]-pref[sorted[ind].y];        if(left &gt; right)&#123;            r = sorted[ind].y-1;        &#125;        else&#123;            l = sorted[ind].y+1;        &#125;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;endl;&#125;\nç·šæ®µæ¨¹ä½œæ³•å¦‚æœç”¨ç·šæ®µæ¨¹å¯¦ä½œï¼Œå°‹æ‰¾å€é–“æœ€å°å€¼ï¼Œå¯ä»¥åœ¨ $O(\\log n)$ çš„æ™‚é–“å…§è©¢å•ã€‚åœ¨æœ€å·®çš„æƒ…æ³ä¸‹ï¼Œä¸€å…±æœƒè©¢å• $n$ æ¬¡ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦ä¸€æ¨£æ˜¯ $O(n\\log n)$ã€‚å¯¦ä½œä¸Šä¹Ÿä¸è¤‡é›œï¼Œå»ºç«‹ç·šæ®µæ¨¹ä»¥åŠå€é–“è©¢å•ï¼Œå€é–“ä¿®æ”¹å’Œæ‡¶æ¨™ä¹‹é¡çš„æ±è¥¿ã€‚å¯ä»¥æ¯”è¼ƒä¸€ä¸‹æ™‚é–“ï¼š\n\nç·šæ®µæ¨¹çš„è¡¨ç¾ç¨å¾®å¥½ä¸€é»ï¼Œä¸éå…¶å¯¦æ˜¯ç›¸ç•¶æ¥è¿‘çš„ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii seg[4*N];//å»ºç«‹ç·šæ®µæ¨¹[l,r)void build(int cur,int l,int r)&#123;    if(r &lt;= l)return;    if(r - l &lt;= 1)&#123;        seg[cur] = &#123;arr[l],l&#125;;        return;    &#125;    int mid = (l+r)/2;    build(2*cur,l,mid);    build(2*cur+1,mid,r);    if(seg[2*cur].x &lt; seg[2*cur+1].x)        seg[cur] = seg[2*cur];    else        seg[cur] = seg[2*cur+1];&#125;//è©¢å•å€é–“æœ€å°å€¼ï¼Œå›å‚³pairpii query(int cur,int l,int r,int ql,int qr)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return &#123;INT_MAX,INT_MAX&#125;;    if(ql &lt;= l &amp;&amp; qr &gt;= r)return seg[cur];    int mid = (l+r)/2;    pii lft = query(2*cur,l,mid,ql,qr);    pii rgt = query(2*cur+1,mid,r,ql,qr);    if(lft.x &lt; rgt.x)return lft;    return rgt;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    build(1,1,n+1);    int l = 1,r = n+1;        while(r - l &gt; 1)&#123;        int ind = query(1,1,n+1,l,r).y;        int left = pref[ind-1] - pref[l-1];        int right = pref[r-1] - pref[ind];        if(left &gt; right)r = ind;        else l = ind + 1;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;&quot;\\n&quot;;&#125;\næ­æ©ä½œæ³•\nBY thanksone\n\næœ‰ä¸€ç¨®äºŒå…ƒæ¨¹ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“å«å•¥ï¼Œæ ¹ç‚ºå…¨åºåˆ—æœ€å°å€¼ï¼Œå·¦ç¯€é»ç‚ºå·¦é‚Šåºåˆ—æœ€å°å€¼ï¼Œå³ç¯€é»ç‚ºå³é‚Šåºåˆ—æœ€å°å€¼ã€‚\nå»ºæ³•ç´€éŒ„æ¯å€‹ä½ç½®å·¦ã€å³é‚Šé›¢è‡ªå·±æœ€è¿‘ã€æ¯”è‡ªå·±å°çš„ï¼Œçˆ¸çˆ¸å°±æ˜¯å…©å€‹ä¹‹ä¸­æ¯”è¼ƒå¤§çš„é‚£ä¸€å€‹ã€‚\næ™‚é–“è¤‡é›œåº¦ï¼š ç¨®æ¨¹åŠ è·‘ç­”æ¡ˆç¸½å…± $O(n)$\n#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define ff first#define ss secondusing namespace std;array&lt;int, 300004&gt; A, S, L, R;array&lt;pii, 300004&gt; tree;void plant(int n)&#123;    for(int i = 1; i &lt;= n; i++)&#123;        if(A[L[i]] &gt; A[R[i]]) tree[L[i]].ss = i;        else tree[R[i]].ff = i;    &#125;&#125;int solve(int l, int r, int m)&#123;    if(l == r) return A[l];    if(S[m - 1] - S[l - 1] &gt; S[r] - S[m]) return solve(l, m - 1, tree[m].ff);    else return solve(m + 1, r, tree[m].ss);&#125;signed main()&#123;    int n;    cin &gt;&gt; n;    stack&lt;pii&gt; s;    pii m = &#123;1e9, 0&#125;;    s.push(&#123;0, 0&#125;);    for(int i = 1; i &lt;= n; i++)&#123;        cin &gt;&gt; A[i];        if(A[i] &lt; m.ff) m = &#123;A[i], i&#125;;        S[i] = A[i] + S[i - 1];        while(A[i] &lt; s.top().ff)&#123;            R[s.top().ss] = i;            s.pop();        &#125;        L[i] = s.top().ss;        s.push(&#123;A[i], i&#125;);    &#125;    plant(n);    cout &lt;&lt; solve(1, n, m.ss);    return 0;&#125;\nå¦‚æœæŠŠç¯„æ¸¬çš„ç¬›å¡çˆ¾æ¨¹å…·è±¡åŒ–ï¼Œå¤§æ¦‚é•·é€™æ¨£ï¼š\n\n83 9 4 5 1 6 2 8\n\n\nå¤§è‡´æ­¥é©Ÿå°±æ˜¯ï¼š\n\nç”¨å–®èª¿éšŠåˆ—å»ºç«‹å‡½æ•¸ $L$ ä»¥åŠ $R$ï¼Œè¡¨ç¤ºå¾€å·¦å¾€å³çœ‹ç¬¬ä¸€å€‹å°æ–¼è‡ªå·±çš„æ•¸\nå»ºç«‹ç¬›å¡çˆ¾æ¨¹ï¼ˆ$L[i],R[i]$ æŒ‘å¤§çš„ä½œç‚ºçˆ¶ç¯€é»ï¼‰\nå¾æ ¹ç¯€é»é–‹å§‹èµ°è¨ªï¼Œå·¦å³ç¯€é»å°±æœƒåˆ†åˆ¥æ˜¯å·¦å³å€é–“çš„æœ€å°å€¼\nåˆ©ç”¨å‰ç¶´å’Œè¨ˆç®—å€é–“å¤§å°ï¼Œæ±ºå®šè¦èµ°å·¦é‚„æ˜¯å³å­æ¨¹\nèµ°è¨ªåˆ°å€é–“é•·åº¦ç‚º $1$ æ™‚å³ç­”æ¡ˆï¼\n\n\n            ç¸½å…±æœ‰ä¸‰å€‹ä¸åŒçš„ä½œæ³•ï¼Œä½¿ç”¨åˆ°æ’åºã€ç·šæ®µæ¨¹ã€ç¬›å¡å…’æ¨¹çš„ä½œæ³•ã€‚å…¶ä¸­ï¼Œä»–å€‘çš„é–“è¤‡é›œåº¦åˆ†åˆ¥æ˜¯ $O(n\\log n)$ã€$O(n\\log n)$ã€$O(n)$ã€‚æ’åºä½œæ³•ï¼šAC (0.1s, 9.5MB)ç·šæ®µæ¨¹ä½œæ³•ï¼šAC (84ms, 20.9MB)æ­æ©ä½œæ³•ï¼šAC (82ms, 15.6MB)åœ¨ç¬›å¡å…’æ¨¹çš„ä½œæ³•ä¸­ï¼Œå°æ¯ä¸€å€‹æ•¸å­—å°‹æ‰¾å…©å´ç¬¬ä¸€å€‹å°æ–¼å®ƒçš„æ•¸å­—ï¼ˆé€™å¯ä»¥ç”¨å–®èª¿éšŠåˆ—å®Œæˆï¼‰ï¼Œä¹‹å¾ŒæŠŠæ¯ä¸€å€‹æ•¸å­—çš„çˆ¶è¦ªç¯€é»è¨­ç‚ºæ‰¾åˆ°çš„å…©ç«¯æ•¸å­—ä¸­è¼ƒå¤§çš„é‚£ä¸€å€‹ã€‚æ­¤ä½œæ³•çš„æ¦‚å¿µæ˜¯ï¼Œå‡è¨­åºåˆ—ä¸­ç¬¬ $i$ å€‹æ•¸å­—æ‰¾åˆ°å…©å´æ•¸å­—åˆ†åˆ¥æ˜¯ $l_i$ ä»¥åŠ $r_i$ï¼Œç•¶ä»–å¦‚æœæ˜¯å€é–“æœ€å°æ™‚ï¼Œå€é–“å¿…é ˆåœ¨ $[l_i+1:r_i-1]$ ä¹‹ä¸­ï¼Œå¦å‰‡å®ƒå°±ä¸æœƒæ˜¯æœ€å°å€¼äº†ã€‚è‡³æ–¼ç‚ºä½•æ˜¯é¸æ“‡ $max(A[l_i],A[r_i])$ ç•¶åšçˆ¶ç¯€é»ï¼Ÿå‰‡æ˜¯å› ç‚ºå¦‚æœé¸æ“‡è¼ƒå°çš„é‚£ä¸€å€‹ï¼Œåœ¨ç¸®å°å€é–“ç¯„åœå¾Œï¼Œç„¡æ³•ç¢ºå®šå¦å¤–ä¸€å€‹æ˜¯å¦åœ¨å€é–“å¤–ï¼Œå¦‚æœåŒ…å«å€é–“å…§ï¼Œå‰‡ $A[i]$ ä¾¿ä¸æœƒæ˜¯æœ€å°å€¼ï¼Œé•åäº†å®šç¾©ã€‚æ›è¨€ä¹‹ï¼Œé¸æ“‡äº†è¼ƒå¤§çš„é‚£ä¸€å€‹ç•¶ä½œçˆ¶ç¯€é»ï¼ŒæŒ‰ç…§å®šç¾©ç•¶èµ°åˆ°é€™å€‹çˆ¶ç¯€é»æ™‚ï¼Œå®ƒæ˜¯å€é–“çš„æœ€å°å€¼ï¼Œå°‡å®ƒæ’é™¤ä¹‹å¾Œï¼Œ$A[i]$ å°±æœƒæ˜¯ä¸‹ä¸€å€‹å€é–“çš„æœ€å°å€¼ï¼\n          \n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSç¾é£Ÿåšè¦½æœƒ","url":"/apcs2109-4/","content":"P4 ç¾é£Ÿåšè¦½æœƒ\né¡Œç›®é€£çµ\nå°æ–¼åºåˆ—ä¸­kå€‹é€£çºŒçš„å€é–“ï¼Œæ¯ä¸€å€‹å€é–“æ»¿è¶³å€é–“å…§çš„å…ƒç´ çš†ä¸é‡è¤‡ï¼Œå€é–“ç¯„åœå¯ä»¥é‡ç–Šï¼ˆä¸éé‡ç–Šéƒ¨åˆ†åªæœƒç®—ä¸€æ¬¡ï¼‰ï¼Œæ‰¾å‡ºé€™kå€‹é€£çºŒå€é–“æ‰€èƒ½è¦†è“‹åˆ°çš„æœ€å¤§é•·åº¦ã€‚\næ„Ÿè¦ºè·ŸèƒŒåŒ…å•é¡Œçš„æ¦‚å¿µæœ‰é»åƒï¼Œnå€‹ç‰©å“å¯ä»¥å°æ‡‰åˆ°kå€‹å€é–“ï¼Œé‡é‡å‰‡å°æ‡‰åˆ°é€™è£¡çš„åºåˆ—ä¸­çš„æ•¸å­—ã€‚é€™é¡Œç”¨DPè§£ã€‚\nå®šç¾©å®šç¾© $dp[i][j]$ ç‚º $i$ å€‹è©¦åƒå“¡ï¼Œçœ‹äº†å‰ $j$ å€‹æ”¤ä½ï¼Œæœ€å¤šå¯ä»¥åƒåˆ°å¹¾å€‹æ”¤ä½ã€‚\nè½‰ç§»å¼ç¶­è­·ä¸€å€‹å‡½æ•¸ $f[i]$ è¡¨ç¤ºå¦‚æœè©¦åƒå“¡åƒäº†ç¬¬ $i$ å€‹æ”¤ä½çš„ç¾é£Ÿï¼Œä»–æ‰€èƒ½åƒåˆ°æœ€å·¦ç«¯çš„æ”¤ä½çš„ç´¢å¼•å€¼ã€‚ä¹Ÿå°±æ˜¯èªªï¼Œè©¦åƒå“¡å¯ä»¥åƒ $f[i]$ åˆ° $i$ æ”¤ä½çš„ç¾é£Ÿã€‚\ndp[i][j] = max(dp[i][j-1],dp[i-1][f[j]-1]+j-f[j]+1)è½‰ç§»å¼ä»£è¡¨äº†è¦ä½¿ç”¨ç¬¬ $i$ çš„æ”¤ä½ä½œç‚ºå³ç«¯é»ï¼Œæˆ–æ˜¯ä¸è¦ä½¿ç”¨ï¼ˆç›´æ¥ç”¨å‰ä¸€å€‹ï¼‰ï¼Œå–å…©è€…çš„æœ€å¤§å€¼ã€‚å¾Œé¢ä¸€ä¸²åŠ æ¸›æ˜¯è¨ˆç®—å€é–“å¤§å°\né‚Šç•Œdp[i][j] = 0,\\text{for all 0â‰¤iâ‰¤k,0â‰¤jâ‰¤n}å¾è½‰ç§»å¼å¯ä»¥çœ‹åˆ°ä»–ç©ºé–“å¯ä»¥ç”¨æ»¾å‹•DPå„ªåŒ–ï¼\n\n            GREEDYçš„ä½œæ³•ï¼Ÿå¦‚æœæ¯ä¸€æ¬¡éƒ½é¸æ“‡æœ€å¤§çš„å€é–“ï¼Œä¸¦å°‡é€™å€‹å€é–“çš„å€¼éƒ½æ”¹æˆ0ï¼Œåš7æ¬¡ï¼Œå¾—åˆ°ç­”æ¡ˆï¼Œæ˜¯æ­£ç¢ºçš„åšæ³•å—ï¼Ÿæœ€å¤§çš„å€é–“ä¸ä¸€å®šæœƒè¢«å®Œå…¨é¸åˆ°ã€‚ä»¥ä¸‹æ¸¬è³‡ï¼š12 25 4 3 2 1 3 4 5 6 4 3 2å¦‚æœæ˜¯Greedyæœƒé¸æ“‡ $2 \\,1\\, 3\\, 4\\, 5\\, 6$ ï¼Œç„¶å¾Œå¾å…©é‚ŠæŒ‘ä¸€é‚Šã€‚ç­”æ¡ˆæ˜¯ $9$ã€‚ä½†æ˜¯ç”¨DPåšæœƒæ˜¯ $5\\, 4\\, 3\\, 2\\, 1$ åŠ ä¸Š $5\\, 6\\, 4\\, 3\\, 2$ï¼Œç­”æ¡ˆæ˜¯ $10$ã€‚\n          \næ™‚é–“è¤‡é›œåº¦ï¼š å…©å±¤è¿´åœˆç¸½å…±æ˜¯ $O(kn)$\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,k,dp[2][N],lft[N],arr[N];int mp[N];signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;k;    memset(dp,0,sizeof(dp));    memset(lft,0,sizeof(lft));    memset(mp,0,sizeof(mp));    rep(i,1,n)cin&gt;&gt;arr[i];    int maxn = 0;    for(int i=1;i&lt;=n;i++)&#123;        if(mp[arr[i]]!=0)&#123;            lft[i] = mp[arr[i]]+1;            mp[arr[i]] = i;        &#125;        else&#123;            lft[i] = 1;            mp[arr[i]] = i;        &#125;        lft[i] = max(maxn,lft[i]);        maxn = max(maxn,lft[i]);    &#125;        for(int i=0;i&lt;k;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            dp[1][j] = max(dp[1][j-1],dp[0][lft[j]-1]+j-lft[j]+1);        &#125;        for(int j=1;j&lt;=n;j++)&#123;            dp[0][j] = dp[1][j];        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;endl;&#125;// 1 1 2 1 4 1 7 1 3 8// 1 1 2 2 4 4 7 7 7 8\nEXTRA ç‰ˆæœ¬\nBY thanksone\n\n\nç†Ÿæ‚‰çš„é¡Œç›®ï¼Œå¤§çš„æ„Ÿäººçš„kã€‚å¦‚æœä¾ç…§ä¸Šé¢$O(nk)$çš„åšæ³•è‚¯å®šTLEã€‚ä¿—è©±èªªå¾—å¥½ : â€œå¥½çš„DPå®šç¾©æ˜¯ACçš„ä¸€åŠâ€å› æ­¤ç¶“éä¸€ç³»åˆ—é€šéˆï¼Œæˆ‘å€‘å¾—åˆ°äº†ä¸€å€‹éå¸¸æ¼‚äº®çš„å®šç¾©\nå®šç¾© $dp[i] =$ å¿…é ˆé¸ç¬¬ $i$ å®¶ï¼Œ$($èƒ½åƒæœ€å¤šçš„æ”¤è²©æ•¸é‡ï¼Œéœ€è¦çš„äººæ•¸$) (dp[i]$æ˜¯ä¸€å€‹$pair)$\nè½‰ç§»å¼ç¶­è­·ä¸€å€‹å‡½æ•¸ $L[i]$ ï¼Œå…¶å¯¦å°±æ˜¯æ¨“ä¸Šçš„ $f[i]$ï¼Œä½†æ˜¯æˆ‘æ¯”è¼ƒæƒ³è¦å«ä»– $L$\ndp[i] = max_{j","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"APCSé¡Œè§£ï¼š2021å¹´9æœˆ","url":"/apcs2109/","content":"é€™æ¬¡æ²’æœ‰å ±åAPCSï¼Œå› ç‚ºå ±åæ‰‹çºŒæœ‰é»éº»ç…©ï¼Œé‚„è¦åœ¨å­¸è­‰æ˜å’Œæ•™å¸«ç°½åç­‰ç­‰ï¼Œæ‰€ä»¥å°±æ²’æœ‰å ±â€¦ã€‚ç¸½ä¹‹ï¼Œåˆ©ç”¨ZeroJudgeçš„æ¸¬è³‡ä¾†å¯«å¯«çœ‹ï¼Œä½†åœ¨ZJä¸Šé¢æœƒéä¸èƒ½ä¿è­‰çœŸçš„å»è€ƒAPCSçš„æ¸¬è³‡å°±ä¸€å®šæœƒéï¼\n\nP1 ä¸ƒè¨€å°è¯é¡Œç›®é€£çµ\nç¸½å…±æœ‰ABCä¸‰ç¨®è¦å‰‡ï¼Œå°±æ¯ä¸€ç¨®éƒ½æ¯”å°ä¸€æ¬¡å°±å¯ä»¥äº†ï¼\næ™‚é–“è¤‡é›œåº¦ï¼š å…±æœ‰ $n$ çµ„å°è¯ï¼Œæ¯ä¸€çµ„éƒ½ $O(1)$ æª¢æŸ¥ï¼Œæ™‚é–“ $O(n)$ ã€‚ï¼ˆä¸énæœ€å¤§ä¹Ÿæ‰50ï¼Œä¸è«–ä»€éº¼è¤‡é›œåº¦éƒ½å¯ä»¥å§ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 50#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;bool a[N],b[N],f = 1;signed main()&#123;    Orz;    cin&gt;&gt;n;    while(n--)&#123;        rep(i,1,7)cin&gt;&gt;a[i];        rep(i,1,7)cin&gt;&gt;b[i];        f = 1;        if(a[2]==a[4]||a[2]!=a[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        else if(b[2]==b[4]||b[2]!=b[6])&#123;                cout&lt;&lt;&quot;A&quot;;f = 0;        &#125;        if(a[7]!=1 || b[7]!=0)&#123;                cout&lt;&lt;&quot;B&quot;;f = 0;        &#125;        if(a[2]==b[2]||a[4]==b[4]||a[6]==b[6])&#123;                cout&lt;&lt;&quot;C&quot;;f = 0;        &#125;        if(f)cout&lt;&lt;&quot;None&quot;&lt;&lt;endl;        else cout&lt;&lt;endl;    &#125;&#125;\nP2 é­”ç‹è¿·å®®é¡Œç›®é€£çµ\né€™ä¸€é¡Œæˆ‘å¥½åƒå¤ªæ—©å¯«äº†ï¼Œé¡Œç›®é‚„åœ¨æ•´ä¿®éšæ®µï¼Œä¸Ÿä¸Šå»TLEï¼Œç™¼ç¾é¡Œç›®æ•˜è¿°åˆæ”¹äº†XDï¼Œå¾é­”ç‹è¸©åˆ°ç‚¸å½ˆçˆ†ç‚¸å¾Œï¼Œã€Œç‚¸å½ˆä¸æœƒæ¶ˆå¤±ã€ï¼Œåˆ°ã€Œç‚¸å½ˆæœƒæ¶ˆå¤±ã€ï¼Œé‚„æœ‰ç¯„æ¸¬ä¹Ÿæœ‰æ”¹è®Šã€‚\né€™ä¸€é¡Œæ˜¯å»æ¨¡æ“¬æ¯ä¸€å€‹é­”ç‹ç§»å‹•çš„ç‹€æ³ï¼Œè¦ç‰¹åˆ¥æ³¨æ„æ¯ä¸€è¼ªçš„åœ‹ç‹æ˜¯åŒæ™‚ç§»å‹•çš„ï¼Œæ²’æœ‰å…ˆå¾Œé †åºï¼Œä¹Ÿå°±æ˜¯èªªä¸€é¡†ç‚¸å½ˆå¯ä»¥ç‚¸æ‰ä¸åªä¸€ä½é­”ç‹ï¼Œå¦‚æœæœ‰å¤šå€‹é­”ç‹ç§»å‹•åˆ°åŒä¸€å€‹æ ¼å­ï¼Œå‰‡ä»–å€‘æœƒä¸€èµ·è¢«ç‚¸æ‰ã€‚\næ™‚é–“è¤‡é›œåº¦ï¼š æœ‰é»é›£ä¼°è¨ˆï¼Œå› ç‚ºå¾ˆé›£ç¢ºå®šæ¯ä¸€å€‹é­”ç‹çš„ç§»å‹•ç‹€æ³æ¬¡æ•¸ï¼Œä¸éç”±æ–¼æ•¸å­—ç¯„åœä¸å¤§ï¼Œä¸” $k$ åªæœ‰åˆ°500ï¼Œå› æ­¤ç›´æ¥åšè¤‡é›œåº¦æ˜¯å¯è¡Œçš„ã€‚\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,k;bool maze[N][N],bomb[N][N];struct node&#123;    int x,y,s,t;    bool alive;&#125;mp[505];signed main()&#123;    Orz;    memset(maze,0,sizeof(maze));    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    rep(i,0,k-1)&#123;        cin&gt;&gt;mp[i].x&gt;&gt;mp[i].y;        cin&gt;&gt;mp[i].s&gt;&gt;mp[i].t;        mp[i].alive = 1;    &#125;        int now_alive = k;    while(now_alive)&#123;        memset(bomb,0,sizeof(bomb));        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            maze[i][j] = 1;        &#125;        for(int p=0;p&lt;k;p++)&#123;            if(mp[p].alive == 0)continue;            int i = mp[p].x,j = mp[p].y;            int nx = i + mp[p].s;            int ny = j + mp[p].t;            if(nx &gt;= n || nx &lt; 0 || ny &gt;= m ||ny &lt; 0)&#123;                now_alive--;                mp[p].alive = 0;            &#125;            else if(maze[nx][ny])&#123;                now_alive--;                mp[p].alive = 0;                bomb[nx][ny] = 1;            &#125;            else&#123;                mp[p].x = nx;                mp[p].y = ny;            &#125;        &#125;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;m;j++)&#123;                if(bomb[i][j] == 1)                    maze[i][j] = 0;            &#125;        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            if(maze[i][j])ans++;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nP3 å¹¸é‹æ•¸å­—é¡Œç›®é€£çµ\nä»¥å€é–“æœ€å°å€¼ä½œç‚ºå€åˆ†é»å°‡æ•¸åˆ—åˆ†æˆå…©åŠï¼Œå¯ä»¥åˆ©ç”¨ç·šæ®µæ¨¹æ‰¾å€é–“æœ€å°å€¼ï¼Œåˆ©ç”¨è¿´åœˆæ¨¡æ“¬æ¯ä¸€æ¬¡ç¯„åœç¸®å°çš„æƒ…æ³ã€‚\nä¸éé€™ä¸€é¡Œæ¯”è¼ƒç‰¹åˆ¥ï¼Œä»–çš„å€é–“ç¯„åœä¸€å®šæœƒè¶Šä¾†è¶Šå°ï¼Œä¸”å€é–“å¤–çš„æ•¸å­—ä¹Ÿå°±ä¸éœ€è¦ä½¿ç”¨åˆ°ï¼Œå› æ­¤å¯ä»¥å°‡æ•¸åˆ—åšä¸€æ¬¡æ’åºï¼Œå¾é ­é–‹å§‹æ‰¾å¦‚æœé‡ä¸Šå€é–“å¤–çš„æ•¸å­—å‰‡ä¸ç†ä»–ï¼Œå¦å‰‡ä½¿ç”¨å®ƒç•¶ä½œå€é–“çš„åˆ†éš”é»ï¼ˆé€™ä¸€å®šæœƒæ˜¯æœ€å°å€¼ï¼Œå› ç‚ºç”±å°åˆ°å¤§æ’åºï¼‰ï¼Œå°‡å€é–“ç¯„åœç¸®å°ã€‚\nè‡³æ–¼æŒ‘é¸å·¦å³å€é–“çš„å€é–“å’Œï¼Œå‰‡å¯ä»¥é€éå‰ç¶´å’Œ $O(1)$ ç®—å‡ºç­”æ¡ˆã€‚\næ™‚é–“è¤‡é›œåº¦ï¼š å¦‚æœæ˜¯ä¸€å€‹éå¢æˆ–éæ¸›çš„åºåˆ—ï¼Œå‰‡æ¯ä¸€æ¬¡å€é–“å¤§å°åªæœƒç¸®æ¸›1ï¼Œæ­¤æ™‚è¤‡é›œåº¦ç‚º $O(n)$ï¼ŒåŠ ä¸Šæœ€ä¸€é–‹å§‹çš„æ’åºæ˜¯ $O(n\\log n)$ï¼Œç¸½å…±ç‚º $O(n\\log n)$ã€‚\næ’åºä½œæ³•#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii sorted[N];signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;sorted[i-1].x;        arr[i] = sorted[i-1].x;        sorted[i-1].y = i;        pref[i] = pref[i-1]+arr[i];    &#125;    sort(sorted,sorted+n);    int ind = 0,l = 1,r = n;    while(r&gt;l)&#123;        while(sorted[ind].y &gt; r || sorted[ind].y &lt; l)ind++;        int left = pref[sorted[ind].y-1]-pref[l-1];        int right = pref[r]-pref[sorted[ind].y];        if(left &gt; right)&#123;            r = sorted[ind].y-1;        &#125;        else&#123;            l = sorted[ind].y+1;        &#125;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;endl;&#125;\nç·šæ®µæ¨¹ä½œæ³•å¦‚æœç”¨ç·šæ®µæ¨¹å¯¦ä½œï¼Œå°‹æ‰¾å€é–“æœ€å°å€¼ï¼Œå¯ä»¥åœ¨ $O(\\log n)$ çš„æ™‚é–“å…§è©¢å•ã€‚åœ¨æœ€å·®çš„æƒ…æ³ä¸‹ï¼Œä¸€å…±æœƒè©¢å• $n$ æ¬¡ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦ä¸€æ¨£æ˜¯ $O(n\\log n)$ã€‚å¯¦ä½œä¸Šä¹Ÿä¸è¤‡é›œï¼Œå»ºç«‹ç·šæ®µæ¨¹ä»¥åŠå€é–“è©¢å•ï¼Œå€é–“ä¿®æ”¹å’Œæ‡¶æ¨™ä¹‹é¡çš„æ±è¥¿ã€‚å¯ä»¥æ¯”è¼ƒä¸€ä¸‹æ™‚é–“ï¼š\n\nç·šæ®µæ¨¹çš„è¡¨ç¾ç¨å¾®å¥½ä¸€é»ï¼Œä¸éå…¶å¯¦æ˜¯ç›¸ç•¶æ¥è¿‘çš„ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 300005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,arr[N],pref[N];pii seg[4*N];//å»ºç«‹ç·šæ®µæ¨¹[l,r)void build(int cur,int l,int r)&#123;    if(r &lt;= l)return;    if(r - l &lt;= 1)&#123;        seg[cur] = &#123;arr[l],l&#125;;        return;    &#125;    int mid = (l+r)/2;    build(2*cur,l,mid);    build(2*cur+1,mid,r);    if(seg[2*cur].x &lt; seg[2*cur+1].x)        seg[cur] = seg[2*cur];    else        seg[cur] = seg[2*cur+1];&#125;//è©¢å•å€é–“æœ€å°å€¼ï¼Œå›å‚³pairpii query(int cur,int l,int r,int ql,int qr)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return &#123;INT_MAX,INT_MAX&#125;;    if(ql &lt;= l &amp;&amp; qr &gt;= r)return seg[cur];    int mid = (l+r)/2;    pii lft = query(2*cur,l,mid,ql,qr);    pii rgt = query(2*cur+1,mid,r,ql,qr);    if(lft.x &lt; rgt.x)return lft;    return rgt;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        cin&gt;&gt;arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    build(1,1,n+1);    int l = 1,r = n+1;        while(r - l &gt; 1)&#123;        int ind = query(1,1,n+1,l,r).y;        int left = pref[ind-1] - pref[l-1];        int right = pref[r-1] - pref[ind];        if(left &gt; right)r = ind;        else l = ind + 1;    &#125;    cout&lt;&lt;arr[l]&lt;&lt;&quot;\\n&quot;;&#125;\næ­æ©ä½œæ³•\nBY thanksone\n\næœ‰ä¸€ç¨®äºŒå…ƒæ¨¹ï¼Œæˆ‘ä¹Ÿä¸çŸ¥é“å«å•¥ï¼Œæ ¹ç‚ºå…¨åºåˆ—æœ€å°å€¼ï¼Œå·¦ç¯€é»ç‚ºå·¦é‚Šåºåˆ—æœ€å°å€¼ï¼Œå³ç¯€é»ç‚ºå³é‚Šåºåˆ—æœ€å°å€¼ã€‚\nå»ºæ³•ç´€éŒ„æ¯å€‹ä½ç½®å·¦ã€å³é‚Šé›¢è‡ªå·±æœ€è¿‘ã€æ¯”è‡ªå·±å°çš„ï¼Œçˆ¸çˆ¸å°±æ˜¯å…©å€‹ä¹‹ä¸­æ¯”è¼ƒå¤§çš„é‚£ä¸€å€‹ã€‚\næ™‚é–“è¤‡é›œåº¦ï¼š ç¨®æ¨¹åŠ è·‘ç­”æ¡ˆç¸½å…± $O(n)$\n#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int, int&gt;#define ff first#define ss secondusing namespace std;array&lt;int, 300004&gt; A, S, L, R;array&lt;pii, 300004&gt; tree;void plant(int n)&#123;    for(int i = 1; i &lt;= n; i++)&#123;        if(A[L[i]] &gt; A[R[i]]) tree[L[i]].ss = i;        else tree[R[i]].ff = i;    &#125;&#125;int solve(int l, int r, int m)&#123;    if(l == r) return A[l];    if(S[m - 1] - S[l - 1] &gt; S[r] - S[m]) return solve(l, m - 1, tree[m].ff);    else return solve(m + 1, r, tree[m].ss);&#125;signed main()&#123;    int n;    cin &gt;&gt; n;    stack&lt;pii&gt; s;    pii m = &#123;1e9, 0&#125;;    s.push(&#123;0, 0&#125;);    for(int i = 1; i &lt;= n; i++)&#123;        cin &gt;&gt; A[i];        if(A[i] &lt; m.ff) m = &#123;A[i], i&#125;;        S[i] = A[i] + S[i - 1];        while(A[i] &lt; s.top().ff)&#123;            R[s.top().ss] = i;            s.pop();        &#125;        L[i] = s.top().ss;        s.push(&#123;A[i], i&#125;);    &#125;    plant(n);    cout &lt;&lt; solve(1, n, m.ss);    return 0;&#125;\nå¦‚æœæŠŠç¯„æ¸¬çš„ç¬›å¡çˆ¾æ¨¹å…·è±¡åŒ–ï¼Œå¤§æ¦‚é•·é€™æ¨£ï¼š\n\n83 9 4 5 1 6 2 8\n\n\nå¤§è‡´æ­¥é©Ÿå°±æ˜¯ï¼š\n\nç”¨å–®èª¿éšŠåˆ—å»ºç«‹å‡½æ•¸ $L$ ä»¥åŠ $R$ï¼Œè¡¨ç¤ºå¾€å·¦å¾€å³çœ‹ç¬¬ä¸€å€‹å°æ–¼è‡ªå·±çš„æ•¸\nå»ºç«‹ç¬›å¡çˆ¾æ¨¹ï¼ˆ$L[i],R[i]$ æŒ‘å¤§çš„ä½œç‚ºçˆ¶ç¯€é»ï¼‰\nå¾æ ¹ç¯€é»é–‹å§‹èµ°è¨ªï¼Œå·¦å³ç¯€é»å°±æœƒåˆ†åˆ¥æ˜¯å·¦å³å€é–“çš„æœ€å°å€¼\nåˆ©ç”¨å‰ç¶´å’Œè¨ˆç®—å€é–“å¤§å°ï¼Œæ±ºå®šè¦èµ°å·¦é‚„æ˜¯å³å­æ¨¹\nèµ°è¨ªåˆ°å€é–“é•·åº¦ç‚º $1$ æ™‚å³ç­”æ¡ˆï¼\n\n\n            ç¸½å…±æœ‰ä¸‰å€‹ä¸åŒçš„ä½œæ³•ï¼Œä½¿ç”¨åˆ°æ’åºã€ç·šæ®µæ¨¹ã€ç¬›å¡å…’æ¨¹çš„ä½œæ³•ã€‚å…¶ä¸­ï¼Œä»–å€‘çš„é–“è¤‡é›œåº¦åˆ†åˆ¥æ˜¯ $O(n\\log n)$ã€$O(n\\log n)$ã€$O(n)$ã€‚æ’åºä½œæ³•ï¼šAC (0.1s, 9.5MB)ç·šæ®µæ¨¹ä½œæ³•ï¼šAC (84ms, 20.9MB)æ­æ©ä½œæ³•ï¼šAC (82ms, 15.6MB)åœ¨ç¬›å¡å…’æ¨¹çš„ä½œæ³•ä¸­ï¼Œå°æ¯ä¸€å€‹æ•¸å­—å°‹æ‰¾å…©å´ç¬¬ä¸€å€‹å°æ–¼å®ƒçš„æ•¸å­—ï¼ˆé€™å¯ä»¥ç”¨å–®èª¿éšŠåˆ—å®Œæˆï¼‰ï¼Œä¹‹å¾ŒæŠŠæ¯ä¸€å€‹æ•¸å­—çš„çˆ¶è¦ªç¯€é»è¨­ç‚ºæ‰¾åˆ°çš„å…©ç«¯æ•¸å­—ä¸­è¼ƒå¤§çš„é‚£ä¸€å€‹ã€‚æ­¤ä½œæ³•çš„æ¦‚å¿µæ˜¯ï¼Œå‡è¨­åºåˆ—ä¸­ç¬¬ $i$ å€‹æ•¸å­—æ‰¾åˆ°å…©å´æ•¸å­—åˆ†åˆ¥æ˜¯ $l_i$ ä»¥åŠ $r_i$ï¼Œç•¶ä»–å¦‚æœæ˜¯å€é–“æœ€å°æ™‚ï¼Œå€é–“å¿…é ˆåœ¨ $[l_i+1:r_i-1]$ ä¹‹ä¸­ï¼Œå¦å‰‡å®ƒå°±ä¸æœƒæ˜¯æœ€å°å€¼äº†ã€‚è‡³æ–¼ç‚ºä½•æ˜¯é¸æ“‡ $max(A[l_i],A[r_i])$ ç•¶åšçˆ¶ç¯€é»ï¼Ÿå‰‡æ˜¯å› ç‚ºå¦‚æœé¸æ“‡è¼ƒå°çš„é‚£ä¸€å€‹ï¼Œåœ¨ç¸®å°å€é–“ç¯„åœå¾Œï¼Œç„¡æ³•ç¢ºå®šå¦å¤–ä¸€å€‹æ˜¯å¦åœ¨å€é–“å¤–ï¼Œå¦‚æœåŒ…å«å€é–“å…§ï¼Œå‰‡ $A[i]$ ä¾¿ä¸æœƒæ˜¯æœ€å°å€¼ï¼Œé•åäº†å®šç¾©ã€‚æ›è¨€ä¹‹ï¼Œé¸æ“‡äº†è¼ƒå¤§çš„é‚£ä¸€å€‹ç•¶ä½œçˆ¶ç¯€é»ï¼ŒæŒ‰ç…§å®šç¾©ç•¶èµ°åˆ°é€™å€‹çˆ¶ç¯€é»æ™‚ï¼Œå®ƒæ˜¯å€é–“çš„æœ€å°å€¼ï¼Œå°‡å®ƒæ’é™¤ä¹‹å¾Œï¼Œ$A[i]$ å°±æœƒæ˜¯ä¸‹ä¸€å€‹å€é–“çš„æœ€å°å€¼ï¼\n          \nP4 ç¾é£Ÿåšè¦½æœƒé¡Œç›®é€£çµ\nå°æ–¼åºåˆ—ä¸­kå€‹é€£çºŒçš„å€é–“ï¼Œæ¯ä¸€å€‹å€é–“æ»¿è¶³å€é–“å…§çš„å…ƒç´ çš†ä¸é‡è¤‡ï¼Œå€é–“ç¯„åœå¯ä»¥é‡ç–Šï¼ˆä¸éé‡ç–Šéƒ¨åˆ†åªæœƒç®—ä¸€æ¬¡ï¼‰ï¼Œæ‰¾å‡ºé€™kå€‹é€£çºŒå€é–“æ‰€èƒ½è¦†è“‹åˆ°çš„æœ€å¤§é•·åº¦ã€‚\næ„Ÿè¦ºè·ŸèƒŒåŒ…å•é¡Œçš„æ¦‚å¿µæœ‰é»åƒï¼Œnå€‹ç‰©å“å¯ä»¥å°æ‡‰åˆ°kå€‹å€é–“ï¼Œé‡é‡å‰‡å°æ‡‰åˆ°é€™è£¡çš„åºåˆ—ä¸­çš„æ•¸å­—ã€‚é€™é¡Œç”¨DPè§£ã€‚\nå®šç¾©å®šç¾© $dp[i][j]$ ç‚º $i$ å€‹è©¦åƒå“¡ï¼Œçœ‹äº†å‰ $j$ å€‹æ”¤ä½ï¼Œæœ€å¤šå¯ä»¥åƒåˆ°å¹¾å€‹æ”¤ä½ã€‚\nè½‰ç§»å¼ç¶­è­·ä¸€å€‹å‡½æ•¸ $f[i]$ è¡¨ç¤ºå¦‚æœè©¦åƒå“¡åƒäº†ç¬¬ $i$ å€‹æ”¤ä½çš„ç¾é£Ÿï¼Œä»–æ‰€èƒ½åƒåˆ°æœ€å·¦ç«¯çš„æ”¤ä½çš„ç´¢å¼•å€¼ã€‚ä¹Ÿå°±æ˜¯èªªï¼Œè©¦åƒå“¡å¯ä»¥åƒ $f[i]$ åˆ° $i$ æ”¤ä½çš„ç¾é£Ÿã€‚\ndp[i][j] = max(dp[i][j-1],dp[i-1][f[j]-1]+j-f[j]+1)è½‰ç§»å¼ä»£è¡¨äº†è¦ä½¿ç”¨ç¬¬ $i$ çš„æ”¤ä½ä½œç‚ºå³ç«¯é»ï¼Œæˆ–æ˜¯ä¸è¦ä½¿ç”¨ï¼ˆç›´æ¥ç”¨å‰ä¸€å€‹ï¼‰ï¼Œå–å…©è€…çš„æœ€å¤§å€¼ã€‚å¾Œé¢ä¸€ä¸²åŠ æ¸›æ˜¯è¨ˆç®—å€é–“å¤§å°\né‚Šç•Œdp[i][j] = 0,\\text{for all 0â‰¤iâ‰¤k,0â‰¤jâ‰¤n}å¾è½‰ç§»å¼å¯ä»¥çœ‹åˆ°ä»–ç©ºé–“å¯ä»¥ç”¨æ»¾å‹•DPå„ªåŒ–ï¼\n\n            GREEDYçš„ä½œæ³•ï¼Ÿå¦‚æœæ¯ä¸€æ¬¡éƒ½é¸æ“‡æœ€å¤§çš„å€é–“ï¼Œä¸¦å°‡é€™å€‹å€é–“çš„å€¼éƒ½æ”¹æˆ0ï¼Œåš7æ¬¡ï¼Œå¾—åˆ°ç­”æ¡ˆï¼Œæ˜¯æ­£ç¢ºçš„åšæ³•å—ï¼Ÿæœ€å¤§çš„å€é–“ä¸ä¸€å®šæœƒè¢«å®Œå…¨é¸åˆ°ã€‚ä»¥ä¸‹æ¸¬è³‡ï¼š12 25 4 3 2 1 3 4 5 6 4 3 2å¦‚æœæ˜¯Greedyæœƒé¸æ“‡ $2 \\,1\\, 3\\, 4\\, 5\\, 6$ ï¼Œç„¶å¾Œå¾å…©é‚ŠæŒ‘ä¸€é‚Šã€‚ç­”æ¡ˆæ˜¯ $9$ã€‚ä½†æ˜¯ç”¨DPåšæœƒæ˜¯ $5\\, 4\\, 3\\, 2\\, 1$ åŠ ä¸Š $5\\, 6\\, 4\\, 3\\, 2$ï¼Œç­”æ¡ˆæ˜¯ $10$ã€‚\n          \næ™‚é–“è¤‡é›œåº¦ï¼š å…©å±¤è¿´åœˆç¸½å…±æ˜¯ $O(kn)$\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,k,dp[2][N],lft[N],arr[N];int mp[N];signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;k;    memset(dp,0,sizeof(dp));    memset(lft,0,sizeof(lft));    memset(mp,0,sizeof(mp));    rep(i,1,n)cin&gt;&gt;arr[i];    int maxn = 0;    for(int i=1;i&lt;=n;i++)&#123;        if(mp[arr[i]]!=0)&#123;            lft[i] = mp[arr[i]]+1;            mp[arr[i]] = i;        &#125;        else&#123;            lft[i] = 1;            mp[arr[i]] = i;        &#125;        lft[i] = max(maxn,lft[i]);        maxn = max(maxn,lft[i]);    &#125;        for(int i=0;i&lt;k;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            dp[1][j] = max(dp[1][j-1],dp[0][lft[j]-1]+j-lft[j]+1);        &#125;        for(int j=1;j&lt;=n;j++)&#123;            dp[0][j] = dp[1][j];        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;endl;&#125;// 1 1 2 1 4 1 7 1 3 8// 1 1 2 2 4 4 7 7 7 8\nEXTRA ç‰ˆæœ¬\nBY thanksone\n\n\nç†Ÿæ‚‰çš„é¡Œç›®ï¼Œå¤§çš„æ„Ÿäººçš„kã€‚å¦‚æœä¾ç…§ä¸Šé¢$O(nk)$çš„åšæ³•è‚¯å®šTLEã€‚ä¿—è©±èªªå¾—å¥½ : â€œå¥½çš„DPå®šç¾©æ˜¯ACçš„ä¸€åŠâ€å› æ­¤ç¶“éä¸€ç³»åˆ—é€šéˆï¼Œæˆ‘å€‘å¾—åˆ°äº†ä¸€å€‹éå¸¸æ¼‚äº®çš„å®šç¾©\nå®šç¾© $dp[i] =$ å¿…é ˆé¸ç¬¬ $i$ å®¶ï¼Œ$($èƒ½åƒæœ€å¤šçš„æ”¤è²©æ•¸é‡ï¼Œéœ€è¦çš„äººæ•¸$) (dp[i]$æ˜¯ä¸€å€‹$pair)$\nè½‰ç§»å¼ç¶­è­·ä¸€å€‹å‡½æ•¸ $L[i]$ ï¼Œå…¶å¯¦å°±æ˜¯æ¨“ä¸Šçš„ $f[i]$ï¼Œä½†æ˜¯æˆ‘æ¯”è¼ƒæƒ³è¦å«ä»– $L$\ndp[i] = max_{j","categories":["APCSæª¢å®š"],"tags":["APCS","ç«¶è³½ç­†è¨˜"]},{"title":"[é¡Œè§£]APCSä¿®è£œåœç±¬","url":"/apcs2111-1/","content":"P1 ä¿®è£œåœç±¬\né¡Œç›®é€£çµ\né¡Œè§£å¦‚æœåœ¨å…©ç«¯å°±ç›´æ¥å–æ—é‚Šçš„é«˜åº¦ï¼Œå¦å‰‡å–è·Ÿå·¦å³é‚Šé«˜åº¦çš„æœ€å°å€¼ã€‚\næ™‚é–“è¤‡é›œåº¦$O(n)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define N 105#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,A[N];signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;A[i];    int ans = 0;    if(A[0] == 0)ans += A[1];    if(A[n-1] == 0)ans += A[n-2];    for(int i=1;i&lt;n-1;i++)&#123;        if(A[i] == 0)ans += min(A[i-1],A[i+1]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSå‹•ç·šå®‰æ’","url":"/apcs2111-2/","content":"P2 å‹•ç·šå®‰æ’(é­”ç‹é¡Œ)\né¡Œç›®é€£çµ\né¡Œè§£æŠŠç·šåˆ†æˆæ©«çš„è·Ÿç›´çš„å°±å¯ä»¥å¥½å¥½è™•ç†äº¤å‰äº†!\næ™‚é–“è¤‡é›œåº¦$O(h(n + m))$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt = 0, ans = 0;array&lt;array&lt;int, 104&gt;, 104&gt; R, C, I;void add(int r, int c)&#123;    bool ok;    I[r][c] = 1;    cnt++;    if(C[r][c] || R[r][c]) cnt--;    C[r][c] = R[r][c] = 0;    ok = 0;     //ç›´ä¸‹æƒ…æ³    for(int i = r + 1; i &lt; n; i++)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r + 1; i &lt; n; i++)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //ç›´ä¸Šæƒ…æ³    for(int i = r - 1; i &gt;= 0; i--)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r - 1; i &gt;= 0; i--)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //æ©«å³æƒ…æ³    for(int i = c + 1; i &lt; m; i++)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c + 1; i &lt; m; i++)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;    ok = 0;     //æ©«å·¦æƒ…æ³    for(int i = c - 1; i &gt;= 0; i--)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c - 1; i &gt;= 0; i--)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;&#125;void pull(int r, int c)&#123;    I[r][c] = 0;    cnt--;    for(int i = r + 1; i &lt; n; i++)&#123;     //ç›´ä¸‹æƒ…æ³        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = r - 1; i &gt;= 0; i--)&#123;    //ç›´ä¸Šæƒ…æ³        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = c + 1; i &lt; m; i++)&#123;     //æ©«å³æƒ…æ³        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;    for(int i = c - 1; i &gt;= 0; i--)&#123;    //æ©«å·¦æƒ…æ³        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;&#125;signed main()&#123;    int h, r, c, t;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;    while(h--)&#123;        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t;        if(t)&#123;            pull(r, c);        &#125;else&#123;            add(r, c);        &#125;        ans = max(ans, cnt);    &#125;    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot; &lt;&lt; cnt;    return 0;&#125;\n\nBY thanksone\n\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSç”Ÿç”¢ç·š","url":"/apcs2111-3/","content":"P3 ç”Ÿç”¢ç·š\né¡Œç›®é€£çµ\nå·®åˆ†ä½œæ³•é¡Œè§£ç”¨å·®åˆ†çš„æƒ³æ³•åŠ å€¼ï¼Œå†ç”¨å‰ç¶´é‚„åŸï¼Œæœ€å¾Œå†æ’åºã€‚æœ€å¾Œåˆ©ç”¨Greedyçš„æƒ³æ³•ï¼Œå°‡æ¯ä¸€é …æœ€å°çš„å·¥ä½œé‡ä¹˜ä¸Šæœ€å¤§çš„æ™‚é–“ï¼Œç¸½å’Œå³ç‚ºç­”æ¡ˆã€‚\n\n            å·®åˆ†å·®åˆ†æ˜¯å‰ç¶´å’Œçš„é€†é‹ç®—ï¼Œä¹Ÿå°±æ˜¯èªªï¼ŒæŠŠå…©é …çš„å·®ç®—å‡ºä¾†å°±æ˜¯å·®åˆ†ã€‚å®šç¾©å¦‚ä¸‹ï¼šb_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}å·®åˆ†çš„ä½¿ç”¨æ™‚æ©Ÿæ˜¯å€é–“åŠ å€¼ï¼Œä¸€å€‹å€é–“å…§çš„æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å®šå€¼ï¼Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨åˆ°å·®åˆ†çš„æŠ€å·§ã€‚ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼Œç•¶æˆ‘è¦åœ¨å€é–“ $[l,r]$ çš„æ¯ä¸€å€‹æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å€¼$v$ï¼Œä»¥ä¸‹æ­¥é©Ÿï¼šå®šç¾©ä¸€å€‹æ–°çš„é™£åˆ— $b_i$ è¡¨ç¤ºæ¯ä¸€é …å·®åˆ†è¨­ $b[l] =  b[l] + v,b[r+1] = b[r+1] - v$å°‡å·®åˆ†çš„æ¯ä¸€é …åŠ ä¸Šå‰ä¸€é …ï¼ˆåšå‰ç¶´å’Œ $b[i] = b[i]+b[i-1]$ï¼‰ï¼Œå³ç‚ºåŸæ•¸åˆ—ç¬¬äºŒæ­¥é©Ÿå¯ä»¥é‡è¤‡å¥½å¹¾æ¬¡åšï¼Œé€™æ¨£è¤‡é›œåº¦å¾åŸæœ¬çš„$O(n)$å°±è®Šæˆäº†$O(1)$äº†ï¼\n          \næ™‚é–“è¤‡é›œåº¦å·®åˆ†ï¼š$O(m)$ ã€æ’åº $O(n\\log n)$\nç¸½æ™‚é–“è¤‡é›œåº¦ï¼š$O(n\\log n + m)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,A[N],B[N];signed main()&#123;    IOS;    memset(A,0,sizeof(A));    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        A[x] += w;        A[y+1] -= w;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];    for(int i=1;i&lt;=n;i++)A[i] = A[i] + A[i-1];    sort(A+1,A+n+1);    sort(B+1,B+n+1);    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans += A[i] * B[n-i+1];    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\nç·šæ®µæ¨¹ä½œæ³•\nå¾ˆå¥‡æ€ªï¼Œæœ€è¿‘å…©æ¬¡çš„APCSç¬¬ä¸‰é¡Œéƒ½æœ‰äººæƒ³è¦ç ¸è³‡çµï¼Œç‰¹åˆ¥æ˜¯ç·šæ®µæ¨¹ï¼Œå¯èƒ½æœ‰äº›äººç‰¹åˆ¥åæ„›ç·šæ®µæ¨¹å§ï¼\né¡Œè§£ç·šæ®µæ¨¹æœ€åŸæœ¬çš„æ‡‰è©²æ˜¯å€é–“è©¢å•ã€å–®é»ä¿®æ”¹ï¼Œå¦‚æœè¦å€é–“ä¿®æ”¹çš„è©±å°±æœƒç”¨åˆ°æ‡¶æ¨™ï¼Œæ‰€ä»¥å¯¦ä½œä¸Šç›¸å°ä¸Šæ¯”è¼ƒè¤‡é›œä¸€é»ã€‚é€™ä¸€é¡Œç”¨ç·šæ®µæ¨¹çš„ç›®çš„æ˜¯å€é–“åŠ å€¼ï¼ŒåŠ å€¼å®Œéå¾Œçš„æ’åºä»¥åŠGreedyè·Ÿå·®åˆ†çš„ä½œæ³•æ˜¯ä¸€æ¨£çš„ï¼Œç”¨ç·šæ®µæ¨¹çœŸçš„æ˜¯å¤šæ­¤å…©èˆ‰ï¼ˆå¯¦ä½œè¼ƒè¤‡é›œã€è¼ƒè€—æ™‚ï¼‰ï¼\nç•¶ç„¶ï¼Œé€™ä¸€é¡Œæ¯”è¼ƒç‰¹åˆ¥åªæœ‰æœ€å¾Œä¸€èµ·åšå–®é»æŸ¥è©¢ï¼Œå› æ­¤ä¸ç”¨æ‡¶æ¨™ï¼Œæœ€ä¾¯ç›´æ¥è¨ˆç®—ä¸€è·¯å»ç¶“éçš„ç­”æ¡ˆä¹Ÿè¡Œï¼ä¸‹é¢çš„ç¨‹å¼ç¢¼å°±æ˜¯æŠŠå®Œå…¨åŒ…å«å€é–“çš„ç¯€é»åŠ å€¼ï¼Œä¸ç”¨ä½¿ç”¨åˆ°æ‡¶æ¨™ï¼Œæœ€å¾Œä¸€æ¬¡æŸ¥è©¢ã€‚\næ™‚é–“è¤‡é›œåº¦å€é–“åŠ å€¼ $O(m\\log n)$ï¼Œnå€‹é»çš„è©¢å• $O(n\\log n)$ï¼Œæ’åº $O(n\\log n)$\nç¸½æ™‚é–“è¤‡é›œåº¦ï¼š$O((n+m)\\log n)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,t,A[N],B[N],ans = 0;struct node&#123;    int val = 0,sz;&#125;seg[4*N];void build(int id,int l,int r)&#123;    seg[id].sz = r - l;    if(r - l &lt;= 1)return;    int mid = (l + r) / 2;    build(id*2,l,mid);    build(id*2+1,mid,r);&#125;void modify(int id,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || r &lt;= ql || l &gt;= qr)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[id].val += val;        return;    &#125;    int mid = (l + r) / 2;    modify(id*2,l,mid,ql,qr,val);    modify(id*2+1,mid,r,ql,qr,val);&#125;void query(int id,int l,int r,int val)&#123;    if(r &lt;= l)return;    ans += seg[id].val;    if(r - l == 1)return;    int mid = (l + r) / 2;    if(val &lt; mid)return query(id*2,l,mid,val);    else return query(id*2+1,mid,r,val);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    build(1,1,n+1);    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        y++;        modify(1,1,n+1,x,y,w);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        ans = 0;query(1,1,n+1,i);        A[i] = ans;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];        sort(A+1,A + n + 1);    sort(B+1,B + n + 1);    int ans = 0;    for(int i=1;i&lt;=n;i++)ans += A[i] * B[n-i+1];    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"[é¡Œè§£]APCSçœŸå‡å­åœ–","url":"/apcs2111-4/","content":"P4 çœŸå‡å­åœ–\né¡Œç›®é€£çµ\näºŒåˆ†æœå°‹+DFSä½œæ³•é¡Œè§£ä¸€é–‹å§‹çœ‹åˆ°é€™é¡Œï¼Œæ‡‰è©²å¾ˆé›£é€šéˆå‡ºäºŒåˆ†æœé€™å€‹ä½œæ³•ï¼ˆæˆ‘è¦ºå¾—å…‰æŠŠé¡Œç›®çœ‹æ‡‚å°±æœ‰é»é›£åº¦äº†ï¼‰ã€‚é€™é¡Œæœ‰ä¸€å€‹æ¢ä»¶è¦ç‰¹åˆ¥æ³¨æ„ï¼š\n\nä¿è­‰è‹¥èª¿æŸ¥å“¡çš„ k å€‹ pair çš„çµæœå’Œçµ„é•·å­˜ç•™çš„ m å€‹ pair ä¸æœƒç”¢ç”ŸçŸ›ç›¾, å‰‡ä¿è­‰èª¿æŸ¥å“¡çš„è³‡æ–™ä¸€å®šå’ŒåŸæœ¬ A, B åˆ†çµ„å»åˆ\né€™ä¸€é¡Œæ¯ä¸€å€‹è§€å¯Ÿå“¡ä¸¦å¯çœ‹æˆä¸æ˜¯ç¨ç«‹çš„ï¼ˆå‡å¦‚ä¸€å€‹è§€å¯Ÿå“¡ä¸ç”¢ç”ŸçŸ›ç›¾ï¼Œå‰‡ä»–å›å‚³çš„é‚£ä¸€äº›é‚Šéƒ½æœƒè¢«æ²¿ç”¨ï¼‰ï¼Œæ‰€ä»¥é¡Œç›® $p$ ç­†è©¢å•å¯ä»¥è¯é›†ä¸€èµ·è™•ç†ã€‚\n\nå°‡æƒ…å ±å“¡ç•¶æˆé»ï¼Œåˆä½œé—œä¿‚ç•¶æˆé‚Šï¼Œé‚£éº¼åˆæ³•çš„åœ–å°±æœƒæœ‰å…©å€‹é»é›†ï¼Œé»é›†ä¸­çš„é»äº’ä¸ç›¸é„°ï¼Œä¹Ÿå°±æ˜¯äºŒåˆ†åœ–ã€‚\näºŒåˆ†æœç¬¬ä¸€å€‹ä½¿å¾—åœ–è®Šå¾—ä¸äºŒåˆ†çš„äººï¼ŒæŠŠå®ƒæ¶ˆå¤±ï¼Œæœ€å¤šé‡è¤‡3æ¬¡å°±åšå®Œäº†ã€‚\n\n            ç‚ºä»€éº¼å¯ä»¥äºŒåˆ†æœï¼ŸäºŒåˆ†æœæ˜¯ç”¨ä¾†æ‰¾ä¸€ä¸²01å­—ä¸²çš„åˆ†ç•Œé»ï¼Œä¸¦ä¸”å¿…é ˆå…·æœ‰å–®èª¿æ€§æ‰èƒ½äºŒåˆ†æœã€‚é€™ä¸€é¡Œä¹‹æ‰€ä»¥æœƒæœ‰å–®èª¿æ€§æ˜¯å› ç‚ºï¼Œç•¶æˆ‘æŸ¥è©¢è§€å¯Ÿå“¡$P_i$çš„å›å‚³è³‡æ–™æ˜¯å¦æ­£ç¢ºæ™‚ï¼Œæœƒå°‡å‰é¢ $1$ åˆ° $i-1$ çš„è§€å¯Ÿå“¡å›å‚³çš„æ‰€æœ‰é‚Šç´å…¥è€ƒæ…®ã€‚å‡è¨­æœ‰ä¸€å€‹è§€å¯Ÿå“¡ $P_j(1\\le j &lt; i)$ å›å‚³çš„è³‡æ–™æ˜¯éŒ¯èª¤çš„ï¼Œé€™äº›é‚Šæœƒå°è‡´æ•´å¼µåœ–è®ŠæˆéäºŒåˆ†åœ–ï¼Œå°æ–¼ $j$ å¾Œé¢çš„æ‰€æœ‰é»ä¾†èªªï¼Œéƒ½æ˜¯éäºŒåˆ†åœ–ã€‚é€™æ¨£å°±æœ‰äº†ä»¥ $j$ ç‚ºåˆ†ç•Œé»çš„å–®èª¿æ€§ï¼Œå³å¯äºŒåˆ†æœã€‚\n          \näºŒåˆ†åœ–åˆ¤æ–·å¯ä»¥ç”¨ DFS åšï¼ŒDFS çš„æ™‚å€™æŠŠæ¯å€‹é»å¡—ä¸Šé¡è‰²ï¼Œå¦‚æœç›¸é„°çš„é»è·Ÿè‡ªå·±é¡è‰²ä¸€æ¨£å°±è¡¨ç¤ºé€™ä¸æ˜¯ä¸€å¼µäºŒåˆ†åœ–ã€‚\næ™‚é–“è¤‡é›œåº¦$O((n + m + pk)\\log p)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define pb push_back#define mid (l + r) / 2using namespace std;struct e&#123;    int u, v;&#125;;int n;array&lt;bool, 10004&gt; WA;          //ä¸å¯è¡Œçš„è§€å¯Ÿå“¡ç·¨è™Ÿarray&lt;int, 20004&gt; vis;          //DFSæ˜¯å¦èµ°è¨ªã€äºŒåˆ†åœ–é¡è‰²array&lt;vector&lt;e&gt;, 10004&gt; E;      //æ¯ä¸€å€‹è§€å¯Ÿå“¡çš„å›å‚³é‚Šarray&lt;vector&lt;int&gt;, 20004&gt; G;    //å­˜é€²è¡ŒDFSçš„åœ–bool dfs(int u, int t)&#123;         //ç”¨DFSå¡—è‰²ã€åˆ¤æ–·äºŒåˆ†åœ–    if(vis[u]) return 1;    bool ans = 1;    vis[u] = t;    for(int v : G[u])&#123;        if(vis[v] == t) return 0;        ans &amp;= dfs(v, 3 - t);    &#125;    return ans;&#125;bool check(int p)&#123;               //æª¢æŸ¥ç¬¬på€‹è§€å¯Ÿå“¡å›å‚³æ˜¯å¦æ­£ç¢º    bool ans = 1;    for(int i = 0; i &lt; n; i++)&#123;        G[i].clear();        vis[i] = 0;    &#125;    for(int i = 0; i &lt;= p; i++)&#123;        for(auto [u, v] : E[i])&#123; //å°‡è§€å¯Ÿå“¡çš„é‚Šæ¨å…¥G            G[u].pb(v);            G[v].pb(u);        &#125;    &#125;    for(int i = 0; i &lt; n; i++)&#123;        ans &amp;= dfs(i, 1);        //å°‡æ¯ä¸€å€‹é€£é€šå¡Š    &#125;    return ans;&#125;void BS(int l, int r)&#123;           //äºŒåˆ†æœè§€å¯Ÿå“¡    if(check(r)) return;         //ç•¶é‚Šçš„é€£é›†ä¸æœƒè®“åœ–æœ‰å•é¡Œï¼Œå‰‡å›å‚³    while(l != r)&#123;        if(check(mid)) l = mid + 1;        else r = mid;    &#125;    WA[l] = 1;    E[l].clear();                //å‰”é™¤ä¸€éŒ¯èª¤è§€å¯Ÿå“¡&#125;signed main()&#123;    int m, p, k, a, b;    cin &gt;&gt; n &gt;&gt; m;    while(m--)&#123;        cin &gt;&gt; a &gt;&gt; b;        E[0].pb(&#123;a, b&#125;);    &#125;    cin &gt;&gt; p &gt;&gt; k;    for(int i = 1; i &lt;= p; i++)&#123;        for(int j = 0; j &lt; k; j++)&#123;            cin &gt;&gt; a &gt;&gt; b;            E[i].pb(&#123;a, b&#125;);        &#125;    &#125;    for(int i = 0; i &lt; 3; i++)&#123;     //è‡³å¤šä¸‰å€‹è§€å¯Ÿå“¡        BS(0, p);    &#125;    for(int i = 1; i &lt;= p; i++)&#123;        if(WA[i]) cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\nBY thanksone\n\nDSUä½œæ³•\nIdea From Kennyfs\n\né¡Œè§£é€™ä¸€é¡Œçš„é¡Œç›®é™åˆ¶æœ‰èªªæœ€å¤š3å€‹éŒ¯èª¤çš„æƒ…å ±å“¡ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥ç”¨ä¸Šé¢äºŒåˆ†æœçš„æ–¹å¼åšä¸‰æ¬¡æ‰¾åˆ°ç­”æ¡ˆã€‚å¦‚æœé¡Œç›®ä¸é™åˆ¶éŒ¯èª¤èª¿æŸ¥å“¡çš„æ•¸é‡ï¼Œä¹Ÿå°±æ˜¯ç”¨äºŒåˆ†æœæ™‚é–“æœƒè¶…æ™‚ï¼Œä½†æ˜¯ç”¨DSUå¯ä»¥åœ¨ç·šæ€§æ™‚é–“å…§å®Œæˆï¼\nDSUçš„ç›®çš„åœ¨è™•ç†é›†åˆå•é¡Œï¼Œæ ¹æ“šä¸‹é¢é€™å€‹é—œéµæ¢ä»¶ï¼š\n\nä¿è­‰è‹¥èª¿æŸ¥å“¡çš„ k å€‹ pair çš„çµæœå’Œçµ„é•·å­˜ç•™çš„ m å€‹ pair ä¸æœƒç”¢ç”ŸçŸ›ç›¾, å‰‡ä¿è­‰èª¿æŸ¥å“¡çš„è³‡æ–™ä¸€å®šå’ŒåŸæœ¬ A, B åˆ†çµ„å»åˆ\n\næˆ‘å€‘åªè¦å°æ¯ä¸€ç­†è©¢å•çœ‹æœƒä¸æœƒèˆ‡çµ„é•·æ‰‹ä¸­çš„pairçŸ›ç›¾å³å¯ã€‚å¦‚æœæ¯ä¸€æ¬¡éƒ½åšDFSï¼Œæœƒç™¼ç¾æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(pn)$ï¼Œå¿…ç„¶è¶…æ™‚ã€‚\nDSUçš„æƒ³æ³•æ˜¯ï¼Œæˆ‘å€‘å°‡çµ„é•·æ‰‹ä¸­çš„åœ–ä¸­ä¸Šæ¯ä¸€å€‹é€£é€šå¡Šéƒ½åˆ†åˆ¥å¡—ä¸Šå…©ç¨®é¡è‰²ï¼ˆå¿…ç‚ºäºŒåˆ†åœ–ï¼Œå› æ­¤å°‡å…©é‚Šå„å¡—ä¸Šä¸åŒé¡è‰²ï¼‰ã€‚æ¥è‘—ï¼ŒæŠŠæ¯å€‹é¡è‰²ç•¶ä½œåˆå§‹çš„ä¸¦æŸ¥é›†ä¸­çš„é›†åˆï¼Œå°‡æ¯ä¸€ç­†è§€å¯Ÿå“¡å›å‚³çš„é‚Šçš„å…©ç«¯æŒ‡å‘çš„é›†åˆåˆä½µèµ·ä¾†ï¼Œéç¨‹ä¸­å¦‚æœç™¼ç”Ÿé‚Šçš„å…©ç«¯åŒå±¬ä¸€å€‹é›†åˆï¼Œè¡¨ç¤ºé€™æ˜¯ä¸€å€‹éŒ¯èª¤çš„è§€å¯Ÿå“¡ã€‚åšå®Œæ¯ä¸€å€‹è§€å¯Ÿå“¡ä¹‹å¾Œï¼ŒæŠŠæ‰€æœ‰è®Šæ›´éçš„é‚„åŸæˆåˆå§‹ç‹€æ…‹ï¼ˆçµ„é•·æ‰‹ä¸­çš„åœ–ï¼‰å³å¯ã€‚\n\n            èˆ‰ä¾‹8 50 2 1 3 1 2 4 6 5 61 21 4 0 6æ•´å€‹éç¨‹å°±æ˜¯ä¸‹é¢é€™å¼µGIFï¼šæ­¥é©Ÿï¼šåˆ©ç”¨DFSç‚ºçµ„é•·æ‰‹ä¸­çš„åœ–ä¸Šè‰²ï¼Œæ¯ä¸€å€‹é€£é€šå¡Šå…©è‰²ï¼ˆä»¥ç·¨è™Ÿ1,2,3â€¦ï¼‰å°‡æ¯ä¸€å€‹é¡è‰²ç•¶ä½œä¸¦æŸ¥é›†å…ƒç´ è§€å¯Ÿå“¡è¼¸å…¥çš„é‚Šå…©ç«¯ $(u,v)$éåŒè‰²ï¼Œè¡¨ç¤ºä¸ç™¼ç”ŸçŸ›ç›¾ï¼Œå‰‡å°‡uæ‰€åœ¨é›†åˆèˆ‡væ‰€åœ¨é›†åˆçš„å°æ–¹ï¼ˆé€£é€šå¡Šå…©è‰²çš„å¦ä¸€è‰²ï¼‰åˆä½µé‡è¤‡ æ­¥é©Ÿ3 å…±kæ¬¡ï¼Œå¦‚æœç™¼ç”Ÿ$(u,v)$ç‚ºåŒä¸€è‰²ï¼Œå‰‡è§€å¯Ÿå“¡éŒ¯èª¤ã€‚\n          \næ™‚é–“è¤‡é›œåº¦$O(n + pk\\alpha)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 20005#define M 10005using namespace std;int n,m,p,k;int color[N],boss[N],num[N];bool WA[M],f;int other(int s)&#123;return (s%2)?s+1:s-1;&#125; //otherç‚ºåŒä¸€é€£é€šå¡Šå¦å¤–ä¸€ç¨®é¡è‰²vector&lt;int&gt; edge[N],change;void init()&#123;                            //åˆå§‹åŒ–    memset(color,0,sizeof(color));    memset(WA,0,sizeof(WA));&#125;void dfs(int id,int col)&#123;           //å°æ‰€æœ‰é»ä¸Šè‰²    color[id] = col;    for(auto i:edge[id])&#123;        if(!color[i])dfs(i,other(col));    &#125;&#125;int find_boss(int id)&#123;              //å°‹æ‰¾ç¥–å…ˆã€åŠè·¯å¾‘å£“ç¸®    if(boss[id] == id)return id;    change.push_back(id);    return boss[id] = find_boss(boss[id]);&#125;signed main()&#123;    IOS;    init();    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    int now = 1;    for(int i=0;i&lt;n;i++)&#123;           //å°æ‰€æœ‰é»ä¸Šè‰²        if(!color[i])&#123;            dfs(i,now);now += 2;        &#125;    &#125;    for(int i=1;i&lt;=now;i++)&#123;boss[i] = i;num[i] = 1;&#125;    cin&gt;&gt;p&gt;&gt;k;    for(int i=1;i&lt;=p;i++)&#123;        change.clear();                                  //å„²å­˜å¾…æ›´æ”¹çš„é»é›†f = 0;        for(int j=0;j&lt;k;j++)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            if(f)continue;            x = color[x],y = color[y];                   //å°‹æ‰¾é‚Šå…©ç«¯é»çš„é¡è‰²æ‰€è™•çš„é›†åˆ            int bx =  find_boss(x),by = find_boss(y);            int ox = find_boss(other(y)),oy = find_boss(other(x));            if(bx == by)&#123;WA[i] = 1;f = 1;continue;&#125;     //ä½æ–¼åŒä¸€é›†åˆï¼Œæ­¤è§€å¯Ÿå“¡æ˜¯éŒ¯çš„            //ä»¥ä¸‹æ˜¯å•Ÿç™¼å¼åˆä½µï¼ˆå°çš„é›†åˆä¸¦åˆ°å¤§çš„é›†åˆï¼‰            if(num[bx] &lt; num[ox])&#123;                boss[bx] = ox;num[ox] += num[bx];                change.push_back(bx);            &#125;            else&#123;                boss[ox] = bx;num[bx] += num[ox];                change.push_back(ox);            &#125;            if(num[by] &lt; num[oy])&#123;                boss[by] = oy;num[oy] += num[by];                change.push_back(by);            &#125;            else&#123;                boss[oy] = by;num[by] += num[oy];                change.push_back(oy);            &#125;        &#125;        for(auto i : change)&#123;boss[i] = i;num[i] = 1;&#125;   //è§€å¯Ÿå“¡çš„é‚ŠçµæŸï¼Œçœ‹å®Œå¾Œå¾©åŸ    &#125;    for(int i=1;i&lt;=p;i++)if(WA[i])cout&lt;&lt;i&lt;&lt;endl;        //è¼¸å‡ºæœ€å¾ŒéŒ¯èª¤è§€å¯Ÿå“¡ç­”æ¡ˆ&#125;\n\nBY peienwu\n\n","categories":["APCSé¡Œè§£"],"tags":["é¡Œè§£","APCSæª¢å®š"]},{"title":"APCSé¡Œè§£ï¼š2021å¹´11æœˆ","url":"/apcs2111/","content":"P1 ä¿®è£œåœç±¬é¡Œç›®é€£çµ\né¡Œè§£å¦‚æœåœ¨å…©ç«¯å°±ç›´æ¥å–æ—é‚Šçš„é«˜åº¦ï¼Œå¦å‰‡å–è·Ÿå·¦å³é‚Šé«˜åº¦çš„æœ€å°å€¼ã€‚\n\næ™‚é–“è¤‡é›œåº¦$O(n)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define N 105#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,A[N];signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;A[i];    int ans = 0;    if(A[0] == 0)ans += A[1];    if(A[n-1] == 0)ans += A[n-2];    for(int i=1;i&lt;n-1;i++)&#123;        if(A[i] == 0)ans += min(A[i-1],A[i+1]);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\nP2 å‹•ç·šå®‰æ’(é­”ç‹é¡Œ)é¡Œç›®é€£çµ\né¡Œè§£æŠŠç·šåˆ†æˆæ©«çš„è·Ÿç›´çš„å°±å¯ä»¥å¥½å¥½è™•ç†äº¤å‰äº†!\næ™‚é–“è¤‡é›œåº¦$O(h(n + m))$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, cnt = 0, ans = 0;array&lt;array&lt;int, 104&gt;, 104&gt; R, C, I;void add(int r, int c)&#123;    bool ok;    I[r][c] = 1;    cnt++;    if(C[r][c] || R[r][c]) cnt--;    C[r][c] = R[r][c] = 0;    ok = 0;     //ç›´ä¸‹æƒ…æ³    for(int i = r + 1; i &lt; n; i++)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r + 1; i &lt; n; i++)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //ç›´ä¸Šæƒ…æ³    for(int i = r - 1; i &gt;= 0; i--)&#123;        if(I[i][c]) ok = 1;    &#125;    if(ok)&#123;        for(int i = r - 1; i &gt;= 0; i--)&#123;            if(I[i][c] || R[i][c]) break;            R[i][c]++;            cnt += C[i][c] == 0;        &#125;    &#125;    ok = 0;     //æ©«å³æƒ…æ³    for(int i = c + 1; i &lt; m; i++)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c + 1; i &lt; m; i++)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;    ok = 0;     //æ©«å·¦æƒ…æ³    for(int i = c - 1; i &gt;= 0; i--)&#123;        if(I[r][i]) ok = 1;    &#125;    if(ok)&#123;        for(int i = c - 1; i &gt;= 0; i--)&#123;            if(I[r][i] || C[r][i]) break;            C[r][i]++;            cnt += R[r][i] == 0;        &#125;    &#125;&#125;void pull(int r, int c)&#123;    I[r][c] = 0;    cnt--;    for(int i = r + 1; i &lt; n; i++)&#123;     //ç›´ä¸‹æƒ…æ³        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = r - 1; i &gt;= 0; i--)&#123;    //ç›´ä¸Šæƒ…æ³        if(!R[i][c]) break;        R[i][c]--;        cnt -= C[i][c] == 0;    &#125;    for(int i = c + 1; i &lt; m; i++)&#123;     //æ©«å³æƒ…æ³        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;    for(int i = c - 1; i &gt;= 0; i--)&#123;    //æ©«å·¦æƒ…æ³        if(!C[r][i]) break;        C[r][i]--;        cnt -= R[r][i] == 0;    &#125;&#125;signed main()&#123;    int h, r, c, t;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; h;    while(h--)&#123;        cin &gt;&gt; r &gt;&gt; c &gt;&gt; t;        if(t)&#123;            pull(r, c);        &#125;else&#123;            add(r, c);        &#125;        ans = max(ans, cnt);    &#125;    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot; &lt;&lt; cnt;    return 0;&#125;\n\nBY thanksone\n\nP3 ç”Ÿç”¢ç·šé¡Œç›®é€£çµ\nå·®åˆ†ä½œæ³•é¡Œè§£ç”¨å·®åˆ†çš„æƒ³æ³•åŠ å€¼ï¼Œå†ç”¨å‰ç¶´é‚„åŸï¼Œæœ€å¾Œå†æ’åºã€‚æœ€å¾Œåˆ©ç”¨Greedyçš„æƒ³æ³•ï¼Œå°‡æ¯ä¸€é …æœ€å°çš„å·¥ä½œé‡ä¹˜ä¸Šæœ€å¤§çš„æ™‚é–“ï¼Œç¸½å’Œå³ç‚ºç­”æ¡ˆã€‚\n\n            å·®åˆ†å·®åˆ†æ˜¯å‰ç¶´å’Œçš„é€†é‹ç®—ï¼Œä¹Ÿå°±æ˜¯èªªï¼ŒæŠŠå…©é …çš„å·®ç®—å‡ºä¾†å°±æ˜¯å·®åˆ†ã€‚å®šç¾©å¦‚ä¸‹ï¼šb_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}å·®åˆ†çš„ä½¿ç”¨æ™‚æ©Ÿæ˜¯å€é–“åŠ å€¼ï¼Œä¸€å€‹å€é–“å…§çš„æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å®šå€¼ï¼Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨åˆ°å·®åˆ†çš„æŠ€å·§ã€‚ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼Œç•¶æˆ‘è¦åœ¨å€é–“ $[l,r]$ çš„æ¯ä¸€å€‹æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å€¼$v$ï¼Œä»¥ä¸‹æ­¥é©Ÿï¼šå®šç¾©ä¸€å€‹æ–°çš„é™£åˆ— $b_i$ è¡¨ç¤ºæ¯ä¸€é …å·®åˆ†è¨­ $b[l] =  b[l] + v,b[r+1] = b[r+1] - v$å°‡å·®åˆ†çš„æ¯ä¸€é …åŠ ä¸Šå‰ä¸€é …ï¼ˆåšå‰ç¶´å’Œ $b[i] = b[i]+b[i-1]$ï¼‰ï¼Œå³ç‚ºåŸæ•¸åˆ—ç¬¬äºŒæ­¥é©Ÿå¯ä»¥é‡è¤‡å¥½å¹¾æ¬¡åšï¼Œé€™æ¨£è¤‡é›œåº¦å¾åŸæœ¬çš„$O(n)$å°±è®Šæˆäº†$O(1)$äº†ï¼\n          \næ™‚é–“è¤‡é›œåº¦å·®åˆ†ï¼š$O(m)$ ã€æ’åº $O(n\\log n)$\nç¸½æ™‚é–“è¤‡é›œåº¦ï¼š$O(n\\log n + m)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,A[N],B[N];signed main()&#123;    IOS;    memset(A,0,sizeof(A));    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        A[x] += w;        A[y+1] -= w;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];    for(int i=1;i&lt;=n;i++)A[i] = A[i] + A[i-1];    sort(A+1,A+n+1);    sort(B+1,B+n+1);    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans += A[i] * B[n-i+1];    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n\nBY peienwu\n\nç·šæ®µæ¨¹ä½œæ³•\nå¾ˆå¥‡æ€ªï¼Œæœ€è¿‘å…©æ¬¡çš„APCSç¬¬ä¸‰é¡Œéƒ½æœ‰äººæƒ³è¦ç ¸è³‡çµï¼Œç‰¹åˆ¥æ˜¯ç·šæ®µæ¨¹ï¼Œå¯èƒ½æœ‰äº›äººç‰¹åˆ¥åæ„›ç·šæ®µæ¨¹å§ï¼\né¡Œè§£ç·šæ®µæ¨¹æœ€åŸæœ¬çš„æ‡‰è©²æ˜¯å€é–“è©¢å•ã€å–®é»ä¿®æ”¹ï¼Œå¦‚æœè¦å€é–“ä¿®æ”¹çš„è©±å°±æœƒç”¨åˆ°æ‡¶æ¨™ï¼Œæ‰€ä»¥å¯¦ä½œä¸Šç›¸å°ä¸Šæ¯”è¼ƒè¤‡é›œä¸€é»ã€‚é€™ä¸€é¡Œç”¨ç·šæ®µæ¨¹çš„ç›®çš„æ˜¯å€é–“åŠ å€¼ï¼ŒåŠ å€¼å®Œéå¾Œçš„æ’åºä»¥åŠGreedyè·Ÿå·®åˆ†çš„ä½œæ³•æ˜¯ä¸€æ¨£çš„ï¼Œç”¨ç·šæ®µæ¨¹çœŸçš„æ˜¯å¤šæ­¤å…©èˆ‰ï¼ˆå¯¦ä½œè¼ƒè¤‡é›œã€è¼ƒè€—æ™‚ï¼‰ï¼\nç•¶ç„¶ï¼Œé€™ä¸€é¡Œæ¯”è¼ƒç‰¹åˆ¥åªæœ‰æœ€å¾Œä¸€èµ·åšå–®é»æŸ¥è©¢ï¼Œå› æ­¤ä¸ç”¨æ‡¶æ¨™ï¼Œæœ€ä¾¯ç›´æ¥è¨ˆç®—ä¸€è·¯å»ç¶“éçš„ç­”æ¡ˆä¹Ÿè¡Œï¼ä¸‹é¢çš„ç¨‹å¼ç¢¼å°±æ˜¯æŠŠå®Œå…¨åŒ…å«å€é–“çš„ç¯€é»åŠ å€¼ï¼Œä¸ç”¨ä½¿ç”¨åˆ°æ‡¶æ¨™ï¼Œæœ€å¾Œä¸€æ¬¡æŸ¥è©¢ã€‚\næ™‚é–“è¤‡é›œåº¦å€é–“åŠ å€¼ $O(m\\log n)$ï¼Œnå€‹é»çš„è©¢å• $O(n\\log n)$ï¼Œæ’åº $O(n\\log n)$\nç¸½æ™‚é–“è¤‡é›œåº¦ï¼š$O((n+m)\\log n)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,t,A[N],B[N],ans = 0;struct node&#123;    int val = 0,sz;&#125;seg[4*N];void build(int id,int l,int r)&#123;    seg[id].sz = r - l;    if(r - l &lt;= 1)return;    int mid = (l + r) / 2;    build(id*2,l,mid);    build(id*2+1,mid,r);&#125;void modify(int id,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || r &lt;= ql || l &gt;= qr)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[id].val += val;        return;    &#125;    int mid = (l + r) / 2;    modify(id*2,l,mid,ql,qr,val);    modify(id*2+1,mid,r,ql,qr,val);&#125;void query(int id,int l,int r,int val)&#123;    if(r &lt;= l)return;    ans += seg[id].val;    if(r - l == 1)return;    int mid = (l + r) / 2;    if(val &lt; mid)return query(id*2,l,mid,val);    else return query(id*2+1,mid,r,val);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    build(1,1,n+1);    while(m--)&#123;        int x,y,w;cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;        y++;        modify(1,1,n+1,x,y,w);    &#125;    for(int i=1;i&lt;=n;i++)&#123;        ans = 0;query(1,1,n+1,i);        A[i] = ans;    &#125;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;B[i];        sort(A+1,A + n + 1);    sort(B+1,B + n + 1);    int ans = 0;    for(int i=1;i&lt;=n;i++)ans += A[i] * B[n-i+1];    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nP4 çœŸå‡å­åœ–é¡Œç›®é€£çµ\näºŒåˆ†æœå°‹+DFSä½œæ³•é¡Œè§£ä¸€é–‹å§‹çœ‹åˆ°é€™é¡Œï¼Œæ‡‰è©²å¾ˆé›£é€šéˆå‡ºäºŒåˆ†æœé€™å€‹ä½œæ³•ï¼ˆæˆ‘è¦ºå¾—å…‰æŠŠé¡Œç›®çœ‹æ‡‚å°±æœ‰é»é›£åº¦äº†ï¼‰ã€‚é€™é¡Œæœ‰ä¸€å€‹æ¢ä»¶è¦ç‰¹åˆ¥æ³¨æ„ï¼š\n\nä¿è­‰è‹¥èª¿æŸ¥å“¡çš„ k å€‹ pair çš„çµæœå’Œçµ„é•·å­˜ç•™çš„ m å€‹ pair ä¸æœƒç”¢ç”ŸçŸ›ç›¾, å‰‡ä¿è­‰èª¿æŸ¥å“¡çš„è³‡æ–™ä¸€å®šå’ŒåŸæœ¬ A, B åˆ†çµ„å»åˆ\né€™ä¸€é¡Œæ¯ä¸€å€‹è§€å¯Ÿå“¡ä¸¦å¯çœ‹æˆä¸æ˜¯ç¨ç«‹çš„ï¼ˆå‡å¦‚ä¸€å€‹è§€å¯Ÿå“¡ä¸ç”¢ç”ŸçŸ›ç›¾ï¼Œå‰‡ä»–å›å‚³çš„é‚£ä¸€äº›é‚Šéƒ½æœƒè¢«æ²¿ç”¨ï¼‰ï¼Œæ‰€ä»¥é¡Œç›® $p$ ç­†è©¢å•å¯ä»¥è¯é›†ä¸€èµ·è™•ç†ã€‚\n\nå°‡æƒ…å ±å“¡ç•¶æˆé»ï¼Œåˆä½œé—œä¿‚ç•¶æˆé‚Šï¼Œé‚£éº¼åˆæ³•çš„åœ–å°±æœƒæœ‰å…©å€‹é»é›†ï¼Œé»é›†ä¸­çš„é»äº’ä¸ç›¸é„°ï¼Œä¹Ÿå°±æ˜¯äºŒåˆ†åœ–ã€‚\näºŒåˆ†æœç¬¬ä¸€å€‹ä½¿å¾—åœ–è®Šå¾—ä¸äºŒåˆ†çš„äººï¼ŒæŠŠå®ƒæ¶ˆå¤±ï¼Œæœ€å¤šé‡è¤‡3æ¬¡å°±åšå®Œäº†ã€‚\n\n            ç‚ºä»€éº¼å¯ä»¥äºŒåˆ†æœï¼ŸäºŒåˆ†æœæ˜¯ç”¨ä¾†æ‰¾ä¸€ä¸²01å­—ä¸²çš„åˆ†ç•Œé»ï¼Œä¸¦ä¸”å¿…é ˆå…·æœ‰å–®èª¿æ€§æ‰èƒ½äºŒåˆ†æœã€‚é€™ä¸€é¡Œä¹‹æ‰€ä»¥æœƒæœ‰å–®èª¿æ€§æ˜¯å› ç‚ºï¼Œç•¶æˆ‘æŸ¥è©¢è§€å¯Ÿå“¡$P_i$çš„å›å‚³è³‡æ–™æ˜¯å¦æ­£ç¢ºæ™‚ï¼Œæœƒå°‡å‰é¢ $1$ åˆ° $i-1$ çš„è§€å¯Ÿå“¡å›å‚³çš„æ‰€æœ‰é‚Šç´å…¥è€ƒæ…®ã€‚å‡è¨­æœ‰ä¸€å€‹è§€å¯Ÿå“¡ $P_j(1\\le j &lt; i)$ å›å‚³çš„è³‡æ–™æ˜¯éŒ¯èª¤çš„ï¼Œé€™äº›é‚Šæœƒå°è‡´æ•´å¼µåœ–è®ŠæˆéäºŒåˆ†åœ–ï¼Œå°æ–¼ $j$ å¾Œé¢çš„æ‰€æœ‰é»ä¾†èªªï¼Œéƒ½æ˜¯éäºŒåˆ†åœ–ã€‚é€™æ¨£å°±æœ‰äº†ä»¥ $j$ ç‚ºåˆ†ç•Œé»çš„å–®èª¿æ€§ï¼Œå³å¯äºŒåˆ†æœã€‚\n          \näºŒåˆ†åœ–åˆ¤æ–·å¯ä»¥ç”¨ DFS åšï¼ŒDFS çš„æ™‚å€™æŠŠæ¯å€‹é»å¡—ä¸Šé¡è‰²ï¼Œå¦‚æœç›¸é„°çš„é»è·Ÿè‡ªå·±é¡è‰²ä¸€æ¨£å°±è¡¨ç¤ºé€™ä¸æ˜¯ä¸€å¼µäºŒåˆ†åœ–ã€‚\næ™‚é–“è¤‡é›œåº¦$O((n + m + pk)\\log p)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define pb push_back#define mid (l + r) / 2using namespace std;struct e&#123;    int u, v;&#125;;int n;array&lt;bool, 10004&gt; WA;          //ä¸å¯è¡Œçš„è§€å¯Ÿå“¡ç·¨è™Ÿarray&lt;int, 20004&gt; vis;          //DFSæ˜¯å¦èµ°è¨ªã€äºŒåˆ†åœ–é¡è‰²array&lt;vector&lt;e&gt;, 10004&gt; E;      //æ¯ä¸€å€‹è§€å¯Ÿå“¡çš„å›å‚³é‚Šarray&lt;vector&lt;int&gt;, 20004&gt; G;    //å­˜é€²è¡ŒDFSçš„åœ–bool dfs(int u, int t)&#123;         //ç”¨DFSå¡—è‰²ã€åˆ¤æ–·äºŒåˆ†åœ–    if(vis[u]) return 1;    bool ans = 1;    vis[u] = t;    for(int v : G[u])&#123;        if(vis[v] == t) return 0;        ans &amp;= dfs(v, 3 - t);    &#125;    return ans;&#125;bool check(int p)&#123;               //æª¢æŸ¥ç¬¬på€‹è§€å¯Ÿå“¡å›å‚³æ˜¯å¦æ­£ç¢º    bool ans = 1;    for(int i = 0; i &lt; n; i++)&#123;        G[i].clear();        vis[i] = 0;    &#125;    for(int i = 0; i &lt;= p; i++)&#123;        for(auto [u, v] : E[i])&#123; //å°‡è§€å¯Ÿå“¡çš„é‚Šæ¨å…¥G            G[u].pb(v);            G[v].pb(u);        &#125;    &#125;    for(int i = 0; i &lt; n; i++)&#123;        ans &amp;= dfs(i, 1);        //å°‡æ¯ä¸€å€‹é€£é€šå¡Š    &#125;    return ans;&#125;void BS(int l, int r)&#123;           //äºŒåˆ†æœè§€å¯Ÿå“¡    if(check(r)) return;         //ç•¶é‚Šçš„é€£é›†ä¸æœƒè®“åœ–æœ‰å•é¡Œï¼Œå‰‡å›å‚³    while(l != r)&#123;        if(check(mid)) l = mid + 1;        else r = mid;    &#125;    WA[l] = 1;    E[l].clear();                //å‰”é™¤ä¸€éŒ¯èª¤è§€å¯Ÿå“¡&#125;signed main()&#123;    int m, p, k, a, b;    cin &gt;&gt; n &gt;&gt; m;    while(m--)&#123;        cin &gt;&gt; a &gt;&gt; b;        E[0].pb(&#123;a, b&#125;);    &#125;    cin &gt;&gt; p &gt;&gt; k;    for(int i = 1; i &lt;= p; i++)&#123;        for(int j = 0; j &lt; k; j++)&#123;            cin &gt;&gt; a &gt;&gt; b;            E[i].pb(&#123;a, b&#125;);        &#125;    &#125;    for(int i = 0; i &lt; 3; i++)&#123;     //è‡³å¤šä¸‰å€‹è§€å¯Ÿå“¡        BS(0, p);    &#125;    for(int i = 1; i &lt;= p; i++)&#123;        if(WA[i]) cout &lt;&lt; i &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\nBY thanksone\n\nDSUä½œæ³•\nIdea From Kennyfs\n\né¡Œè§£é€™ä¸€é¡Œçš„é¡Œç›®é™åˆ¶æœ‰èªªæœ€å¤š3å€‹éŒ¯èª¤çš„æƒ…å ±å“¡ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥ç”¨ä¸Šé¢äºŒåˆ†æœçš„æ–¹å¼åšä¸‰æ¬¡æ‰¾åˆ°ç­”æ¡ˆã€‚å¦‚æœé¡Œç›®ä¸é™åˆ¶éŒ¯èª¤èª¿æŸ¥å“¡çš„æ•¸é‡ï¼Œä¹Ÿå°±æ˜¯ç”¨äºŒåˆ†æœæ™‚é–“æœƒè¶…æ™‚ï¼Œä½†æ˜¯ç”¨DSUå¯ä»¥åœ¨ç·šæ€§æ™‚é–“å…§å®Œæˆï¼\nDSUçš„ç›®çš„åœ¨è™•ç†é›†åˆå•é¡Œï¼Œæ ¹æ“šä¸‹é¢é€™å€‹é—œéµæ¢ä»¶ï¼š\n\nä¿è­‰è‹¥èª¿æŸ¥å“¡çš„ k å€‹ pair çš„çµæœå’Œçµ„é•·å­˜ç•™çš„ m å€‹ pair ä¸æœƒç”¢ç”ŸçŸ›ç›¾, å‰‡ä¿è­‰èª¿æŸ¥å“¡çš„è³‡æ–™ä¸€å®šå’ŒåŸæœ¬ A, B åˆ†çµ„å»åˆ\n\næˆ‘å€‘åªè¦å°æ¯ä¸€ç­†è©¢å•çœ‹æœƒä¸æœƒèˆ‡çµ„é•·æ‰‹ä¸­çš„pairçŸ›ç›¾å³å¯ã€‚å¦‚æœæ¯ä¸€æ¬¡éƒ½åšDFSï¼Œæœƒç™¼ç¾æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(pn)$ï¼Œå¿…ç„¶è¶…æ™‚ã€‚\nDSUçš„æƒ³æ³•æ˜¯ï¼Œæˆ‘å€‘å°‡çµ„é•·æ‰‹ä¸­çš„åœ–ä¸­ä¸Šæ¯ä¸€å€‹é€£é€šå¡Šéƒ½åˆ†åˆ¥å¡—ä¸Šå…©ç¨®é¡è‰²ï¼ˆå¿…ç‚ºäºŒåˆ†åœ–ï¼Œå› æ­¤å°‡å…©é‚Šå„å¡—ä¸Šä¸åŒé¡è‰²ï¼‰ã€‚æ¥è‘—ï¼ŒæŠŠæ¯å€‹é¡è‰²ç•¶ä½œåˆå§‹çš„ä¸¦æŸ¥é›†ä¸­çš„é›†åˆï¼Œå°‡æ¯ä¸€ç­†è§€å¯Ÿå“¡å›å‚³çš„é‚Šçš„å…©ç«¯æŒ‡å‘çš„é›†åˆåˆä½µèµ·ä¾†ï¼Œéç¨‹ä¸­å¦‚æœç™¼ç”Ÿé‚Šçš„å…©ç«¯åŒå±¬ä¸€å€‹é›†åˆï¼Œè¡¨ç¤ºé€™æ˜¯ä¸€å€‹éŒ¯èª¤çš„è§€å¯Ÿå“¡ã€‚åšå®Œæ¯ä¸€å€‹è§€å¯Ÿå“¡ä¹‹å¾Œï¼ŒæŠŠæ‰€æœ‰è®Šæ›´éçš„é‚„åŸæˆåˆå§‹ç‹€æ…‹ï¼ˆçµ„é•·æ‰‹ä¸­çš„åœ–ï¼‰å³å¯ã€‚\n\n            èˆ‰ä¾‹8 50 2 1 3 1 2 4 6 5 61 21 4 0 6æ•´å€‹éç¨‹å°±æ˜¯ä¸‹é¢é€™å¼µGIFï¼šæ­¥é©Ÿï¼šåˆ©ç”¨DFSç‚ºçµ„é•·æ‰‹ä¸­çš„åœ–ä¸Šè‰²ï¼Œæ¯ä¸€å€‹é€£é€šå¡Šå…©è‰²ï¼ˆä»¥ç·¨è™Ÿ1,2,3â€¦ï¼‰å°‡æ¯ä¸€å€‹é¡è‰²ç•¶ä½œä¸¦æŸ¥é›†å…ƒç´ è§€å¯Ÿå“¡è¼¸å…¥çš„é‚Šå…©ç«¯ $(u,v)$éåŒè‰²ï¼Œè¡¨ç¤ºä¸ç™¼ç”ŸçŸ›ç›¾ï¼Œå‰‡å°‡uæ‰€åœ¨é›†åˆèˆ‡væ‰€åœ¨é›†åˆçš„å°æ–¹ï¼ˆé€£é€šå¡Šå…©è‰²çš„å¦ä¸€è‰²ï¼‰åˆä½µé‡è¤‡ æ­¥é©Ÿ3 å…±kæ¬¡ï¼Œå¦‚æœç™¼ç”Ÿ$(u,v)$ç‚ºåŒä¸€è‰²ï¼Œå‰‡è§€å¯Ÿå“¡éŒ¯èª¤ã€‚\n          \næ™‚é–“è¤‡é›œåº¦$O(n + pk\\alpha)$\nACç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 20005#define M 10005using namespace std;int n,m,p,k;int color[N],boss[N],num[N];bool WA[M],f;int other(int s)&#123;return (s%2)?s+1:s-1;&#125; //otherç‚ºåŒä¸€é€£é€šå¡Šå¦å¤–ä¸€ç¨®é¡è‰²vector&lt;int&gt; edge[N],change;void init()&#123;                            //åˆå§‹åŒ–    memset(color,0,sizeof(color));    memset(WA,0,sizeof(WA));&#125;void dfs(int id,int col)&#123;           //å°æ‰€æœ‰é»ä¸Šè‰²    color[id] = col;    for(auto i:edge[id])&#123;        if(!color[i])dfs(i,other(col));    &#125;&#125;int find_boss(int id)&#123;              //å°‹æ‰¾ç¥–å…ˆã€åŠè·¯å¾‘å£“ç¸®    if(boss[id] == id)return id;    change.push_back(id);    return boss[id] = find_boss(boss[id]);&#125;signed main()&#123;    IOS;    init();    cin&gt;&gt;n&gt;&gt;m;    while(m--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    int now = 1;    for(int i=0;i&lt;n;i++)&#123;           //å°æ‰€æœ‰é»ä¸Šè‰²        if(!color[i])&#123;            dfs(i,now);now += 2;        &#125;    &#125;    for(int i=1;i&lt;=now;i++)&#123;boss[i] = i;num[i] = 1;&#125;    cin&gt;&gt;p&gt;&gt;k;    for(int i=1;i&lt;=p;i++)&#123;        change.clear();                                  //å„²å­˜å¾…æ›´æ”¹çš„é»é›†f = 0;        for(int j=0;j&lt;k;j++)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            if(f)continue;            x = color[x],y = color[y];                   //å°‹æ‰¾é‚Šå…©ç«¯é»çš„é¡è‰²æ‰€è™•çš„é›†åˆ            int bx =  find_boss(x),by = find_boss(y);            int ox = find_boss(other(y)),oy = find_boss(other(x));            if(bx == by)&#123;WA[i] = 1;f = 1;continue;&#125;     //ä½æ–¼åŒä¸€é›†åˆï¼Œæ­¤è§€å¯Ÿå“¡æ˜¯éŒ¯çš„            //ä»¥ä¸‹æ˜¯å•Ÿç™¼å¼åˆä½µï¼ˆå°çš„é›†åˆä¸¦åˆ°å¤§çš„é›†åˆï¼‰            if(num[bx] &lt; num[ox])&#123;                boss[bx] = ox;num[ox] += num[bx];                change.push_back(bx);            &#125;            else&#123;                boss[ox] = bx;num[bx] += num[ox];                change.push_back(ox);            &#125;            if(num[by] &lt; num[oy])&#123;                boss[by] = oy;num[oy] += num[by];                change.push_back(by);            &#125;            else&#123;                boss[oy] = by;num[by] += num[oy];                change.push_back(oy);            &#125;        &#125;        for(auto i : change)&#123;boss[i] = i;num[i] = 1;&#125;   //è§€å¯Ÿå“¡çš„é‚ŠçµæŸï¼Œçœ‹å®Œå¾Œå¾©åŸ    &#125;    for(int i=1;i&lt;=p;i++)if(WA[i])cout&lt;&lt;i&lt;&lt;endl;        //è¼¸å‡ºæœ€å¾ŒéŒ¯èª¤è§€å¯Ÿå“¡ç­”æ¡ˆ&#125;\n\nBY peienwu\n\n","categories":["APCSæª¢å®š"],"tags":["APCS","ç«¶è³½ç­†è¨˜"]},{"title":"APCS CLASS PART 3","url":"/apcs3/","content":"APCS Classé¡Œç›®ç¬¬ä¸‰éƒ¨åˆ†ï¼\nM. [åŸºç¤è³‡æ–™çµæ§‹ II åŠåŸºç¤æ¼”ç®—æ³• II ] è²ªå©ªæ³•a071. æ’éšŠè²·é£²æ–™\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    priority_queue&lt;int,vector&lt;int&gt;,greater&lt;&gt;&gt;pq;        cin&gt;&gt;n&gt;&gt;m;    int ans=0,time=0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;time;        if(i&gt;m)&#123;            time+=pq.top();            pq.pop();        &#125;        pq.push(time);        ans = max(ans,time);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\na075. é†œæ•¸#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n;signed main()&#123;    Orz;    cin&gt;&gt;n;    vector&lt;int&gt; vec;    vec.push_back(1);    int id2 = 0,id3 = 0,id5 = 0;    //ç”¨å‰é¢çš„é†œæ•¸æ¨å¾Œé¢çš„ï¼Œä¸æœƒæœ‰å…¶ä»–è³ªæ¨¹    for(int i=1;i&lt;n;i++)&#123;        int ugly = min(vec[id2]*2,min(vec[id3]*3,vec[id5]*5));        vec.push_back(ugly);        if(vec[i]==vec[id2]*2)id2+=1;        if(vec[i]==vec[id3]*3)id3+=1;        if(vec[i]==vec[id5]*5)id5+=1;    &#125;    cout&lt;&lt;vec[n-1]&lt;&lt;endl;&#125;\na091. Add All#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 51#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m;void solve()&#123;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; pq;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            pq.push(temp);        &#125;        int ans = 0;        while(pq.size()!=1)&#123;            int cur = pq.top();            pq.pop();            cur += pq.top();            pq.pop();            ans+=cur;            pq.push(cur);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t=1;    while(t--)&#123;        solve();    &#125;&#125;\na139. èƒŒåŒ…ç½®ç‰©å•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,k;vector&lt;int&gt; vec,p;signed main()&#123;    cin&gt;&gt;n;    vec.assign(1,-1);    cin.ignore();    string s;getline(cin,s);    stringstream ss(s);    int temp;    while(ss&gt;&gt;temp)vec.push_back(temp);    cin&gt;&gt;k;        int ans = 0,len = vec.size();    for(int i=1;i&lt;=len-1;i++)&#123;        if(find(p.begin(),p.end(),vec[i])!=p.end())continue;        else if(p.size()&lt;k)&#123;            p.push_back(vec[i]);            continue;        &#125;        int index = 0, dis = 0, max_dis=0;                for(int j=0;j&lt;p.size();j++)&#123;            dis = 0;            for(int q=i+1;q&lt;=len;q++)&#123;                if(vec[q]==p[j])break;                dis += 1;            &#125;            if(max_dis &lt; dis)&#123;                max_dis = dis;                index = j;            &#125;        &#125;//        cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;index&lt;&lt;endl;        p[index] = vec[i];        ans += 1;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na141. åŸºåœ°å°#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 50005using namespace std;int n,k,arr[N];//ç¢ºèªç›´å¾‘å¯å¦è¦†è“‹å…¨éƒ¨ï¼ˆgreedyï¼‰bool check(int sum)&#123;    int max_cover = arr[0]+sum;    int cnt=1;    for(int i=1;i&lt;n;i++)&#123;        if(max_cover &lt; arr[i])&#123;            max_cover = arr[i]+sum;            cnt++;        &#125;    &#125;    return (cnt&lt;=k);&#125;void solve()&#123;    cin&gt;&gt;n&gt;&gt;k;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr,arr+n);    int l = 1,r = ceil((arr[n-1]-arr[0])/k);    //å€é–“[l,r]äºŒåˆ†æœå°‹ç›´å¾‘    while(l&lt;r)&#123;        int mid = (l+r)/2;        if(check(mid))r = mid;        else l = mid+1;    &#125;    cout&lt;&lt;l&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\nN. [åŸºç¤è³‡æ–™çµæ§‹ II åŠåŸºç¤æ¼”ç®—æ³• II ] åˆ†è€Œæ²»ä¹‹èˆ‡å›æº¯æ³•a089. è˜‡ä¸¹ç‹ä½ç¹¼æ‰¿è€…#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,chess[N][N],Q[N],ans=0;bool check(int row,int col)&#123;    for(int i=1;i&lt;row;i++)&#123;        if(col == Q[i]||abs(row-i)==abs(col-Q[i]))return 0;    &#125;    return 1;&#125;void Queen(int row)&#123;    if(row&gt;8)&#123;        int sum = 0;        rep(i,1,8)sum += chess[i][Q[i]];        ans = max(ans,sum);        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(row,i))&#123;            Q[row] = i;            Queen(row+1);        &#125;    &#125;&#125;void solve()&#123;    memset(chess,0,sizeof(chess));    memset(Q,0,sizeof(Q));    ans = 0;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            cin&gt;&gt;chess[i][j];        &#125;    &#125;    Queen(1);    cout&lt;&lt;right&lt;&lt;setw(5)&lt;&lt;ans&lt;&lt;endl;    &#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na090. è³ªæ•¸ç’°#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 20#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,prime[105],ans[N],cnt = 0;bool visit[N];void init()&#123;    rep(i,0,100)prime[i] = 1;    prime[1] = 0;    for(int i=2;i&lt;=100;i++)&#123;        if(prime[i]==0)continue;        for(int j=2*i;j&lt;=100;j+=i)&#123;            prime[j] = 0;        &#125;    &#125;&#125;void dfs(int id,int val)&#123;    ans[id] = val;    if(id&gt;=n-1)&#123;        if(!prime[val+1])return;        for(int i=0;i&lt;n;i++)cout&lt;&lt;ans[i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;        return;    &#125;    for(int i=2;i&lt;=n;i++)&#123;        if(visit[i])continue;        if(prime[val+i]==0)continue;        visit[i] = 1;        dfs(id+1,i);        visit[i] = 0;    &#125;&#125;signed main()&#123;    Orz;    init();    while(cin&gt;&gt;n)&#123;        cnt+=1;        memset(ans,0,sizeof(ans));        memset(visit,0,sizeof(visit));        cout&lt;&lt;&quot;Case &quot;&lt;&lt;cnt&lt;&lt;&quot;:&quot;&lt;&lt;endl;        dfs(0,1);    &#125;&#125;\na142. ç„¡åˆ»åº¦å®¹å™¨å€’æ°´å•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define double long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int x,y,z;int a[N][N];bool visit[N][N];void solve()&#123;    cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;    memset(a,0x3f3f3f3f,sizeof(a));memset(visit,0,sizeof(visit));    a[0][0] = 0;    queue&lt;pii&gt;que;    que.push(&#123;0,0&#125;);    visit[0][0] = 1;        bool f = 0;    while(!que.empty())&#123;        pii cur = que.front();        que.pop();        int mmin = cur.x,mmax = cur.y;        int dx[6] = &#123;max(0,mmax-(y-mmin)),min(mmax+mmin,x),x,mmin,0,mmin&#125;;        int dy[6] = &#123;min(y,mmax+mmin),max(0,mmax-(x-mmin)),mmax,y,mmax,0&#125;;                for(int i=0;i&lt;6;i++)&#123;            int nx = dx[i],ny = dy[i];            if(nx==z||ny==z)&#123;                f = 1;                cout&lt;&lt;a[mmin][mmax]+1&lt;&lt;endl;                return;            &#125;            if(visit[nx][ny])continue;            a[nx][ny] = a[mmin][mmax]+1;            visit[nx][ny] = 1;            que.push(&#123;nx,ny&#125;);        &#125;    &#125;    if(!f)cout&lt;&lt;-1&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\na165. æœ€è¿‘é»å°å•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 10002#define INF 5e18#define FOR(i,n) for(int i=0;i&lt;n;i++)#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;#define pdd pair&lt;double,double&gt;using namespace std;int n;vector&lt;pii&gt; p,temp;void init()&#123;    cout&lt;&lt;fixed&lt;&lt;setprecision(4);    temp.clear();    p.assign(n,&#123;0,0&#125;);&#125;bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125;double dis(pii a,pii b)&#123;    double x1 = a.x-b.x,y1 = a.y-b.y;    return sqrt(x1 * x1 + y1 * y1);&#125;//å€é–“[l,r]double solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l+r)/2,mid_pos = p[mid].x;;    double ans = min(solve(l,mid),solve(mid+1,r));        temp.assign((r-l+1),&#123;0,0&#125;);    merge(        p.begin() + l, p.begin() + mid + 1,        p.begin() + mid + 1, p.begin() + r + 1,        temp.begin(), cmp    );    rep(i, l, r)p[i] = temp[i-l];    temp.clear();    rep(i, l, r)&#123;        if(abs(p[i].x - mid_pos) &lt;= ans)            temp.push_back(p[i]);    &#125;    int len = temp.size();    rep(i, 0, len-1)&#123;        rep(j, i+1, len-1)&#123;            ans = min(ans, dis(temp[i],temp[j]));            if(abs(temp[i].y-temp[j].y) &gt; ans)                break;        &#125;    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        init();        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        double ans = solve(0,n-1);        if(ans &gt; 10000)cout&lt;&lt;&quot;INFINITY&quot;&lt;&lt;endl;        else cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nO. [åŸºç¤è³‡æ–™çµæ§‹ II åŠåŸºç¤æ¼”ç®—æ³• II ] å‹•æ…‹è¦åŠƒa143. é—œéµå­—æœå°‹æ¨¡æ“¬#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,num_key = 0;string key[N];vector&lt;pif&gt; ans;int com_string(string s1, string s2)&#123;    s1 = &quot;0&quot;+s1;s2 = &quot;0&quot;+s2;    int ans = 0,com[N][N];memset(com,0,sizeof(com));    int len1 = s1.size(),len2 = s2.size();    for(int i=1;i&lt;len1;i++)&#123;        for(int j=1;j&lt;len2;j++)&#123;            if(s1[i] == s2[j])&#123;                com[i][j] = com[i-1][j-1]+1;                ans = max(ans,com[i][j]);            &#125;        &#125;    &#125;    return ans;&#125;bool cmp(pif a,pif b)&#123;    if(a.y == b.y)return a.x &lt; b.x;    return a.y &gt; b.y;&#125;float max_num(string s)&#123;    float ans = 0.0;    for(int i=0;i&lt;num_key;i++)&#123;        ans = max(ans,(float)com_string(s,key[i])/key[i].size());    &#125;    return ans;&#125;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);    while(ss&gt;&gt;key[num_key++]);    cin&gt;&gt;n;cin.ignore();    while(n--)&#123;        int doc_num;        getline(cin,s);        stringstream ss2(s);        ss2&gt;&gt;doc_num;        float score = 0.0;        while(ss2 &gt;&gt; s)score += max_num(s);                score = round(score*100)/100;        ans.push_back(&#123;doc_num,score&#125;);    &#125;    sort(ans.begin(),ans.end(),cmp);    if(ans[0].y &lt;= 0)cout&lt;&lt;&quot;FALSE&quot;&lt;&lt;endl;    else for(auto i: ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;;&#125;\na144. è¾²ä½œç‰©æ¡æ”¶å•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 25#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,num[N][N],dp[N][N];void init()&#123;    memset(num,0,sizeof(num));    memset(dp,0,sizeof(dp));&#125;signed main()&#123;    init();    cin&gt;&gt;n;    rep(i,1,n)rep(j,1,n)cin&gt;&gt;num[i][j];        for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            num[i][j]+=num[i-1][j]+num[i][j-1]-num[i-1][j-1];        &#125;    &#125;    int ans = 0;        //å·¦ä¸Š(a,b)å³ä¸‹(x,y)    rep(i,1,n)rep(j,1,n)rep(a,1,i)rep(b,1,j)    ans = max(ans,num[i][j]-num[a-1][j]-num[i][b-1]+num[a-1][b-1]);        cout&lt;&lt;ans&lt;&lt;endl;&#125;\na145. æ¬å®¶è¦ç•«å•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;signed main()&#123;    string s;getline(cin,s);    stringstream ss(s);        int w[N],v[N],ind=0;    while(ss&gt;&gt;w[ind++]);    ind--;    for(int i=0;i&lt;ind;i++)cin&gt;&gt;v[i];    int c;cin&gt;&gt;c;    int dp[c+5];    memset(dp,0,sizeof(dp));    for(int i=0;i&lt;ind;i++)&#123;        for(int j=c;j&gt;=w[i];j--)&#123;            dp[j] = max(dp[j],dp[j-w[i]]+v[i]);        &#125;    &#125;    cout&lt;&lt;dp[c]&lt;&lt;endl;    &#125;\na155. é›™å­æ˜Ÿå¡”#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,dp[N][N],a[N],b[N],cnt = 0;signed main()&#123;        while(cin&gt;&gt;n&gt;&gt;m)&#123;        if(!n &amp;&amp; !m)break;        cnt+=1;        cout&lt;&lt;&quot;Twin Towers #&quot;&lt;&lt;cnt&lt;&lt;endl;        memset(dp,0,sizeof(dp));        rep(i,1,n)cin&gt;&gt;a[i];        rep(i,1,m)cin&gt;&gt;b[i];                for(int i=1;i&lt;=n;i++)&#123;            for(int j=1;j&lt;=m;j++)&#123;                if(a[i]==b[j])&#123;                    dp[i][j] = dp[i-1][j-1]+1;                &#125;                else dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            &#125;        &#125;        cout&lt;&lt;&quot;Number of Tiles : &quot;;        cout&lt;&lt;dp[n][m]&lt;&lt;endl;    &#125;&#125;\nP. [åŸºç¤è³‡æ–™çµæ§‹ II åŠåŸºç¤æ¼”ç®—æ³• II ] æ¨¹ç‹€åœ–å½¢çµæ§‹æ¼”ç®—æ³•a136. å…ƒä»¶æ¸¬è©¦æ’ç¨‹å•é¡Œ#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 30#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,ans[N];;bool edge[N][N],is_root[N];bool is_front(int u, int v)&#123;    if(edge[u][v])return true;    for(int i=0;i&lt;n;i++)&#123;        if(edge[u][i] &amp;&amp; is_front(i,v))            return true;    &#125;    return false;&#125;bool togological()&#123;    int deg[N],sum = 0,ind = 0;    memset(deg,0,sizeof(deg));    rep(i,0,n-1)&#123;        rep(j,0,n-1)&#123;            if(edge[i][j])deg[j] += 1;        &#125;    &#125;    queue&lt;int&gt; que;    rep(i,0,n-1)if(deg[i]==0)&#123;        if(sum == 1)return false;        sum += 1;        que.push(i);    &#125;    while(!que.empty())&#123;        int cur = que.front();sum = 0;        ans[ind++] = cur;        que.pop();        for(int i=0;i&lt;n;i++)&#123;            if(edge[cur][i])&#123;                deg[i]--;                if(deg[i] == 0)&#123;                    if(sum == 1)return false;                    sum += 1;                    que.push(i);                &#125;            &#125;        &#125;    &#125;    if(ind &lt; n)return false;    return true;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    bool flag = 1;    memset(edge,0,sizeof(edge));    fill(is_root,is_root+N,1);    for(int i=1;i&lt;=m;i++)&#123;        char a,b;cin&gt;&gt;a&gt;&gt;b;        int from = a-&#x27;A&#x27;,to = b-&#x27;A&#x27;;        is_root[to] = 0;        edge[from][to] = 1;        if(is_front(to,from))&#123;            flag = 0;            cout&lt;&lt;&quot;Order conflict after getting pair &quot;&lt;&lt;i&lt;&lt;endl;            break;        &#125;        else if(togological())&#123;            flag = 0;            cout&lt;&lt;&quot;Determine the testing sequence after getting pair &quot;&lt;&lt;i&lt;&lt;&quot; : &quot;;            for(int i=0;i&lt;n;i++)cout&lt;&lt;(char)(ans[i]+&#x27;A&#x27;);            cout&lt;&lt;endl;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;No answer&quot;&lt;&lt;endl;&#125;\na137. å‹‡è€…å†’éšª#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,0,sizeof(mp));    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return 0;            &#125;            if(mp[nx][ny] == 0)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;    return 0;&#125;\na138. æœ€å°èŠ±è²»çš„èˆªç©ºä¹‹æ—…#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,k,visit[20];struct Ticket&#123;    int id,cost;    vector&lt;int&gt; next_city;    //é™£åˆ—ticket[i]å­˜ä»¥iç‚ºèµ·é»&#125;;vector&lt;Ticket&gt; ticket[30];          //ticket[i] èµ·é»ç‚ºiçš„è¯ç¥¨struct node&#123;    int cost,cur_pos,visit_pos;    vector&lt;int&gt; used_ticket;    //cur_posç¾åœ¨æ‰€åœ¨ä½ç½®ã€visit_posåœ¨è¡Œç¨‹å–®ä¸Šä½ç½®&#125;;struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;    //è®“priority_queueå¯ä»¥popå‡ºæœ€å°çš„costçš„è·¯å¾‘&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        int cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;        vector&lt;int&gt; temp;        rep(j,1,num-1)&#123;            int k;cin&gt;&gt;k;            temp.push_back(k);        &#125;        ticket[s].push_back(&#123;i,cost,temp&#125;);    &#125;    cin&gt;&gt;k;    rep(i,1,k)cin&gt;&gt;visit[i];        for(auto i : ticket[visit[1]])&#123;         //è¡Œç¨‹ç¬¬ä¸€å€‹èµ·é»çš„è¯ç¥¨èµ·é»        int p = 1;        for(auto j : i.next_city)&#123;            if(p &lt; k &amp;&amp; j == visit[p+1])p++;            pq.push(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);//            cout&lt;&lt;&quot;ä¸€é–‹å§‹è¯ç¥¨ï¼š&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        &#125;    &#125;    while(!pq.empty())&#123;        node cur = pq.top();        pq.pop();        if(cur.visit_pos == k)&#123;            cout&lt;&lt;&quot;Cost = &quot;&lt;&lt;cur.cost&lt;&lt;&quot;, Tickets used: &quot;                &lt;&lt;cur.used_ticket[0];            for(int i=1;i&lt;cur.used_ticket.size();i++)                cout&lt;&lt;&quot;, &quot;&lt;&lt;cur.used_ticket[i];            cout&lt;&lt;endl;            break;        &#125;        for(auto i : ticket[cur.cur_pos])&#123;            vector&lt;int&gt; vec(cur.used_ticket);            vec.push_back(i.id);                //å°‡ç¾åœ¨ä½¿ç”¨çš„ç¬¬iè¯ç¥¨æ¨å…¥            int p = cur.visit_pos;            for(auto j : i.next_city)&#123;                if(p &lt; k &amp;&amp; j == visit[p+1])p++;                pq.push(&#123;cur.cost+i.cost,j,p,vec&#125;);            &#125;        &#125;    &#125;&#125;\nQ. [é¡Œç›®è§£æ] APCS ç¨‹å¼é–‹ç™¼ç’°å¢ƒã€é¡Œç›®è§£æa140. ç‰©å“å †ç–Š#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii p[N];bool cmp(pii a, pii b)&#123;    return a.x*b.y &lt; a.y*b.x;    //p[1~n]è®Šæˆå¾ä¸Šåˆ°ä¸‹&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,0,n-1)cin&gt;&gt;p[i].x;    rep(i,0,n-1)cin&gt;&gt;p[i].y;    sort(p,p+n,cmp);    int weight = 0,ans = 0;    for(int i=0;i&lt;n-1;i++)&#123;        weight += p[i].x;        ans += weight*p[i+1].y;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\na160. ç·šæ®µè¦†è“‹é•·åº¦#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n;pii a[N];signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;        sort(a,a+n);                int sum = a[0].y - a[0].x,R = a[0].y;        for(int i=1;i&lt;n;i++)&#123;            if(a[i].y &gt; R)&#123;                sum += (a[i].y-a[i].x)-(R-a[i].x)*((R-a[i].x)&gt;0);                R = a[i].y;            &#125;        &#125;        cout&lt;&lt;sum&lt;&lt;endl;    &#125;&#125;\n","categories":["APCSæª¢å®š"],"tags":["APCS","ç«¶è³½ç­†è¨˜"]},{"title":"ä¼¯ç‰¹è˜­æ‚–è«–ï¼ˆBertrand Paradoxï¼‰","url":"/bertrand/","content":"ç°¡ä»‹Bertrand Paradoxæ˜¯Bertrandä»–åœ¨ä»–çš„ä¸€æœ¬æ›¸ä¸­æåˆ°é—œæ–¼æ©Ÿç‡è«–çš„æ‚–è«–ï¼Œä»–ä»¥ã€Œåœ¨åœ“ä¸Šç”¢ç”Ÿéš¨æ©Ÿçš„å¼¦ã€ä¾†èªªæ˜ç•¶æ²’æœ‰åš´è¬¹çš„å®šç¾©å¥½ç”¢ç”Ÿéš¨æ©Ÿçš„ã€Œæ–¹æ³•ã€ï¼Œå°±æœ‰å¯èƒ½ç”¢ç”Ÿè¨±å¤šåˆç†ä½†çµæœå»å®Œå…¨ä¸åŒçš„ç­”æ¡ˆã€‚\næ‚–è«–å¦‚ä¸‹ï¼šçµ¦å®šä¸€å€‹å¹³é¢ä¸Šçš„åœ“ï¼Œå…§æ¥ä¸€å€‹é‚Šé•·ç‚º $T$ çš„æ­£ä¸‰è§’å½¢ã€‚æ¥è‘—éš¨æ©Ÿç”¢ç”Ÿåœ’å…§çš„ä¸€æ¢å¼¦ï¼Œæƒ³å•é€™æ¢å¼¦çš„é•·åº¦å¤§æ–¼ $T$ çš„æ©Ÿç‡æœ‰å¤šå¤§ï¼Ÿä»¥ä¸‹ä¸‰å€‹æ–¹æ³•æœƒåˆ†åˆ¥ç”¢ç”Ÿå‡ºä¸‰å€‹ä¸åŒçš„çµæœï¼Œå½±ç‰‡ã€åœ–ç‰‡éƒ¨åˆ†æ˜¯ç”¨manimä»¥åŠmatplotlibç¹ªè£½è€Œæˆçš„ã€‚\nç”¢ç”Ÿå¼¦çš„ä¸åŒæ–¹æ³•æ–¹æ³•1ï¼šéš¨æ©Ÿç«¯é»é€™æ˜¯æœ€ç›´è¦ºç”¢ç”Ÿå¼¦çš„æ–¹æ³•ï¼Œéš¨æ©Ÿé¸æ“‡åœ“ä¸Šçš„å…©å€‹é»é€£æˆä¸€æ¢å¼¦ã€‚å¦‚ä¸‹åœ–ï¼Œä¸å¤±ä¸€èˆ¬æ€§å‡è¨­å…¶ä¸­ä¸€å€‹é»æ˜¯$A$ï¼Œå‰‡å¦å¤–ä¸€å€‹é»å¯èƒ½è½åœ¨$A1,A2,A3$çš„å¼¦ä¸Šã€‚è‹¥è¦ç”¢ç”Ÿå¤§æ–¼ä¸‰è§’å½¢é‚Šé•·çš„å¼¦ï¼Œå‰‡å¿…é ˆè½åœ¨$A3$ä¸Šï¼Œå…¶æ©Ÿç‡ç‚º$\\frac{1}{3}$ã€‚\n\nä»¥ä¸‹å½±ç‰‡ç‚ºæ¨¡æ“¬éš¨æ©Ÿç”¢ç”Ÿå¼¦çš„ç‹€æ³ï¼Œå¼¦é•·åº¦å¤§æ–¼ $T$ æ©Ÿç‡ç´„ç‚º$0.33$å·¦å³ã€‚\n\n\n\nå°‡ç”¢ç”Ÿçš„å¼¦æç¹ªå‡ºä¾†å¦‚ä¸‹åœ–ï¼š\næ–¹æ³•2ï¼šéš¨æ©ŸåŠå¾‘æ­¤ä½œæ³•æ˜¯éš¨æ©Ÿç”¢ç”Ÿä¸€æ¢åŠå¾‘ï¼Œå‡è¨­å…¶èˆ‡åœ“å‘¨äº¤æ–¼$A$ï¼Œæ¥è‘—éš¨æ©Ÿåœ¨åŠå¾‘ä¸Šæ‰¾ä¸€é»ï¼Œåšå‡ºéæ­¤é»ä¸”èˆ‡åŠå¾‘å‚ç›´çš„å¼¦ã€‚æˆ‘å€‘å¯ä»¥ç™¼ç¾ï¼Œç•¶é»çš„ä½ç½®ä¸‹åœ–ç¶ è‰²ç·šæ®µä¸Šæ™‚ï¼Œå¼¦çš„é•·åº¦å¤§æ–¼ $T$ï¼Œåœ¨é»ƒè‰²ç·šæ®µæ™‚å‰‡å°æ–¼ $T$ã€‚\né»ƒè‰²èˆ‡ç¶ è‰²ç·šæ®µé•·åº¦ç›¸ç­‰ï¼Œå› æ­¤ç”¢ç”Ÿå¤§æ–¼ $T$ çš„å¼¦é•·æ©Ÿç‡ç‚º$\\frac{1}{2}$ï¼Œç´„è«$0.5$å·¦å³ã€‚\n\n\n@@ æ–¹æ³•3ï¼šéš¨æ©Ÿä¸­é»\nå°‡ç”¢ç”Ÿçš„å¼¦æç¹ªå‡ºä¾†å¦‚ä¸‹åœ–ï¼š\n\næ–¹æ³•3ï¼šéš¨æ©Ÿä¸­é»æ­¤ä½œæ³•æ˜¯åœ¨åœ’ä¸­éš¨æ©Ÿç”¢ç”Ÿä¸€å€‹é»ï¼Œä»¥æ­¤é»ç‚ºä¸­é»ç”¢ç”Ÿä¸€æ¢å¼¦ã€‚ä»¥ä¸‹åœ–ä¾†èªªï¼Œå‡è¨­æ­¤é»åœ¨å°åœ“å…§ï¼Œå‰‡å¼¦é•·æœƒå¤§æ–¼ $T$ï¼Œåœ¨å°åœ“å¤–å‰‡å°æ–¼ $T$ï¼Œè‹¥æ°å¥½è½åœ¨å°åœ“åœ“é€±ä¸Šï¼Œå‰‡å¼¦é•·ç­‰æ–¼ $T$ã€‚\nç”±æ–¼å°åœ“çš„åŠå¾‘æ˜¯å¤§åœ“åŠå¾‘çš„ä¸€åŠï¼ˆå¯ä»¥å‡è¨­å¤§åœ“åŠå¾‘$R$ï¼Œ$T = \\sqrt3R$ï¼Œå°åœ“åœ“å¿ƒè½åœ¨ä¸‰è§’å½¢é‡å¿ƒä¸Šè­‰æ˜ï¼‰ï¼Œå°åœ“å¤§åœ“é¢ç©æ¯”ç‚º$1:4$ï¼Œå› æ­¤é•·åº¦å¤§æ–¼ $T$ çš„å¼¦æ©Ÿç‡ç‚º$\\frac{1}{4}$ã€‚\n\né€éæ¨¡æ“¬å¾—åˆ°æ©Ÿç‡ç´„ç‚º$0.25$å·¦å³ï¼Œç•¶æ¨£æœ¬æ•¸è¶Šé«˜ï¼Œæ©Ÿç‡æœƒè¶Šç²¾æº–ã€‚\n\n\nå°‡ç”¢ç”Ÿçš„å¼¦æç¹ªå‡ºä¾†å¦‚ä¸‹åœ–ï¼Œè·Ÿå‰é¢å…©å€‹æ¯”èµ·ä¾†ï¼Œé€šéåœ“ä¸­å¿ƒé™„è¿‘çš„å¼¦æ•¸é‡è¼ƒå°‘ï¼š\n\nä¸‰è€…æ¯”è¼ƒåˆ©ç”¨matplotlibç•«å‡ºæ¯æ¢å¼¦çš„ä¸­é»ä¸¦ç•™ä¸‹è»Œè·¡ï¼Œå¯ä»¥å¾—åˆ°ä¸‹é¢çš„åœ–å½¢ï¼Œéš¨æ©Ÿç«¯é»èˆ‡éš¨æ©ŸåŠå¾‘ç”¢ç”Ÿçš„åœ–å½¢æ¯”è¼ƒç›¸è¿‘ï¼Œé›†ä¸­åœ¨åœ“çš„ä¸­å¿ƒï¼Œè€Œéš¨æ©Ÿä¸­é»çš„åˆ†ä½ˆå‰‡ååˆ†å¹³å‡ã€‚\næ–¹æ³•1ï¼šéš¨æ©Ÿç«¯é»\næ–¹æ³•2ï¼šéš¨æ©ŸåŠå¾‘\næ–¹æ³•3ï¼šéš¨æ©Ÿä¸­é»\nåœ¨æ²’æœ‰çµ¦å®šé¡å¤–è³‡è¨Šçš„æƒ…æ³ä¸‹ï¼Œä¸¦æ²’æœ‰å“ªä¸€ç¨®æ–¹æ³•æ‰æ˜¯æ‰€è¬‚æ­£ç¢ºè§£ç­”ï¼Œä¸å­˜åœ¨å”¯ä¸€çš„é¸æ“‡æ–¹æ³•ï¼Œé‚£éº¼ä¹Ÿå°±ä¸å­˜åœ¨ä¸€å€‹å”¯ä¸€çš„è§£ç­”ã€‚\nåƒè€ƒè³‡æ–™æ­¤ç¯‡æ–‡ç« çš„ç›®çš„åœ¨ç†Ÿæ‚‰manimè£½ä½œå‹•ç•«ä»¥åŠmatplotlibçš„æ“ä½œï¼Œå…§å®¹çš†ç‚ºå·²çŸ¥å–”ã€‚\nGithub: Code and Photos\nBertrandâ€™s Paradox (with 3blue1brown) - Numberphile\nWiki: Bertrand paradox)\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","æ©Ÿç‡"]},{"title":"ç”Ÿæ—¥å•é¡Œï¼ˆBirthday Paradoxï¼‰","url":"/birthday/","content":"æœ‰åŒå­¸å•æˆ‘ç”Ÿæ—¥å•é¡Œçš„æ©Ÿç‡æ„Ÿè¦ºè »å¥½ç©çš„ï¼Œæ±ºå®šå¥½å¥½ç ”ç©¶ä¸€ç•ªã€‚ç”Ÿæ—¥æ‚–è«–å…¶å¯¦ä¸æ˜¯ä¸€å€‹æ‚–è«–ï¼Œåªæ˜¯æœ‰é»é•èƒŒç›´è¦ºè€Œå·²ï¼Œä¸¦éæ•¸å­¸ä¸­å®šç¾©çš„æ‚–è«–ï¼é€™ä¸€ç¯‡æœƒç”¨è’™åœ°å¡ç¾…æ¨¡æ“¬ä¾†é€²è¡Œèˆ‡ç†è«–çš„æ¯”è¼ƒ\nå•é¡Œæ•˜è¿°é¡Œç›®ï¼šä¸€å€‹æˆ¿é–“è¦å¤šå°‘äººï¼Œå‰‡å…©å€‹äººçš„ç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡è¦å¤§æ–¼50%ï¼Ÿ\nç­”æ¡ˆæ˜¯23äººã€‚å¦‚æœæƒ³è¦çœ‹1åˆ°100äººæœ‰åŒä¸€å¤©çš„æ©Ÿç‡å¯ä»¥é»é€™è£¡ï¼\næ©Ÿç‡èˆ‡äººæ•¸çš„é—œä¿‚å…©ç¨®ç†è§£æ–¹å¼å°æ–¼ç”Ÿæ—¥å•é¡Œå¯èƒ½æœƒæœ‰å…©ç¨®ç†è§£æ–¹å¼ï¼š\n\né¡Œæ„ï¼šã€Œ23äººä¹‹ä¸­å…©å…©ä¹‹é–“å­˜åœ¨ç”Ÿæ—¥ç›¸åŒã€ å°æ–¼åŸæœ¬é¡Œç›®è¦é—¡è¿°çš„æ„ç¾©å¯ä»¥åˆ—å‡ºä»¥ä¸‹æ•¸å­¸å¼ï¼š\\begin{split}p(n)&=1-p'(n) \\\\&= 1-(1\\times\\frac{364}{365}\\times\\frac{363}{365}\\times\\cdots\\frac{365-(n-1)}{365})\\end{split}\néŒ¯èª¤ç†è§£ï¼šã€Œå…¶ä»–22äººèˆ‡ä½ çš„ç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ã€ é€™æ¨£çš„ç†è§£æœƒé€ æˆç®—å‡ºä¾†çš„æ©Ÿç‡å¤§ç‚ºæ¸›å°‘ï¼ˆç”¨å…¨éƒ¨æ‰£æ‰çš†ä¸ç›¸åŒï¼‰ï¼šq(n) = 1-(\\frac{364}{365})^n\n\næœ‰äº†ä»¥ä¸Šå…©å€‹é—œä¿‚å¼ï¼Œå°±å¯ä»¥é€²è¡Œåœ–è¡¨çš„ç¹ªè£½ã€‚xè»¸è¡¨ç¤ºäººæ•¸ï¼Œyè»¸è¡¨ç¤ºæ©Ÿç‡ï¼Œå¯ä»¥çœ‹å‡ºä¾†å…©ç¨®ç†è§£æ–¹å¼æœƒé€ æˆæ©Ÿç‡æœ‰å¾ˆå¤§çš„å·®åˆ¥ï¼\nä¸Šåœ–ç¹ªè£½ç¨‹å¼ç¢¼ï¼š\nimport numpy as npimport matplotlib.pyplot as pltplt.title(&quot;Possibility to Number of people&quot;, fontsize=20) #åœ–è¡¨æ¨™é¡Œplt.xlabel(&quot;Number of people&quot;, fontsize=16) #xè»¸æ¨™é¡Œplt.ylabel(&quot;Possibility&quot;, fontsize=16) #yè»¸æ¨™é¡Œd = 1p = 1x = []y1 = []y2 = []for i in range(1,365):    y1.append(1-p)    p = p*d    d = d-(1/365)for i in range(365,400):    y1.append(1)d2 = 364/365for i in range(1,400):    x.append(i)    y2.append(1-d2)    d2 = d2*(364/365)plt.plot(x,y1,&#x27;red&#x27;,label=&#x27;p(n)&#x27;)plt.plot(x,y2,&#x27;blue&#x27;,label=&#x27;q(n)&#x27;)plt.legend(loc = &#x27;upper left&#x27;)plt.show() #é¡¯ç¤ºç¹ªè£½çš„åœ–å½¢\né€™å¼µåœ–è¡¨é‚„å¯ä»¥å‘Šè¨´æˆ‘å€‘ï¼Œä»»å…©å€‹äººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡å¾ˆé«˜ï¼Œä½†ç›¸å°çš„ï¼Œå³ä½¿æœ‰400å€‹äººï¼Œè¦æœ‰äººè·Ÿä½ çš„ç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡æ¯”6æˆé«˜ä¸€é»è€Œå·²ï¼Œå‘Šè¨´æˆ‘å€‘ã€Œå…¨éƒ¨çš„æ—¥æœŸè‡³å°‘æœ‰ä¸€äººç”Ÿæ—¥ã€çš„æ©Ÿç‡å…¶å¯¦ä¸é«˜ï¼\nå…¶ä»–äººèˆ‡ä½ çš„ç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡å¦‚æœåœ¨çœ‹æ›´ä»”ç´°ä¸€é»ï¼Œå°æ–¼ã€Œå…¶ä»–äººèˆ‡ä½ çš„ç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ã€ä½œåœ–æœƒå‘ˆç¾ä¸‹æ–¹çš„åœ–å½¢\nå› ç‚ºç”Ÿæ—¥æ˜¯éš¨æ©Ÿçš„ï¼Œå› æ­¤åœ¨å¾ˆå¤§é‡æ•¸æ“šæ¸¬è©¦ä¸‹ï¼Œæˆ‘å€‘å¯ä»¥æœŸæœ›å…±æœ‰365äººçš„æ™‚å€™æœƒå‡ºç¾ç¬¬ä¸€å€‹èˆ‡è‡ªå·±ç”Ÿæ—¥ç›¸åŒæ—¥æœŸçš„äººï¼å¯¦éš›ä»¥äº‚æ•¸æ¨¡æ“¬ï¼Œæ‰€å¾—åˆ°çš„æœŸæœ›å€¼æ¬¡æ•¸èˆ‡ç†è«–æ˜¯ç›¸ç¬¦çš„ï¼\n#include &lt;bits/stdc++.h&gt;using namespace std;bool birthday[400];int main()&#123;    srand((unsigned)time(NULL));    int sum = 0,t = 5000000,times = t;    while(times--)&#123;        memset(birthday,0,sizeof(birthday));        int target = rand()%365,ind=0;        for(int i=0;;i++)&#123;            ind = rand()%365;            if(target==ind)&#123;                sum+=i+1;                break;            &#125;            else birthday[ind] = 1;        &#125;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(4);    cout&lt;&lt;&quot;å¹³å‡æ–¼ç¬¬ï¼š&quot;&lt;&lt;(double)sum/t&lt;&lt;&quot;æ¬¡&quot;&lt;&lt;endl&lt;&lt;&quot;æœƒå‡ºç¾ç¬¬ä¸€å€‹èˆ‡è‡ªå·±ç”Ÿæ—¥ç›¸åŒçš„äºº&quot;&lt;&lt;endl;&#125;\nè‡³å°‘kå€‹äººç”Ÿæ—¥ç›¸åŒæ©Ÿç‡å°æ–¼è‡³å°‘käººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡è¦å¤§æ–¼50%ï¼Œéœ€è¦çš„äººæ•¸å¦‚ä¸‹è¡¨ï¼šç”¨ç¨‹å¼é©—è­‰çœ‹çœ‹ï¼š\n\n\n\n\nk\nå…±Näºº\næ©Ÿç‡\n\n\n\n\n2\n23\n0.506949\n\n\n3\n88\n0.511169\n\n\n4\n187\n0.502883\n\n\n5\n313\n0.501057\n\n\n6\n460\n0.502686\n\n\n7\n623\n0.503298\n\n\n8\n798\n0.500304\n\n\n9\n985\n0.501191\n\n\n10\n1181\n0.500178\n\n\n\n\næ ¹æ“šé€™ä¸€ç¯‡æä¾›çš„å…¬å¼ï¼Œåœ¨$kâ‰¤20$çš„æƒ…æ³ä¸‹$n\\cong47(k-1.5)^{\\frac{3}{2}}$ï¼Œé€™æ˜¯é€™ç¯‡ä½œè€…æŠŠké‚„æ˜¯å¾ˆå°çš„æ™‚å€™é€²è¡Œè¿‘ä¼¼ï¼Œä½†å¯¦éš›çš„å…¬å¼æˆ‘é‚„ä¸æ˜¯å¾ˆäº†è§£:cry:\n#include &lt;bits/stdc++.h&gt;using namespace std;int birthday[400],power[1000];int main()&#123;    srand((unsigned)time(NULL));    int sum = 0,t = 10000000,times = t;    int arr[10] = &#123;23,88,187,313,460,623,798,985,1181&#125;;    for(int j=0;j&lt;9;j++)&#123;        times = t;sum = 0;        while(times--)&#123;            memset(birthday,0,sizeof(birthday));            for(int i=0;i&lt;arr[j];i++)&#123;                int ind = rand()%365;                birthday[ind]+=1;                if(birthday[ind]&gt;=j+2)&#123;                    sum+=1;                    break;                &#125;            &#125;        &#125;        cout&lt;&lt;fixed&lt;&lt;setprecision(7);        cout&lt;&lt;(double)sum/t&lt;&lt;endl;    &#125;&#125;\næ©Ÿç‡è­‰æ˜å…¬å¼æ¨è¨ç”Ÿæ—¥å•é¡Œå¯ä»¥ç†è§£æˆï¼šè‡³å°‘å…©äººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ é€™å€‹å•é¡Œï¼Œè€Œå¦å®šé€™å€‹å•é¡Œå³ç‚ºï¼šã€Œæ²’æœ‰äººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ã€ã€‚å› ç‚ºé€™å…©å€‹äº‹ä»¶çš„è¯é›†å³ç‚ºæ¨£æœ¬ç©ºé–“ï¼Œå¯ä»¥ç”¨æ‰£çš„æ–¹å¼å¾—åˆ°ç­”æ¡ˆï¼\nå°æ–¼æˆ¿é–“è£¡æœ‰näººçš„æƒ…æ³ï¼Œå®šç¾© $p(n)$ ç‚ºã€Œè‡³å°‘å…©äººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ã€ã€$pâ€™(n)$ ç‚ºã€Œæ²’æœ‰äººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ã€ï¼Œåœ¨ä¸è€ƒæ…®ç‰¹æ®Šå¼·æ³ï¼ˆé–å¹´ç­‰ï¼‰ï¼Œä¸¦å‡è¨­ç”Ÿæ—¥æœƒå¹³å‡åˆ†ä½ˆçš„ç‹€æ³ä¸‹ï¼š\n\\begin{split}p(n)&=1-p'(n) \\\\&= 1-(1\\times\\frac{364}{365}\\times\\frac{363}{365}\\times\\cdots\\frac{365-(n-1)}{365})\\\\\\\\&=1-\\frac{365!}{365^n\\cdot(365-n)!}\\end{split}ç°¡å–®è§£é‡‹ä¸€ä¸‹ï¼Œå°æ–¼æ¯ä¸€å€‹åŠ å…¥æˆ¿é–“çš„äººéƒ½æœ‰$365$ç¨®å¯èƒ½ï¼Œå› æ­¤åˆ†æ¯çš†ç‚º$365$ï¼›å°æ–¼ç¬¬ $i$ å€‹åŠ å…¥çš„äººè¦é¿é–‹å‰ $i-1$ å€‹äººçš„ç”Ÿæ—¥ï¼Œå› æ­¤åˆ†å­ç‚º$365-(i-1)$ã€‚ç¶“éæ•´ç†å¯ä»¥å¾—åˆ°é€™å€‹æœ‰éšä¹˜åˆæœ‰æ¬¡æ–¹çš„å¾ˆé›£çœ‹çš„ä¸€å€‹å…¬å¼ï¼\né€™æ™‚å€™æˆ‘å€‘å¯ä»¥å¼•å…¥æ³°å‹’å…¬å¼ï¼š\n\\begin{split}e^x&=\\sum_{k=0}^\\infty\\frac{x^k}{k!}=1+\\frac{x^1}{1!}+\\frac{x^2}{2!}+\\frac{x^3}{3!}\\cdots\\end{split}ç‚ºä»€éº¼è¦å¼•å…¥é€™å€‹å…¬å¼ï¼Ÿæ˜¯å› ç‚ºæˆ‘å€‘æƒ³è¦æ§‹é€ å‡ºä¸Šé¢æ©Ÿç‡è¨ˆç®—ä¸­çš„æ¯ä¸€é … $1-\\frac{x}{365}$ ï¼Œå› ç‚ºæ³°å‹’å…¬å¼æ˜¯ä¸€å€‹ç„¡çª®ç´šæ•¸ï¼Œæˆ‘å€‘å¯ä»¥é©åº¦çš„åšä¸€äº›å–æ¨ï¼Œä¾‹å¦‚åªå–ç¬¬ä¸€é …èˆ‡ç¬¬äºŒé …ï¼ˆåœ¨ä¸‹å»éƒ½æ˜¯å°æ•¸é»4,5ä½ä»¥ä¸Šäº†)ï¼Œå¾—åˆ°ä»¥ä¸‹ï¼š\ne^x\\cong1+x\\to e^{-\\frac{x}{365}}\\cong1-\\frac{x}{365}æ¥è‘—å°±å¯ä»¥æŠŠæ¯ä¸€é …æ›¿æ›æˆå¤šé …å¼çš„å‹æ…‹ï¼š\n\\begin{split}p'(n)&=1\\times\\frac{364}{365}\\times\\frac{363}{365}\\times\\cdots\\frac{365-n+1}{365}\\\\&\\cong1\\times e^{-\\frac{1}{365}}\\times e^{-\\frac{2}{365}}\\times\\cdots\\times e^{-\\frac{n-1}{365}}\\\\&=e^{-\\frac{1+2+\\cdots+(n-1)}{365}}\\\\&=e^{-\\frac{n(n-1)/2}{365}}\\\\&=e^{-\\frac{n^2-n}{730}}\\end{split}æ¥è‘—å°±å¯ä»¥ç®—å‡ºæ­£ç¢ºçš„æ©Ÿç‡äº†ï¼\n\\begin{split}p(n) &= 1-p'(n)\\\\&\\cong1-e^{-\\frac{n^2-n}{730}}\\end{split}å¯¦éš›æ©Ÿç‡æˆ‘åˆ©ç”¨ç¨‹å¼å¯¦éš›é‹ç®—æ±‚å‡ºæ©Ÿç‡ï¼Œä¸¦è·Ÿå…¬å¼è§£åšæ¯”è¼ƒå¦‚ä¸‹ï¼šç™¼ç¾åˆ°èª¤å·®æœƒéš¨è‘—äººæ•¸å¢åŠ è€Œæœ‰è®Šå¤§çš„è¶¨å‹¢ï¼Œä¸ééƒ½æ˜¯åœ¨å°æ•¸é»å¾Œä¸‰ä½çš„äº‹æƒ…ï¼Œèª¤å·®ä¸åˆ°1%ï¼Œæ‰€ä»¥å…¬å¼è§£å…¶å¯¦æ˜¯å¯ä»¥ç”¨çš„ï¼å…¶å¯¦å¯ä»¥è§€å¯Ÿåˆ°ä¸€å€‹ç¾è±¡ï¼Œå°æ–¼$pâ€™(n)$çš„ç†è«–è§£éƒ½æœƒæ¯”å¯¦éš›å€¼é«˜ï¼Œå› ç‚ºå¤šåŠ äº†å¹¾é …è¢«æˆ‘å€‘çœç•¥æ‰çš„æ•¸å­—ï¼Œå› æ­¤è¨ˆç®—å‡ºä¾†çš„å…¬å¼è§£æœƒæ¯”å¯¦éš›æ©Ÿç‡ä½ä¸€äº›ï¼\nç”Ÿæ—¥æ”»æ“Šç”Ÿæ—¥æ”»æ“Šå°±æ˜¯åˆ©ç”¨ç”Ÿæ—¥å•é¡Œçš„ç‰¹æ€§åœ¨ $\\sqrt{H}$ çš„æ™‚é–“æš´åŠ›ç ´è§£æ‰¾å‡ºç¢°æ’ã€‚Googleç ´è§£SHA1å¯¦ç¾ç¢°æ’æ”»æ“Šï¼Œå¦‚æœæœ‰äººå¯ä»¥è®“å…©å€‹ä¸åŒçš„æª”æ¡ˆå¾—å‡ºç›¸åŒé›œæ¹Šå€¼ï¼Œè®“æ”»æ“Šè€…å¯èƒ½å·å·æŠŠæƒ¡æ„çš„ç¨‹å¼ç¢¼æ”¾é€²æª”æ¡ˆï¼Œä½†å¾—å‡ºä¾†çš„é›œæ¹Šå€¼è·ŸåŸæœ¬çš„æª”æ¡ˆä¸€æ¨£ï¼Œä½¿äººåœ¨æ²’æœ‰é˜²å‚™çš„æƒ…æ³ä¸‹èª¤ä»¥ç‚ºå±éšªæª”æ¡ˆå®‰å…¨ï¼Œé€™å¯ä»¥é”åˆ°ç”Ÿæ—¥æ”»æ“Šï¼ˆä¹Ÿå°±æ˜¯æ‰¾åˆ°ç¢°æ’ï¼‰\né›œæ¹Šæ¼”ç®—æ³•æœ€è¿‘æœ‰å­¸é›œæ¹Šç›¸é—œæ±è¥¿ï¼Œé‚£å‰›å¥½ç”Ÿæ—¥å•é¡Œå…¶å¯¦è·Ÿé›œæ¹Šå¾ˆæœ‰é—œä¿‚ï¼Œå› ç‚ºç”Ÿæ—¥å¯ä»¥è¢«ç•¶ä½œé›œé›œæ¹Šç©ºé–“å¤§å°ï¼Œç©ºé–“è¶Šå¤§é›–ç„¶æ¶ˆè€—è¨˜æ†¶é«”è¼ƒå¤§ä½†ç™¼ç”Ÿç¢°æ’çš„æ©Ÿæœƒæœƒè¶Šå°ã€‚æ›ä½œæ˜¯é›œæ¹Šæ¼”ç®—æ³•ä¸­ï¼Œæˆ‘å€‘æƒ³è¦è¨è«–çš„å°±æ˜¯é–‹çš„ç©ºé–“å¤§å°èˆ‡ç™¼ç”Ÿç¢°æ’çš„å˜—è©¦æ¬¡æ•¸çš„é—œä¿‚ã€‚\né¦–å…ˆè¨ˆç®—ç”Ÿæ—¥å•é¡Œäººæ•¸çš„æœŸæœ›å€¼ï¼Œä¹Ÿå°±æ˜¯åœ¨åŠ å…¥ç¬¬å¹¾å€‹äººä¹‹å¾Œï¼Œæœƒç™¼ç”Ÿæœ‰å…©äººç”Ÿæ—¥åŒä¸€å¤©çš„æƒ…æ³ï¼Œä»¥ä¸‹ç‚ºæ¨¡æ“¬çš„æƒ…å½¢ï¼šé€éå…¬å¼çš„è¨ˆç®—ï¼Œå¯ä»¥å¾—åˆ°ä¸åŒäººæ•¸å°æ‡‰åˆ°çš„æ©Ÿç‡ï¼Œå‡è¨­å…±iäººçš„æƒ…æ³ä¸‹æ©Ÿç‡ç‚ºf(i)ï¼Œå‰‡f(i)-f(i-1)ç‚ºåŠ å…¥ç¬¬iäººæ™‚æ°å¥½æœ‰äººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ï¼Œå°±å¯ä»¥æ ¹æ“šæœŸæœ›å€¼çš„å…¬å¼ç®—å‡ºæœŸæœ›åœ¨å…±æœ‰å¹¾äººæ™‚ç™¼ç”Ÿç¢°æ’ã€‚ä»¥ä¸‹æ˜¯è¨ˆç®—çµæœï¼šå…©è€…çš„èª¤å·®æ¥µå°ï¼Œå¯ä»¥æ¨è«–å‡ºåœ¨å¹³å‡ç´„åœ¨åŠ å…¥ç¬¬24.617å€‹äººçš„æ™‚å€™æœƒç™¼ç”Ÿç¢°æ’ï¼\næˆ‘å€‘å·²ç¶“è¨ˆç®—å‡ºå°æ–¼näººçš„æƒ…æ³ä¸‹ä»»å…©äººç”Ÿæ—¥ç›¸åŒçš„æ©Ÿç‡ï¼Œé€™æ™‚å€™å¯ä»¥æ¨å»£åˆ°ä¸åªæ˜¯365å¤©ï¼Œä¹Ÿå°±ä»£è¡¨åœ¨é›œæ¹Šç©ºé–“å¤§å°ç‚ºdçš„æ™‚å€™ç™¼ç”Ÿç¢°æ’çš„æ©Ÿç‡å¦‚ä¸‹ï¼š\n\\begin{split}p(n) &= 1-p'(n)\\\\p(n,d)&\\cong1-e^{-\\frac{n^2-n}{2d}}\\end{split}å› æ­¤æˆ‘å¯«äº†ä¸€å€‹å¯¦éš›æ¨¡æ“¬çš„ç¨‹å¼è·Ÿé€™å€‹å…¬å¼æ¨¡æ“¬çš„çµæœåšæ¯”è¼ƒï¼Œæ ¹æ“šç©ºé–“å¤§å°åˆ†åˆ¥ç‚º365èˆ‡1000åšè¨è«–ï¼Œçµæœå¦‚ä¸‹ï¼š\nç”±æ¨¡æ“¬çš„çµæœå¯ä»¥çœ‹å‡ºï¼Œè‹¥ä¸€å¹´æœ‰1000å¤©ï¼ˆå‡è¨­è€Œå·²ï¼ï¼‰å‰‡åœ¨38å€‹äººçš„åœ˜é«”ä¸­ä»»å…©äººç”Ÿæ—¥åŒå¤©çš„æ©Ÿç‡å·²ç¶“è¶…é50%ï¼Œè·Ÿç›´è¦ºç›¸å·®æŒºå¤§çš„ï¼\nçµ¦å®šæ©Ÿç‡é æ¸¬æœ€å¤šæ•¸é‡åœ¨ä¸Šé¢çš„åšæ³•æ˜¯äººæ•¸è¨ˆç®—æ©Ÿç‡ï¼Œå¯ä»¥æ›ä¸€å€‹æ–¹å¼ï¼Œçµ¦å®šç¢°æ’æ©Ÿç‡æ±‚æœ€å¤šçš„äººæ•¸ç‚ºå¤šå°‘ã€‚å¯ä»¥å¾ä¸Šé¢çš„å…¬å¼ä¾†æ¨ï¼Œä»¥ä¸‹n,Håˆ†åˆ¥ä»£è¡¨æ•¸é‡èˆ‡ç©ºé–“å¤§å°ï¼š\n\\begin{split}p(n,H)&\\cong1-e^{-\\frac{n^2-n}{2H}}\\cong1-e^{-\\frac{n^2}{2H}}\\\\&\\to e^{-\\frac{n^2}{2H}}=1-p\\\\&\\to e^{\\frac{n^2}{2H}}\\frac{1}{1-p}\\\\&\\to\\frac{n^2}{2H}=\\ln\\frac{1}{1-p}\\\\&\\to n(p,H)\\cong \\sqrt{2H\\ln\\frac{1}{1-p}}\\end{split}å› ç‚ºæˆ‘å€‘æŠŠ$n^2-n$ç•¶æˆ$n^2$ï¼Œæ‰€ä»¥åœ¨å°ç¯„åœä¼°è¨ˆçš„æ™‚å€™æœƒæœ‰æ¯”è¼ƒå¤§çš„èª¤å·®ï¼Œä¸éç•¶nå¾ˆå¤§çš„æ™‚å€™ï¼Œé‡ç´šå°±æœƒæ˜¯$n^2$ï¼Œå› æ­¤å¯ä»¥å¿½ç•¥ä¸€æ¬¡æ–¹çš„$n$\né¦–æ¬¡ç¢°æ’çš„æœŸæœ›å€¼æ¬¡æ•¸åœ¨ä¸Šé¢æœ‰åšä¸€æ¬¡æœŸæœ›å€¼çš„ä¼°è¨ˆï¼Œä¸ééç¨‹è »éº»ç…©çš„ï¼Œè¦å…ˆç®—å‡ºæ¯ä¸€å€‹æ•¸é‡æ©Ÿç‡çš„å·®ï¼Œå†ä¹˜ä¸Šæ•¸é‡ä¸¦åŠ ç¸½ã€‚é€™é‚Šæœ‰ä¸€å€‹å…¬å¼æ˜¯æä¾›åœ¨ç¯„åœå¾ˆå¤§æ™‚çš„ä¸€å€‹ä¼°è¨ˆå…¬å¼ï¼š\nQ(H)\\cong\\sqrt{\\frac{\\pi}{2}H}é€™å°å‡ºä¸€å€‹é‡è¦çš„çµè«–ï¼šå°æ–¼nä½å¯†ç¢¼å…±æœ‰$2^n$ç¨®å¯èƒ½çµ„åˆï¼Œç¢ºåƒ…åƒ…éœ€è¦æœŸæœ›$2^{\\frac{n}{2}}$æ¬¡å˜—è©¦å°±å¯ä»¥é‡åˆ°ç¢°æ’ï¼ä»¥ä¸‹å˜—è©¦H=800000ç­†èˆ‡H=1500000ç­†æ•¸æ“šï¼Œæœƒæœ‰ä¸€é»èª¤å·®ï¼Œå¯èƒ½çš„åŸå› æ˜¯æ¸¬è©¦çš„æ¨£æœ¬æ•¸ä¸å¤ (100è¬æ¬¡)\n\nç¨‹å¼ç¢¼å¯¦ä½œçš„æ¦‚å¿µå°±æ˜¯é–‹ä¸€å€‹$O(n)$çš„é™£åˆ—ç´€éŒ„ï¼Œå¦‚æœé‡åˆ°ä¹‹å‰å‡ºç¾éçš„å°±è¨˜éŒ„ä¸‹ä¾†\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;bool hash_map[2000006];int main()&#123;    ios;    srand((unsigned)time(NULL));    int N,M;cin&gt;&gt;N&gt;&gt;M; //Nç­†è¼¸å…¥,ç©ºé–“å¤§å°M    int t = 1000000;    int times = t,sum = 0;    while(times--)&#123;        memset(hash_map,0,sizeof(hash_map));        for(int i=0;i&lt;N;i++)&#123;            int temp = rand()%M;            if(hash_map[temp]==0)hash_map[temp] = 1;            else&#123;                sum+=i;                break;            &#125;        &#125;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    cout&lt;&lt;&quot;å°æ–¼è¼¸å…¥ç­†æ•¸å…±æœ‰ï¼š&quot;&lt;&lt;N&lt;&lt;&quot;ã€ç©ºé–“å¤§å°ç‚ºï¼š&quot;&lt;&lt;M&lt;&lt;endl&lt;&lt;&quot;ç¬¬ä¸€æ¬¡ç™¼ç”Ÿç¢°æ’æ¬¡æ•¸å¹³å‡å€¼ç‚ºï¼š&quot;&lt;&lt;(double)sum/t&lt;&lt;endl;    cout&lt;&lt;&quot;ç†è«–é æ¸¬æ¬¡æ•¸ï¼š&quot;&lt;&lt;sqrt(M_PI_2*M)&lt;&lt;endl;    // cout&lt;&lt;&quot;ç†è«–é æ¸¬ï¼š&quot;&lt;&lt;1-exp(-(N*(N-1)/(double)(2*M)))&lt;&lt;endl;&#125;\nCherylâ€™s birthdayé€™ä¸€é¡Œè·Ÿç”Ÿæ—¥å•é¡Œæ²’å•¥é—œä¿‚ï¼Œä½†æ—¢ç„¶éƒ½æåˆ°ã€Œç”Ÿæ—¥ã€ï¼Œå°±ä¾†çœ‹ä¸€é¡Œæœ‰è¶£çš„\n\nè‰¾ä¼¯ç‰¹å’ŒæŸç´å‰›èªè­˜é›ªè‰å…’ï¼Œæƒ³è¦çŸ¥é“é›ªè‰å…’çš„ç”Ÿæ—¥ï¼Œé›ªè‰å…’åˆ—å‡ºäº†åå€‹å¯èƒ½çš„æ—¥æœŸï¼š5æœˆ15æ—¥ã€5æœˆ16æ—¥ã€5æœˆ19æ—¥ã€6æœˆ17æ—¥6æœˆ18æ—¥ã€7æœˆ14æ—¥ã€7æœˆ16æ—¥ã€8æœˆ14æ—¥8æœˆ15æ—¥ã€8æœˆ17æ—¥æ¥è‘—é›ªè‰å…’åˆ†åˆ¥å‘Šè¨´è‰¾ä¼¯ç‰¹åŠæŸç´å¥¹ç”Ÿæ—¥çš„æœˆåŠæ—¥ï¼Œä»¥ä¸‹æ˜¯è‰¾ä¼¯ç‰¹å’ŒæŸç´çš„å›æ‡‰\nè‰¾ä¼¯ç‰¹ï¼šæˆ‘ä¸çŸ¥é“é›ªè‰å…’çš„ç”Ÿæ—¥æ˜¯å“ªä¸€å¤©ï¼Œä½†æˆ‘çŸ¥é“æŸç´ä¹Ÿä¸çŸ¥é“æŸç´ï¼šä¸€é–‹å§‹æˆ‘ä¸çŸ¥é“é›ªè‰å…’çš„ç”Ÿæ—¥ï¼Œä½†ç¾åœ¨æˆ‘çŸ¥é“äº†è‰¾ä¼¯ç‰¹ï¼šé‚£æˆ‘ä¹ŸçŸ¥é“é›ªè‰å…’çš„ç”Ÿæ—¥äº†è«‹å•é›ªè‰å…’çš„ç”Ÿæ—¥æ˜¯é‚£ä¸€å¤©ï¼Ÿ\n[è¨»ï¼šè‰¾ä¼¯ç‰¹çš„ç¬¬ä¸€å¥è©±ä»–ç¢ºå®šæŸç´100%ä¸çŸ¥é“ç”Ÿæ—¥æ˜¯å“ªä¸€å¤©]\n\nè§£ç­”é»æ­¤ï¼š\n\nç¬¬ä¸€å¥è©±ä¸­ï¼ŒæŸç´è‹¥è¦çŸ¥é“æ˜ç¢ºçš„ç”Ÿæ—¥æ—¥æœŸï¼Œå”¯ä¸€çš„å¯èƒ½æ˜¯ç”Ÿæ—¥æ—¥æœŸçš„æ—¥åœ¨åå€‹å¯èƒ½æ—¥æœŸä¸­åªå‡ºç¾éä¸€æ¬¡ï¼Œä¹Ÿå°±æ˜¯18æ—¥å’Œ19æ—¥ã€‚ä½†è‰¾ä¼¯ç‰¹èªªä»–çŸ¥é“æŸç´ä¹Ÿä¸çŸ¥é“ç”Ÿæ—¥æ˜¯å“ªä¸€å¤©ï¼Œå› æ­¤å¯ä»¥å¯ä»¥æ’é™¤5æœˆå’Œ6æœˆçš„æ‰€æœ‰æ—¥æœŸï¼ˆå¦‚æœæ˜¯5æœˆæˆ–6æœˆæœ‰ä¸€å®šçš„æ©Ÿæœƒè‰¾ä¼¯ç‰¹ç„¡æ³•ç¢ºå®šæŸç´ä¸çŸ¥é“æ˜¯å“ªä¸€å¤©ï¼‰\n\næ ¹æ“šç¬¬ä¸€å¥è©±æŸç´å¯ä»¥æ¨æ¸¬æœˆä»½æ˜¯7æœˆæˆ–8æœˆï¼Œè€Œä»–å·²ç¶“çŸ¥é“ç”Ÿæ—¥æ˜¯å“ªä¸€å¤©ï¼Œè¡¨ç¤ºä»–çŸ¥é“çš„æ—¥æ˜¯åœ¨7æœˆæˆ–8æœˆä¸­åªå‡ºç¾éä¸€æ¬¡çš„æ—¥ï¼Œå› æ­¤å¯ä»¥æ’é™¤7æœˆåŠ8æœˆå¯èƒ½ç”Ÿæ—¥ä¸­éƒ½æœ‰å‡ºç¾çš„14æ—¥ï¼ŒæŸç´çŸ¥é“çš„æ—¥å¯èƒ½æ˜¯15æ—¥ã€16æ—¥æˆ–17æ—¥ã€‚\n\nç›®å‰é‚„æœ‰å¯èƒ½çš„ç”Ÿæ—¥æ˜¯7æœˆ16æ—¥ã€8æœˆ15æ—¥åŠ8æœˆ17æ—¥ï¼Œè€Œè‰¾ä¼¯ç‰¹åœ¨è½å®Œç¬¬äºŒå¥è©±å°±å¯ä»¥çŸ¥é“ç”Ÿæ—¥æ˜¯å“ªä¸€å¤©ï¼Œè¡¨ç¤ºä»–çŸ¥é“çš„æœˆä»½åœ¨7æœˆ16æ—¥ã€8æœˆ15æ—¥åŠ8æœˆ17æ—¥ä¸­åªå‡ºç¾ä¸€æ¬¡ã€‚å› æ­¤ä»–çŸ¥é“çš„æœˆä»½æ˜¯7æœˆï¼Œç”Ÿæ—¥æ˜¯7æœˆ16æ—¥ã€‚\n\n\nç­”æ¡ˆæ˜¯7æœˆ16æ—¥ã€‚\n\né€™ä¸€é¡Œè·Ÿç”Ÿæ—¥å•é¡Œå…¶å¯¦æ²’ä»€éº¼é—œä¿‚ï¼Œå°±ç•¶ä½œæ˜¯ä¸€å€‹ã€Œç”Ÿæ—¥ã€æœ‰é—œçš„æœ‰è¶£é‚è¼¯æ¨ç†çš„é¡Œç›®å§ï¼\nçµè«–æ•´ç†ä»¥ä¸Šæåˆ°çš„å…¬å¼å§\nå·²çŸ¥äººæ•¸æ¨ç®—æ©Ÿç‡\\begin{split}p(n)&=1-\\frac{365!}{365^n\\cdot(365-n)!}\\end{split}\\begin{split}p(n) \\cong1-e^{-\\frac{n^2-n}{730}}\\end{split}å·²çŸ¥æ©Ÿç‡é æ¸¬æ•¸é‡ï¼ˆä¹Ÿå°±æ˜¯äººæ•¸ï¼‰\\begin{split}n(p,H)\\cong \\sqrt{2H\\ln\\frac{1}{1-p}}\\end{split}é¦–æ¬¡ç¢°æ’çš„æœŸæœ›å€¼Q(H)\\cong\\sqrt{\\frac{\\pi}{2}H}æ²’æƒ³åˆ°ç”Ÿæ—¥å•é¡Œå¯ä»¥è¡ä¼¸å‡ºå¦‚æ­¤å¤šã€å¦‚æ­¤ç¹é›œçš„æ•¸å­¸å…¬å¼ï¼Œä¸åƒ…åƒ…æ˜¯æ•¸å­¸é ˜åŸŸï¼Œåœ¨è³‡å®‰ä¸Šé¢ä¹Ÿæ‰®æ¼”äº†ä¸€å€‹éå¸¸é‡è¦çš„è§’è‰²ï¼Œä¹Ÿå°±æ˜¯é›œæ¹Šç©ºé–“ç‚ºHçš„æ™‚ï¼Œæ ¹æ“šå…¬å¼æˆ‘å€‘å¯ä»¥æœŸæœ›åœ¨$\\sqrt{H}$çš„å˜—è©¦å…§æ‰¾åˆ°ç¢°æ’ï¼Œä¹Ÿå°±æ˜¯æ‰€è¬‚çš„Birthday Attackï¼\né™„éŒ„ä¸€äº›æ•¸å­¸è­‰æ˜ï¼š\n\nåƒè€ƒè³‡æ–™å¯†ç¢¼å­¸ç³»åˆ—ä¹‹ï¼šç”Ÿæ—¥æ”»æ“Šç¶­åŸºç™¾ç§‘ï¼šç”Ÿæ—¥å•é¡ŒDiaconis and Mosteller 1989 - methods for studying coincidences\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","æ©Ÿç‡","2021æš‘æœŸç­†è¨˜"]},{"title":"Educational Codeforces Round 103 (Rated for Div. 2)","url":"/cf1/","content":"\nRating change:1137-&gt;1197(+60)\nProblem solved: 1\n\n\nProblem 1é¡Œåºï¼šé»æ­¤\n            You are given two integers ğ‘› and ğ‘˜.You should create an array of ğ‘› positive integers ğ‘1,ğ‘2,â€¦,ğ‘ğ‘› such that the sum (ğ‘1+ğ‘2+â‹¯+ğ‘ğ‘›) is divisible by ğ‘˜ and maximum element in ğ‘ is minimum possible.What is the minimum possible maximum element in ğ‘?InputThe first line contains a single integer ğ‘¡ (1â‰¤ğ‘¡â‰¤1000) â€” the number of test cases.The first and only line of each test case contains two integers ğ‘› and ğ‘˜ (1â‰¤ğ‘›â‰¤10^9^; 1â‰¤ğ‘˜â‰¤10^9^).OutputFor each test case, print one integer â€” the minimum possible maximum element in array ğ‘ such that the sum (ğ‘1+â‹¯+ğ‘ğ‘›) is divisible by ğ‘˜.\n          \nè§£é¡Œæƒ³æ³•ä¸€é–‹å§‹çœ‹åˆ°æ¸¬è³‡ç¯„åœï¼š10^9^ï¼Œå°±æƒ³åˆ°O(n)çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ä¸å¯è¡Œçš„ï¼ˆæœ‰å¥½å¤šäººåœ¨è³½å¾Œå› ç‚ºé€™æ¨£è¢«hackï¼‰ã€‚ä¸€é–‹å§‹çš„æƒ³æ³•æ˜¯åˆ†æ®µè¨è«–ï¼šn = k, n &gt; k, n &lt; k\n#include &lt;bits/stdc++.h&gt;using namespace std;int t; signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,k;cin&gt;&gt;n&gt;&gt;k;        if(n==k)&#123;            cout&lt;&lt;1&lt;&lt;endl;            continue;        &#125;        if(n&gt;k)&#123;            if(n%k==0)cout&lt;&lt;1&lt;&lt;endl;            else cout&lt;&lt;2&lt;&lt;endl;        &#125;        else&#123;            int temp = k/n;            if(k%n==0)cout&lt;&lt;temp&lt;&lt;endl;            else cout&lt;&lt;temp+1&lt;&lt;endl;        &#125;    &#125;&#125;\nçœ‹éåˆ¥äººç¨‹å¼ç¢¼å¾Œï¼Œç™¼ç¾å…¶å¯¦ä¹Ÿå¯ä»¥é€™æ¨£æ”¹ï¼š\n#include&lt;iostream&gt;using namespace std;int main() &#123;    int t;    cin&gt;&gt;t;    while(t--)&#123;        int n,k;cin&gt;&gt;n&gt;&gt;k;        k = k*(int)((n+k-1)/k);//å¤§æ–¼ç­‰æ–¼nçš„kçš„æœ€å°å€æ•¸        if(k%n==0) cout&lt;&lt;k/n&lt;&lt;&#x27;\\n&#x27;;        else cout&lt;&lt;k/n+1&lt;&lt;&#x27;\\n&#x27;;    &#125;    return 0;&#125;\nè€Œå®˜æ–¹è§£æ³•å‰‡æ˜¯å®Œå…¨çš„æ•¸å­¸ï¼ŒæŠŠå¼å­å¯«å‡ºä¾†ä¹‹å¾Œï¼Œç›´æ¥O(1)çš„è¤‡é›œåº¦ç®—å‡ºç­”æ¡ˆ\n            Letâ€™s denote ğ‘  as the sum of array ğ‘. From one side, since ğ‘  should be divisible by ğ‘˜ then we can say $ğ‘ =ğ‘ğ‘“â‹…ğ‘˜$ From other side, since all ğ‘ğ‘– are positive, then $ğ‘ â‰¥ğ‘›$.Itâ€™s quite obvious that the smaller $ğ‘ $ â€” the smaller maximum $ğ‘ğ‘–$ so we need to find the smallest $ğ‘ğ‘“$ that $ğ‘ğ‘“â‹…ğ‘˜â‰¥ğ‘›$. Thenğ‘ğ‘“=âŒˆ\\frac{ğ‘›}{ğ‘˜}âŒ‰=âŒŠ\\frac{ğ‘›+ğ‘˜âˆ’1}{ğ‘˜}âŒ‹Now we now that $ğ‘ =ğ‘ğ‘“â‹…ğ‘˜$ and we need to represent it as ğ‘1+â‹¯+ğ‘ğ‘› with maximum ğ‘ğ‘– minimized. Itâ€™s easy to prove by contradiction that maximumğ‘ğ‘–â‰¥âŒˆ\\frac{ğ‘ }{ğ‘›}âŒ‰.Moreover we can always construct such array ğ‘ that its sum is equal to ğ‘  and the maximum element is equal to $âŒˆ\\frac{ğ‘ }{ğ‘›}âŒ‰$As a result, the answer isâŒˆ\\frac{ğ‘ }{ğ‘›}âŒ‰=âŒŠ\\frac{ğ‘ğ‘“â‹…ğ‘˜+ğ‘›âˆ’1}{ğ‘›}âŒ‹, ğ‘ğ‘“=âŒŠ\\frac{ğ‘›+ğ‘˜âˆ’1}{ğ‘˜}âŒ‹.\n          ä»¥ä¸‹ç‚ºå®˜è§£ï¼š\n#include&lt;bits/stdc++.h&gt;using namespace std;int t;int main()&#123;  cin &gt;&gt; t;  while(t--) &#123;    long long n, k;    cin &gt;&gt; n &gt;&gt; k;    long long cf = (n + k - 1) / k;    k *= cf;        cout &lt;&lt; (k + n - 1) / n &lt;&lt; endl;  &#125;  return 0;&#125;\nè§£é¡Œç´€éŒ„\n            é€™ä¸€é¡Œå…±èŠ±äº†17åˆ†é˜æ‰å¯«å‡ºä¾†å¯èƒ½æ˜¯å°é¡Œç›®çš„åæ‡‰ä¸å¤ å¿«ï¼Œæ²’æœ‰ç¬¬ä¸€æ™‚é–“å°±æƒ³å‡ºè§£æ³•ä½†ç¬¬ä¸€é¡Œå°±æ‡‰è©²æ˜¯è¦å¾ˆç°¡å–®çš„å‘€ï¼ç¬¬ä¸€é¡Œæ˜¯æ‹šé€Ÿåº¦ï¼Œé€Ÿåº¦å¿«å°±å¯ä»¥æ’åæ¯”è¼ƒå‰é¢(æˆ‘çœ‹æœ‰è¨±å¤šäººä¸åˆ°5åˆ†é˜å°±å¯«å®Œäº†ï¼)\n          \nProblem 2é¡Œåºï¼šé»æ­¤\n            é¡Œç›®æ•˜è¿°çµ¦å®šå…©å€‹æ•´æ•¸n,kï¼Œèˆ‡nå€‹æ•´æ•¸p~0~,p~1~,â€¦ğ‘~ğ‘›âˆ’1~  (1â‰¤ğ‘~ğ‘–~â‰¤10^9^),å…¶ä¸­p~0~ä»£è¡¨ç‰©å“çš„åŸå§‹åƒ¹æ ¼ï¼Œğ‘~ğ‘–~å‰‡ä»£è¡¨åœ¨ç¬¬ ğ‘–-å€‹æœˆçš„åƒ¹æ ¼è®ŠåŒ–ã€‚kä»£è¡¨æ¯å€‹æœˆçš„é€šè„¹ä¿‚æ•¸ä¸å¾—è¶…é ğ‘˜ï¼…ï¼Œå› æ­¤å¿…é ˆå°ğ‘~ğ‘–~å¢åŠ ä¸€äº›å€¼ï¼Œä½¿æ‰€æœ‰ğ‘~ğ‘–~ç‚ºæ•´æ•¸ä¸”æ¯å€‹æœˆçš„é€šè„¹ä¿‚æ•¸ä¸è¶…é ğ‘˜ï¼…ã€‚è©¦æ±‚æœ€å°çš„ğ‘~ğ‘–~å¢åŠ å€¼ç‚ºä½•ï¼Ÿç¯„ä¾‹æ¸¬è³‡&gt;è¼¸å…¥ï¼š24 120100 1 202 2023 1001 1 1è¼¸å‡ºï¼š990\n          \nè§£é¡Œæƒ³æ³•ä¾ç…§é¡Œæ„ï¼Œé–‹ä¸€å€‹é•·åº¦ç‚ºnçš„é™£åˆ—ï¼Œç”±ç¬¬ä¸€å¤©çš„ä¸Šå‡åƒ¹æ ¼é–‹å§‹ï¼Œä¾åºè¨ˆç®—çœ‹æœƒä¸æœƒè¶…ék%çš„è†¨è„¹ä¿‚æ•¸ã€‚\n            Let sum = p$0$+p$_1$+$\\cdots$+p${i-1}$x ç‚º p$_{i}$è¦åŠ çš„æ•´æ•¸å‰‡ï¼š\\frac{p_i}{sum+x} \\le \\frac{k}{100}ç¶“éé€šåˆ†å¾Œï¼šx = \\lceil\\frac{100\\times p_i-sum\\times k}{k}\\rceil\\ge0\n          \nå› æ­¤å¯ä»¥å¯«å‡ºä»¥ä¸‹ç¨‹å¼ç¢¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int t,arr[105]; signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,k,base,sum =0,ans = 0;        cin&gt;&gt;n&gt;&gt;k&gt;&gt;base;        sum=base;        for(int i=0;i&lt;n-1;i++)cin&gt;&gt;arr[i];        for(int i=0;i&lt;n-1;i++)&#123;            if(100*arr[i]&gt;k*sum)&#123;                int temp = ceil((arr[i]*100-sum*k)/(double)k);                ans+=temp;                sum+=temp;            &#125;            sum+=arr[i];        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n\n            int temp = ceil((arr[i]*100-sum*k)/(double)k);é€™ä¸€æ®µç¨‹å¼ç¢¼å¯ä»¥æ”¹æˆï¼šint temp = (arr[i]*100-sum*k+k-1)/k;ä¹Ÿå¯ä»¥é”åˆ°å–ä¸Šé«˜æ–¯çš„æ•ˆæœå¾Œè€…æ™‚é–“å¿«ä¸Šè¨±å¤š\n          \nè§£é¡Œç´€éŒ„ç•¶åˆåœ¨å¯«çš„æ™‚å€™å¿˜è¨˜è¦åœ¨æ¸›å®Œå¾Œé™¤ä»¥kï¼Œå› æ­¤åƒäº†ä¸‰æ¬¡WAæ‰€ä»¥ä»¥å¾ŒçŸ¥é“ï¼Œåœ¨å¯«é¡Œç›®ä¹‹å‰ï¼Œæœ€å¥½éƒ½å…ˆæŠŠæ•¸å­¸å¼å¯«å¾—æ¸…æ¥šåœ¨è§£é¡Œçš„æ™‚å€™æ‰ä¸æœƒçŠ¯ä¸‹é€™ç¨®éŒ¯ï¼å¦å¤–ï¼Œæˆ‘ç¾åœ¨æ‰çŸ¥é“ï¼Œå–ä¸‹é«˜æ–¯å°±æ˜¯é™¤æ³•çš„doubleè½‰intå°±å¯ä»¥äº†ä¸Šé«˜æ–¯çš„è©±ï¼Œé™¤äº†ç”¨ ceil() å‡½å¼ï¼Œé‚„å¯ä»¥ç”¨ä¸Šé¢é‚£å€‹æ–¹å¼ä¾†é”åˆ°åŒæ¨£çš„æ•ˆæœã€‚é€™ä¸€æ¬¡rating change å‰›å¥½å·®äº†3å°±åˆ°1200ï¼ŒçœŸæ˜¯å¯æƒœï¼Œé‚„è¦å†æ‰“ä¸€å ´æ‰å¯ä»¥å‡å»\n\n            é€™ä¸€å ´ä¸»è¦å­¸åˆ°çš„é‡é»æ‡‰è©²æ˜¯æ€éº¼æ¨£æŠŠå–ä¸Šé«˜æ–¯è½‰æ›ç‚ºä¸‹é«˜æ–¯ï¼ˆä¸ç”¨ceil()å–ï¼‰!\n          \n","categories":["C++åŸºç¤ä¸»é¡Œ","CF"],"tags":["CF","ç«¶è³½"]},{"title":"2021.2.5 Codeforces Round","url":"/cf2/","content":"\nRating change:1197-&gt;1201(+4)\nProblem solved: 2\n\nçµ‚æ–¼ä¸Šç¶ äº†ï¼ï¼é€™æ¬¡åªæœ‰åŠ å››ï¼ˆåŠ çš„åˆ†æ•¸è¶Šä¾†è¶Šå°‘ï¼Œè¡¨ç¤ºè¦æ›´å¼·æ‰èƒ½åŠ æ›´å¤šåˆ†ï¼‰ï¼Œçµ±è¨ˆä¸€ä¸‹ç¸½å…±æ‰“äº†å…­å ´æ‰å‡åˆ° rating 1200ã€‚\n\nProblem 1é¡Œåºï¼šé»æ­¤\nè§£é¡Œæƒ³æ³•çœ‹å®Œé¡Œç›®èŠ±äº†æˆ‘å¤§æ¦‚äº”åˆ†é˜ï¼ˆå¤ªæ…¢ï¼ï¼‰ï¼Œç†è§£é¡Œæ„å¾Œç™¼ç¾è »ç°¡å–®çš„ï¼Œåªè¦åˆ†åˆ¥çµ±è¨ˆ U,D,R,L çš„æ•¸é‡å³å¯ï¼Œåˆ¤æ–·  U,D,R,Lçš„æ•¸é‡è¶³ä¸è¶³å¤ åˆ°æŒ‡å®šçš„ç›®æ¨™ã€‚\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int t; int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        string s;        int x,y;cin&gt;&gt;x&gt;&gt;y;        cin&gt;&gt;s;                int arr[4] = &#123;0&#125;;        long int len = s.length();        for(int i=0;i&lt;len;i++)&#123;            if(s[i]==&#x27;U&#x27;)arr[0]++;            else if(s[i]==&#x27;D&#x27;)arr[1]++;            else if(s[i]==&#x27;R&#x27;)arr[2]++;            else if(s[i]==&#x27;L&#x27;)arr[3]++;        &#125;        if(x&gt;=0 &amp;&amp; x&lt;=arr[2] &amp;&amp; y&gt;=0 &amp;&amp; y&lt;=arr[0])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else if(x&gt;=0 &amp;&amp; x&lt;=arr[2] &amp;&amp; y&lt;=0 &amp;&amp; abs(y)&lt;=arr[1])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else if(x&lt;=0 &amp;&amp; abs(x)&lt;=arr[3]&amp;&amp; y&gt;=0 &amp;&amp; y&lt;=arr[0])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else if(x&lt;=0 &amp;&amp; abs(x)&lt;=arr[3]&amp;&amp; y&lt;=0 &amp;&amp; abs(y)&lt;=arr[1])&#123;            cout&lt;&lt;&quot;YES&quot;&lt;&lt;endl;        &#125;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;endl;    &#125;&#125;\nçµæœæˆ‘é‚„æ˜¯åƒäº†waï¼Œå› ç‚ºæ²’æœ‰ &lt;= å¯«æˆ &lt;ï¼Œæ”¹å®Œä¹‹å¾Œï¼ˆæ”¹å¤ªå¿«æ²’æœ‰æ³¨æ„åˆ°ï¼‰çµæœCEï¼Œæ¯ä¸€æ¬¡ä¸Šå‚³éƒ½è¦è‡ªå·±å…ˆç·¨è­¯éå•Šï¼Œæ‰ä¸æœƒçŠ¯é€™ç¨®ä½ç´šéŒ¯èª¤ï¼\nè§£é¡Œç´€éŒ„é€™ä¸€é¡Œç”¨äº†30åˆ†é˜æ‰å¯«å‡ºä¾†ï¼ŒåŒå­¸ç”¨äº†å¤§æ¦‚17åˆ†é˜å°±è§£å‡ºä¾†äº†ã€‚é€™å¤§æ¦‚æ˜¯æˆ‘ç¬¬ä¸€æ¬¡é«”æœƒåˆ° coding çš„é€Ÿåº¦è·Ÿä¸ä¸Šè…¦è¢‹æƒ³çš„é€Ÿåº¦ï¼ˆåŠ›ä¸å¾å¿ƒï¼‰ï¼Œæ˜æ˜å·²ç¶“æƒ³åˆ°è¦æ€éº¼è§£ï¼Œå»å¯«å¾—å¾ˆæ…¢ã€‚æ‰€ä»¥çœ‹é¡Œç›®çš„æ™‚é–“ï¼‹æ‰‹é€Ÿå¾ˆæ…¢ï¼å¾—åˆ†å¾ˆå°‘ã€‚å¯«ç¨‹å¼çš„é€Ÿåº¦éœ€è¦æ™‚é–“æ…¢æ…¢åŸ¹é¤Šï¼Œé¦–å…ˆè¦åšçš„å°±æ˜¯åŠ å¿«æ‰“å­—çš„é€Ÿåº¦ï¼é™¤æ­¤ä¹‹å¤–ï¼Œé‚„è¦é¿å…çŠ¯ä¸‹ä½ç´šéŒ¯èª¤ï¼Œå‹™å¿…è¦åœ¨ä¸Šå‚³ä¹‹å‰å…ˆæª¢æŸ¥ä¸€ä¸‹!\nProblem 2é¡Œåºï¼šé»æ­¤\nè§£é¡Œæƒ³æ³•ç›´è¦ºæƒ³åˆ°å°±æ˜¯æ¨¡æ“¬ç¬¬1é¡†çƒåˆ°k-1é¡†çƒï¼Œå°±å¯ä»¥æ¨å¾—ç¬¬ké¡†çƒçš„ä½ç½®\n#include &lt;iostream&gt;using namespace std;int t; int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,k;cin&gt;&gt;n&gt;&gt;k;        int arr[n];        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];                while(--k)&#123;            int ind = 0;            while(arr[ind]&gt;=arr[ind+1] &amp;&amp; ind&lt;n-1)ind++;            if(ind!=n-1)arr[ind]++;            else break;        &#125;        int i=0;        while(arr[i]&gt;=arr[i+1] &amp;&amp; i&lt;n-1)i++;        if(i!=n-1)cout&lt;&lt;i+1&lt;&lt;endl;        else cout&lt;&lt;-1&lt;&lt;endl;    &#125;&#125;\nè§£é¡Œç´€éŒ„å¯«åˆ°ä¸€åŠçœ‹åˆ°kçš„çš„å¤§å° 10^9^ï¼Œé‚„ä»¥ç‚ºO(n)çš„è¤‡é›œåº¦æœƒtleï¼Œä¸éæˆ‘å¯«å®Œä¸Ÿä¸Šå»æ¸¬ï¼Œéäº†ï¼ï¼ˆæˆ‘é‚„è·ŸåŒå­¸èªªé€™å€‹å•é¡Œï¼Œçµæœä»–å°±å»æƒ³æœ‰æ²’æœ‰å…¶ä»–O(n)ä»¥ä¸‹çš„è§£æ³•ï¼Œå¾Œä¾†ä»–å°±æ²’æœ‰å¯«å‡ºä¾†ï¼‰ä¸éèŠ±äº†28åˆ†é˜å¯«å‡ºä¾†ä¹‹å¾Œï¼Œçœ‹äº†ç¯„åœé™åˆ¶æƒ³äº†æƒ³ï¼Œæœ‰ä¸€å€‹é—œéµçš„æ¢ä»¶ï¼š\n1â‰¤ğ‘›â‰¤100, 1â‰¤â„ğ‘–â‰¤100the sum of ğ‘› over all test cases does not exceed 100.ä¹Ÿå°±ä»£è¡¨å¡åœ¨ä¸­é–“çš„çƒæ•¸ä¸æœƒè¶…é$(ğ‘›âˆ’1)â‹…(100âˆ’1)$å€‹ï¼Œä¹Ÿå°±æ˜¯èªªï¼Œæœ€å¤šå¾ç¬¬$(ğ‘›âˆ’1)â‹…(100âˆ’1)+1$ å€‹é–‹å§‹ï¼Œæ¥ä¸‹ä¾†æ¯ä¸€é¡†çƒéƒ½æœƒä¸€è·¯æœ›ä¸‹æ»‘ï¼Œä¸æœƒå¡åœ¨ä¸­é–“ï¼Œé€™æ™‚å€™è¿´åœˆå°±å¯ä»¥breakäº†ã€‚çœ‹ä¾† 10^9^åªæ˜¯æ‹¿ä¾†åš‡äººçš„ï¼Œæ­£å¸¸æ¨¡æ“¬æ˜¯ä¸æœƒtleçš„ï¼ˆæŸåŒå­¸ä¸Ÿäº†3æ¬¡é‚„æ˜¯waï¼‰ã€‚\nå¿ƒå¾—é€™æ˜¯ç›®å‰çš„ratingï¼Œæ˜¨å¤©+4 ä¹‹å¾Œçµ‚æ–¼è®Šæˆç¶ è‰²äº†ï¼é€™å€‹æ˜¯ç›®æ¨™\n            å¸Œæœ›æ¥ä¸‹ä¾†å¯ä»¥é †åˆ©åƒåŠ è³‡è¨Šä¹‹èŠ½ï¼Œå¥½å¥½è®“è‡ªå·²è®Šå¼·ï¼Œå­¸ä¸€äº›dpé‚„æœ‰å…¶ä»–çš„æ¼”ç®—æ³•ï¼ŒæŠŠå­¸é•·çš„è¬›ç¾©çœ‹å®Œç„¶å¾Œå­¸èµ·ä¾†ï¼Œåœ¨é«˜äºŒçš„æ™‚å€™å¯ä»¥æ‰“æ¯”è³½ï¼\n          \n","categories":["C++åŸºç¤ä¸»é¡Œ","CF"],"tags":["CF","ç«¶è³½"]},{"title":"ç¤¾åœ˜åƒèˆ‡ï¼šæ©Ÿå™¨äººç ”ç¿’ç¤¾å­¸ç¿’æ­·ç¨‹","url":"/club1/","content":"è¨­è¨ˆæ€è€ƒï¼ˆDesign Thinkingï¼‰æ´»å‹•æ¦‚è¿°åˆ©ç”¨å¯’å‡çš„ç©ºæª”è·Ÿç¤¾åœ˜çš„åŒå­¸å€‘åˆ°ä»æ„›çš„ç¤¾æœƒå‰µæ–°å¯¦é©—ä¸­å¿ƒé€²è¡Œä¸€å¤©çš„è¨­è¨ˆæ€è€ƒèª²ç¨‹\næ´»å‹•å…§å®¹ä¸»è¦æ˜¯å­¸ç¿’Design Thinking çš„ç²¾é«“ä»¥åŠæ­¥é©Ÿï¼Œä»¥é«˜ä¸­ç”Ÿçš„è§’åº¦é‡å° 108æ–°èª²ç¶± çš„è­°é¡Œé€²è¡Œè¨­è¨ˆæ€è€ƒï¼Œé€éé«”ã€ç…‰ã€å‰µã€å¡‘ã€è©¦é€™äº”å€‹éšæ®µï¼Œåˆ†æä½¿ç”¨è€…çš„éœ€æ±‚ï¼Œæœ€å¾Œé€²è¡Œç”¢å“çš„åˆ†äº«\nä¸»è¦ç›®çš„æ˜¯å¸Œæœ›è—‰ç”±é€™å€‹æ´»å‹•ï¼Œè®“æˆ‘å€‘ç«™åœ¨ä½¿ç”¨è€…çš„ç«‹å ´å»æ€è€ƒä»€éº¼å•é¡Œæ˜¯éœ€è¦è¢«è§£æ±ºçš„ï¼Œå¾å®¢æˆ¶çš„ç«‹å ´æ€è€ƒä¸€ä»¶å•†å“çš„å¦‚ä½•è¨­è¨ˆå‡ºäººå€‘æ»¿æ„çš„ä½¿ç”¨é«”é©—\nå­¸ç¿’å…§å®¹è¨­è¨ˆæ€è€ƒçš„è€å¸«åœ¨çµ¦å®šé¡Œç›®ç¯„åœä¹‹å¾Œï¼Œè¦æˆ‘å€‘ç‚ºäº†108èª²ç¶±çš„é«˜ä¸­ç”Ÿï¼Œæä¾›ä¸€å€‹æœ‰å¸å¼•åŠ›çš„ç”¢å“æˆ–æœå‹™ï¼Œä»¥å–å¾—å‰µæ¥­çš„è³‡é‡‘\n\næ–¼æ˜¯åƒè€ƒè¨­è¨ˆæ€è€ƒçš„ä»¥ä¸‹æ­¥é©Ÿï¼š\nEmpathizeï¼ŒåŒç†æ€è€ƒç¬¬ä¸€å€‹æ­¥é©Ÿæ˜¯ã€Œé«”ã€ï¼Œä¹Ÿå°±æ˜¯ç«™åœ¨æˆ‘å€‘ç«‹å ´ï¼Œåœ¨108èª²ç¶±ä¸­é‡åˆ°çš„ç¨®ç¨®å•é¡Œï¼Œä¾‹å¦‚å­¸ç¿’æ­·ç¨‹çš„è£½ä½œã€è‡ªä¸»å­¸ç¿’çš„å…§å®¹ã€æœå‹™å­¸ç¿’é€²è¡Œçš„æ–¹å¼ç­‰\nåœ¨é€™ä¸€å€‹æ­¥é©Ÿï¼Œæˆ‘å€‘åˆ©ç”¨æ›¼é™€ç¾…æ€è€ƒæ³•å°‡æƒ³æ³•å¯«ä¸‹ä¾†ï¼ŒæŠŠã€Œå®¢æˆ¶ã€ã€ä¹Ÿå°±æ˜¯é«˜ä¸­ç”Ÿçš„ç…©æƒ±åœ¨ä¹å®®æ ¼ä¸­å‘ˆç¾å‡ºä¾†\nDefineï¼Œéœ€æ±‚å®šç¾©æ¥ä¸‹ä¾†æ˜¯éœ€æ±‚å®šç¾©ï¼Œåœ¨é€™ä¸€æ­¥é©Ÿä¸­æˆ‘å€‘å½™æ•´å‡ºå€‹çµ„å“¡çš„ä¹å®®æ ¼çš„å…§å®¹ï¼ŒæŠŠä»–å¯«åœ¨ä¾¿æ¢ç´™ä¸Šï¼Œä¸¦è¨è«–æœ‰å“ªä¸€äº›æƒ³æ³•æ˜¯å¯ä»¥ä½¿ç”¨çš„ï¼Œæ·˜æ±°ä¸ç¬¦åˆæ¶ˆè²»è€…éœ€æ±‚çš„æƒ³æ³•ï¼ŒåŒæ™‚æ­¸ç´å‡ºå¹¾å€‹æˆ‘å€‘èªç‚ºé‡è¦çš„éœ€æ±‚\nIdeateï¼Œå‰µæ„ç™¼æƒ³æ¥ä¸‹ä¾†å°±æ˜¯å°‡ç•™ä¸‹ä¾†çš„ä¾¿åˆ©è²¼åˆ†é–€åˆ¥é¡è²¼åœ¨æµ·å ±ä¸Šï¼Œåœ¨éç¨‹ä¸­å› ç‚ºç¶“éå¤§å®¶æ„è¦‹çš„è¨è«–èˆ‡çµ±æ•´ï¼Œæœƒç”¢ç”Ÿå‡ºæ–°çš„æƒ³æ³•ï¼Œç¶“éèˆ‡çµ„å“¡çš„è¨è«–ï¼Œä¹Ÿä¸€ä½µå°‡å…¶åœ¨æµ·å ±ä¸Šå‘ˆç¾\næˆ‘å€‘åˆ†åˆ¥é‡å°è€å¸«ã€å­¸ç”Ÿå…©å€‹è§’åº¦å°æ–°åˆ¶å¯¦æ–½çš„æƒ³æ³•ï¼Œä¸¦åœ¨ä¾¿åˆ©è²¼ä¸Šè²¼ç´…è‰²çš„åœ“æ¨™ç±¤è¡¨ç¤ºè´ŠåŒä¸€å€‹æƒ³æ³•ï¼Œè¶Šå¤šç´…æ¨™ç±¤å°±ä»£è¡¨é€™å€‹æƒ³æ³•æœ‰è¶Šå¤šäººè´ŠåŒ\nPrototypeï¼Œæ¨¡å‹è¨­è¨ˆå†ä¾†æ˜¯Prototype çš„è¨­è¨ˆï¼Œå°‡æƒ³æ³•å½™æ•´åœ¨æµ·å ±ä¸Šå¾Œï¼Œé€éå°çµ„çš„è¨è«–å¾Œï¼Œæˆ‘å€‘çš„ç”¢å“æ˜¯æ¶è¨­ä¸€å€‹æ”¯æ´å®¶é•·ã€è€å¸«ã€å­¸ç”Ÿä¸‰æ–¹å¯ä»¥å¯†åˆ‡æºé€šçš„ç¶²ç«™ï¼Œè¨´æ±‚æœ‰ä¸€ä¸‹ä¸‰é»ï¼š\n\næ•™å¸«èˆ‡å­¸ç”Ÿå¯ä»¥åšåˆ°å³æ™‚çš„æºé€šï¼Œè®“æ•™å¸«å¯ä»¥æ¸…æ¥šæŒæ¡å­¸ç”Ÿå­¸ç¿’é€²åº¦\nå®¶é•·å¯ä»¥åˆ©ç”¨é€™å€‹å¹³å°ï¼Œå³æ™‚æŒæ¡å­¸ç”Ÿçš„å­¸ç¿’ç‹€æ³ï¼Œæ¸›å°‘å®¶é•·çš„è² æ“”\nå­¸ç”Ÿä½¿ç”¨é€™å€‹å¹³å°æ›´æ–¹ä¾¿çš„å–å¾—å®¶é•·èˆ‡è€å¸«çš„æ„è¦‹ï¼Œé€²è¡Œå­¸ç¿’çš„èª¿æ•´\n\næ–¼æ˜¯ï¼Œæˆ‘å€‘å°‡é€™ä¸€å€‹æ§‹æƒ³ï¼ˆç¶²ç«™ï¼‰ä»¥ç•«åœ–çš„æ–¹å¼å‘ˆç¾åœ¨ç´™ä¸Šï¼Œä¸¦èˆ‡ä»–çµ„çš„åŒå­¸åˆ†äº«æˆ‘å€‘çš„ç”¢å“ï¼Œä¸¦è«‹ä»–å€‘æå‡ºæ”¹å–„çš„å»ºè­°\nTestï¼Œæ¨¡æ“¬æ¸¬è©¦æœ€å¾Œçš„æ­¥é©Ÿæ˜¯æ¨¡æ“¬æ¸¬è©¦ï¼Œæˆ‘å€‘ä¸Šå°ç™¼è¡¨çš„æ–¹å¼å‘åŒå­¸èˆ‡è€å¸«å€‘åˆ†äº«æˆ‘å€‘æ¶è¨­ç¶²ç«™çš„æƒ³æ³•ï¼Œé›–ç„¶åœ¨æœ€å¾Œçš„ç¶œåˆè©•åˆ†ä¸­æˆ‘å€‘ä¸¦æ²’æœ‰æ‹¿åˆ°æœ€é«˜ç¥¨ï¼Œä½†èƒ½å¯¦éš›åƒèˆ‡æ•´å€‹éç¨‹è®“æˆ‘æ”¶ç©«å¾ˆå¤š\nå¿ƒå¾—åœ¨è¨­è¨ˆæ€è€ƒçš„æ´»å‹•ä¸­ï¼Œå¯¦éš›åƒèˆ‡äº†ä¸€å€‹å¾åŒç†æ€è€ƒã€éœ€æ±‚å®šç¾©ã€å‰µæ„ç™¼æƒ³ã€åˆ°æ¨¡å‹è¨­è¨ˆèˆ‡æ¨¡æ“¬æ¸¬è©¦çš„æ•´å€‹éç¨‹ã€‚\né¦–å…ˆæ˜¯å‰µæ„ç™¼æƒ³çš„éƒ¨åˆ†ï¼ŒåŸæœ¬ä»¥ç‚ºè‡ªå·±å·²ç¶“å°‡æ‰€æœ‰å¯è¡Œçš„æƒ³æ³•åˆ—å‡ºä¾†äº†ï¼Œä½†åœ¨çœ‹åˆ°åˆ¥äººçš„ä¹å®®æ ¼ä¹‹å¾Œç™¼ç¾åŸæœ¬çœ‹ä¸€ä»¶äº‹æƒ…å¯ä»¥æœ‰é€™éº¼å¤šçš„é¢å‘ï¼é€™å‘Šè¨´æˆ‘ï¼Œèˆ‡ä»–äººçš„æºé€šè¨è«–é™¤äº†å¯ä»¥ç²å¾—æ›´å¤šçš„æƒ³æ³•ä¹‹å¤–ï¼Œé‚„èƒ½é‡æ–°å¯©è¦–è‡ªå·±çš„æ€è€ƒæ˜¯ä¸æ˜¯æœ‰å‡ºç¾ç›²é»\næ¥ä¸‹ä¾†çš„çš„æ„è¦‹åˆ†äº«ä¹Ÿè®“æˆ‘å­¸åˆ°å¾ˆå¤šï¼Œåœ¨æœ‰äº†ä¸€å€‹åˆæ­¥çš„æƒ³æ³•å¾Œï¼Œé‚€è«‹åˆ¥çµ„çš„åŒå­¸ä¾†è½è½æˆ‘å€‘çš„æ§‹æƒ³ï¼Œåœ¨éç¨‹ä¸­æˆ‘æ“”ä»»ä»‹ç´¹ç”¢å“çš„è§’è‰²ï¼ˆä¹Ÿå°±æ˜¯æ¨éŠ·å“¡ï¼‰ï¼Œè¦å¦‚ä½•æ¸…æ¥šã€å®Œæ•´ã€æœ‰æ¢ç†çš„ä»‹ç´¹æˆ‘å€‘çš„ç”¢å“ï¼Œä¸¦æ¨è–¦åˆ¥äººä½¿ç”¨æˆ‘å€‘çš„ç”¢å“æ˜¯ä¸€ä»¶è »å›°é›£çš„äº‹ï¼\næœ€å¾Œæ˜¯ä¸‹é¢é€™å¼µåœ–çš„å°éŠæˆ²ï¼Œå…©é‚Šæ‹¿åˆ°ç›¸åŒçš„æ¨‚é«˜é›¶ä»¶ï¼Œä¸€é‚Šçš„äººè¦é€éè¬›è©±çš„æ–¹å¼æ•™å°å¦ä¸€é‚Šçš„åŒå­¸æ‹¼å‡ºæ­£ç¢ºå½¢ç‹€çš„æ¨¡å‹ã€‚éç¨‹çœ‹ä¼¼å¾ˆç°¡å–®ï¼Œä½†å…¶å¯¦è¦åšåˆ°å®Œå…¨æ­£ç¢ºå»ååˆ†çš„å›°é›£ï¼Œå¾€å¾€æœƒå·®ä¸€å€‹è§’ä¸ä¸€æ¨£è€Œå¤±æ•—ï¼Œå‘Šè¨´æˆ‘å€‘ä¸€èˆ¬åªç”¨å£é ­çš„æºé€šå¸¸å¸¸æœƒç”¢å±±èª¤è§£èˆ‡çŸ›ç›¾ï¼Œè¦é€éä¸åŒçš„æ–¹å¼ï¼ˆå¦‚å¯¦éš›æ¼”ç¤ºï¼‰ç²¾æº–çš„å‚³é”æˆ‘å€‘å¸Œæœ›è¡¨é”çš„è¨Šæ¯ï¼\n\næ ¡å¤–åƒè¨ªæ´»å‹•åƒåŠ æ¯”è³½èˆ‡è£½é€ æ¯”è³½æ©Ÿå™¨èˆ‡è³¼è²·é›¶ä»¶éƒ½è¦èŠ±éŒ¢ï¼Œå› æ­¤æˆ‘å€‘è—‰ç”±åƒè¨ªæ ¡å¤–èˆ‡æ©Ÿå™¨äººè£½é€ ç›¸é—œçš„å…¬å¸ï¼Œä¸€æ–¹é¢å‹Ÿæ¬¾ã€ä¸€æ–¹é¢ä¹Ÿè®“æˆ‘å€‘è¦‹è­˜è¦‹è­˜åœ¨å¹³å¸¸é€™äº›å…¬å¸åœ¨åšäº›ä»€éº¼\næ™‚ç¢©ç§‘æŠ€åˆ©ç”¨ä¸€æ¬¡è‡ªä¸»å­¸ç¿’æ™‚é–“çš„ä¸‹åˆåƒè¨ªäº†æ™‚ç¢©ç§‘æŠ€å…¬å¸ã€‚æœƒåƒè¨ªæ™‚ç¢©æ˜¯å› ç‚ºå»ºä¸­æœ‰ä¸€ä½å¤§å­¸é•·åœ¨é‚£é‚Šæ“”ä»»å·¥ç¨‹å¸«ï¼Œä»–å‘æˆ‘å€‘ä»‹ç´¹äº†æ™‚ç¢©ç§‘æŠ€ä¸»è¦å°ˆæ”»çš„ç²¾å¯†æ±½è»Šé›¶ä»¶èˆ‡èˆªç©ºç²¾å¯†æ©Ÿæ¢°ï¼Œä¸¦å±•ç¤ºäº†ä»–å€‘æ•´å€‹å·¥å» çš„ç”Ÿç”¢ç·š\nå·¥å» åƒè§€è·Ÿè‘—å¤§å­¸é•·çš„è…³æ­¥åƒè§€äº†æ™‚ç¢©å·¥æ¥­çš„å·¥å» ï¼Œå¾æ±½è»Šé›¶ä»¶åˆ°èˆªç©ºç²¾å¯†æ©Ÿæ¢°éƒ½åœ¨ä»–å€‘çš„ç”Ÿç”¢ç¯„åœå…§ï¼Œä¸¦ä»‹ç´¹å·¥å» çš„è¨­å‚™èˆ‡ç›¸é—œé‹ä½œæ¨¡å¼\nè®“æˆ‘æœ€è¨ç•°çš„æ˜¯æ•´å€‹å·¥å» æ”¾çœ¼æœ›å»ä¸è¦‹åŠå€‹äººå½±ï¼Œå…¨éƒ¨éƒ½æ˜¯æ©Ÿå™¨é‹ä½œçš„è²éŸ³ï¼Œèˆ‡è¢å¹•æ¨™ç¤ºè‘—æ•´å€‹å·¥å» çš„æ©Ÿå™¨æ˜¯å¦æ­£å¸¸é‹è¡Œï¼Œè®“æ§åˆ¶å®¤å…§çš„äººå¯ä»¥éš¨æ™‚æŒæ¡å·¥å» é‹ä½œçš„ç‹€æ³\nä¸‹æ–¹æ«ƒå­å…§æ”¾çš„æ˜¯æ™‚ç¢©åœ¨è£½é€ çš„æ±½è»Šé›¶ä»¶ï¼Œæœ‰ä¸‹æ–¹çš„åœ–ç‰‡å‰‡æ˜¯è£½é€ é›¶ä»¶çš„æ©Ÿå™¨ã€‚åƒè¨ªéç¨‹ä¸­ï¼Œå¤§å­¸é•·ä¸æ–·æåˆ°æ¨™æº–åŒ–çš„è¦æ ¼æ˜¯å¤šéº½é‡è¦ï¼Œå› ç‚ºä»–å€‘æ˜¯è£½é€ æ±½è»Šèˆ‡èˆªç©ºç›¸é—œçš„é›¶ä»¶ï¼Œè¦æ˜¯å‡ºä»€éº¼å·®éŒ¯å¯æ˜¯æ”¸é—œäººå‘½çš„ï¼\nè‘£äº‹é•·æ¼”è¬›æ™‚ç¢©å·¥æ¥­çš„è‘£äº‹é•·é»ƒäºèˆˆå‘æˆ‘å€‘ä»‹ç´¹äº†æ•´å€‹æ™‚ç¢©å·¥æ¥­çš„æ­·å²ï¼Œå¾ç•¶åˆçš„å‰µç«‹åˆ°ç¾åœ¨æ˜¯å¦‚ä½•ä¸€æ­¥æ­¥å…‹æœé›£é—œé”åˆ°ç¾åœ¨çš„æˆå°±ã€‚å­¸åˆ°æœ€å¤šçš„æ‡‰è©²æ˜¯ä»–çš„äººç”Ÿè§€ï¼Œå„˜ç®¡ä¸€è·¯ä¸Šå›°é›£é‡é‡ï¼Œé¢å°æ™‚ä»£è®Šé·çš„è½‰å‹å•é¡Œï¼Œä»–æ˜¯å¦‚ä½•å …æŒçš„èµ°ä¸‹å»ï¼Œè¿½æ±‚åœ¨é ˜åŸŸä¸Šçš„é ‚å°–æ°´å¹³ã€‚\n\nå¿ƒå¾—æ™‚ç¢©å·¥æ¥­æ˜¯ä¸€å®¶å¸‚å€¼è¶…é30å„„å°å¹£çš„å…¬å¸ï¼Œèƒ½åƒè§€é€™æ¨£çš„ä¸€å®¶å…¬å¸ä¸¦ç”±è‘£äº‹é•·è¦ªè‡ªæ¼”è¬›ï¼Œå‘Šè¨´æˆ‘å€‘åœ¨é¢å°å›°é›£èˆ‡æŒ«æŠ˜å …æŒä¸‹å»æ…‹åº¦ï¼Œçµåˆä»–è‡ªèº«çš„ç¶“é©—å‘Šè¨´æˆ‘å€‘åœ¨ä¸€å€‹é ˜åŸŸé”åˆ°é ‚å°–çš„é‡è¦æ€§ï¼Œè®“æˆ‘å°è±¡æ·±åˆ»ï¼\nè¯ç¢©å‹Ÿæ¬¾æ´»å‹•é€™å€‹æ´»å‹•æ¯”è¼ƒç‰¹åˆ¥ï¼Œæ˜¯è¯ç¢©çš„å…©å€‹è·å“¡åˆ°ç¤¾åœ˜çš„è¾¦å…¬å®¤è½æˆ‘å€‘çš„ä»‹ç´¹é€²è¡Œå‹Ÿæ¬¾çš„æ´»å‹•ã€‚é€™æ¬¡æ˜¯ç”±æˆ‘å’Œå¦å¤–ä¸€ä½åŒå­¸è² è²¬ä»‹ç´¹å»ºä¸­æ©Ÿç ”ï¼Œå¾ç¤¾åœ˜çš„å‰µç«‹çš„æ­·å²ä»¥åŠæˆ‘å€‘åœ¨åšäº›ä»€éº¼ä¾†ä»‹ç´¹ã€‚\nç”±æ–¼æ“”ä»»å ±å‘Šçš„è§’è‰²ï¼Œæˆ‘å€‘åœ¨ç™¼è¡¨å‰é€²è¡Œå¤šæ¬¡çš„è©¦è¬›ä»¥åŠèª¿æ•´ï¼Œå¸Œæœ›ä»¥æœ€ä½³çš„ç‹€æ…‹ä¸‹å‘ˆç¾ï¼Œè®“æˆ‘å­¸ç¿’åˆ°è¨±å¤šå ±å‘Šçš„æŠ€å·§ã€‚äº‹å¾Œæ­¸ç´å‡ºä»¥ä¸‹å¯ä»¥æ”¹é€²çš„åœ°æ–¹ï¼š\n\næº–å‚™ä¸å¤ å‘¨å…¨ï¼Œåœ¨å ±å‘Šçš„æ™‚å€™æœƒä¸è‡ªè¦ºçœ‹å‘æŠ•å½±ç‰‡\nè¦–ç·šèˆ‡èº«é«”é¢å°çš„æ–¹å‘é¢å‘å´é‚Šï¼Œæ‡‰æœå‘ç›®æ¨™è§€çœ¾\nè‡ªä¿¡ä¸è¶³ï¼Œé€ æˆå¡è©çš„ç‹€æ³\n\nä¸‹æ¬¡å¯ä»¥é€éæ›´å®Œæ•´çš„æ¼”ç·´å¢åŠ è‡ªä¿¡ï¼Œä¸¦å°‡æŠ•å½±ç‰‡çš„å…§å®¹èƒŒèª¦ä¸‹ä¾†ä½¿å ±å‘Šæ›´åŠ æµæš¢ï¼\n\nå°ç£å¾®è»Ÿé€™æ¬¡çš„è¡Œç¨‹å¾ˆç‰¹åˆ¥ï¼Œæˆ‘å€‘åˆ°äº†ä¿¡ç¾©å€å°ç£å¾®è»Ÿçš„ç¸½éƒ¨åƒè§€å¾®è»Ÿçš„ç¸½éƒ¨ã€‚é€™è·Ÿä¹‹å‰åƒè§€æ™‚ç¢©æœ‰å¾ˆå¤§çš„ä¸åŒï¼Œä¸€å€‹æ˜¯åšç¡¬é«”ã€ä¸€å€‹æ˜¯åšè»Ÿé«”ã€‚\nä»‹ç´¹å°ç£å¾®è»Ÿé€™é‚Šè¬›è€…æœ‰æåˆ°ä¸€å€‹ä»¤æˆ‘è »é©šè¨çš„ç¾è±¡ï¼Œå°±æ˜¯å„˜ç®¡åƒå¾®è»Ÿé€™æ¨£ä¸€é–“å¤§å…¬å¸ï¼Œä¹Ÿé‚„æ˜¯æœƒé¢å°æ™‚ä»£è®Šé·å¿…é ˆè½‰å‹çš„å•é¡Œï¼Œå¦å‰‡æœ‰å¯èƒ½æœƒè¢«å¸‚å ´æ·˜æ±°ã€‚\nè¬›è€…èˆ‰äº†å¾®è»Ÿçš„å¸‚å€¼ä½œç‚ºä¾‹å­ï¼Œåœ¨éå»å¹¾åå¹´ï¼Œå¾®è»Ÿçš„è‚¡åƒ¹ä¸€ç›´æ²’æœ‰çªç ´æ€§çš„å¢é•·ï¼Œç›´åˆ°æœ€è¿‘å¹¾å¹´æ‰æœ‰çªç ´æ€§çš„å¢åŠ ã€‚åˆ†æåŸå› æ˜¯å› ç‚ºå¤§å…¬å¸åœ¨é€²è¡Œè½‰å‹çš„éç¨‹ä¸­é‡åˆ°é¾å¤§çš„é˜»åŠ›ï¼Œä¸éç¶œåˆçµæœä¾†çœ‹ï¼Œå¾®è»Ÿçš„è½‰å‹æ˜¯è »æˆåŠŸçš„ï¼Œå¯ä»¥å¾ä¸æ–·ä¸Šæ¼²çš„å¸‚å€¼å¾—çŸ¥ã€‚\nå¾®è»Ÿé‚„æœ‰æä¾›è¨±å¤šå¯¦ç¿’çš„æ©Ÿæœƒï¼Œæœªä¾†æœ‰æ©Ÿæœƒä¸€å®šè¦çˆ­å–çœ‹çœ‹ï¼\nåƒè§€å¾®è»Ÿè¾¦å…¬å®¤æœ€ä»¤æˆ‘æ„Ÿèˆˆè¶£çš„æ˜¯å¾®è»Ÿæœ€æ–°æ¨å‡ºçš„hololensï¼Œå®ƒæ˜¯ä¸€æ¬¾æ··åˆå¯¦å¢ƒçš„ç”¢å“ï¼Œä¸‹åœ–ç‚ºhololens ç¤ºç¯„æ“ä½œçš„éç¨‹ï¼Œå¯¦éš›é«”é©—æœƒç™¼ç¾ä»–æ˜¯ä¸€å€‹å¾ˆæ–°ç©çš„ç”¢å“ï¼Œå¯ä»¥é‹ç”¨åœ¨å­¸ç¿’ã€å·¥å» ã€é†«ç™‚ã€å¨›æ¨‚ç­‰é ˜åŸŸã€‚\nä¸‹åœ–å‰‡æ˜¯å¾®è»Ÿæ¨å‡ºçš„AIè­˜ç›¸ï¼Œå®ƒå¯ä»¥æ‹ç…§ä¸¦ç®—å‘½ï¼Œè »æ–°å¥‡çš„ï¼\nå¿ƒå¾—é€™æ˜¯ç¬¬ä¸€æ¬¡åƒè¨ªå¾®è»Ÿé€™ç¨®åœ‹éš›çš„å¤§å…¬å¸ï¼Œæ•´å€‹éç¨‹éƒ½æ˜¯ç”±å…©ä½å°ç£å¾®è»Ÿçš„å¯¦ç¿’ç”Ÿèˆ‡ä¸€ä½æ­£è·å¸¶è‘—æˆ‘å€‘åƒè§€ã€‚ä»–å€‘åˆ†äº«äº†è‡ªå·±çš„æ­·ç¨‹ï¼Œæ˜¯å¦‚ä½•é€²å…¥åˆ°å¾®è»Ÿä¸Šç­ï¼ˆå…¶ä¸­ä¸€ä½é«˜ä¸­æ™‚æ˜¯è³‡å¥§çš„é¸æ‰‹ï¼‰èˆ‡å·¥ä½œçš„æ—¥å¸¸ï¼Œå…¶ä¸­ä¸€ä½æ˜¯Bing mapçš„å·¥ç¨‹å¸«ï¼Œè½ä»–çš„ä»‹ç´¹æ„Ÿè¦ºåœ¨å¾®è»Ÿä¸Šç­æ˜¯ä¸€ä»¶è »ç‰¹åˆ¥ä¸”æœ‰è¶£çš„å·¥ä½œï¼\næ–‡æ—åœ‹å°ä¹‹å¿—å·¥æœå‹™\næ´»å‹•æ–°èç¨¿åœ¨å¯’å‡æ™‚é–“åˆ°æ–‡æ—åœ‹å°é€²è¡Œå…©å¤©æ©Ÿå™¨äººå†¬ä»¤ç‡Ÿçš„æ´»å‹•ï¼Œæˆ‘æ˜¯ä¸»è¦æ“”ä»»Scratch çš„æ•™å­¸ï¼Œåˆ©ç”¨2.5å€‹å°æ™‚çš„æ™‚é–“å¸¶ä»–å€‘è¨­è¨ˆä¸€å€‹è¸¢è¶³çƒçš„ç¨‹å¼ã€‚\néç¨‹ä¸­é‡åˆ°è »å¤šå›°é›£çš„ï¼Œæœ€å¤§çš„å•é¡Œå…¶å¯¦æ˜¯ä»–å€‘ç¨‹å¼è¨­è¨ˆç¨‹åº¦è½å·®éå¸¸å¤§ï¼Œæœ‰äº›å°æœ‹å‹å·²ç¶“å¯ä»¥èªªæ˜¯ç²¾é€šScratchï¼Œæœ‰äº›å‰‡æ˜¯é€£æœ€åŸºç¤çš„éƒ½ä¸æœƒï¼Œè®“æ•™å­¸æœ‰åŸ·è¡Œä¸Šåˆ°å›°é›£ã€‚\nè—‰ç”±åœ¨èª²å‰è¨­è¨ˆä¸€å€‹ Kahootçš„å°æ¸¬é©— ï¼Œè®“æˆ‘å€‘å¯ä»¥æŒæ¡æ¯ä¸€å€‹å°æœ‹å‹çš„ç¨‹åº¦ï¼Œå°æ–¼èƒ½åŠ›æ¯”è¼ƒå¼·çš„å°±è®“ä»–è¶…å‰å­¸ç¿’ï¼Œè€ŒScratch èƒ½åŠ›æ¯”è¼ƒæ¬ ç¼ºçš„å‰‡æ˜¯å®‰æ’éšŠè¼”ç‰¹åˆ¥æŒ‡å°ã€‚åˆ©ç”¨é€™å€‹æ–¹å¼æˆ‘å€‘ç›¡é‡è®“æ¯ä¸€ä½åŒå­¸éƒ½å¯ä»¥è·Ÿä¸Šï¼Œä¸¦ä¸”å­¸åˆ°æ±è¥¿ã€‚\nä¸‹åœ–æ˜¯è¬›è§£åŸ·è¡Œçš„ç¨‹å¼ï¼Œåœ¨è¬›è§£éå¾Œï¼Œå¤šæ•¸çš„å°æœ‹å‹éƒ½å¯ä»¥åšå‡ºè‡ªå·±çš„è¶³çƒå°éŠæˆ²ï¼Œè®“æˆ‘ç²å¾—è¨±å¤šæˆå°±æ„Ÿï¼\næ•´å€‹æ´»å‹•è®“æˆ‘å°æ•™å­¸é€™æ–¹é¢å­¸åˆ°å¾ˆå¤šï¼Œåœ¨è¬›è§£éç¨‹ä¸­å¿…é ˆéš¨æ©Ÿæ‡‰è®Šè§€å¯Ÿå°ä¸‹çš„åæ‡‰åšå‡ºèª¿æ•´ï¼Œé©æ™‚çš„åœä¸‹ä¾†æ”¾æ…¢é€Ÿåº¦ï¼Œæ‰ä¸æœƒé€ æˆå­¸ç”Ÿéƒ½è½ä¸æ‡‚çš„ç‹€æ³ï¼\näº¤æµæ´»å‹•ä¸‹åœ–æ˜¯è·Ÿå—ç§‘å¯¦ä¸­FRC6998äº¤æµçš„å¤§åˆç…§ï¼Œé€™æ˜¯ç¬¬ä¸€æ¬¡èˆ‡å—ç§‘å¯¦ä¸­é€²è¡Œäº¤æµçš„æ´»å‹•ã€‚åœ¨éç¨‹ä¸­ï¼Œåˆ†äº«äº†å½¼æ­¤åœ¨åšæ©Ÿå™¨äººç«¶è³½çš„ç›¸é—œç¶“é©—ï¼ŒåŒæ™‚åˆ†äº«åœ¨é€²è¡Œç«¶è³½ä¸­ä½¿ç”¨çš„æŠ€è¡“ä»¥åŠæ©Ÿæ¢°çš„è¨­è¨ˆç­‰ç­‰ã€‚\n\nä¸‹åœ–æ˜¯èˆ‡é«˜é›„ä¸­æ­£é«˜å·¥7525æ©Ÿç ”é€²è¡Œäº¤æµç…§ç‰‡\nå—ç§‘æ¨¡æ“¬è³½é€™æ˜¯ä»Šå¹´ç¬¬ä¸€æ¬¡åƒåŠ æ¯”è³½ï¼Œç¸½å…±å…©å¤©ä¸€å¤œçš„æ¯”è³½è®“æˆ‘è¦‹è­˜åˆ°FRCç«¶è³½çš„æ•´å€‹éç¨‹ã€‚\nç¬¬ä¸€å¤©ç¬¬ä¸€å¤©æ­ä¹˜ä¸‹åˆçš„é«˜éµåˆ°å°å—çš„é£¯åº—ï¼Œåœ¨æ™šé¤çµæŸä¹‹å¾Œï¼Œè¦é€²è¡Œè³½å‰çš„åœ˜éšŠæœƒè­°ï¼Œæˆ‘å€‘è©³ç´°çš„è¨è«–æ¯”è³½çš„åˆ†å·¥ï¼ˆæˆ‘æ˜¯è² è²¬å·¥ä½œå€çš„è¨­ç½®èˆ‡Scoutingï¼‰ã€èˆ‡é€²è¡Œæ“ä½œå®‰å…¨ç›¸é—œçš„è€ƒè©¦ï¼ˆç¢ºä¿ä¸æœƒæœ‰å—å‚·ç­‰æ„å¤–ç™¼ç”Ÿï¼‰ä¸‹åœ–æ˜¯é€²è¡Œæ“ä½œå®‰å…¨çš„æ¸¬é©—\nç¬¬äºŒå¤©é€™ä¸€å¤©ä¾†åˆ°å—ç§‘å¯¦ä¸­çš„æ¯”è³½ç¾å ´ï¼Œæ•´å¤©ä¸‹ä¾†çš„æ¯”è³½ç¯€å¥ååˆ†ç·Šæ¹Šï¼Œæˆ‘æ˜¯è² è²¬Scouting ä¹Ÿå°±æ˜¯åˆ†æåˆ¥çš„éšŠä¼è¡¨ç¾çš„ç‹€æ³ï¼Œé€²è¡Œæ¯”è³½ç­–ç•¥çš„ç ”æ“¬ã€‚\n\nå¿ƒå¾—ç¶“éä¸€å¹´ä¸‹ä¾†ï¼Œé€éè‡ªä¸»å­¸ç¿’èˆ‡ç¤¾åœ˜èª²çš„æ™‚é–“ï¼Œé™¤äº†å­¸ç¿’æ©Ÿæ¢°ã€ç¨‹å¼ç›¸é—œæŠ€è¡“æ–¹é¢çš„çŸ¥è­˜ï¼Œé‚„å­¸åˆ°äº†è¨±å¤šä¸ä¸€æ¨£çš„èƒ½åŠ›ï¼Œä¾‹å¦‚ä¸Šå°å ±å‘Šã€æ•™å­¸çš„èƒ½åŠ›ç­‰ã€‚åœ¨èˆ‡ä¸åŒå­¸æ ¡çš„éšŠä¼äº¤æµèˆ‡æ ¡å¤–åƒè¨ªçš„æ´»å‹•ä¸­ï¼Œæ“´å±•äº†æˆ‘çš„è¦–é‡ï¼Œå¯ä»¥è¦ªè‡ªçœ‹åˆ°æ¥­ç•Œçš„äººå¹³å¸¸åœ¨åšäº›ä»€éº¼ï¼Œä»¥åŠæœ‰ä»€éº¼è³‡æºæ˜¯å¯ä»¥å»çˆ­å–çš„ï¼\nåƒè€ƒè³‡æ–™åœ–ç‰‡ä¾†æºï¼šå—ç§‘æ©Ÿå™¨äººç²‰å°ˆ\nä½¿ç”¨é€£çµï¼šå°åŒ—å¸‚æ•™è‚²å±€å…¬å‘Š\n","categories":["è‡ªä¸»å­¸ç¿’"],"tags":["å­¸ç¿’æ­·ç¨‹","è‡ªä¸»å­¸ç¿’"]},{"title":"ç¤¾åœ˜åƒèˆ‡ï¼šæ©Ÿå™¨äººç ”ç¿’ç¤¾è‡ªä¸»å­¸ç¿’","url":"/club2/","content":"è‡ªä¸»å­¸ç¿’èª²ç¨‹å…§å®¹é€™ä¸€å­¸æœŸçš„è‡ªä¸»å­¸ç¿’ä¸»è¦æœ‰ä¸‰å€‹é‡é»ï¼š\n\nSolid work é›»è…¦ç¹ªåœ–\nAnsys æœ‰é™å…ƒç´ åˆ†ææ¨¡æ“¬\nåŸºç¤åŠ›å­¸ç†è«–èª²ç¨‹\nè‡ªè£½MeArmæ©Ÿæ¢°æ‰‹è‡‚\n\nåŸæœ¬è¦åŠƒè¦åˆ†çµ„åšæ©Ÿæ¢°æ‰‹è‡‚ï¼Œä½†å› ç‚ºç–«æƒ…çš„é—œä¿‚å°è‡´è¨ˆç•«æ²’è¾¦æ³•å¯¦è¡Œæ‰€ä»¥æŠŠåŸæœ¬åšæ‰‹è‡‚çš„æ™‚é–“æ‹¿ä¾†åšAnsysèˆ‡Solid Workçš„æ•™å­¸\né€™ä¸€å­¸æœŸçš„åŠ›å­¸èª²ç¨‹ä¸»è¦æ˜¯è®“æˆ‘å€‘å¯ä»¥å»ºç«‹ä¸€äº›åŠ›å­¸ç†è«–çš„è§€å¿µï¼Œåœ¨FRCæ©Ÿå™¨äººç«¶è³½ä¸­å¯ä»¥ç™¼æ®ç†è«–ä¸Šé¢çš„å„ªå‹¢ï¼Œé€éç‰©ç†çš„è§€å¿µèˆ‡å…¬å¼è¨ˆç®—ä¸¦åˆ†æåœ¨è£½ä½œæ©Ÿå™¨äººä¸­é‡åˆ°çš„å•é¡Œï¼Œä¸¦æ ¹æ“šç†è«–çµ¦å‡ºåˆç†çš„è§£æ±ºæ–¹å¼ã€‚\n\n2021.3.10 ä¸‰è§’å‡½æ•¸èˆ‡å¾®ç©åˆ†å…¥é–€é€™å€‹ç¦®æ‹œé™¤äº†åŸºç¤çš„åº§æ¨™ç¨®é¡çš„è¤‡ç¿’ï¼Œé‚„å­¸åˆ°ä¸€äº›ä¸‰è§’å‡½æ•¸çš„çŸ¥è­˜ã€‚é›–ç„¶ç¬¬ä¸€æ¬¡æ¥è§¸åˆ°ï¼Œä¹Ÿæ„Ÿå—åˆ°ä¸‰è§’å‡½æ•¸çš„å›°é›£ï¼Œä¸éæ•´é«”å­¸èµ·ä¾†é‚„ä¸éŒ¯\né‚„æœ‰ä¸€å€‹è »åƒåŠ›çš„ä¸»é¡Œæ˜¯å¾®ç©åˆ†ï¼Œé›–ç„¶åªæ˜¯åŸºç¤çš„åˆ†åˆ¥ä»‹ç´¹ç©åˆ†èˆ‡å¾®åˆ†çš„åŸç†èˆ‡ç›¸é—œæ‡‰ç”¨ï¼Œåœ¨ä¸Šèª²çš„æ™‚å€™é‚„æ˜¯æœ‰è½æ²’æœ‰æ‡‚ï¼Œå›å®¶å†æ¬¡è¤‡ç¿’å¾Œæ‰è¼ƒèƒ½ç†è§£å¾®ç©åˆ†å¤§è‡´çš„æ¦‚å¿µ\nåœ¨å¯’å‡æ©Ÿå™¨çš„Labviewç¨‹å¼è¨­è¨ˆä¸­æœ‰ä½¿ç”¨åˆ°PIDæ§åˆ¶ï¼Œåˆ©ç”¨æ¯”ä¾‹ã€ç©åˆ†ã€å¾®åˆ†çš„ä¸‰å€‹è®Šé‡è®“æ©Ÿå™¨å¯ä»¥ç²¾æº–çš„ç§»å‹•çµ¦å®šçš„è·é›¢ã€‚çœ‹åˆ°æ©Ÿå™¨å› ç‚ºä½¿ç”¨PIDæ§åˆ¶è€Œå‰å¾Œå°å¹…åº¦çš„æŠ–å‹•ï¼Œå°±å¯ä»¥è¦‹åˆ°åœ¨æ¯”ä¾‹èˆ‡ç©åˆ†é€™å…©å¡Šç™¼æ®çš„ä½œç”¨\nä¸Šèª²ç­†è¨˜ï¼š\n\n2021.3.17 éœåŠ›å­¸é€™ä¸€é€±çš„å…§å®¹æ˜¯éœåŠ›å­¸ï¼Œèª²ç¨‹é›£åº¦ç¨å¾®è¼ƒä¸Šé€±è¼•é¬†éœåŠ›å¹³è¡¡èˆ‡è½‰å‹•å¹³è¡¡æ˜¯ä¹‹å‰å°±å­¸éçš„æ¦‚å¿µï¼Œä¸éå†åŠ ä¸Šä¸‰è§’å‡½æ•¸é€²å»åˆ†æï¼Œæ•´å€‹é›£åº¦å°±ç¬é–“æé«˜ï¼ä¸Šèª²ä¸­æåˆ°çš„ä¾‹é¡Œå°±è¦åˆ©ç”¨åˆ°ä¸‰è§’å‡½æ•¸å°‡åŠ›åˆ†è§£ï¼Œä¸¦å°±xæ–¹å‘èˆ‡yæ–¹å‘çš„åŠ›ä½œè¨è«–\nä¸Šèª²ç­†è¨˜ï¼š\n2021.4.28 ææ–™ç‰©ç†ç‰¹æ€§ä»Šå¤©çš„ä¸Šèª²ä¸»é¡Œæœ‰åˆ¥æ–¼å‰å…©æ¬¡çš„èª²ç¨‹ï¼Œå› ç‚ºæ©Ÿå™¨éå¹¾é€±å¾Œè¦å‡ºå»æ¯”è³½çš„é—œä¿‚ï¼ŒåŠ©æ•™æ±ºå®šè¦ä¾†ä¸Šä¸€å ‚ææ–™å­¸çš„ç›¸é—œèª²ç¨‹ï¼ˆå› ç‚ºæ©Ÿå™¨å¤ªå®¹æ˜“ä¸çŸ¥é“ç‚ºä»€éº¼æŸäº›çµæ§‹å°±æ–·æ‰äº†ï¼‰é€™é€±çš„å…§å®¹ä¸»è¦ä»‹ç´¹ææ–™ç‰©ç†æ€§è³ªï¼ˆå‰›æ€§ã€å¼·åº¦ï¼‰ã€é™å¹…é»ï¼ˆå½ˆæ€§æ¥µé™ï¼‰ã€è„†æ€§å»¶æ€§ææ–™ï¼ˆå—åŠ›èˆ‡æ‡‰è®Šé—œä¿‚åœ–ï¼‰ï¼Œå…§å®¹è±å¯Œä¸”è »æœ‰è¶£çš„ï¼\nä¸Šèª²ç­†è¨˜ï¼š\n2021.6.2 ææ–™åŠ›å­¸æ¯”å®Œè³½å¾Œç™¼ç¾æˆ‘å€‘éšŠçš„æ©Ÿå™¨å¤ªå®¹æ˜“æå£äº†ï¼åœ¨è³½ä¸­çš„å›åˆå¹¾ä¹éƒ½æœƒæœ‰é›¶ä»¶å¤±æ•ˆæˆ–å‡ºç‹€æ³ï¼Œå› æ­¤å»¶çºŒä¸Šä¸€é€±çš„ä¸»é¡Œï¼ŒåŠ©æ•™çµ¦æˆ‘å€‘è£œå……å¾ˆå¤šé—œæ–¼ææ–™çš„ç†è«–èˆ‡åŠ›å­¸çš„åˆ†æ\né›£åº¦é —é«˜ï¼Œæˆ‘æ‡·ç–‘åŠ©æ•™æ˜¯ç›´æ¥æŠŠå¤§å­¸æ•™ææ¬éä¾†æ•™æˆ‘å€‘ï¼Œå¾åŸºæœ¬åŠ›çš„ä»‹ç´¹ï¼šæ­£å‘åŠ›(Normal Force)ã€å‰ªåŠ›(Shear Force)ã€å½çŸ©(Bending Moment)ï¼Œåˆ°æ‡‰åŠ›çš„ç¨®é¡ï¼šæ­£æ‡‰åŠ›(Normal Stress)ã€å‰ªæ‡‰åŠ›(Shear Stress)ï¼Œæœ€å›°é›£çš„å…¬å¼æ¨å°èˆ‡ä¸€å †æ–°çš„åè©ï¼šæ¥Šæ°ä¿‚æ•¸ã€å‰ªåˆ‡æ¨¡é‡ã€é ¸ç¸®ç­‰\nç¶“éä¸€é€±çš„æ¶ˆåŒ–ï¼Œæ‰ç¨ç¨ç†è§£é€™å…¶ä¸­çš„å…§å®¹\nä¸Šèª²ç­†è¨˜ï¼š\nSolid Work 3Dç¹ªåœ–è»Ÿé«”é€™å­¸æœŸçš„Solid workç¹ªåœ–ä¸»è¦åˆ†æˆä¸‰éƒ¨åˆ†ï¼š\n\nåŸºç¤åœ–å­¸ï¼ˆå·¥ç¨‹åœ–å­¸ã€æ‰‹ç¹ªåœ–è¦ç¯„ï¼‰\nç¯„ä¾‹å…ƒä»¶ç¹ªè£½\næœŸæœ«Solid workç¹ªåœ–æ¸¬é©—\n\nå€‹äººèªç‚ºæœ€å›°é›£çš„æ‡‰è©²æ˜¯å·¥ç¨‹åœ–å­¸ï¼ŒåŠ©æ•™èŠ±äº†å¾ˆå¤šæ™‚é–“æ•™æˆ‘å€‘åœ–å­¸ä¸­çš„ç®­é ­ã€å°ºåº¦ã€æ¨™è¨»ä½ç½®ã€å–®ä½ã€åœ“èˆ‡å¼§åº¦çš„æ¨™ç¤ºæ–¹å¼ç­‰ç­‰ï¼Œæ±è¥¿åˆå¤šåˆç¹é›œé›–ç„¶è½éä¸€æ¬¡ï¼Œæˆ‘ç›¸ä¿¡é™¤éæœ‰å†è¤‡ç¿’ï¼Œå¦å‰‡ä¸€å®šå¾ˆå¿«å°±æœƒå¿˜è¨˜:cry:\né—œæ–¼æœŸæœ«ç¹ªåœ–æ¸¬é©—çš„éƒ¨åˆ†ï¼Œè¦æ±‚ç¹ªè£½å‡ºä¸€å€‹ç¬¦åˆä»¥ä¸‹é¡Œç›®è¦æ±‚çš„è¦æ ¼ï¼Œä¸¦åœ¨ä¸Šé¢ç¹ªè£½å‡ºèºçµ²å­”ï¼Œè¦æ±‚å¦‚ä¸‹ï¼š\nä¾ç…§é¡Œç›®çš„è¦æ±‚åšå¥½å°ºå¯¸çš„æ¨™è¨˜ï¼ˆé¡Œç›®è¦æ±‚ï¼‰ï¼š\né€™æ˜¯ç¬¦åˆé¡Œç›®è¦æ±‚çš„æœ€çµ‚æˆæœï¼š\nANSYSæœ‰é™å…ƒç´ åˆ†æé€™æ‡‰è©²æ˜¯èª²ç¨‹ä¸­æœ€æœ‰è¶£çš„å–®å…ƒäº†ï¼å¯ä»¥é€éé›»è…¦åˆ†æï¼Œæ¨¡æ“¬å‡ºç‰©é«”åœ¨å—åŠ›èˆ‡åŠ›çŸ©æ™‚çš„æ‡‰è®Šé‡ï¼Œåˆ©ç”¨é€™å€‹åˆ†æåŠ©æ•™æƒ³å‘Šè¨´æˆ‘å€‘èªªå¯ä»¥è—‰ç”±é€™å€‹è»Ÿé«”åˆ†ææ©Ÿå™¨æ‰å—å¤–åŠ›ï¼ˆç¢°æ’ï¼‰çš„æ™‚å€™ï¼Œå“ªä¸€å€‹éƒ¨ä»¶æ‡‰è©²æœƒæœ€å…ˆç™¼ç”Ÿè®Šå½¢ç”šè‡³ç ´è£‚ï¼Œææ—©é˜²ç¯„\nç¸½å…±æœ‰å¹¾å€‹æ­¥é©Ÿéœ€è¦å®Œæˆï¼š\nå‰ç½®è™•ç†ã€å»ºæ¨¡å¯ä»¥å…ˆé€éANSYS å°‡æƒ³è¦æ¨¡æ“¬çš„ç‰©ä»¶å»ºæ¨¡ï¼Œæ–¹ä¾¿ç­‰ä¸€ä¸‹çš„æ±‚è§£ä¸¦å°‡å»ºæ¨¡å®Œæˆçš„ç‰©é«”åŒ¯å…¥Workbench é€²è¡Œå¾ŒçºŒçš„æ¨¡æ“¬èˆ‡åˆ†æ\nåˆ‡ç¶²æ ¼é€™ä¸€æ­¥é©Ÿå¯èªªæ˜¯é‡é»æ­¥é©Ÿï¼Œé€éåˆ‡ç¶²æ ¼çš„æ–¹å¼ï¼Œä¾†æ¨¡æ“¬çœŸå¯¦ä¸–ç•Œä¸­çš„å…ƒç´ ï¼Œå› æ­¤ç¶²æ ¼å¦‚æœåˆ‡çš„è¶Šç´°ï¼Œæ¨¡æ“¬æœƒè®Šå¾—æ›´ç²¾æº–ï¼Œä½†åŒæ™‚æ‰€éœ€è¦èŠ±è²»é‹ç®—çš„æ™‚é–“ä¹Ÿå°±è¶Šé•·åˆ‡ç¶²æ ¼æœ‰ä¸€å€‹é‡é»å°±æ˜¯ç›¡é‡åˆ‡æˆæ­£æ–¹å½¢ï¼ˆæˆ–æ˜¯çŸ©å½¢ï¼‰ï¼Œé¿å…åˆ‡å‡ºä¸è¦å‰‡å½¢ç‹€çš„ç¶²æ ¼!\né€™æ¨£åˆ‡ç¶²æ ¼å°±ä¸æ˜¯ä¸€å€‹å¾ˆå¥½çš„ä½œæ³•ï¼Œç¶²æ ¼æ‡‰è©²è¦æ›´åŠ ç¸å¯†\né€™å°±æ˜¯ä¸€å€‹ä¸éŒ¯çš„ç¶²æ ¼ï¼Œä¸éåˆ‡æˆèˆ‰è¡ŒçŸ©å½¢æ‡‰è©²æœƒæ›´å¥½\nå›ºå®šç‰©ä»¶ä¸¦å¢åŠ åŠ›çŸ©å°‡ç‰©ä»¶çš„å…©ç«¯å›ºå®šä½ï¼Œä¸¦åœ¨å…¶ä¸­ä¸€é‚Šæ–½åŠ åŠ›çŸ©(Yåˆ†é‡ï¼š$-1000Nm$)\næ±‚è§£(Solve)æœ€å¾Œå°±å¯ä»¥æ ¹æ“šè¨­å®šçš„åƒæ•¸çœ‹æ¨¡æ“¬çš„çµæœåœ¨å…¶ä¸­ä¸€ç«¯æ–½åŠ åŠ›çŸ©ï¼Œå¯ä»¥ç™¼ç¾å…©ç«¯çš„æ‡‰è®Šé‡æ˜¯æœ€å¤§çš„ï¼Œå‘å¦å¤–ä¸€ç«¯éæ¸›\næ‡‰è®Šé‡ï¼š\næœ€å¤§ä¸»æ‡‰åŠ›ï¼šå¯ä»¥ç™¼ç¾åœ¨æ´å£çš„åœ°æ–¹çš„å€¼æ˜¯æœ€å¤§çš„ï¼Œä¹Ÿå°±é¡¯ç¤ºåœ¨ç‰©é«”å—åˆ°å¤–åŠ›çš„æ™‚å€™ï¼Œé€šå¸¸åœ¨æœ‰é‘½æ´çš„åœ°æ–¹æ‰€å—åˆ°çš„è² æ“”æ˜¯æœ€å¤§çš„\næ¨¡æ“¬GIF\nå¿ƒå¾—é€™å­¸æœŸå­¸ç¿’åˆ°å¾ˆå¤šï¼Œä¸ç®¡æ˜¯ç†è«–æ–¹é¢çš„çŸ¥è­˜ï¼Œæˆ–æ˜¯é›»è…¦ç¹ªåœ–èˆ‡ç¾è±¡æ¨¡æ“¬çš„æŠ€å·§éƒ½é —æœ‰æ”¶ç²ã€‚æœ€è®“æˆ‘å°è±¡æ·±åˆ»çš„æ˜¯æœ‰é™å…ƒç´ çš„åˆ†æï¼Œé›–ç„¶åœ¨è¼‰é€™å€‹è»Ÿé«”èŠ±è²»äº†ç›¸ç•¶å¤šçš„æ™‚é–“(æª”æ¡ˆè¶…å¤§)ï¼Œåœ¨å»ºæ¨¡èˆ‡è¨­å®šåƒæ•¸ä¹Ÿé‡ä¸Šäº†äº›è¨±å›°é›£ï¼Œä¸éèƒ½é †åˆ©æ±‚è§£ä¹Ÿè®“äººç›¸ç•¶é–‹å¿ƒï¼\nåƒè€ƒè³‡æ–™\nåŠ©æ•™ä¸Šèª²è¬›ç¾©\nSolid workæ•™å­¸ç¶²ç«™\nAnsys æ•™å­¸æŠ•å½±ç‰‡)\n\n","categories":["è‡ªä¸»å­¸ç¿’"],"tags":["å­¸ç¿’æ­·ç¨‹","è‡ªä¸»å­¸ç¿’"]},{"title":"ç‰›ç‰›ç‰§å ´å•é¡Œ","url":"/convex-hull/","content":"é¡Œåºå¾å‰å¾å‰æœ‰ä¸€å€‹äººåå«thanksoneï¼Œä»–èˆ‡ä»–çš„å…©å€‹å“¥å“¥thankstwoä»¥åŠthanksthreeä»¥åŠä»–çš„å¼Ÿå¼Ÿthankszeroä¸€èµ·é–‹äº†ä¸€å®¶ã€Œç‰›ç‰›ç‰§å ´ã€ï¼Œç”¨ä¾†é¤Šç‰›ä»¥åŠä¸€äº›å¥‡æ€ªçš„æ±è¥¿ã€‚\næœ‰ä¸€å¤©ï¼Œä»–ç™¼ç¾ä»–çš„ç‰›ç‰›å°‘äº†å¾ˆå¤šéš»ï¼Œä¸çŸ¥é“æ˜¯è·‘å»äº†å“ªè£¡ï¼Œä»–å¾ˆé›£éï¼Œå› æ­¤ä»–æƒ³è¦å»ºé€ ä¸€å€‹åœç±¬ï¼Œè®“æ‰€æœ‰ç‰›ç‰›éƒ½è·‘ä¸å‡ºå»ã€‚æ–¼æ˜¯ä»–æ‹œè¨—ä»–çš„å…©å€‹å“¥å“¥thankstwoä»¥åŠthanksthreeå»å¸‚é›†è²·äº†$n$å€‹ç”¨ä¾†æ¶è¨­åœç±¬çš„æœ¨æ¨ï¼Œä¸¦è¦æ±‚ä»–å€‘æŠŠé€™äº›æœ¨æ¨æ¶è¨­åœ¨ä»–æŒ‡å®šçš„ä½ç½®ã€‚\næ¥è‘—ï¼Œä»–æ‹œè¨—ä»–çš„å¼Ÿå¼Ÿthankszeroä¹Ÿå»è²·äº†æ¢è¶…é•·çš„åœç±¬ï¼Œä¸¦è¦æ±‚thankszeroåˆ©ç”¨é€™æ¢è¶…é•·åœç±¬å°‡$n$å€‹æœ¨æ¨éƒ½åœèµ·ä¾†ï¼Œæ‰èƒ½è®“ç‰›ç‰›æœ‰ç›¡é‡å¤§çš„æ´»å‹•ç©ºé–“ã€‚thankszeroçš„æ•¸å­¸æ¯”èµ·ä»–çš„å“¥å“¥thanksoneé‚„è¦ç³Ÿï¼Œå› æ­¤ä»–éœ€è¦æ‹œè¨—ä½ å¹«å¿™è¨ˆç®—ä¸€ä¸‹ç•¶ä»–åœå¥½åœç±¬ä¹‹å¾Œï¼Œæœ‰å¤šå°‘å€‹æœ¨æ¨æœƒå‰›å¥½è½åœ¨é€™æ¢åœç±¬ä¸Šã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä»–é‚„å¸Œæœ›ä½ èƒ½çµ¦ä»–æ‰€æœ‰åœ¨åœç±¬ä¸Šçš„æœ¨æ¨çš„ä½ç½®ï¼Œè®“ä»–çŸ¥é“å›ºå®šåœç±¬çš„æœ¨æ¨çš„ä½ç½®ã€‚\næœ€å¾Œï¼Œthanksoneçœ‹åˆ°äº†ä½ é©šäººçš„è¨ˆç®—èƒ½åŠ›ï¼Œæ–¼æ˜¯ä»–è¦æ±‚ä½ è¨ˆç®—å‡ºåœç±¬æ‰€åœå‡ºä¾†çš„é¢ç©æœ‰å¤šå¤§ï¼Œè®“ä»–èƒ½çŸ¥é“ä»–çš„ç‰›ç‰›æœ‰å¤šå°‘çš„æ´»å‹•ç©ºé–“ã€‚\n\nINPUTç¬¬ä¸€è¡Œæœ‰ä¸€å€‹æ­£æ•´æ•¸$n(3â‰¤nâ‰¤2â‹…10^5)$ï¼Œè¡¨ç¤ºæœ‰$n$å€‹æœ¨æ¨åœ¨èŠåœ’ä¸Šæ¥ä¸‹ä¾†æœ‰$n$è¡Œï¼Œæ¯è¡Œæœ‰å…©å€‹æ•´æ•¸ $x$ åŠ $y$ï¼ˆ$âˆ’10^9â‰¤x,yâ‰¤10^9$ï¼‰ï¼Œä»¥ä¸€å€‹ç©ºç™½éš”é–‹ï¼Œç”¨ä»¥ä»£è¡¨ä¸€å€‹æœ¨æ¨åœ¨åº§æ¨™è»¸ä¸Šçš„ä½ç½®ã€‚\nä¿è­‰è¼¸å…¥çš„æ¯ä¸€é»éƒ½ä¸æœƒé‡è¤‡ã€‚\nOUTPUTç¬¬ä¸€è¡Œè«‹è¼¸å‡ºä¸€å€‹æ•´æ•¸$k$ï¼šåœæ¬„ä¸Šæœ¨æ¨çš„å€‹æ•¸ï¼ˆåŒ…å«åœæ¬„é‚Šä¸Šçš„æœ¨æ¨ï¼‰æ¥ä¸‹ä¾†è¼¸å‡º$k$è¡Œï¼Œæ¯ä¸€è¡Œç‚ºåœæ¬„ä¸Šæœ¨æ¨çš„åº§æ¨™ï¼Œç”±$x$åº§æ¨™ç”±å°åˆ°å¤§è¼¸å‡ºï¼Œå¦‚æœ$x$åº§æ¨™ç›¸åŒå‰‡æŒ‰ç…§$y$åº§æ¨™å¤§å°è¼¸å‡ºã€‚æ³¨æ„æ¯ä¸€å€‹æœ¨æ¨æœ€å¤šåªèƒ½è¢«è¼¸å‡ºä¸€æ¬¡ã€‚æœ€å¾Œä¸€è¡Œè¼¸å‡ºåœæ¬„æ‰€åœå‡ºçš„é¢ç©å¤§å°ï¼Œè³‡æ–™å››æ¨äº”å…¥å–åˆ°æ•´æ•¸ä½ã€‚\nSUBTASK40åˆ†ï¼š$n â‰¤100$\n60åˆ†ï¼šæ²’æœ‰ç‰¹åˆ¥é™åˆ¶\nç¯„ä¾‹æ¸¬è³‡1input72 22 01 12 42 34 21 3\noutput51 11 32 02 44 27\nç¯„ä¾‹æ¸¬è³‡2input41 23 22 25 2\noutput41 22 23 25 20\nå¾ç¯„ä¾‹æ¸¬è³‡1å¯ä»¥ç™¼ç¾ï¼Œthanksoneå¯ä»¥å°‡ä¸‹åœ–æœ¨æ¨$B,F,D,G,C$åœèµ·ä¾†ï¼Œèƒ½ç²å¾—æœ€å¤§çš„ç‰›ç‰›ç‰§å ´é¢ç©ï¼š\nç¯„ä¾‹æ¸¬è³‡2å¯ä»¥çœ‹åˆ°ï¼Œthanksoneåœå‡ºä¾†çš„ç‰›ç‰›ç‰§å ´é¢ç©ç‚º $0$ï¼š\né¡Œç›®é€£çµOJDL\né¡Œè§£é€™ä¸€é¡Œå°±æ˜¯å‡¸åŒ…è£¸é¡Œï¼Œè¼¸å‡ºæ‰€æœ‰åŒ…å«åœ¨å‡¸åŒ…ä¸Šçš„é»ï¼ˆé ‚é»è·Ÿé‚Šéƒ½è¦ï¼‰ã€‚\nsubtask 1ä¿è­‰æ‰€å½¢æˆçš„å‡¸åŒ…é¢ç©ä¸ç‚º0ï¼Œæ‰€ä»¥åšå®Œå‡¸åŒ…ä¹‹å¾Œå°‡é‚Šä¸Šçš„é»éƒ½è¼¸å‡ºå‡ºä¾†ï¼Œä¹‹å¾Œå†è¨ˆç®—å‡¸åŒ…é¢ç©å°±å¥½ã€‚\nsubtask 2åšå®Œå‡¸åŒ…å¯èƒ½æœƒæœ‰é»é‡è¤‡çš„å•é¡Œï¼Œæ‰€ä»¥å°‡æ‰€æœ‰é»æ’åºä¹‹å¾Œï¼Œè¨˜å¾—å»é‡ï¼Œå¥½å¥½è™•ç†å°±å¯ä»¥ACäº†ã€‚\nAC code#include &lt;bits/stdc++.h&gt;#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt const &amp;b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt const &amp;b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt const &amp;b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt const &amp;b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt const &amp;b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt const &amp;b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt const &amp;b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;struct comp&#123;    bool operator()(pt const &amp;a,pt const &amp;b)const&#123;        if(a.x == b.x)return a.y &lt; b.y;        return a.x &lt; b.x;    &#125;&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;set&lt;pt,comp&gt; s;int n,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt; 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;signed main()&#123;    cin&gt;&gt;n;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)area += (hull[i]^hull[i+1]);    for(auto i : hull)s.insert(i);    cout&lt;&lt;s.size()&lt;&lt;endl;    for(auto i : s)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;&lt;&lt;i.y&lt;&lt;endl;    cout&lt;&lt;((area%2)?(area/2)+1:(area/2))&lt;&lt;endl;&#125;\n","categories":["C++é€²éšä¸»é¡Œ","è¨ˆç®—å¹¾ä½•"],"tags":["æ¼”ç®—æ³•","å‹•æ…‹è¦åŠƒ"]},{"title":"[é¡Œè§£]CSES 1068 Weird Algorithm","url":"/cses1-1/","content":"Weird Algorithm\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;using namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    while(n != 1)&#123;        cout&lt;&lt;n&lt;&lt;&quot; &quot;;        if(n % 2 == 1)n = 3 * n + 1;        else n = n/2;    &#125;    cout&lt;&lt;1&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1618 Trailing Zeros","url":"/cses1-10/","content":"Trailing Zeros\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int f = 5,ans = 0;    for(int i=0;i&lt;12;i++)&#123;        ans += n / f;        f *= 5;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1754 Coin Piles","url":"/cses1-11/","content":"Coin Piles\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int a,b;cin&gt;&gt;a&gt;&gt;b;    if(a &gt; b)swap(a,b);    if(b - a &gt; a)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    a = a % 3;b = b % 3;    if(a &gt; b)swap(a,b);    if(a == 1 &amp;&amp; b == 2)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else if(a == 0 &amp;&amp; b == 0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;    return 0;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1755 Palindrome Reorder","url":"/cses1-12/","content":"Palindrome Reorder\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n; signed main()&#123;    string str,ans;cin&gt;&gt;str;    n = str.size();    int num[N],cnt = 0,cha = -1;memset(num,0,sizeof(num));    for(int i = 0;i &lt; n;i++)&#123;        num[str[i] - &#x27;A&#x27;] += 1;    &#125;    for(int i=0;i&lt;26;i++)&#123;        if(num[i] &amp; 1)&#123;            cnt++;cha = i;        &#125;    &#125;    ans.resize(n);    if(cnt &gt; 1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt == 1 &amp;&amp; !(n&amp;1))cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt &lt; 1 &amp;&amp; n&amp;1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else&#123;        if(n &amp; 1)&#123;            ans[n/2] = &#x27;A&#x27;+cha;            num[cha]--;        &#125;        int l = 0,r = n-1;        for(int i=0;i&lt;26;i++)&#123;            while(num[i])&#123;                ans[l++] = i + &#x27;A&#x27;;                ans[r--] = i + &#x27;A&#x27;;                num[i] -= 2;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2205 Gray Code","url":"/cses1-13/","content":"Gray Code\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define pb push_back#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;vector&lt;string&gt; str; void solve()&#123;    str.pb(&quot;0&quot;);str.pb(&quot;1&quot;);    for(int i=0;i&lt;n-1;i++)&#123;        vector&lt;string&gt; temp1 = str,temp2 = str;        reverse(temp2.begin(),temp2.end());        str.clear();        int len = temp1.size();        for(int i=0;i&lt;len;i++)temp1[i] = &quot;0&quot; + temp1[i];        for(int i=0;i&lt;len;i++)temp2[i] = &quot;1&quot; + temp2[i];        str.insert(str.begin(),temp1.begin(),temp1.end());        str.insert(str.end(),temp2.begin(),temp2.end());    &#125;    for(auto i : str)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2165 Tower of Hanoi","url":"/cses1-14/","content":"Tower of Hanoi\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;void solve(int from,int to,int by,int n)&#123;    if(n &lt; 1)return;    solve(from,by,to,n-1);    cout&lt;&lt;from&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;&quot;\\n&quot;;    solve(by,to,from,n-1);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    cout&lt;&lt; (1&lt;&lt;n)-1 &lt;&lt;&quot;\\n&quot;;    solve(1,3,2,n);    return 0;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1622 Creating Strings","url":"/cses1-15/","content":"Creating Strings\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size(),num[30];    memset(num,0,sizeof(num));    for(int i=0;i&lt;len;i++)&#123;        num[s[i] - &#x27;a&#x27;] += 1;    &#125;    string str;    for(int i = 0;i &lt; 26;i++)&#123;        while(num[i])&#123;            str += (char)(i + &#x27;a&#x27;);            num[i]--;        &#125;    &#125;    vector&lt;string&gt; ans;    do&#123;        ans.push_back(str);    &#125;while(next_permutation(str.begin(),str.end()));        cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;    return 0;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1623 Apple Division","url":"/cses1-16/","content":"Apple Division\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m = 0,arr[21];void dp()&#123;    int ans = LONG_LONG_MAX;    for(int i=0;i&lt;1&lt;&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;n;j++)&#123;            if(1&lt;&lt;j &amp; i)sum += arr[j];        &#125;        ans = min(ans,abs(m - sum - sum));    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];        m += arr[i];    &#125;    dp();&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1624 Chessboard and Queens","url":"/cses1-17/","content":"Chessboard and Queens\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;bool maze[10][10],vis[10][10];int ans = 0;bool check(int x,int y)&#123;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            if(vis[i][j])&#123;                if(abs(i - x) == abs(j - y))return false;                if(i == x || j == y)return false;            &#125;        &#125;    &#125;    return true;&#125;void dfs(int cur)&#123;    if(cur &gt; 8)&#123;        ans++;        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(cur,i) &amp;&amp; maze[cur][i])&#123;            vis[cur][i] = 1;            dfs(cur+1);            vis[cur][i] = 0;        &#125;    &#125;&#125;signed main()&#123;    IOS;    memset(maze,0,sizeof(maze));    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=8;i++)&#123;        string s;getline(cin,s);        for(int j=1;j&lt;=8;j++)&#123;            if(s[j-1] == &#x27;.&#x27;)maze[i][j] = 1;        &#125;    &#125;    dfs(1);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2431  Digit Queries","url":"/cses1-18/","content":"Digit Queries\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define N 20#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,pref[N],p[20];void init()&#123;    p[0] = 1;    for(int i=1;i&lt;19;i++)&#123;        p[i] = p[i-1] * 10;    &#125;    pref[1] = 9;    for(int i=2;i&lt;18;i++)&#123;        pref[i] = p[i-1] * 9 * i;    &#125;&#125;void solve()&#123;    int ind = 1;    while(n &gt; pref[ind])n -= pref[ind++];    n--;                    //0-BASE    int x = n / ind;        //0-BASE    int y = n % ind;        //0-BASE    int ans = p[ind-1] + x;    string temp = to_string(ans);    cout&lt;&lt;temp[y]&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    init();    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        solve();    &#125;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1625 Grid Paths","url":"/cses1-19/","content":"Grid Paths\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;string str;int dx[4] = &#123;1,0,-1,0&#125;,dy[4] = &#123;0,1,0,-1&#125;;bool vis[9][9];int ans = 0; void solve(int x,int y,int s)&#123;    if(x &lt; 1 || x &gt; 7 || y &lt; 1 || y &gt; 7 || vis[x][y])return;    if(x == 1 &amp;&amp; y == 7 &amp;&amp; s &lt; 48)return;    if(vis[x-1][y] &amp;&amp; vis[x+1][y] &amp;&amp; !vis[x][y+1] &amp;&amp; !vis[x][y-1])return;    if(!vis[x-1][y] &amp;&amp; !vis[x+1][y] &amp;&amp; vis[x][y+1] &amp;&amp; vis[x][y-1])return;    if(s == 48)&#123;        ans++;        return;    &#125;    vis[x][y] = 1;    int ans = 0;    if(str[s] == &#x27;L&#x27;)solve(x - 1, y, s + 1);    if(str[s] == &#x27;R&#x27;)solve(x + 1, y, s + 1);    if(str[s] == &#x27;U&#x27;)solve(x, y - 1, s + 1);    if(str[s] == &#x27;D&#x27;)solve(x, y + 1, s + 1);    if(str[s] == &#x27;?&#x27;)&#123;        for(int i = 0;i &lt; 4;i++)&#123;            int nx = x + dx[i],ny = y + dy[i];            solve(nx,ny,s+1);        &#125;    &#125;    vis[x][y] = 0;&#125; signed main()&#123;    IOS;    cin&gt;&gt;str;    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=7;i++)&#123;        vis[i][0] = 1;        vis[8][i] = 1;        vis[i][8] = 1;        vis[0][i] = 1;    &#125;    solve(1,1,0);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1083 Missing Number","url":"/cses1-2/","content":"Missing Number\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    int sum = n*(n+1)/2;    for(int i=0;i&lt;n-1;i++)&#123;        int temp;cin&gt;&gt;temp;        sum -= temp;    &#125;    cout&lt;&lt;sum&lt;&lt;endl;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1069 Repetitions","url":"/cses1-3/","content":"Repetitions\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std; signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size();    int ans = 1,cur = 1;    for(int i = 1;i &lt; len;i++)&#123;        if(s[i] == s[i-1])cur++;        else cur = 1;        ans = max(ans,cur);    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1094 Increasing Array","url":"/cses1-4/","content":"Increasing Array\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[N]; signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int ans = 0;    for(int i=1;i&lt;n;i++)&#123;        if(arr[i] &lt; arr[i-1])&#123;            ans += arr[i-1] - arr[i];            arr[i] = arr[i-1];        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1070 Permutations","url":"/cses1-5/","content":"Permutations\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    bool vis[N];memset(vis,0,sizeof(vis));    if(n == 2 || n == 3)cout&lt;&lt;&quot;NO SOLUTION&quot;&lt;&lt;endl;    else if(n == 4)cout&lt;&lt;&quot;2 4 1 3 &quot;;    else&#123;        for(int i=1;i&lt;=n;i+=2)&#123;            cout&lt;&lt;i&lt;&lt;&quot; &quot;;            vis[i] = 1;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            if(vis[i] == 0)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1072 Two Knights","url":"/cses1-7/","content":"Two Knights\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 10005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,dp[N]; void build()&#123;    memset(dp,0,sizeof(dp));    for(int i=2;i&lt;=10000;i++)&#123;        int sum = (i*i)*(i*i-1)/2 - 4*(i-1)*(i-2);        dp[i] = sum;    &#125;&#125; signed main()&#123;    IOS;    build();    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;dp[i]&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1071 Number Spiral","url":"/cses1-6/","content":"Number Spiral\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    while(n--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        int ly = max(x,y)-1,st = ly*ly;        if(!(ly % 2))&#123;            if(y &lt; ly+1)cout&lt;&lt;st+y&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-x)&lt;&lt;endl;        &#125;        else&#123;            if(x &lt; ly+1)cout&lt;&lt;st+x&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-y)&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1092 Two Sets","url":"/cses1-8/","content":"Two Sets\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n;void solve()&#123;    int total = n*(n+1)/2,sum = 0,cnt = 0;    bool vis[N];memset(vis,0,sizeof(vis));    if(total &amp; 1)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    for(int i=n;i&gt;=1;i--)&#123;        int next = sum + i;        if(next &lt;= total/2)&#123;            sum += i;            cnt++;            vis[i] = 1;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;&lt;&lt;n - cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 1617 Bit Strings","url":"/cses1-9/","content":"Bit Strings\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int ans = 1;    for(int i=0;i&lt;n;i++)&#123;        ans *= 2;        ans = ans % mod;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"CSES:Introductory Problems","url":"/cses1/","content":"CSES è§£é¡Œç´€éŒ„ã€‚\nMy AccountThanksoneå¸³è™ŸCSES Plan\nIntroductory ProblemsWeird Algorithmé¡Œç›®é€£çµ\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    while(n != 1)&#123;        cout&lt;&lt;n&lt;&lt;&quot; &quot;;        if(n % 2 == 1)n = 3 * n + 1;        else n = n/2;    &#125;    cout&lt;&lt;1&lt;&lt;&quot;\\n&quot;;&#125;\nMissing Numberé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n; signed main()&#123;    cin&gt;&gt;n;    int sum = n*(n+1)/2;    for(int i=0;i&lt;n-1;i++)&#123;        int temp;cin&gt;&gt;temp;        sum -= temp;    &#125;    cout&lt;&lt;sum&lt;&lt;endl;&#125;\nRepetitionsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std; signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size();    int ans = 1,cur = 1;    for(int i = 1;i &lt; len;i++)&#123;        if(s[i] == s[i-1])cur++;        else cur = 1;        ans = max(ans,cur);    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\nIncreasing Arrayé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[N]; signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int ans = 0;    for(int i=1;i&lt;n;i++)&#123;        if(arr[i] &lt; arr[i-1])&#123;            ans += arr[i-1] - arr[i];            arr[i] = arr[i-1];        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\nPermutationsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    bool vis[N];memset(vis,0,sizeof(vis));    if(n == 2 || n == 3)cout&lt;&lt;&quot;NO SOLUTION&quot;&lt;&lt;endl;    else if(n == 4)cout&lt;&lt;&quot;2 4 1 3 &quot;;    else&#123;        for(int i=1;i&lt;=n;i+=2)&#123;            cout&lt;&lt;i&lt;&lt;&quot; &quot;;            vis[i] = 1;        &#125;        for(int i=1;i&lt;=n;i++)&#123;            if(vis[i] == 0)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        &#125;    &#125;    cout&lt;&lt;endl;&#125;\nNumber Spiralé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n; signed main()&#123;    IOS;    cin&gt;&gt;n;    while(n--)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        int ly = max(x,y)-1,st = ly*ly;        if(!(ly % 2))&#123;            if(y &lt; ly+1)cout&lt;&lt;st+y&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-x)&lt;&lt;endl;        &#125;        else&#123;            if(x &lt; ly+1)cout&lt;&lt;st+x&lt;&lt;endl;            else cout&lt;&lt;(st+ly+1)+(ly+1-y)&lt;&lt;endl;        &#125;    &#125;&#125;\nTwo Knightsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 10005#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,dp[N]; void build()&#123;    memset(dp,0,sizeof(dp));    for(int i=2;i&lt;=10000;i++)&#123;        int sum = (i*i)*(i*i-1)/2 - 4*(i-1)*(i-2);        dp[i] = sum;    &#125;&#125; signed main()&#123;    IOS;    build();    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        cout&lt;&lt;dp[i]&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nTwo Setsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n;void solve()&#123;    int total = n*(n+1)/2,sum = 0,cnt = 0;    bool vis[N];memset(vis,0,sizeof(vis));    if(total &amp; 1)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    for(int i=n;i&gt;=1;i--)&#123;        int next = sum + i;        if(next &lt;= total/2)&#123;            sum += i;            cnt++;            vis[i] = 1;        &#125;    &#125;    cout&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;&lt;&lt;n - cnt&lt;&lt;&quot;\\n&quot;;    for(int i=1;i&lt;=n;i++)&#123;        if(!vis[i])cout&lt;&lt;i&lt;&lt;&quot; &quot;;    &#125;    cout&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\nBit Stringsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int ans = 1;    for(int i=0;i&lt;n;i++)&#123;        ans *= 2;        ans = ans % mod;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\nTrailing Zerosé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int f = 5,ans = 0;    for(int i=0;i&lt;12;i++)&#123;        ans += n / f;        f *= 5;    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    cin&gt;&gt;n;    solve();    return 0;&#125;\nCoin Pilesé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005#define mod 1000000007using namespace std;int n;void solve()&#123;    int a,b;cin&gt;&gt;a&gt;&gt;b;    if(a &gt; b)swap(a,b);    if(b - a &gt; a)&#123;        cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;        return;    &#125;    a = a % 3;b = b % 3;    if(a &gt; b)swap(a,b);    if(a == 1 &amp;&amp; b == 2)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else if(a == 0 &amp;&amp; b == 0)cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;    else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;    return 0;&#125;\nPalindrome Reorderé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int n; signed main()&#123;    string str,ans;cin&gt;&gt;str;    n = str.size();    int num[N],cnt = 0,cha = -1;memset(num,0,sizeof(num));    for(int i = 0;i &lt; n;i++)&#123;        num[str[i] - &#x27;A&#x27;] += 1;    &#125;    for(int i=0;i&lt;26;i++)&#123;        if(num[i] &amp; 1)&#123;            cnt++;cha = i;        &#125;    &#125;    ans.resize(n);    if(cnt &gt; 1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt == 1 &amp;&amp; !(n&amp;1))cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else if(cnt &lt; 1 &amp;&amp; n&amp;1)cout&lt;&lt;&quot;NO SOLUTION\\n&quot;;    else&#123;        if(n &amp; 1)&#123;            ans[n/2] = &#x27;A&#x27;+cha;            num[cha]--;        &#125;        int l = 0,r = n-1;        for(int i=0;i&lt;26;i++)&#123;            while(num[i])&#123;                ans[l++] = i + &#x27;A&#x27;;                ans[r--] = i + &#x27;A&#x27;;                num[i] -= 2;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nGray Codeé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define pb push_back#define IOS ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;vector&lt;string&gt; str; void solve()&#123;    str.pb(&quot;0&quot;);str.pb(&quot;1&quot;);    for(int i=0;i&lt;n-1;i++)&#123;        vector&lt;string&gt; temp1 = str,temp2 = str;        reverse(temp2.begin(),temp2.end());        str.clear();        int len = temp1.size();        for(int i=0;i&lt;len;i++)temp1[i] = &quot;0&quot; + temp1[i];        for(int i=0;i&lt;len;i++)temp2[i] = &quot;1&quot; + temp2[i];        str.insert(str.begin(),temp1.begin(),temp1.end());        str.insert(str.end(),temp2.begin(),temp2.end());    &#125;    for(auto i : str)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    solve();    return 0;&#125;\nTower of Hanoié¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;void solve(int from,int to,int by,int n)&#123;    if(n &lt; 1)return;    solve(from,by,to,n-1);    cout&lt;&lt;from&lt;&lt;&quot; &quot;&lt;&lt;to&lt;&lt;&quot;\\n&quot;;    solve(by,to,from,n-1);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    cout&lt;&lt; (1&lt;&lt;n)-1 &lt;&lt;&quot;\\n&quot;;    solve(1,3,2,n);    return 0;&#125;\nCreating Stringsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    IOS;    string s;cin&gt;&gt;s;    int len = s.size(),num[30];    memset(num,0,sizeof(num));    for(int i=0;i&lt;len;i++)&#123;        num[s[i] - &#x27;a&#x27;] += 1;    &#125;    string str;    for(int i = 0;i &lt; 26;i++)&#123;        while(num[i])&#123;            str += (char)(i + &#x27;a&#x27;);            num[i]--;        &#125;    &#125;    vector&lt;string&gt; ans;    do&#123;        ans.push_back(str);    &#125;while(next_permutation(str.begin(),str.end()));        cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i&lt;&lt;&quot;\\n&quot;;    return 0;&#125;\nApple Divisioné¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m = 0,arr[21];void dp()&#123;    int ans = LONG_LONG_MAX;    for(int i=0;i&lt;1&lt;&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;n;j++)&#123;            if(1&lt;&lt;j &amp; i)sum += arr[j];        &#125;        ans = min(ans,abs(m - sum - sum));    &#125;    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];        m += arr[i];    &#125;    dp();&#125;\nChessboard and Queensé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;bool maze[10][10],vis[10][10];int ans = 0;bool check(int x,int y)&#123;    for(int i=1;i&lt;=8;i++)&#123;        for(int j=1;j&lt;=8;j++)&#123;            if(vis[i][j])&#123;                if(abs(i - x) == abs(j - y))return false;                if(i == x || j == y)return false;            &#125;        &#125;    &#125;    return true;&#125;void dfs(int cur)&#123;    if(cur &gt; 8)&#123;        ans++;        return;    &#125;    for(int i=1;i&lt;=8;i++)&#123;        if(check(cur,i) &amp;&amp; maze[cur][i])&#123;            vis[cur][i] = 1;            dfs(cur+1);            vis[cur][i] = 0;        &#125;    &#125;&#125;signed main()&#123;    IOS;    memset(maze,0,sizeof(maze));    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=8;i++)&#123;        string s;getline(cin,s);        for(int j=1;j&lt;=8;j++)&#123;            if(s[j-1] == &#x27;.&#x27;)maze[i][j] = 1;        &#125;    &#125;    dfs(1);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\nDigit Queriesé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define N 20#define int long long#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,pref[N],p[20];void init()&#123;    p[0] = 1;    for(int i=1;i&lt;19;i++)&#123;        p[i] = p[i-1] * 10;    &#125;    pref[1] = 9;    for(int i=2;i&lt;18;i++)&#123;        pref[i] = p[i-1] * 9 * i;    &#125;&#125;void solve()&#123;    int ind = 1;    while(n &gt; pref[ind])n -= pref[ind++];    n--;                    //0-BASE    int x = n / ind;        //0-BASE    int y = n % ind;        //0-BASE    int ans = p[ind-1] + x;    string temp = to_string(ans);    cout&lt;&lt;temp[y]&lt;&lt;&quot;\\n&quot;;&#125;signed main()&#123;    IOS;    init();    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        solve();    &#125;&#125;\nGrid Pathsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;string str;int dx[4] = &#123;1,0,-1,0&#125;,dy[4] = &#123;0,1,0,-1&#125;;bool vis[9][9];int ans = 0; void solve(int x,int y,int s)&#123;    if(x &lt; 1 || x &gt; 7 || y &lt; 1 || y &gt; 7 || vis[x][y])return;    if(x == 1 &amp;&amp; y == 7 &amp;&amp; s &lt; 48)return;    if(vis[x-1][y] &amp;&amp; vis[x+1][y] &amp;&amp; !vis[x][y+1] &amp;&amp; !vis[x][y-1])return;    if(!vis[x-1][y] &amp;&amp; !vis[x+1][y] &amp;&amp; vis[x][y+1] &amp;&amp; vis[x][y-1])return;    if(s == 48)&#123;        ans++;        return;    &#125;    vis[x][y] = 1;    int ans = 0;    if(str[s] == &#x27;L&#x27;)solve(x - 1, y, s + 1);    if(str[s] == &#x27;R&#x27;)solve(x + 1, y, s + 1);    if(str[s] == &#x27;U&#x27;)solve(x, y - 1, s + 1);    if(str[s] == &#x27;D&#x27;)solve(x, y + 1, s + 1);    if(str[s] == &#x27;?&#x27;)&#123;        for(int i = 0;i &lt; 4;i++)&#123;            int nx = x + dx[i],ny = y + dy[i];            solve(nx,ny,s+1);        &#125;    &#125;    vis[x][y] = 0;&#125; signed main()&#123;    IOS;    cin&gt;&gt;str;    memset(vis,0,sizeof(vis));    for(int i=1;i&lt;=7;i++)&#123;        vis[i][0] = 1;        vis[8][i] = 1;        vis[i][8] = 1;        vis[0][i] = 1;    &#125;    solve(1,1,0);    cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES"],"tags":["CSES"]},{"title":"[é¡Œè§£]CSES 2189 Point Location Test","url":"/cses7-1/","content":"Point Location Test\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        int x1,y1,x2,y2,x3,y3;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;        pt l = &#123;x2 - x1,y2 - y1&#125;, o = &#123;x3 - x1,y3 - y1&#125;;                if((l ^ o) == 0)cout&lt;&lt;&quot;TOUCH&quot;&lt;&lt;&quot;\\n&quot;;        else if((l ^ o) &gt; 0)cout&lt;&lt;&quot;LEFT&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;RIGHT&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2190 Line Segment Intersection","url":"/cses7-2/","content":"Line Segment Intersection\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;bool onseg(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return cross == 0 &amp;&amp; dot &lt;= 0;    //dot == 0 when o is a or b&#125;int dir(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(pt a,pt b,pt c,pt d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if((dir(a,b,c) * dir(a,b,d)) == -1       &amp;&amp; (dir(c,d,a) * dir(c,d,b)) == -1)        return true;    return false;&#125;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        pt pot[4];        for(int i=0;i&lt;4;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;        if(inter(pot[0],pot[1],pot[2],pot[3]))cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2191 Polygon Area","url":"/cses7-3/","content":"Polygon Area\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;pot[N];int solve()&#123;    int ans = 0;    for(int i=0;i&lt;n;i++)ans += (pot[i] ^ pot[i+1]);    return ans;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;    pot[n] = pot[0];    cout&lt;&lt;abs(solve())&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2192 Point in Polygon","url":"/cses7-4/","content":"Point in Polygon\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define INF 1000000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];bool onseg(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return (cross == 0) &amp;&amp; (dot &lt;= 0);&#125;int dir(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(point a,point b,point c,point d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if(dir(a,b,c) * dir(a,b,d) &lt; 0 &amp;&amp; dir(c,d,a) * dir(c,d,b) &lt; 0)        return true;    return false;&#125;int solve(point cur)&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)&#123;        if(onseg(pt[i],pt[i+1],cur) == 1)return -1;        if(inter(pt[i],pt[i+1],cur,point&#123;INF,cur.y&#125;))sum++;        point temp = pt[i].y &gt; pt[i+1].y ? pt[i] : pt[i+1];        if(temp.y == cur.y &amp;&amp; temp.x &gt; cur.x)sum--;    &#125;    return sum;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    for(int i=0;i&lt;m;i++)&#123;        point temp;cin&gt;&gt;temp.x&gt;&gt;temp.y;        int ans = solve(temp);        if(ans == -1)cout&lt;&lt;&quot;BOUNDARY&quot;&lt;&lt;&quot;\\n&quot;;        else if(ans &amp; 1)cout&lt;&lt;&quot;INSIDE&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;OUTSIDE&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2193 Polygon Lattice Points","url":"/cses7-5/","content":"Polygon Lattice Points\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 100005#define INF 1000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];int solve()&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)sum += pt[i] ^ pt[i+1];    return abs(sum);&#125;int gcd(int a,int b)&#123;    if(b == 0)return a;    return gcd(b,a%b);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    int cnt = 0,ans = 0;    for(int i=0;i&lt;n;i++)        cnt += gcd(abs(pt[i].x-pt[i+1].x),abs(pt[i].y-pt[i+1].y));    ans = (solve() + 2 - cnt)/2;    cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2194 Minimum Euclidean Distance","url":"/cses7-6/","content":"Minimum Euclidean Distance\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;vector &lt;pii&gt; pt; int dis(pii a,pii b)&#123;    int x = a.x - b.x,y = a.y - b.y;    return x * x + y * y;&#125; bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125; vector &lt;pii&gt; temp;//å€é–“[l,r]int solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l + r) / 2,mid_x = pt[mid].x;    int ans = min(solve(l,mid),solve(mid+1,r));        temp.assign(r - l + 1,&#123;0 , 0&#125;);    merge(          pt.begin() + l,pt.begin() + mid + 1,          pt.begin() + mid + 1,pt.begin() + r + 1,          temp.begin(), cmp    );    for(int i=l;i&lt;=r;i++)pt[i] = temp[i-l];    temp.clear();    for(int i=l;i&lt;=r;i++)&#123;        if(abs(pt[i].x - mid_x)*abs(pt[i].x - mid_x) &lt;= ans)temp.push_back(pt[i]);    &#125;    int len = temp.size();    for(int i = 0;i &lt; len;i++)&#123;        for(int j = i+1;j &lt; len;j++)&#123;            ans = min(ans,dis(temp[i],temp[j]));            if(abs(temp[i].y - temp[j].y)*abs(temp[i].y - temp[j].y) &gt; ans)break;        &#125;    &#125;    return ans;&#125; signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    sort(pt.begin(),pt.end());    cout&lt;&lt;solve(0,n-1)&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"[é¡Œè§£]CSES 2195 Convex Hull","url":"/cses7-7/","content":"Convex Hull\né¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;;vector&lt;point&gt; pt;bool cmp(point a,point b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool dir(point a,point b,point c)&#123;    point A = a - c,B = b - c;    return (A ^ B) &gt;= 0;&#125;vector&lt;point&gt; convex()&#123;    vector&lt;point&gt; h;    sort(all(pt),cmp);    for(auto i : pt)&#123;        while(h.size() &gt; 1 &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int down = h.size();    h.pop_back();    reverse(all(pt));    for(auto i : pt)&#123;        while(h.size() &gt; down &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    h.pop_back();    return h;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    vector&lt;point&gt; ans = convex();    cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;&lt;&lt;i.y&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSESé¡Œè§£"],"tags":["é¡Œè§£","CSES"]},{"title":"CSES:Geometry","url":"/cses7/","content":"GeometryPoint Location Testé¡Œç›®é€£çµ#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        int x1,y1,x2,y2,x3,y3;        cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;x3&gt;&gt;y3;        pt l = &#123;x2 - x1,y2 - y1&#125;, o = &#123;x3 - x1,y3 - y1&#125;;                if((l ^ o) == 0)cout&lt;&lt;&quot;TOUCH&quot;&lt;&lt;&quot;\\n&quot;;        else if((l ^ o) &gt; 0)cout&lt;&lt;&quot;LEFT&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;RIGHT&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nLine Segment Intersectioné¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 10000#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;;bool onseg(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return cross == 0 &amp;&amp; dot &lt;= 0;    //dot == 0 when o is a or b&#125;int dir(pt a,pt b,pt o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(pt a,pt b,pt c,pt d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if((dir(a,b,c) * dir(a,b,d)) == -1       &amp;&amp; (dir(c,d,a) * dir(c,d,b)) == -1)        return true;    return false;&#125;signed main()&#123;    IOS;    int t;cin&gt;&gt;t;    while(t--)&#123;        pt pot[4];        for(int i=0;i&lt;4;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;        if(inter(pot[0],pot[1],pot[2],pot[3]))cout&lt;&lt;&quot;YES&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;NO&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nPolygon Areaé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct pt&#123;    int x,y;    bool operator == (pt b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    pt operator - (pt b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    pt operator + (pt b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (pt b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (pt b)&#123;return (x * b.x + y * b.y);&#125;&#125;pot[N];int solve()&#123;    int ans = 0;    for(int i=0;i&lt;n;i++)ans += (pot[i] ^ pot[i+1]);    return ans;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pot[i].x&gt;&gt;pot[i].y;    pot[n] = pot[0];    cout&lt;&lt;abs(solve())&lt;&lt;&quot;\\n&quot;;&#125;\nPoint in Polygoné¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 1005#define INF 1000000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];bool onseg(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    int dot = (a - o) * (b - o);    return (cross == 0) &amp;&amp; (dot &lt;= 0);&#125;int dir(point a,point b,point o)&#123;    int cross = (a - o) ^ (b - o);    if(cross == 0)return 0;    else if(cross &gt; 0)return 1;    else return -1;&#125;bool inter(point a,point b,point c,point d)&#123;    if(onseg(a,b,c) || onseg(a,b,d))return true;    if(onseg(c,d,a) || onseg(c,d,b))return true;    if(dir(a,b,c) * dir(a,b,d) &lt; 0 &amp;&amp; dir(c,d,a) * dir(c,d,b) &lt; 0)        return true;    return false;&#125;int solve(point cur)&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)&#123;        if(onseg(pt[i],pt[i+1],cur) == 1)return -1;        if(inter(pt[i],pt[i+1],cur,point&#123;INF,cur.y&#125;))sum++;        point temp = pt[i].y &gt; pt[i+1].y ? pt[i] : pt[i+1];        if(temp.y == cur.y &amp;&amp; temp.x &gt; cur.x)sum--;    &#125;    return sum;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    for(int i=0;i&lt;m;i++)&#123;        point temp;cin&gt;&gt;temp.x&gt;&gt;temp.y;        int ans = solve(temp);        if(ans == -1)cout&lt;&lt;&quot;BOUNDARY&quot;&lt;&lt;&quot;\\n&quot;;        else if(ans &amp; 1)cout&lt;&lt;&quot;INSIDE&quot;&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;OUTSIDE&quot;&lt;&lt;&quot;\\n&quot;;    &#125;&#125;\nPolygon Lattice Pointsé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 100005#define INF 1000005#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;pt[N];int solve()&#123;    int sum = 0;    for(int i=0;i&lt;n;i++)sum += pt[i] ^ pt[i+1];    return abs(sum);&#125;int gcd(int a,int b)&#123;    if(b == 0)return a;    return gcd(b,a%b);&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    pt[n] = pt[0];    int cnt = 0,ans = 0;    for(int i=0;i&lt;n;i++)        cnt += gcd(abs(pt[i].x-pt[i+1].x),abs(pt[i].y-pt[i+1].y));    ans = (solve() + 2 - cnt)/2;    cout&lt;&lt;ans&lt;&lt;&quot; &quot;&lt;&lt;cnt&lt;&lt;&quot;\\n&quot;;&#125;\nMinimum Euclidean Distanceé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;vector &lt;pii&gt; pt; int dis(pii a,pii b)&#123;    int x = a.x - b.x,y = a.y - b.y;    return x * x + y * y;&#125; bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125; vector &lt;pii&gt; temp;//å€é–“[l,r]int solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l + r) / 2,mid_x = pt[mid].x;    int ans = min(solve(l,mid),solve(mid+1,r));        temp.assign(r - l + 1,&#123;0 , 0&#125;);    merge(          pt.begin() + l,pt.begin() + mid + 1,          pt.begin() + mid + 1,pt.begin() + r + 1,          temp.begin(), cmp    );    for(int i=l;i&lt;=r;i++)pt[i] = temp[i-l];    temp.clear();    for(int i=l;i&lt;=r;i++)&#123;        if(abs(pt[i].x - mid_x)*abs(pt[i].x - mid_x) &lt;= ans)temp.push_back(pt[i]);    &#125;    int len = temp.size();    for(int i = 0;i &lt; len;i++)&#123;        for(int j = i+1;j &lt; len;j++)&#123;            ans = min(ans,dis(temp[i],temp[j]));            if(abs(temp[i].y - temp[j].y)*abs(temp[i].y - temp[j].y) &gt; ans)break;        &#125;    &#125;    return ans;&#125; signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    sort(pt.begin(),pt.end());    cout&lt;&lt;solve(0,n-1)&lt;&lt;&quot;\\n&quot;;&#125;\nConvex Hullé¡Œç›®é€£çµ\n#include &lt;bits/stdc++.h&gt;#define int long long#define double long double#define pii pair&lt;int, int&gt;#define N 200005#define INF LONG_LONG_MAX#define x first#define y second#define all(a) a.begin(),a.end()#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m;struct point&#123;    int x,y;    bool operator == (point b)&#123;        if(x == b.x &amp;&amp; y == b.y)return true;        return false;    &#125;    point operator - (point b)&#123;return &#123;x - b.x , y - b.y&#125;;&#125;    point operator + (point b)&#123;return &#123;x + b.x , y + b.y&#125;;&#125;    int operator ^ (point b)&#123;return (x * b.y - y * b.x);&#125;    int operator * (point b)&#123;return (x * b.x + y * b.y);&#125;&#125;;vector&lt;point&gt; pt;bool cmp(point a,point b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool dir(point a,point b,point c)&#123;    point A = a - c,B = b - c;    return (A ^ B) &gt;= 0;&#125;vector&lt;point&gt; convex()&#123;    vector&lt;point&gt; h;    sort(all(pt),cmp);    for(auto i : pt)&#123;        while(h.size() &gt; 1 &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int down = h.size();    h.pop_back();    reverse(all(pt));    for(auto i : pt)&#123;        while(h.size() &gt; down &amp;&amp; !dir(h[h.size()-1],i,h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    h.pop_back();    return h;&#125;signed main()&#123;    IOS;    cin&gt;&gt;n;    pt.assign(n,&#123;0,0&#125;);    for(int i=0;i&lt;n;i++)cin&gt;&gt;pt[i].x&gt;&gt;pt[i].y;    vector&lt;point&gt; ans = convex();    cout&lt;&lt;ans.size()&lt;&lt;&quot;\\n&quot;;    for(auto i : ans)cout&lt;&lt;i.x&lt;&lt;&quot; &quot;&lt;&lt;i.y&lt;&lt;&quot;\\n&quot;;&#125;\n","categories":["CSES"],"tags":["CSES"]},{"title":"éŒ¯æ’å•é¡Œï¼ˆDerangementsï¼‰","url":"/derangement/","content":"å®šç¾©éŒ¯æ’æ˜¯çµ„åˆæ•¸å­¸ä¸­çš„å•é¡Œä¹‹ä¸€ã€‚è€ƒæ…®ä¸€å€‹æœ‰nå€‹å…ƒç´ çš„æ’åˆ—ï¼Œè‹¥ä¸€å€‹æ’åˆ—ä¸­æ‰€æœ‰çš„å…ƒç´ éƒ½ä¸åœ¨è‡ªå·±åŸä¾†çš„ä½ç½®ä¸Šï¼Œé‚£éº¼é€™æ¨£çš„æ’åˆ—å°±ç¨±ç‚ºåŸæ’åˆ—çš„ä¸€å€‹éŒ¯æ’ã€‚æœ¬æ–‡å°‡å¾éŒ¯æ’å…¬å¼çš„æ¨å°é–‹å§‹ï¼Œè¿‘ä¸€æ­¥æ¢ç©¶å…¶æ€§è³ªåŠæ‡‰ç”¨ã€‚\n$n$å€‹å…ƒç´ çš„éŒ¯æ’æ•¸è¨˜ç‚º $D_n$ æˆ– $!n$ã€‚ ç ”ç©¶ä¸€å€‹æ’åˆ—éŒ¯æ’å€‹æ•¸çš„å•é¡Œï¼Œå«åšéŒ¯æ’å•é¡Œæˆ–ç¨±ç‚ºæ›´åˆ—å•é¡Œã€‚\nè¦å¾‹èˆ‡å…¬å¼åé¢æšèˆ‰å‰å¹¾é …å¯ä»¥ç”¨å–æ¨åŸç†ï¼ˆæˆ–çª®èˆ‰æ‰€æœ‰å¯èƒ½ï¼‰æ±‚å¾—ï¼š\n\\begin{align}D_1 &= 0 \\\\ D_2 &= 1\\\\D_3 &= 2 \\\\ D_4 &= 9\\end{align}\n            ä¸‰å€‹å…ƒç´ çš„éŒ¯æ’ï¼Œä»¥ä¸‹å…±å…©ç¨®ï¼šå››å€‹å…ƒç´ çš„éŒ¯æ’ï¼Œä»¥ä¸‹å…±9ç¨®ï¼š412334213142431224132341432134122143\n          \nå¦‚ä¸‹é¢çš„æ–‡æ°åœ–å¯ä»¥çœ‹åˆ°ï¼Œä»¥ä¸‰å€‹å…ƒç´ çš„éŒ¯æ’ç‚ºä¾‹ï¼Œæˆ‘å€‘è¦æ±‚çš„å°±æ˜¯ç¶ è‰²å€åŸŸçš„æ•¸é‡ï¼Œé€éæ’å®¹åŸç†ï¼ˆå–æ¨åŸç†ï¼‰ä¾†ç®—ã€‚\n\\begin{split}D_3 = 3!-C^3_1\\cdot2!+C^3_2\\cdot1!-C^3_3\\cdot0! =2\\end{split}å¦‚æœè¦æ±‚ $!4$ ä¹Ÿæ˜¯ä¸€æ¨£çš„ä½œæ³•ï¼š\nD_4 = 4!-C^4_1\\cdot3!+C^4_2\\cdot2!-C^4_3\\cdot1!+C^4_4\\cdot0! = 9é€™é‚Šå¯ä»¥è§€å¯Ÿåˆ°ä¸€å€‹é‡è¦çš„è¦å¾‹ï¼Œéšä¹˜çš„éæ¸›ã€Cå–çš„æ•¸å­—éå¢ä»¥åŠæ­£è² äº¤æ›¿ï¼Œé€™äº›æ€§è³ªæœƒè¢«ç”¨åœ¨ç­‰ä¸€ä¸‹çš„ä¸€èˆ¬åŒ–æ¨å°ï¼\néè¿´è§£ç¬¬ä¸€å€‹å…¬å¼æ˜¯é«˜ä¸­æ•¸å­¸åˆ©ç”¨éè¿´çš„æ¦‚å¿µå¾—åˆ°çš„ï¼š\nD_n=(n-1)(D_{n-1}+D_{n-2})\n            è­‰æ˜ï¼šåœ¨åŸæœ¬ $n-1$ å€‹å…ƒç´ ç•¶ä¸­å–ä¸€å€‹å…ƒç´ è·Ÿæ–°åŠ å…¥çš„å…ƒç´ ï¼ˆç¬¬nå€‹å…ƒç´ ï¼‰åšäº¤æ›ï¼Œå…±æœ‰$C^{n-1}_1$ ç¨®å–æ³•ï¼Œå‡è¨­å–åˆ°çš„å…ƒç´ æ˜¯Kï¼Œå‰‡Kæœ‰ä»¥ä¸‹å…©ç¨®æƒ…æ³ï¼šKæœ¬èº«å³ä¸åœ¨åŸæœ¬çš„ä½ç½®ä¸Šï¼Œè·Ÿæ–°åŠ å…¥çš„å…ƒç´ èª¿æ›äº¦æ˜¯éŒ¯æ’Kåœ¨åŸæœ¬çš„ä½ç½®ä¸Šï¼Œè·Ÿæ–°åŠ å…¥çš„å…ƒç´ èª¿æ›å¾Œå½¢æˆéŒ¯æ’ç¶œåˆä»¥ä¸Šå…©ç¨®ç‹€æ³ï¼Œå¯ä»¥æ¨å¾—ä¸Šé¢çš„å…¬å¼\n          \nç¬¬äºŒå€‹æ˜¯ç¶­åŸºç™¾ç§‘ä¸Šé¢çš„å…¬å¼ï¼š\nD_n = nD_{n-1}+(-1)^né€™ä¸€å€‹å…¬å¼å¯ä»¥ç”±ç­‰ä¸€ä¸‹çš„ä¸€èˆ¬å¼çš„å…¬å¼ï¼ˆä¸‹é¢çš„å…¬å¼è§£ï¼‰æ¨è¨éä¾†ï¼š\n\\begin{split}D_n&=n!\\sum_{k=0}^{n}\\frac{(-1)^k}{k!}\\\\&=n(n-1)!\\sum_{k=0}^{n-1}\\frac{(-1)^k}{k!}+n!\\cdot\\frac{(-1)^n}{n!}\\\\&=nD_{n-1}+(-1)^n\\end{split}ç”¨é€™å…©å€‹éè¿´å¼å¯ä»¥æ¨å¾—ç¬¬né …çš„æ•¸å€¼ï¼Œä¸éæ™‚é–“è¤‡é›œåº¦ä¾ç„¶æ˜¯$O(n)$ï¼Œæƒ³è¦æ±‚å¾—çš„æ˜¯$O(1)$çš„å…¬å¼è§£\nå…¬å¼è§£å…¬å¼è§£å¯ä»¥åˆ©ç”¨å–æ¨åŸç†æ±‚å¾—ï¼Œå¯«æˆä¸€èˆ¬åŒ–çš„å½¢å¼ã€‚å°æ–¼ç¬¬né …çš„éŒ¯æ’æ•¸å¯ä»¥åˆ©ç”¨ä¹‹å‰è§€å¯Ÿåˆ°æ’å®¹åŸç†çš„è¦å¾‹æ•´ç†å‡ºä»¥ä¸‹å¼å­ï¼š\n\\begin{split}D_n&=n!-C^n_1(n-1)!+C^n_2(n-2)!-\\cdots+C^n_n0!\\\\&=\\sum^n_{k=0}C^n_k(n-k)!\\cdot(-1)^k\\\\&=\\sum_{k=0}^{n}\\frac{n!}{k!(n-k)!}\\cdot(n-k)!\\cdot(-1)^k\\\\&=n!\\sum^{n}_{k=0}\\frac{(-1)^k}{k!}\\end{split}é€™å€‹å°±æ˜¯éŒ¯æ’æ•¸çš„ä¸€èˆ¬åŒ–å…¬å¼ï¼Œå¦‚æœæƒ³è¦æŠŠsigmaæ¶ˆæ‰ï¼Œé‚„å¯ä»¥ç”¨ä»¥ä¸‹è™•ç†ï¼š\n\\begin{split}D_n&=n!\\sum^{n}_{k=0}\\frac{(-1)^k}{k!}\\\\&=n![1-\\frac{1}{1!}+\\frac{1}{2!}-\\cdots+(-1)^n\\frac{1}{n!}]\\end{split}æ ¹æ“šæ³°å‹’å…¬å¼ï¼ˆ$R_n$ç‚ºä¿®æ­£é …ï¼‰\n\\begin{split}e^{-1}&=1+\\frac{(-1)^1}{1!}+\\frac{(-1)^2}{2!}+\\cdots+(-1)^n\\frac{1}{n!}+R(n)\\\\&=[1-\\frac{1}{1!}+\\frac{1}{2!}-\\cdots+(-1)^n\\frac{1}{n!}]+R(n)\\end{split}å› ç‚ºæ³°å‹’å…¬å¼ï¼Œä¸­æ‹¬è™Ÿå…§çš„æ•¸å€¼åœ¨nè¶Šå¤§æ™‚æœƒè¶Šæ¥è¿‘$e^{-1}$ï¼Œå› æ­¤å¯ä»¥æ”¹å¯«æˆä»¥ä¸‹å¼å­ï¼š\n\\begin{split}D_n \\cong n!\\cdot e^{-1}\\to\\frac{D_n}{n!}\\cong e^{-1}\\end{split}é€™å°±æ˜¯næ¨£ç‰©å“éŒ¯æ’çš„æ©Ÿç‡ï¼Œé‚£å› ç‚ºé€™åªæ˜¯è¿‘ä¼¼å€¼ï¼Œç”±æ–¼æ­£è² äº¤æ›¿ï¼Œæ•¸å€¼æœƒåœ¨$e^{-1}$ çš„åœ°æ–¹éœ‡ç›ªã€‚ç‚ºäº†è¦æ±‚å‡ºç¢ºåˆ‡çš„$D_n$çš„è§£ï¼Œæˆ‘å€‘è¦åœ¨å¾Œé¢åŠ ä¸Šä¸€å€‹ä¿®æ­£é …ï¼ˆæ³°å‹’å±•é–‹é¤˜é …$R_n$ï¼‰ï¼Œç¶“éæ•´ç†ç™¼ç¾é€™å€‹é¤˜é … $\\frac{1}{n+1}$ æœƒåš´æ ¼å°æ–¼ $0.5$ï¼Œå› æ­¤å¾—åˆ°ä»¥ä¸‹çš„ä¸€èˆ¬é …å…¬å¼ï¼š\nD_n=\\lfloor\\frac{n!}{e}+0.5\\rfloorä»¥ä¸Šå°±æ˜¯å°æ–¼ä¸€èˆ¬é …$D_n$ çš„ä¸€èˆ¬é …å…¬å¼ï¼\nå¯¦éš›æ¨¡æ“¬åˆ©ç”¨ggbçš„æ¨¡æ“¬åšå‡ºéœ‡ç›ªçš„æ•ˆæœï¼Œæˆ‘æ˜¯ç›´æ¥è¼¸å…¥ä¸€èˆ¬åŒ–çš„å…¬å¼ï¼Œä½†è¨è«–nä¸æ˜¯æ­£æ•´æ•¸çš„æƒ…æ³å…¶å¯¦æ²’æœ‰æ„ç¾©ï¼Œä¸éç¨‹å¼é‚„æ˜¯å¯ä»¥è·‘å‡ºä¸€å€‹æ•¸å€¼å¦‚ä¸‹ï¼š\næœ€å¾Œæœƒè¶¨è¿‘æ–¼$e^{-1}\\cong0.36787944$å› ç‚ºæˆ‘å€‘è¨è«–çš„éƒ½æ˜¯æ•´æ•¸è§£çš„ç‹€æ³ï¼Œåˆ©ç”¨python æ¨¡æ“¬å‡ºæ­£æ•´æ•¸è§£çš„æƒ…æ³ï¼š\nå°å‡ºnå¾ä¸€åˆ°20çš„è·Ÿ$e^{-1}$çš„å·®è·ï¼Œå¯ä»¥çœ‹åˆ°æœ‰æ­£è² äº¤æ›¿çš„æƒ…æ³ï¼Œä¸”æ¯ä¸€æ¬¡çš„å·®è·éƒ½è¶Šä¾†è¶Šå°ï¼š\nä»¥ä¸Šéƒ½æ˜¯è¿‘ä¼¼çš„æƒ…æ³ï¼Œå› ç‚ºå…¬å¼æ˜¯ä¸€å€‹ç„¡çª®ç´šæ•¸ï¼Œåªæœƒè¶Šä¾†è¶Šæ¥è¿‘ç†è«–çš„æ©Ÿç‡ $e^{-1}$ ï¼Œä½†æ°¸é éƒ½æœƒæœ‰ä¸€å€‹å¾®å°çš„å·®è·ï¼Œä¹Ÿå°±æ˜¯ç„¡é™é€¼è¿‘çš„æ¦‚å¿µï¼\nimport numpy as npimport matplotlib.pyplot as pltconst = np.exp(-1)l = [0 for i in range(100)]l[0] = 1for i in range(1,21):    l[i] = l[i-1]*ia = [0 for i in range(100)]a[0] = 0a[1] = 0a[2] = 1a[3] = 2a[4] = 9for i in range(5,21):    a[i]= (a[i-1]+a[i-2])*(i-1)x = []y = []for i in range(1,21):    x.append(i)    y.append((a[i]/l[i]))    print((a[i]/l[i])-const)plt.title(&quot;Possibility to N&quot;, fontsize=20) #åœ–è¡¨æ¨™é¡Œplt.xlabel(&quot;N&quot;, fontsize=16) #xè»¸æ¨™é¡Œplt.ylabel(&quot;Possibility&quot;, fontsize=16) #yè»¸æ¨™é¡Œplt.xticks([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])plt.yticks([0,0.1,0.2,0.3,0.4,0.5,0.6])plt.plot(x,y)plt.show() #é¡¯ç¤ºç¹ªè£½çš„åœ–å½¢\né¡Œç›®â€”P3182 [HAOI2016]æ”¾æ£‹å­é¡Œç›®é€£çµé¡Œç›®æ•˜è¿°æ˜¯é€™æ¨£ï¼š\n\nçµ¦ä½ ä¸€å€‹ NÃ—N çš„çŸ©é™£ï¼Œæ¯è¡Œæœ‰ä¸€å€‹éšœç¤™ï¼Œæ•¸æ“šä¿è­‰ä»»æ„å…©å€‹éšœç¤™ä¸åœ¨åŒä¸€è¡Œï¼Œä»»æ„å…©å€‹éšœç¤™ä¸åœ¨åŒä¸€åˆ—ï¼Œè¦æ±‚ä½ åœ¨é€™å€‹çŸ©é™£ä¸Šæ”¾ N æšæ£‹å­ï¼ˆéšœç¤™çš„ä½ç½®ä¸èƒ½æ”¾æ£‹å­ï¼‰ï¼Œè¦æ±‚ä½ æ”¾ N å€‹æ£‹å­ä¹Ÿæ»¿è¶³æ¯è¡Œåªæœ‰ä¸€æšæ£‹å­ï¼Œæ¯åˆ—åªæœ‰ä¸€æšæ£‹å­çš„é™åˆ¶ï¼Œæ±‚æœ‰å¤šå°‘ç¨®æ–¹æ¡ˆã€‚ç¬¬ä¸€è¡Œä¸€å€‹Nï¼Œæ¥ä¸‹ä¾†ä¸€å€‹N*Nçš„çŸ©é™£ã€‚nâ‰¤200ï¼Œ0 è¡¨ç¤ºæ²’æœ‰éšœç¤™ï¼Œ1 è¡¨ç¤ºæœ‰éšœç¤™ï¼Œè¼¸å‡ºä¸€å€‹æ•´æ•¸ï¼Œå³åˆæ³•çš„æ–¹æ¡ˆæ•¸ã€‚\n\né€™ä¸€é¡Œæ˜¯åœ¨æ•´ç†éŒ¯æ’ç›¸é—œå…¬å¼çš„æ™‚å€™ç™¼ç¾é€™ä¸€é¡Œï¼Œå¾ˆæ˜é¡¯çš„ï¼Œéšœç¤™ç‰©ä»£è¡¨åŸä¾†çš„ä½ç½®ï¼Œæ‰€ä»¥å…¶å¯¦è¦æ±‚çš„å°±æ˜¯nå€‹å…ƒç´ çš„éŒ¯æ’ç¨®é¡ã€‚å› ç‚ºé€™ä¸€é¡Œçš„$nâ‰¤200$ï¼Œç¬¬200é …çš„å€¼æœƒæ¥è¿‘$200!$çš„é‡ç´šï¼Œå¤§ç´„æ˜¯$10^{374}$ é€™éº¼å¤šï¼Œå°å¤§æ•¸åŠ æ³•ä¹˜æ³•ä¾†èªªå»æ˜¯è¼•è€Œæ˜“èˆ‰ï¼å¯ä»¥ç”¨D_n = nD_{n-1}+(-1)^nçš„éè¿´å…¬å¼ï¼Œæ™‚é–“è¤‡é›œåº¦$O(n)$çš„æ™‚é–“ï¼ˆæŠŠå¤§æ•¸é‹ç®—ç•¶ä½œ$O(1)$ä½†å…¶å¯¦å®ƒçš„å¸¸æ•¸ç®—å¤§ï¼‰æ±‚å‡ºç­”æ¡ˆï¼\nå¦‚æœæƒ³çœ‹å¾3å€‹å…ƒç´ åˆ°200å€‹å…ƒç´ çš„éŒ¯æ’ç¸½æ•¸ï¼Œå¯ä»¥é»é€™è£¡ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,c[1000],lenc=0;int power(int x)&#123;    if(x%2==0)return 1;    else return -1;&#125;void calculate(int s,string x)&#123;    int lenn = x.size(),product[lenc+lenn+10],brr[lenn+5];    memset(product,0,sizeof(product));    memset(brr,0,sizeof(brr));    for(int i=0;i&lt;lenn;i++)brr[i] = x[lenn-i-1]-&#x27;0&#x27;;    for(int i=0;i&lt;lenn;i++)&#123;        for(int j=0;j&lt;lenc;j++)&#123;            product[i+j] += brr[i]*c[j];            if(product[i+j] &gt;= 10)&#123;                product[i+j+1] += product[i+j]/10;                product[i+j] %= 10;            &#125;        &#125;    &#125;    for(int i=lenc+lenn+9;i&gt;=0;i--)&#123;        if(product[i]!=0)&#123;            lenc = i+1;            break;        &#125;    &#125;    for(int i=0;i&lt;lenc;i++)c[i] = product[i];    c[0] += power(s);    if(c[0]==10)&#123;        c[0] = 0;        c[1] += 1;        int ind = 1;        while(c[ind]&gt;=10)&#123;            c[ind+1]+=1;c[ind] = 0;            ind++;        &#125;    &#125;    else if(c[0]==-1)&#123;        c[0] = 9;        c[1] -= 1;        int ind = 1;        while(c[ind]&lt;=-1)&#123;            c[ind+1]-=1;c[ind]=9;            ind++;        &#125;    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;n;    memset(c,0,sizeof(c));    if(n==1)cout&lt;&lt;0&lt;&lt;endl;    else if(n==2)cout&lt;&lt;1&lt;&lt;endl;    else&#123;        c[0] = 1;lenc=1;        for(int i=3;i&lt;=n;i++)&#123;            string temp = to_string(i);            calculate(i,temp);        &#125;        for(int i=lenc-1;i&gt;=0;i--)cout&lt;&lt;c[i];        cout&lt;&lt;endl;    &#125;&#125;\nçµè«–æ•´ç†ä¸€ä¸‹ä¸Šé¢æåˆ°éŒ¯æ’æ•¸çš„å…¬å¼ï¼š\néè¿´D_n = (n-1)(D_{n-1}+D_{n-2})\\quad,n\\ge3\\\\D_n = nD_{n-1}+(-1)^n\\quad,n\\ge2ä¸€èˆ¬é …å…¬å¼è§£D_n=\\lfloor\\frac{n!}{e}+0.5\\rfloor\\quad,n\\ge1\\\\D_n=n!\\sum^{n}_{k=0}\\frac{(-1)^k}{k!}\\quad,n\\ge1åˆ†æéŒ¯æ’å•é¡Œæ‰€ç”¨åˆ°çš„æŒ‡æ•¸å‡½æ•¸èˆ‡æ³°å‹’å±•é–‹æœƒåœ¨ä»¥å¾Œå­¸åˆ°çš„æ™‚å€™æŠŠç›¸é—œæ±è¥¿è£œèµ·ä¾†ï¼Œåœ¨é€™ä¹‹å‰å°±å…ˆæ¥å—çµè«–å§ï¼æ­æ‹‰ï¼šã€ŒéŒ¯æ’å•é¡Œçµ„åˆæ•¸å­¸ä¸­çš„ä¸€å€‹å¥‡å¦™å•é¡Œã€ï¼Œå¯¦éš›æŸ¥æ‰¾è³‡æ–™ç™¼ç¾åˆ°é«˜ä¸­æ•™éŒ¯æ’ä¹Ÿåªæ˜¯æ·ºæ·ºçš„å¸¶éå…¬å¼ï¼Œä¸¦æ²’æœ‰å¾ˆæ·±åˆ»çš„å°é€™å€‹å•é¡Œåšè¨è«–ï¼ˆä¹Ÿç®—è¶…å‡ºç¯„åœå•¦ï¼‰ï¼Œå°±æƒ³èªªå°é€™å€‹ä¸»é¡Œåšæ›´æ·±å…¥çš„ä¸€äº›æ¢è¨ï¼\né™„éŒ„ä¸€äº›çš„æ•¸å­¸è­‰æ˜ï¼š\nè¦ç”¨python ç¹ªåœ–ä¹‹å‰è¦å…ˆåœ¨macçµ‚ç«¯å®‰è£ä¸€äº›æ±è¥¿ï¼š\npython3 -m pip install numpypython3 -mpip install matplotlib\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","2021æš‘å‡ç­†è¨˜"]},{"title":"äºŒç¶­éƒ½åœå‹’æ•ˆæ‡‰æ¨¡æ“¬å¯¦é©—è¨ˆç•«","url":"/doppler/","content":"å¯¦é©—å™¨æ\néº¥å…‹é¢¨ä¸€æ”¯\nèœ‚é³´å™¨ä¸€æš\nåœ“å½¢è½‰ç›¤(å»ºä¸­å¯¦é©—å®¤)\nç­†é›»ä¸€å°(è£å¥½è²éŸ³è™•ç†è»Ÿé«”ï¼Œä¸¦ç¢ºä¿å¯ä»¥é€£ä¸Šéº¥å…‹é¢¨)\n\n\nç†è«–éƒ¨åˆ†æ•´ç†ä¸€äº›æœƒç”¨åˆ°çš„ç‰©ç†å…¬å¼ã€åè©ç­‰ã€‚åœ¨å°è«–æ–‡ä¸­ï¼Œæˆ‘å€‘ç¸½å…±åšäº†è§’åº¦å°é »ç‡çš„é—œä¿‚åœ–ï¼Œä»¥åŠé »ç‡å°æ™‚é–“çš„é—œä¿‚åœ–ï¼Œæˆ‘å€‘åœ¨å¯¦é©—ä¸­ä¸»è¦æœƒç”¨åˆ°çš„æ˜¯é »ç‡å°æ™‚é–“çš„é—œä¿‚åœ–ï¼Œå…¶å¯¦æœ€é‡è¦çš„é‚„æ˜¯é »ç‡çš„æœ€å¤§å€¼èˆ‡æœ€å°å€¼ã€‚\nå¯¦é©—åšå®Œä»¥å¾Œï¼Œæœƒçµåˆæˆ‘å€‘å°è«–æ–‡æœ€å¾Œä¸€éƒ¨åˆ†:ç†è«–èˆ‡æ¨¡æ“¬çš„æ¯”è¼ƒé€™ä¸€å€‹éƒ¨åˆ†ï¼Œçµåˆå¯¦é©—ï¼Œåšå‡ºæ›´è©³ç›¡ï¼Œæœ‰èªªæœåŠ›çš„è«–è¿°ã€‚\néƒ½åœå‹’æ•ˆæ‡‰å…¬å¼å› ç‚ºæ˜¯åšæ™‚é–“å°ä¸Šé »ç‡çš„é—œä¿‚åœ–ï¼Œå› æ­¤æˆ‘å€‘è¦ç”¨çš„å°±æ˜¯ä¸€èˆ¬ä¸€ç¶­çš„éƒ½åœå‹’æ•ˆæ‡‰å…¬å¼ã€‚å…ˆå®šç¾© $fâ€™$ ç‚ºè§€å¯Ÿè€…(éœæ­¢)æ‰€è§€æ¸¬åˆ°çš„é »ç‡ï¼Œ$f$ ç‚ºèœ‚é³´å™¨ç™¼å°„å‡ºä¾†çš„é »ç‡ï¼Œ$v$ ç‚ºè²éŸ³çš„æ³¢é€Ÿï¼Œ$v_s$ ç‚ºèœ‚é³´å™¨ç›¸å°æ–¼ä»‹è³ªçš„ç§»å‹•é€Ÿåº¦ã€‚ä»¥ä¸‹å…¬å¼ï¼š\nf' = \\frac{v}{v+v_s}\\cdot fæ³¨æ„åˆ° $v_s$ è¦ä»£å…¥çš„æ˜¯åˆ‡ç·šé€Ÿåº¦(åˆ°æ™‚å€™æœƒç”¨è§’é€Ÿåº¦æ›ç®—è€Œä¾†)  \nè§’é€Ÿåº¦èˆ‡åˆ‡ç·šé€Ÿåº¦\nè§’é€Ÿåº¦ $\\omega$ ä»£è¡¨çš„æ˜¯ä¸€ç§’å…§èƒ½å¤ è½‰å‹•çš„å¼§åº¦å¤šå°‘ï¼Œå…¶å–®ä½ç‚º $\\frac{rad}{s}$ ï¼Œè¦æ³¨æ„çš„æ˜¯å¼§åº¦æ²’æœ‰å–®ä½!å¾å®šç¾©å¯ä»¥æ¨å°å‡ºä»¥ä¸‹å…¬å¼ï¼š\n\\omega = \\frac{\\Delta \\theta}{\\Delta t}è€Œæ ¹æ“šå¼§åº¦çš„å®šç¾©ï¼Œæˆ‘å€‘çŸ¥é“ $\\theta = \\frac{S}{r}$ ï¼Œå¦‚æœè¦æ±‚å‡ºåˆ‡ç·šé€Ÿåº¦ $v$ ï¼Œæˆ‘å€‘å¯ä»¥åˆ—å‡ºä»¥ä¸‹å¼å­ï¼š\nv = \\frac{d \\, S}{d \\,t}æ›å¥è©±èªªå°±æ˜¯å°è·é›¢ä½œå¾®åˆ†å¾—åˆ°æ™‚é–“ã€‚å…¶ä¸­ $S = r\\cdot\\theta$ï¼Œä»£å…¥ä¹‹å¾Œå¾—åˆ°ï¼š\nv = \\frac{r\\times \\Delta\\theta}{\\Delta t} = r\\cdot \\omegaæœ‰äº†åˆ‡ç·šé€Ÿåº¦ä¹‹å¾Œï¼Œå°±å¯ä»¥ç›´æ¥ä»£å…¥éƒ½åœå‹’æ•ˆæ‡‰å…¬å¼ä¸­èœ‚é³´å™¨ $v_s$ ç®—å‡ºé »ç‡äº†!\nä¸ç¢ºå®šåº¦ä¸ç¢ºå®šåº¦å¯ä»¥åˆ†æˆ A é¡ä¸ç¢ºå®šåº¦ä»¥åŠ B é¡ä¸ç¢ºå®šåº¦ï¼Œä»¥ $u_A,u_B$ è¡¨ç¤ºã€‚å…¶ä¸­ A é¡ä¸ç¢ºå®šåº¦çš„å…¬å¼ï¼š\n\nB é¡å‰‡æ˜¯ç”¨å„€å™¨çš„æœ€å°åˆ»åº¦ä¹˜ä¸Š$\\frac{1}{2\\sqrt{3}}$ï¼Œåˆ°æ™‚å€™çœ‹çœ‹éº¥å…‹é¢¨çš„è¦æ ¼å†ä¾†ç®—ä¸€ä¸‹ã€‚è€Œæœ‰äº†é€™å…©å€‹ä¸ç¢ºå®šåº¦ä¹‹å¾Œï¼Œå°±è¦ç®—çµ„åˆä¸ç¢ºå®šåº¦ï¼š\nu = \\sqrt{u_A^2+u_B^2}ç®—ä¸ç¢ºå®šåº¦éƒ½æ˜¯å–æœ‰æ•ˆä½æ•¸å…©ä½ï¼Œæœ€ä½³ä¼°è¨ˆå€¼å°é½Šä¸ç¢ºå®šåº¦çš„ä½æ•¸ã€‚å¯«æˆçµæœ X = æœ€ä½³ä¼°è¨ˆå€¼ Â± ä¸ç¢ºå®šåº¦çš„å½¢å¼ã€‚\nå¯¦é©—æµç¨‹\nè¨­å®šè½‰ç›¤è½‰é€Ÿã€èœ‚é³´å™¨æ—‹è½‰åŠå¾‘(å¯ä»¥å›ºå®šèˆ‡è§€å¯Ÿè€…çš„è·é›¢ï¼Œå› ç‚ºé€™å€‹è·é›¢å°é »ç‡ä¸æœƒæœ‰å½±éŸ¿)\nè½‰å‹•æ—‹è½‰åœ“ç›¤ï¼Œç”¨éº¥å…‹é¢¨æ¥æ”¶é »ç‡ï¼Œä¸¦è¼¸å…¥è»Ÿé«”ä¹‹å¾Œç•«å‡ºf-tåœ–(å…ˆæ‰¾å‡ºèœ‚é³´å™¨åœ¨å“ªä¸€å€‹é »ç‡å€é–“çš„è²éŸ³æ˜¯æœ€å¤§è²çš„)\næ‰¾å‡ºæ¯ä¸€çµ„æ•¸æ“šä¸­é »ç‡çš„æœ€å¤§å€¼ä»¥åŠæœ€å°å€¼ï¼Œä¸¦èˆ‡ç†è«–ä½œæ¯”è¼ƒ\n\né æœŸå‘ˆç¾æ–¹å¼(å¯¦é©—è¡¨æ ¼)é€™å€‹è¡¨æ ¼æ˜¯è§’é€Ÿåº¦å°ä¸Šèœ‚é³´å™¨çš„æ—‹è½‰åŠå¾‘(å…¬åˆ†)çš„åœ–ï¼Œè¡¨æ ¼è£¡é¢çš„æ•¸å­—å‰‡æ˜¯åˆ‡ç·šé€Ÿåº¦(å…¬åˆ†/ç§’ï¼Œå¯èƒ½é‚„è¦åšä¸€äº›å–®ä½çš„æ›ç®—ä¹‹å¾Œä»£å…¥å…¬å¼)ï¼š\n\n\n\n\nw-r\n2.5\n5\n7.5\n10\n\n\n\n\n1Ï€\n2.5Ï€\n5Ï€\n7.5Ï€\n10Ï€\n\n\n2Ï€\n5Ï€\n10Ï€\n15Ï€\n20Ï€\n\n\n3Ï€\n7.5Ï€\n15Ï€\n22.5Ï€\n30Ï€\n\n\n4Ï€\n4Ï€\n20Ï€\n30Ï€\n40Ï€\n\n\n\n\né€™æ˜¯ç†è«–ç®—å‡ºä¾†çš„çµæœï¼š\næœƒæœ‰å…©å€‹è¡¨æ ¼åˆ†åˆ¥æ˜¯ç†è«–çš„é »ç‡æœ€å¤§ã€æœ€å°å€¼ï¼Œä»¥åŠå¯¦é©—è¡¨æ ¼è¦å¡«å…¥è§€å¯Ÿçš„çµæœ(ç”¨Audacityåˆ†æ)ï¼Œå½¢å¼å¤§æ¦‚å°±æ˜¯é•·æˆä¸Šè¡¨é€™æ¨£ã€‚\n\næœ€å¾Œï¼Œæˆ‘å€‘æ‰“ç®—å›ºå®šè½‰å‹•çš„é€Ÿåº¦(è§’é€Ÿåº¦)ï¼Œç•«å‡ºé »ç‡å°ä¸ŠåŠå¾‘çš„åœ–å½¢(xåº§æ¨™ç‚ºåŠå¾‘ã€yåº§æ¨™ç‚ºé »ç‡)ï¼Œç”¨å…©æ¢ç›´ç·šè¡¨ç¤ºç†è«–å’Œå¯¦éš›æ¸¬é‡çš„çµæœã€‚\nç¨‹å¼éƒ¨åˆ†ç¨‹å¼ç¢¼é€£çµ\nå°‡ä¹‹å‰çš„ç¨‹å¼ç¢¼çš„æ•¸å­—æ”¹æˆç¬¦åˆçœŸå¯¦ç‹€æ³ä¹‹å¾Œï¼Œåœ–ç•«å‡ºä¾†çš„æ•ˆæœå¾ˆç³Ÿï¼Œå› ç‚ºä¹‹å‰éƒ½æ˜¯ä»¥å…¬å°ºç‚ºå–®ä½ï¼Œç•¶è™•ç†åˆ°ä»¥å…¬åˆ†ç‚ºå–®ä½çš„ç´°å¾®è®ŠåŒ–æ™‚ï¼Œå°±æœƒè·‘å‡ºå¾ˆç³Ÿç³•çš„åœ–å½¢ã€‚å› æ­¤ï¼Œæˆ‘å€‘å°‡ä¹‹å‰çš„ç¨‹å¼ç¢¼çš„æ™‚é–“è®ŠåŒ–dtæ”¹æˆ $10^{-8}$ï¼Œä½¿æ¯ä¸€æ¬¡çš„æ³¢çš„ä½ç§»é‡ç›¡é‡å°ï¼Œæ‰èƒ½è®“çµæœæ›´ç²¾æº–ã€‚\né€™æ˜¯æœ‰bugä¸€é–‹å§‹çš„é†œé™‹åœ–å½¢ï¼š\n\nåŠ ä¸Šäº†ä¸€é»æ™‚é–“å»¶é²çš„è™•ç†ä¹‹å¾Œï¼Œè‹¥å¸¶å…¥ä¸Šé¢çš„æ•¸æ“šï¼Œèˆ‡å…¬å¼æ¨å‡ºä¾†çš„çµæœèª¤å·®æœƒåœ¨æ­£è²  $0.005$ ä¹‹é–“ï¼Œç®—æ™‚è »ç²¾æº–çš„ï¼Œä¾‹å¦‚ä¸‹åœ–ï¼š\n\né€™å€‹æ˜¯ç”¨ $10^{-7}$ ç‚ºé–“éš”çš„åœ–å½¢ï¼Œåœ¨æœ€å¤§æœ€å°å€¼è·Ÿç†è«–æœ‰äº›å°çš„å·®è·ã€‚å› æ­¤ï¼Œåœ¨æ±‚æœ€å¤§æœ€å°å€¼çš„æ™‚å€™ï¼Œæœƒä»¥ $10^{-8}$ ç‚ºé–“éš”ï¼Œç¼ºé»æ˜¯è·‘å¾—å¾ˆæ…¢å°±æ˜¯äº†ï¼Œå› æ­¤æ¡ç”¨ç›´æ¥æŠŠåˆå§‹ä½ç½®è¨­åœ¨ç™¼ç”Ÿé »ç‡æ¥µå€¼é™„è¿‘ï¼Œæ¯”è¼ƒèƒ½å¿«é€Ÿè§€å¯Ÿã€‚\n\nèª¤å·®ç´„ç‚º $3.5\\times 10^{-4}\\%$ å·¦å³ã€‚\nPraatä½¿ç”¨\n            ä½¿ç”¨å…¶ä»–éŸ³é »åˆ†æè»Ÿé«”å‰›å‰›ä¸‹è¼‰äº†Sonic Visualizer æ¸¬è©¦çœ‹çœ‹ï¼Œæœç„¶å¯ä»¥åˆ†ææ¯ä¸€å€‹æ™‚é–“é»ä¸­ï¼Œå„å€‹é »ç‡çš„å¼·åº¦ç‚ºä½•ã€‚æˆ‘å…ˆç”¨æ‰‹æ©Ÿæ’­æ”¾400HZä»¥åŠ4000HZçš„è²éŸ³ã€‚ä¸‹åœ–å°±æ˜¯400HZçš„æ³¢æ®µï¼Œå¯ä»¥çœ‹åˆ°åœ¨å°æ‡‰çš„é »ç‡å¼·åº¦æœ€å¼·ï¼Œå…¶ä»–æ‡‰è©²å°±æ˜¯èƒŒæ™¯é›œéŸ³çš„éƒ¨åˆ†ã€‚é€™æ˜¯4000HZçš„åœ–å½¢ï¼Œä½†ä»–å¥½åƒæ²’è¾¦æ³•å®Œå…¨åšåˆ°æ™‚é »åœ–ã€‚ä¸çŸ¥é“é€™å€‹åŠŸèƒ½å¯ä¸å¯ä»¥ä½¿ç”¨ï¼Œä¸‹é¢çš„åœ–å½¢ä¸­ï¼Œç¸±è»¸è¡¨ç¤ºçš„æ˜¯é »ç‡ï¼Œæ©«è»¸æ˜¯æ™‚é–“ï¼Œä¹Ÿå°±æ˜¯æ™‚é »åœ–ï¼Œç”¨ä¸åŒé¡è‰²ä¾†å€åˆ†è²éŸ³çš„å¤§å°ã€‚å¯ä»¥çœ‹åˆ°å‰åŠéƒ¨åˆ†é»ƒè‰²ç·šæ˜¯æ˜é¡¯çš„400HZï¼Œè€Œå¾Œé¢æœ‰ä¸€æ®µç”±å¥½å¤šå€‹é»æ§‹æˆçš„ç·šæ®µï¼ˆä¸å¤ªæ˜é¡¯ï¼Œå¯èƒ½æ˜¯è²éŸ³ä¸å¤ å¤§çš„çµæœï¼‰å‰‡æ˜¯4000HZã€‚å¦‚æœè¦åˆ†æé€™äº›çš„è©±ï¼Œé‚£é™¤äº†è²éŸ³è¦å¤ å¤§ä¹‹å¤–ï¼Œé »ç‡è®ŠåŒ–è¦æ˜é¡¯æ‰èƒ½çœ‹å¾—å‡ºå·®åˆ¥ã€‚\n          \nä¸Šç¶²æŸ¥äº†ä¸€ä¸‹ç™¼ç¾ Audacity å¥½åƒç„¡æ³•ç•«å‡ºæ™‚é »åœ–(ç ”ç©¶å¾ˆä¹…éƒ½æ²’æœ‰çµæœ)ï¼Œæ‰€ä»¥æ‰¾åˆ°äº† Praat é€™å€‹æ‡‰ç”¨ç¨‹å¼ï¼Œè€Œç¶“éä¸€ç¿»ç ”ç©¶å¾Œçš„ç¢ºå¯ä»¥ç•«å‡ºé »è­œåœ–ã€‚\næˆ‘å€‘è‡ªå·±éŒ„äº†ä¸€å°æ®µç”¨æ‰‹æ©Ÿæ’­æ”¾å‡ºä¾†çš„éŸ³é »ï¼Œåˆ†æå¾Œçš„çµæœå¤§æ¦‚å¦‚ä¸‹åœ–ï¼š\néŸ³æª”åˆ†æçµæœï¼š\nç¶“éå¯¦é©—æ¸¬è©¦ï¼Œæœªä¾†å°‡ä»¥éº¥å…‹é¢¨æ”¶éŸ³å¾Œå‚³å…¥ Audacityï¼ŒåŒ¯å‡ºæˆéŸ³æª”å¾Œå‚³é€² Praat å¾Œé€²è¡Œåˆ†æã€‚\nç›®å‰å›°å¢ƒ\n[ ] å˜—è©¦ä½¿ç”¨ Arduino çš„èœ‚é³´å™¨ï¼Œå¤ªå°è²ï¼Œå¿…é ˆè²·å¤§è²ä¸€é»çš„èœ‚é³´å™¨(å‡ºè²¨ä¸­)ã€‚\n\n[ ] è·Ÿæ“šç†è«–é æ¸¬ï¼Œé »ç‡è®ŠåŒ–çš„é‡ä¸å¤ªæ˜é¡¯ï¼Œå¿…é ˆä½¿ç”¨é »ç‡è¼ƒé«˜çš„èœ‚é³´å™¨æ‰èƒ½è®“é »ç‡æœ€å¤§å€¼æœ€å°å€¼çš„å·®è·æ”¾å¤§ï¼Œæˆ–è®Šå¾—æ›´é¡¯è‘—ã€‚ä¸éé‚„æ˜¯æœƒæ“”å¿ƒèªªé »ç‡çš„è®ŠåŒ–æœƒä¸æ˜é¡¯ï¼Œåªèƒ½ç­‰å¯¦éš›åšåšçœ‹å¯¦é©—æ‰çŸ¥é“ã€‚ç›®å‰æ‰“ç®—ç”¨ä¸€å€‹4000HZçš„èœ‚é³´å™¨é€²è¡Œå¯¦é©—ï¼Œå¸Œæœ›åœ¨é »ç‡è¡¨ç¾ä¸Šå¯ä»¥æ›´åŠ æ˜é¡¯(çœ‹åˆ°æœ‰å¤§å­¸å¯¦é©—å®¤æ˜¯åˆ©ç”¨ 40kHz é€²è¡Œå¯¦é©—ï¼Œæ‰€ç”¢ç”Ÿçš„é »ç‡è®ŠåŒ–æ‡‰è©²æœƒæ˜é¡¯è¨±å¤š)\n\n\nå¯¦é©—çµæœV = 30,R = 5\nV = 60,R = 5\nV = 90,R = 5\nV = 30,R = 10\nV = 60,R = 10\nV = 90,R = 10\nâ€”&gt;\n5cm éœæ­¢\n5cm v = 30\n5cm v = 60\n5cm v = 90\n10cm éœæ­¢\n10cm v = 30\n10cm v = 60\n10cm v = 90\n","categories":["ç¨‹å¼æ¨¡æ“¬"],"tags":["æ•¸å­¸","å°ˆé¡Œ"]},{"title":"[é¡Œè§£]TIOJ 1354 æ± å¡˜è£¡çš„é’è›™","url":"/dp2-1/","content":"tioj-1354 æ± å¡˜è£¡çš„é’è›™\né¡Œåºé€™æ˜¯ä¸€å€‹æ’åˆ—çµ„åˆçš„æ•¸å­¸é¡Œç›®ï¼Œé€éå‹•æ…‹è¦åŠƒç´€éŒ„å°å•é¡Œçš„ç­”æ¡ˆ\nå®šç¾©å®šç¾©$dp[i][0]$ç‚ºè·³iæ¬¡ä¸å›åˆ°Açš„æ–¹æ³•æ•¸ï¼Œ$dp[i][1]$ç‚ºè·³iæ¬¡å›åˆ°Açš„æ–¹æ³•æ•¸\nè½‰ç§»æ–¹å¼\n$dp[i][1]$ = $dp[i-1][0]$æ‡‰è©²ä¸é›£ç†è§£ï¼Œå›åˆ°Açš„æ–¹æ³•æ•¸ç‚ºä¸Šä¸€æ¬¡ä¸å›åˆ°Açš„æ–¹æ³•æ•¸ * 1\n$dp[i][0] = 3\\times dp[i-1][1]+2\\times dp[i-1][0]$ä¸å›åˆ°Aå¯ä»¥åˆ†ç‚º2ç¨®æƒ…æ³ï¼Œä¸Šä¸€æ¬¡å›åˆ°Aä¹‹å¾Œï¼Œå¯ä»¥å¾€B,C,Dï¼Œå…±ä¸‰ç¨®æƒ…æ³ã€‚ä¸Šä¸€æ¬¡ä¸å›åˆ°Açš„æƒ…æ³ä¸­ï¼Œæ¯ä¸€å€‹éƒ½æœ‰å…©å€‹å¯ä»¥å»çš„åœ°æ–¹ã€‚\n\né‚Šç•Œæ¢ä»¶$dp[0][1] = 0, dp[0][0] = 1$\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t,k;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;k;        int dp[k+1][2];        memset(dp, 0, sizeof(dp));        dp[0][0] = 0;dp[0][1] = 1;        for(int i=1;i&lt;=k;i++)&#123;            dp[i][1] = dp[i-1][0];            dp[i][0] = 3*dp[i-1][1]+2*dp[i-1][0];        &#125;        cout&lt;&lt;dp[k][1]&lt;&lt;endl;    &#125;&#125;\nè¤‡é›œåº¦\n            é€™ä¸€é¡Œå¾ˆè¨å­çš„ï¼Œæ²’æœ‰çµ¦å®šæ¸¬è³‡çš„ç¯„åœï¼Œä¸ç„¶æ‡‰è©²æ˜¯å¯ä»¥ç›´æ¥å»ºè¡¨ç„¶å¾Œç”¨O(1)çš„è¤‡é›œåº¦æ±‚ç­”æ¡ˆ\n          \n","categories":["DPé¡Œè§£"],"tags":["é¡Œè§£","DP"]},{"title":"DPå•é¡Œ-ç¶“å…¸é¡Œå­¸ç¿’","url":"/dp1/","content":"å‹•æ…‹è¦åŠƒçš„è¦ç´ å¯ä»¥å‹•æ…‹è¦åŠƒçš„å•é¡Œç¬¦åˆå…©å€‹æ¢ä»¶\né‡è¤‡å­å•é¡Œ\nå¯åˆ†æ²»æ€§\n\nå‹•æ…‹è¦åŠƒçš„ä¸‰è¦ç´ \n0.å®šç¾©\n1.ç‹€æ…‹è½‰ç§»æ–¹å¼\n2.åˆå§‹ç‹€æ…‹ï¼ˆé‚Šç•Œæ¢ä»¶ï¼‰\n\n\nå‹•æ…‹è¦åŠƒæ‡‰æ³¨æ„çš„å•é¡Œ\nè½‰ç§»æ–¹å¼ï¼šTop-Down or Bottom-up\nè¤‡é›œåº¦=ç‹€æ…‹æ•¸*è½‰ç§»æ™‚é–“\nè½‰ç§»é †åº\n\n[IOI 1994] ä¸‰è§’æ—…è¡Œ\n0.å®šç¾©å®šç¾©é™£åˆ—dp[i][j]ç‚ºèµ°åˆ°ç¬¬ i æ©«æ’ç¬¬ j æ ¼çš„æ™‚å€™å¯èƒ½çš„æœ€å¤§å€¼ã€‚\n1.è½‰ç§»æ–¹å¼ç¬¬ i æ©«æ’ç¬¬ j æ ¼çš„è§£ç‚ºï¼šã€Œç¬¬ i+1 æ©«æ’ç¬¬ j æ ¼ã€èˆ‡ã€Œç¬¬ i+1 æ©«æ’ç¬¬ j+1 æ ¼ã€çš„æœ€å¤§å€¼ï¼ŒåŠ ä¸ŠåŸæœ¬ç¬¬ i æ©«æ’ç¬¬ j æ ¼çš„å€¼ã€‚ä»¥ç¯„æ¸¬ç‚ºä¾‹:è½‰ç§»ç¨‹å¼ç¢¼ï¼š\ndp[i][j] = max(dp[i+1][j],dp[i+1][j+1])+arr[i][j];\n2.é‚Šç•Œæ¢ä»¶æˆ‘æ˜¯å¾ç¬¬ n-1 å±¤é–‹å§‹dpè½‰ç§»ï¼Œæ‰€ä»¥é‚Šç•Œå°±æ˜¯ç¬¬ n å±¤çš„æ‰€æœ‰å…ƒç´ \nfor(int i=0;i&lt;n;i++)    dp[n-1][i] = arr[n-1][i];\nè€Œç­”æ¡ˆå³ç‚ºdp[0][0]ï¼Œä¹Ÿå°±æ˜¯ä¸‰è§’å½¢çš„é ‚ç«¯\nç¨‹å¼ç¢¼#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int n,dp[105][105] = &#123;0&#125;,arr[105][105] = &#123;0&#125;;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)        for(int j=0;j&lt;=i;j++)cin&gt;&gt;arr[i][j];        for(int i=0;i&lt;n;i++)dp[n-1][i] = arr[n-1][i];        for(int i=n-2;i&gt;=0;i--)&#123;        for(int j=0;j&lt;=i;j++)&#123;            dp[i][j] = max(dp[i+1][j],dp[i+1][j+1])+arr[i][j];        &#125;    &#125;    cout&lt;&lt;dp[0][0]&lt;&lt;endl;&#125;\næœ€å¤§å­é™£åˆ—leetcode 53æš´åŠ›è§£ï¼ˆO(n^2^)ï¼‰æˆ–æ˜¯ç”¨å‹•æ…‹è¦åŠƒè™•ç†ï¼ˆO(n)ï¼‰æ–¹æ³•ï¼šåˆ©ç”¨è®Šæ•¸ sum åŠ ç¸½a[0],a[1] åˆ° a[n-1]ï¼Œåœ¨åŠ ç¸½éç¨‹ä¸­ï¼Œå¦‚æœå‡ºç¾è² æ•¸ï¼Œå‰‡ä»£è¡¨å°æœ€å¤§å­é™£åˆ—æ²’æœ‰å¹«åŠ©ï¼ˆåªæœƒè¶Šä¾†è¶Šå°‘ï¼Œæ‰€ä»¥æ¨æ£„ï¼‰ï¼Œå‰‡è®“sum=0 ï¼Œç¹¼çºŒåŠ ç¸½ï¼Œä¸¦åœ¨æ¯ä¸€æ¬¡ç›¸åŠ éç¨‹ç´€éŒ„æœ€å¤§å€¼ maxã€‚\nclass Solution &#123;public:    int maxSubArray(vector&lt;int&gt;&amp; nums) &#123;        int sum = 0,len = nums.size(),max = -1e9;        for(int i=0;i&lt;len;i++)&#123;            sum+=nums[i];            if(sum&gt;max)max = sum;            if(sum&lt;0)sum = 0;        &#125;        return max;    &#125;&#125;;\nèƒŒåŒ…å•é¡ŒèƒŒåŒ…å•é¡Œç¸½å…±æœ‰ä»¥ä¸‹å¹¾ç¨®ï¼š\n\nåˆ†æ•¸èƒŒåŒ…ï¼ˆä¸€å€‹ç‰©å“å¯ä»¥åˆ‡ä¸‹ä¸€éƒ¨åˆ†ã€åªå–å¹¾åˆ†ä¹‹å¹¾æ”¾é€²èƒŒåŒ…ï¼‰â€”Greedy\n01èƒŒåŒ…å•é¡Œ\nç„¡é™èƒŒåŒ…\n\nåˆ†æ•¸èƒŒåŒ…ç­–ç•¥ï¼šè²ªå¿ƒæ³•ã€‚æ¯ä¸€æ¬¡å–å–®ä½åƒ¹å€¼æœ€é«˜çš„ç‰©å“ï¼Œå„ªå…ˆæ”¾é€²èƒŒåŒ…ã€‚ç¸½æ˜¯ç”¨ç•¶ä¸‹æœ€å¥½çš„ç‰©å“å¡«æ»¿èƒŒåŒ…ç©ºéš™ï¼Œæœ€å¾Œæ²’æœ‰ç•™ä¸‹ä»»ä½•ç©ºéš™ã€‚æ¯ä¸€ä»½èƒŒåŒ…ç©ºé–“ï¼Œéƒ½æ˜¯æœ€æœ‰åƒ¹å€¼çš„ç‰©å“ï¼Œå°±ç®—æ˜¯äº¤æ›ç‰©å“ä¹Ÿç„¡æ³•å¢åŠ ç¸½åƒ¹å€¼ â”€â”€ é¡¯ç„¶æ˜¯æœ€ä½³è§£ã€‚æ™‚é–“è¤‡é›œåº¦ï¼š$O(n)$ï¼Œnç‚ºç‰©å“æ•¸é‡\n01èƒŒåŒ…å•é¡Œä¸è€ƒæ…®æœ€ä½³è§£è·¯å¾‘è§£ä¸€ï¼šæš´åŠ›æ³•ï¼ˆéè¿´æ±‚è§£ï¼‰ã€‚æšèˆ‰æ¯ä¸€ç¨®ç‰©å“è¦æ”¾æˆ–ä¸æ”¾é€²èƒŒåŒ…ï¼Œä½†è¤‡é›œåº¦æœƒçˆ†æ‰ $O(2^N)$ä»¥zerojudge b184 ç‚ºä¾‹ï¼š\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int back_pack(int n,int w)&#123;//å›å‚³næ¨£ç‰©å“è€é‡ç‚ºwçš„æœ€å¤§åƒ¹å€¼    if(w&lt;0)return -1e9;//è€é‡ç‚ºè² ï¼Œåªèƒ½ä¸å–    if(n==0)return 0;        return max(       back_pack(n-1,w-weight[n])+val[n],//å–ç¬¬nå€‹ç‰©å“       back_pack(n-1,w));//ä¸å–ç¬¬nå€‹ç‰©å“&#125;int main()&#123;    int n;    while(cin&gt;&gt;n)&#123;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        cout&lt;&lt;back_pack(n,100)&lt;&lt;endl;    &#125;&#125;\n\n            if(w&lt;0)return -1e9;if(n==0)return 0;é€™å…©è¡Œç¨‹å¼ç¢¼ä¸èƒ½é¡›å€’æ”¾ï¼Œå¦å‰‡åœ¨æœ€æœ«ç«¯çš„è¨ˆç®—ä¸Šæœƒå‡ºç¾å•é¡Œï¼ï¼ˆåœ¨é€™é‚Šdebug è¶…ä¹…ï¼Œé¡›å€’æ”¾æœƒè®“ä¸è©²æ”¾çš„ç‰©å“æœ‰å¯èƒ½è¢«æ”¾é€²èƒŒåŒ… :zany_face:ï¼‰\n          \nè§£äºŒï¼šå› ç‚ºéè¿´çš„é—œä¿‚ï¼Œå¯ä»¥é€éäºŒç¶­é™£åˆ—ç´€éŒ„å°å•é¡Œçš„è§£ï¼Œé€™æ¨£å¯ä»¥æ›´æœ‰æ•ˆç‡\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int dp[1000][105] = &#123;0&#125;;//dp[][]å„²å­˜æ”¾næ¨£ç‰©å“è€é‡wçš„æœ€å¤§åˆ©æ½¤int back_pack(int n,int w)&#123;//å›å‚³næ¨£ç‰©å“è€é‡ç‚ºwçš„æœ€å¤§åƒ¹å€¼    if(w&lt;0)return -1e9;    if(n==0)return 0;    if(dp[n][w])return dp[n][w];        return dp[n][w] = max(       back_pack(n-1,w-weight[n])+val[n],       back_pack(n-1,w));&#125;int main()&#123;    int n;    while(cin&gt;&gt;n)&#123;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        cout&lt;&lt;back_pack(n,100)&lt;&lt;endl;        for(int i=0;i&lt;1000;i++)for(int k=0;k&lt;105;k++)dp[i][k] = 0;    &#125;&#125;\nè§£ä¸‰ï¼šå¯ä»¥é‡è¤‡åˆ©ç”¨è¨˜æ†¶é«”ï¼Œå»ºç«‹ä¸€æ¢é™£åˆ—ï¼›ä¸éè¨ˆç®—é †åºè¦æ”¹æˆç”±é™£åˆ—å¾Œç«¯é–‹å§‹â€“ å¾å‰ç«¯å¯èƒ½æœƒé‡è¤‡ä½¿ç”¨åˆ°åŒä¸€å€‹ç‰©å“ï¼Œè€Œç‰©å“åªæœ‰ä¸€å€‹ï¼Œä¸èƒ½é‡è¤‡åˆ©ç”¨(å¯ä»¥é‡è¤‡åˆ©ç”¨å°±è®Šæˆç„¡é™èƒŒåŒ…)ã€‚\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int main()&#123;    int n,w;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];    cin&gt;&gt;w;        int dp[105] = &#123;0&#125;;    for(int i=0;i&lt;n;i++)&#123;        for(int j=w;j&gt;=weight[i];j--)&#123;            dp[j] = max(dp[j],dp[j-weight[i]]+val[i]);        &#125;    &#125;    cout&lt;&lt;dp[w]&lt;&lt;endl;&#125;\næ™‚é–“è¤‡é›œåº¦ O(NW) ï¼Œç©ºé–“è¤‡é›œåº¦ O(W) ã€‚å…¶ä¸­ N æ˜¯ç‰©å“æ•¸é‡ï¼Œ W æ˜¯èƒŒåŒ…é‡é‡é™åˆ¶ã€‚ï¼ˆä¸Šæ–¹11-15è¡Œï¼‰\nè§£å››ï¼šç”¨åƒ¹å€¼ä½œç‚ºç‹€æ…‹ï¼Œdpç´€éŒ„é‡é‡çš„æœ€å°å€¼ï¼Œå¯ä»¥çœ‹é€™è£¡\n#include &lt;bits/stdc++.h&gt;#define INF 0x3f3f3f3fusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,val[105],weight[100005];cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[100005];        //å®šç¾©f(n,m)å–næ¨£ç‰©å“,åƒ¹å€¼ç‚ºm,é‡é‡ç¸½å’Œæœ€å°        //dp[i]ï¼šåƒ¹å€¼ç‚ºiæ™‚,é‡é‡æœ€å°ç‚ºdp[i]        memset(dp,INF,sizeof(dp));        dp[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=10000;j&gt;=val[i];j--)&#123;                dp[j] = min(dp[j],dp[j-val[i]]+weight[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;=10000;i++)            if(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\næ™‚é–“è¤‡é›œåº¦ O(NV) ï¼Œç©ºé–“è¤‡é›œåº¦ O(V) ã€‚å…¶ä¸­ N æ˜¯ç‰©å“æ•¸é‡ï¼Œ Væ˜¯åƒ¹å€¼ç¸½å’Œã€‚ï¼ˆä¸Šæ–¹11-15è¡Œï¼‰\nç´°ç¯€æ³¨æ„ï¼š\n            èƒŒåŒ…å•é¡Œæ˜¯å¦æ°å¥½è£æ»¿å°æ–¼åŸæœ¬åˆå§‹åŒ–dp[0] = 0ï¼Œä»£è¡¨å°æ–¼é‡é‡é™åˆ¶ç‚º0çš„èƒŒåŒ…åƒ¹å€¼æœ€é«˜ç‚º0æ¥ä¸‹ä¾†æœ‰å…©ç¨®æƒ…æ³éœ€è¦è¨è«–ï¼Œç¬¬ä¸€ç¨®æ˜¯é‡é‡é™åˆ¶ç‚ºwçš„èƒŒåŒ…æœ€å¤šçš„åƒ¹å€¼1. æ°å¥½è£æ»¿æ­¤æ™‚å¿…é ˆåˆå§‹åŒ–dp[i] = -INFï¼Œæ˜¯å› ç‚ºè¦æ°å¥½è£æ»¿çš„é—œä¿‚ï¼Œåˆå§‹åŒ–çš„dp æ•¸çµ„äº‹å¯¦ä¸Šå°±æ˜¯åœ¨æ²’æœ‰ä»»ä½•ç‰©å“å¯ä»¥æ”¾å…¥èƒŒåŒ…æ™‚çš„åˆæ³•ç‹€æ…‹ï¼Œå…¶ä»–é™¤äº†0ä¹‹å¤–å®¹é‡çš„èƒŒåŒ…å‡æ²’æœ‰åˆæ³•çš„è§£ï¼Œå±¬æ–¼æœªå®šç¾©çš„ç‹€æ…‹ï¼Œæ‰€ä»¥éƒ½æ‡‰è©²è¢«è³¦å€¼ç‚º âˆ’âˆ ã€‚ç•¶å‰çš„åˆæ³•è§£ï¼Œä¸€å®šæ˜¯å¾ä¹‹å‰çš„åˆæ³•ç‹€æ…‹æ¨å¾—çš„2. ä¸éœ€æ°å¥½è£æ»¿å¦‚æœèƒŒåŒ…ä¸¦éå¿…é ˆè¢«è£æ»¿ï¼Œé‚£éº¼ä»»ä½•å®¹é‡çš„èƒŒåŒ…éƒ½æœ‰ä¸€å€‹åˆæ³•è§£â€œä»€éº¼ä¹Ÿä¸è£â€ï¼Œé€™å€‹è§£çš„åƒ¹å€¼ç‚º0,æ‰€ä»¥åˆå§‹åŒ–æ™‚ç‹€æ…‹çš„å€¼ä¹Ÿå°±å…¨éƒ¨ç‚º0äº†ã€‚\n          \nè€ƒæ…®æœ€ä½³è§£è·¯å¾‘éœ€è¦äºŒç¶­é™£åˆ— p[i][j] ç´€éŒ„ç¬¬ i å€‹ç‰©å“åœ¨è€é‡ j ä¸‹æ˜¯å¦æœ‰æ”¾å…¥èƒŒåŒ…ç”±ä¸‹é¢çš„ç¨‹å¼ç¢¼å¯ä»¥ç™¼ç¾ï¼Œä¸€å€‹ç‰©å“å¦‚æœæ”¾å…¥èƒŒåŒ…ï¼Œå‰‡æ›´æ–°p[i][j]ç‚º1\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005],p[105][105] = &#123;0&#125;;int main()&#123;    int n,w;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];    cin&gt;&gt;w;        int dp[105] = &#123;0&#125;;    for(int i=0;i&lt;n;i++)&#123;        for(int j=w;j&gt;=weight[i];j--)&#123;            if(dp[j-weight[i]]+val[i]&gt;dp[j])&#123;                dp[j] = dp[j-weight[i]]+val[i];                p[i][j] = 1;            &#125;        &#125;    &#125;    cout&lt;&lt;dp[w]&lt;&lt;endl;    for(int i=n-1,j = w;i&gt;=0;i--)&#123;        if(p[i][j])&#123;            cout&lt;&lt;&quot;ç¬¬&quot;&lt;&lt;i+1&lt;&lt;&quot;å€‹ç‰©å“æ”¾å…¥èƒŒåŒ…&quot;&lt;&lt;endl;            j-=weight[i];        &#125;    &#125;&#125;\nç‚ºä»€éº¼ä¸Šæ–¹ç¬¬20è¡Œç¨‹å¼ç¢¼è¦å¾n-1é–‹å§‹è·‘ï¼Ÿ\n            ä»¥ä¸‹æ¸¬è³‡ï¼š43 204 459 7012 8512å¯ä»¥ç™¼ç¾ç¬¬1,3ç‰©å“æ”¾å…¥èƒŒåŒ…ï¼Œä½†å¦‚æœè®Šæˆä»¥ä¸‹æ¸¬è³‡ï¼š53 204 459 7012 853 10012ç¬¬äº”å€‹ç‰©å“å¯ä»¥å–ä»£ç¬¬ä¸€å€‹ç‰©å“ï¼Œå¦‚æœå¾ j=0 é–‹å§‹è¨ˆç®—ï¼ŒæœƒæŠŠç¬¬ä¸€å€‹ç‰©å“ä¹Ÿç®—é€²å»ï¼Œè€Œé€™æ¨£æ˜¯éŒ¯çš„ã€‚å¾ n-1 é–‹å§‹è¨ˆç®—å¯ä»¥ç¢ºä¿ç­”æ¡ˆæ­£ç¢ºã€‚å…¶å¯¦å¾å¾Œé¢è¨ˆç®—æ‰èƒ½ç®—åˆ°åœ¨wè€é‡ä¸‹æœ€å¾Œä¸€å€‹è¢«åŠ å…¥èƒŒåŒ…çš„ç‰©å“ï¼Œå¦‚æœå¾å‰é¢é–‹å§‹è¨ˆç®—ï¼Œå‰é¢ä¸æ˜¯æœ€ä½³è§£çš„ç‰©å“æœƒè¢«ç®—é€²å»ã€‚ä»¥é€™å€‹p[][]çš„çµæœä¾†èªªï¼Œæœ€å¾Œä¸€å€‹è¢«åŠ é€²å»çš„æ‰æ˜¯æœ€ä½³è§£ï¼Œå‰é¢éƒ½æ˜¯è¢«æ›¿æ›æ‰çš„ï¼ˆåœ¨é™£åˆ—dp[]ä¸­è¢«å–ä»£ï¼Œå› ç‚ºé™£åˆ—dp[]è¢«æ›´æ–°çš„æ¢ä»¶å°±æ˜¯æœ‰åƒ¹å€¼æ›´é«˜çš„è§£ï¼‰\n          \nè½‰ç§»æ–¹å‘çš„ä¸åŒï¼š\n            01èƒŒåŒ…å•é¡Œåœ¨å£“æˆä¸€ç¶­çš„éç¨‹ä¸­å¿…é ˆçŸ¥é“æ˜¯æ€éº¼ä¾†çš„ï¼Œå¾äºŒç¶­å£“æˆä¸€ç¶­ï¼Œdpæ›´æ–°çš„é †åºè¦å¾å‰åˆ°å¾Œæˆ–å¾Œåˆ°å‰è¦çœ‹æ˜¯å­˜å–åˆ°å“ªä¸€æ ¼çš„å…§å®¹ã€‚é€™æ˜¯01èƒŒåŒ…å•é¡Œè½‰ç§»å¼æ‰€ç”¨åˆ°çš„æ ¼å­ï¼š$f(n,m) = max(f(n-1,m),f(n-1,m-w_n)+v_n)$å°æ–¼æ¯ä¸€å€‹f(n,m)åªæœƒå–ç”¨åˆ°2å€‹æ ¼å­$f(n-1,m)$å’Œ$f(n-1,m-w_n)$å…©å€‹æ ¼å­ï¼Œå¦‚æœå¾å‰åˆ°å¾Œæ›´æ–°æ ¼å­çš„è©±ï¼Œå·¦ä¸Šæ–¹çš„è—è‰²æ ¼å­æœƒå…ˆè¢«æ›´æ–°åˆ°ï¼Œæ‰€ä»¥æ”¹æˆä¸€ç¶­é™£åˆ—ä¹‹å¾Œå¿…é ˆè¦å¾å¾Œå¾€å‰æ›´æ–°æ¥ä¸‹ä¾†æ˜¯ç„¡é™èƒŒåŒ…å•é¡Œï¼šå·¦é‚Šçš„è—è‰²æ ¼å­æ˜¯è¢«æ›´æ–°å¾Œçš„ï¼Œå› æ­¤ç„¡é™èƒŒåŒ…å•é¡Œå¿…é ˆå¾å‰åˆ°å¾Œæ›´æ–°\n          \nç„¡é™èƒŒåŒ…ç‰©å“æœ‰è¨±å¤šç¨®é¡ï¼Œæ¯ä¸€ç¨®ç‰©å“éƒ½ç„¡é™é‡ä¾›æ‡‰çš„èƒŒåŒ…å•é¡Œã€‚æ¼”ç®—æ³•ï¼šè·Ÿè§£ä¸‰å·®ä¸å¤šï¼Œå› ç‚ºç‰©å“æœ‰ç„¡é™å¤šå€‹ï¼Œæ‰€ä»¥ç¬¬äºŒå€‹è¿´åœˆè¦å¾ weight[i] é–‹å§‹åŸ·è¡Œï¼š\n#include &lt;bits/stdc++.h&gt;using namespace std;int weight[105],val[60005];int main()&#123;    int n,w;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];    cin&gt;&gt;w;        int dp[105] = &#123;0&#125;;    for(int i=0;i&lt;n;i++)&#123;        for(int j=weight[i];j&lt;=w;j++)&#123;            dp[j] = max(dp[j],dp[j-weight[i]]+val[i]);        &#125;    &#125;    cout&lt;&lt;dp[w]&lt;&lt;endl;&#125;\næ‰¾é›¶éŒ¢å•é¡Œæ‰¾é›¶éŒ¢å•é¡Œç¸½å…±æœ‰ä»¥ä¸‹å¹¾ç¨®ï¼š\n\næ¹Šå¾—æŸåƒ¹ä½çš„æœ€å°‘éŒ¢å¹£ç”¨é‡\næ¹Šå¾—æŸå€‹åƒ¹ä½çš„æ¹Šæ³•ç¸½å…±å¹¾ç¨®\n\næ‰¾é›¶éŒ¢å•é¡Œå°±æ˜¯å¼±åŒ–ç‰ˆçš„èƒŒåŒ…å•é¡Œï¼\næ¹Šå¾—æŸåƒ¹ä½çš„æœ€å°‘éŒ¢å¹£ç”¨é‡ä¸è€ƒæ…®æœ€ä½³è§£è·¯å¾‘å®šç¾©ï¼šdp(n,m) ä»£è¡¨ç”¨ç¬¬0ç¨®åˆ°ç¬¬nç¨®éŒ¢å¹£æ¹Šå¾—åƒ¹ä½mçš„æœ€å°‘ç¡¬å¹£æ•¸åˆå§‹å€¼ï¼šdpå€¼è¨­ç‚º $\\infty$ï¼ˆæ±‚æœ€å°‘ï¼‰ï¼Œdp[0] = 0è½‰ç§»æ–¹å¼ï¼š$dp[j] = min(dp[j], dp[j-val[i]]+1)$\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,dp[105],val[100],target;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i];    cin&gt;&gt;target;    memset(dp, 0x6f, sizeof(dp));    dp[0] = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=val[i];j&lt;=target;j++)&#123;            dp[j] = min(dp[j], dp[j-val[i]]+1);        &#125;    &#125;    cout&lt;&lt;dp[target]&lt;&lt;endl;&#125;\nè€ƒæ…®æœ€ä½³è§£è·¯å¾‘ä½¿ç”¨é™£åˆ—p[i] ä»£è¡¨é”æˆé‡‘é¡iå…ƒæœ€å¾ŒåŠ å…¥çš„ç¡¬å¹£é¢é¡ï¼ˆå³é”æˆæœ€å°ç¡¬å¹£æ•¸é‡çš„é¢é¡ï¼‰\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,dp[105],val[100],target,p[105];//p[i]é”æˆé‡‘é¡iå…ƒæœ€å¾ŒåŠ å…¥çš„ç¡¬å¹£é¢é¡int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i];    cin&gt;&gt;target;    memset(dp, 0x6f, sizeof(dp));    memset(p, 0, sizeof(p));    dp[0] = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=val[i];j&lt;=target;j++)&#123;            if(dp[j]&gt;dp[j-val[i]]+1)&#123;//åŠ å…¥ç¬¬iç¨®ç¡¬å¹£ï¼Œä½¿æ•¸é‡æ›´å°‘                dp[j] = dp[j-val[i]]+1;                p[j] = val[i];            &#125;        &#125;    &#125;//é™£åˆ—pç•™ä¸‹ä¾†çš„å³ç‚ºé”æˆé‡‘é¡iå…ƒæœ€å¾ŒåŠ å…¥çš„ç¡¬å¹£é¢é¡    cout&lt;&lt;dp[target]&lt;&lt;endl;    int  k= target;    while(k&gt;0)&#123;        cout&lt;&lt;p[k]&lt;&lt;&quot; &quot;;        k = k - p[k];//å‰å¾€ä¸‹ä¸€å€‹éŒ¢å¹£æ•¸ç›®    &#125;    cout&lt;&lt;endl;&#125;\næ¹Šå¾—æŸå€‹åƒ¹ä½çš„æ¹Šæ³•ç¸½å…±å¹¾ç¨®å®šç¾©ï¼šdp(n,m) ä»£è¡¨ç”¨ç¬¬0ç¨®åˆ°ç¬¬nç¨®éŒ¢å¹£æ¹Šå¾—åƒ¹ä½mçš„æ¹Šæ³•æ•¸ç›®åˆå§‹å€¼ï¼šdp[0]=1(é›–ç„¶ç¾å¯¦ä¸­ä¸å¯èƒ½æ¹Šåˆ°0å…ƒ)è½‰ç§»æ–¹å¼ï¼š$dp[j] =dp[j] + dp[j-val[i]]$\n            ç¨‹å¼ç¢¼ä¸­ä½¿ç”¨ += æ˜¯å› ç‚ºã€Œä¸åŠ ä¸Šç¬¬nç¨®éŒ¢å¹£çš„æ¹Šæ³•ï¼ˆå°±æ˜¯æœªæ›´æ–°çš„dp[j]ï¼‰ã€åŠ ä¸Šã€ŒåŠ ä¸Šç¬¬nç¨®éŒ¢å¹£çš„æ¹Šæ³•ï¼ˆå‰©ä¸‹çš„å°±æ˜¯æ¹Šæ»¿ j-val[i] çš„æ¹Šæ³•ï¼‰ã€\n          \n#include &lt;bits/stdc++.h&gt;using namespace std;int n,dp[1005],val[105],target;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i];    cin&gt;&gt;target;    memset(dp, 0, sizeof(dp));    dp[0] = 1;    for(int i=0;i&lt;n;i++)&#123;        for(int j=val[i];j&lt;=target;j++)&#123;            dp[j] += dp[j-val[i]];        &#125;    &#125;    cout&lt;&lt;dp[target]&lt;&lt;endl;&#125;\næœ€é•·ä¸Šå‡å­åºåˆ—ï¼ˆLISï¼‰\nçµ¦ä½ ä¸€å€‹æ­£æ•´æ•¸åºåˆ—ï¼Œå•ä½ æœ€å¤šå¯ä»¥å¾è£¡é¢é¸å‡ºå¹¾å€‹å…ƒç´ ï¼ˆä¸æ”¹è®Šé †åºï¼‰ï¼Œä½¿å¾—é€™äº›å…ƒç´ åš´æ ¼éå¢ã€‚\n\nä¸è€ƒæ…®æœ€ä½³è§£è·¯å¾‘è§£ä¸€ï¼šè¤‡é›œåº¦ï¼ˆO(n^2^)ï¼‰å®šç¾©ï¼šä»¥é™£åˆ—dp[i] ä»£è¡¨é•·åº¦ç‚ºåºåˆ—é•·åº¦ç‚º i æ™‚çš„LIS(è®“dp[i]è¡¨ç¤ºå–äº†a[i]ç‚ºæœ€å¾Œä¸€å€‹æ•¸å­—çš„LIS)åˆå§‹å€¼ï¼šdpä¸­çš„æ¯ä¸€å€‹å…ƒç´ åˆå§‹å€¼ç‚º1è½‰ç§»æ–¹å¼ï¼šå°‡ç¬¬ i å€‹å…ƒç´ è¨­ç‚ºç¬¬ 0 åˆ° i-1 çš„å…ƒç´ ä¹‹æœ€å¤§å€¼åŠ ä¸€ï¼š$dp[i] = max_{j&lt;i,a[j]&lt;a[i]} (dp[j])+1$\nä»¥tioj 1175 Longest Increasing Subsequenceç‚ºä¾‹ï¼š\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,arr[100005],dp[100005];int main()&#123;    cin&gt;&gt;n;    memset(arr, 0, sizeof(arr));    memset(dp, 0, sizeof(dp));    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;arr[i];        dp[i] = 1;    &#125;    for(int i=1;i&lt;n;i++)&#123;        for(int j=0;j&lt;i;j++)&#123;            if(arr[j]&lt;arr[i])                dp[i] = max(dp[i],dp[j]+1);        &#125;    &#125;    int ans = *max_element(dp,dp+n);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nè§£äºŒï¼šè¤‡é›œåº¦ï¼ˆ$O(nlogn)$ï¼‰å¯ä»¥åˆ©ç”¨vectorç¶­è­·ä¸€å€‹åš´æ ¼éå¢çš„åºåˆ—ï¼ŒåŒæ™‚åˆ©ç”¨lower_bound ä¾†äºŒåˆ†æœa[i]è©²åœ¨åºåˆ—ä¸­çš„å“ªä¸€å€‹ä½ç½®ä»¥ leetcode 300ç‚ºä¾‹ï¼š\nclass Solution &#123;public:    int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123;        vector&lt;int&gt; lis;        int len=nums.size();        lis.push_back(nums[0]);        for(int i=1;i&lt;len;i++)&#123;            if(lis.back()&lt;nums[i])lis.push_back(nums[i]);            else *lower_bound(lis.begin(),lis.end(),nums[i]) = nums[i];        &#125;        return lis.size();    &#125;&#125;;\nè€ƒæ…®æœ€ä½³è§£è·¯å¾‘\n            ä¸Šé¢æ–¹æ³•é›–ç„¶å¯ä»¥æ­£ç¢ºæ±‚å‡ºLISçš„é•·åº¦ï¼Œå»ç„¡æ³•ä¿è­‰vector lisè£¡é¢å„²å­˜çš„æ˜¯æ­£ç¢ºçš„åºåˆ—ï¼ˆç•¶æœ€æœ«ç«¯çš„LISå‡ºç¾å¾Œï¼Œå¾Œé¢çš„å…ƒç´ æœƒå› ç‚ºlower_boundæ’å…¥çš„é—œä¿‚å‡ºç¾åœ¨åºåˆ—çš„ä¸­é–“è§£æ±ºæ–¹æ³•ï¼šé€édp[]ç´€éŒ„æ¯ä¸€å€‹å…ƒç´ å‡ºç¾çš„ä½ç½®ï¼Œå¯ä»¥æ±‚å¾—æ­£ç¢ºçš„åºåˆ—\n          \nkeyï¼šä¸‹æ–¹ç¬¬30-35è¡Œç¨‹å¼ç¢¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,L,dp[100005],temp;vector&lt;int&gt; vec,lis,ans;int main()&#123;    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        cin&gt;&gt;temp;        vec.push_back(temp);    &#125;    lis.push_back(vec[0]);    dp[0] = 1;    for(int i=1;i&lt;n;i++)&#123;        int ind = 0;        if(vec[i]&gt;lis.back())&#123;            lis.push_back(vec[i]);            ind = lis.size();            dp[i] = ind;        &#125;        else&#123;            ind = lower_bound(lis.begin(), lis.end(),vec[i])-lis.begin();            lis[ind] = vec[i];            dp[i] = ind+1;//dpä»¥1ç‚ºèµ·å§‹        &#125;    &#125;    L = lis.size();    cout&lt;&lt;&quot;LIS:&quot;&lt;&lt;L&lt;&lt;endl;//è¼¸å‡ºlisé•·åº¦ï¼Œä½†æ­¤æ™‚vector lisä¸­çš„åºåˆ—æ˜¯éŒ¯èª¤çš„        for(int i=n-1;i&gt;=0;i--)&#123;        if(dp[i] == L)&#123;            ans.push_back(vec[i]);//åˆ©ç”¨vecè£¡çš„æ±è¥¿ç”¢ç”Ÿæ­£ç¢ºåºåˆ—ansï¼Œæ¨æ£„lis            L--;        &#125;    &#125;    reverse(ans.begin(), ans.end());    for(auto i: ans)cout&lt;&lt;i&lt;&lt;&quot; &quot;;&#125;\n\n            ç¯„ä¾‹æ¸¬è³‡ï¼š810 9 2 5 3 7 101 6å¾—åˆ°çš„dp = {1 1 1 2 2 3 4 3}æˆ‘å€‘è¦çš„å°±æ˜¯ä¸Šæ–¹ç²—é«”å°æ‡‰åˆ°çš„å°±æ˜¯æ­£ç¢ºçš„LISï¼š2 3 7 101\n          \næœ€é•·å…±åŒå­åºåˆ—ï¼ˆLCSï¼‰\nçµ¦å®šå…©å€‹è‹±æ–‡å­—ä¸²ï¼Œæ‰¾å‡º LCSã€‚ï¼ˆåœ¨å…©å€‹å­—ä¸²ä¸­å„å–å‡ºå­—ä¸²ä¸­å­—å…ƒï¼Œä½¿å…©è€…ç›¸ç­‰çš„æœ€å¤§é•·åº¦â€”å­—æ¯é †åºä¸å¯ä»¥æ”¹è®Šï¼‰\n\nä¸è€ƒæ…®æœ€ä½³è§£è·¯å¾‘å®šç¾©ï¼šçµ¦å®šå­—ä¸² s1,s2ï¼Œdp[n][m]ç‚ºs1é•·åº¦ç‚ºnã€s2é•·åº¦ç‚ºmæ™‚çš„LCSåˆå§‹å€¼ï¼šåˆå§‹é™£åˆ—dpç‚º0è½‰ç§»ï¼š\ndp[i][j] = dp[i-1][j-1]+1, if\\ s1[i-1]=s2[j-1]$$$$dp[i][j] = max(dp[i-1][j],dp[i][j-1]), if\\ s1[i-1]!=s2[j-1]æ¨å°éç¨‹å¯ä»¥çœ‹ï¼šè³‡èŠ½è¬›ç¾©\nä»¥ leetcode 1143. Longest Common Subsequenceç‚ºä¾‹ï¼š\nclass Solution &#123;public:int longestCommonSubsequence(string text1, string text2) &#123;    int n1 = text1.size(), n2 = text2.size(),dp[n1+1][n2+1];    memset(dp,0,sizeof(dp));    for(int i=1;i&lt;=n1;i++)&#123;        for(int j=1;j&lt;=n2;j++)&#123;            if(text1[i-1]==text2[j-1])&#123;                dp[i][j] = dp[i-1][j-1]+1;            &#125;            else&#123;                dp[i][j] = max(dp[i-1][j],dp[i][j-1]);            &#125;        &#125;    &#125;    return dp[n1][n2];&#125;&#125;;\nè€ƒæ…®æœ€ä½³è§£è·¯å¾‘æ±‚å‡ºä¸€çµ„LCSçš„æ–¹æ³•ï¼Œå¯ä»¥åˆ©ç”¨ä¸€å€‹äºŒç¶­é™£åˆ—p[i][j] ç´€éŒ„dp[i][j]å¾ä½•è€Œä¾†ï¼Œç”±æ±‚LCSçš„éç¨‹ä¸­å¯ä»¥ç™¼ç¾ï¼Œdp[i][j]å¯ä»¥æœ‰ä¸‰å€‹ä¾†æº(18-32è¡Œ)ï¼Œåˆ†åˆ¥æ˜¯ï¼š\n\nå·¦ä¸Šæ ¼ï¼ˆæ­¤æ™‚a[i]=b[j]) â€” å®šç¾©ç‚º0\nå·¦æ ¼ï¼ˆæ­¤æ™‚ dp[i][j-1]&gt;dp[i-1][j]ï¼‰â€” å®šç¾©ç‚º1\nä¸Šæ ¼ï¼ˆæ­¤æ™‚ dp[i-1][j]&gt;dp[i][j-1]ï¼‰â€” å®šç¾©ç‚º2\n\nç´€éŒ„å®Œæˆå¾Œï¼Œé€ééè¿´æˆ–è¿´åœˆçš„æ–¹å¼å›æœ”æ±‚å¾—ç­”æ¡ˆã€‚å¾æœ«ç«¯é–‹å§‹ï¼Œå¦‚æœé‡åˆ°0 å‰‡å¾€å·¦ä¸Šæ ¼ç§»å‹•ï¼Œ1 å‰‡å¾€å·¦æ ¼ï¼Œ2å‰‡å¾€ä¸Šæ ¼ã€‚\nåˆ©ç”¨éè¿´æ±‚è§£\nvoid print(int i,int j)&#123;    if(i==0||j==0)return;//é‚Šç•Œ    if(p[i][j]==0)&#123;        print(i-1, j-1);        cout&lt;&lt;a[i-1];    &#125;    else if(p[i][j]==1)print(i, j-1);//å·¦æ ¼    else print(i-1, j);//ä¸Šæ ¼&#125;\nåˆ©ç”¨è¿´åœˆæ±‚è§£å› ç‚ºæ˜¯åˆ©ç”¨å›æœ”æ³•ï¼Œè¼¸å‡ºæœƒæ˜¯ååºï¼Œå› æ­¤æ–°é–‹ä¸€å€‹é™£åˆ—å„²å­˜ç­”æ¡ˆ\nvoid print(int i,int j)&#123;    if(!len)return;    int l = len;    char lcs[l];    while(l&gt;0)&#123;        if(p[i][j]==0)&#123;            l--;i--;j--;            lcs[l] = a[i];        &#125;        else if(p[i][j]==1)j--;//å·¦æ ¼        else i--;//ä¸Šæ ¼    &#125;    cout&lt;&lt;lcs;&#125;\nå®Œæ•´ç‰ˆç¨‹å¼ç¢¼ï¼š\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;string a,b;int lenA,lenB,p[1005][1005],len;void print(int i,int j);signed main()&#123;    cin&gt;&gt;a&gt;&gt;b;    lenA = a.length();    lenB = b.length();        int dp[lenA+1][lenB+1];    memset(dp, 0, sizeof(dp));    memset(p, 0, sizeof(p));//ç´€éŒ„æ¯ä¸€å€‹dpå…ƒç´ å¾ä½•è€Œä¾†    //å®šç¾©ï¼š0 å·¦ä¸Šæ ¼ï¼Œ1 å·¦æ ¼ï¼Œ2ä¸Šæ ¼ã€‚    for(int i=1;i&lt;=lenA;i++)&#123;        for(int j=1;j&lt;=lenB;j++)&#123;            if(a[i-1]==b[j-1])&#123;                dp[i][j] = dp[i-1][j-1]+1;                p[i][j] = 0;//left-top            &#125;            else&#123;                if(dp[i-1][j]&lt;dp[i][j-1])&#123;                    dp[i][j] = dp[i][j-1];                    p[i][j] = 1;//left                &#125;                else&#123;                    dp[i][j] = dp[i-1][j];                    p[i][j] = 2;//top                &#125;            &#125;        &#125;    &#125;    len = dp[lenA][lenB];    cout&lt;&lt;len&lt;&lt;endl;    print(lenA, lenB);    cout&lt;&lt;endl;&#125;//éè¿´void print(int i,int j)&#123;    if(i==0||j==0)return;    if(p[i][j]==0)&#123;        print(i-1, j-1);        cout&lt;&lt;a[i-1];    &#125;    else if(p[i][j]==1)print(i, j-1);    else print(i-1, j);&#125;//è¿´åœˆvoid print(int i,int j)&#123;    if(!len)return;    int l = len;    char lcs[l];    while(l&gt;0)&#123;        if(p[i][j]==0)&#123;            l--;i--;j--;            lcs[l] = a[i];        &#125;        else if(p[i][j]==1)j--;        else i--;    &#125;    cout&lt;&lt;lcs;&#125;\né¡Œç›®ï¼†è³‡æºå­¸é•·è¬›yeehttps://leetcode.com/tag/dynamic-programming/\n\n[x] https://tioj.ck.tp.edu.tw/problems/1354\n[x] https://tioj.ck.tp.edu.tw/problems/1019\n[ ] https://codeforces.com/problemset/problem/1207/C\n[x] https://tioj.ck.tp.edu.tw/problems/1097\n[ ] https://codeforces.com/problemset/problem/1398/D\n[x] https://tioj.ck.tp.edu.tw/problems/1029\n[x] https://zerojudge.tw/ShowProblem?problemid=d038\n[x] https://zerojudge.tw/ShowProblem?problemid=d390\n[x] https://zerojudge.tw/ShowProblem?problemid=d133\n[x] https://zerojudge.tw/ShowProblem?problemid=a133\n[x] https://zerojudge.tw/ShowProblem?problemid=d674\n\n","categories":["C++åŸºç¤ä¸»é¡Œ","å‹•æ…‹è¦åŠƒ"],"tags":["æ¼”ç®—æ³•","å‹•æ…‹è¦åŠƒ"]},{"title":"[é¡Œè§£]TIOJ 1019 Jumping Up","url":"/dp2-2/","content":"tioj-1019 Jumping Up\né¡Œåº\nå®šç¾©å®šç¾© dp[i] ç‚ºç¬¬ 0 å€‹åˆ°ç¬¬ i å€‹éˆ´éºçš„æœ€å°ç§»å‹•æ°´å¹³è·é›¢ç¸½å’Œ\nè½‰ç§»æ–¹å¼ä»¤$a0,a_1â€¦a{n-1}$ç‚ºç›¸å°æ–¼è¢å¹•æ­£ä¸­å¤®çš„æ°´å¹³ä½ç§»ï¼Œé¸æ“‡è·³ä¸€æ ¼æˆ–è·³å…©æ ¼ã€‚\n$dp[i] = min(dp[i-1]+abs(ai-a{i-1}),dp[i-2]+abs(ai-a{i-2}))$\né‚Šç•Œæ¢ä»¶$dp[0] = 0,$ $dp[1] = abs(a_1-a_0)$\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int T,N;signed main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;N;        int arr[N+1],dp[N+1];        memset(arr, 0, sizeof(arr));        memset(dp, 0, sizeof(dp));                for(int i=0;i&lt;N;i++)cin&gt;&gt;arr[i];        dp[0] = 0;dp[1] = abs(arr[1]-arr[0]);                for(int i=2;i&lt;N;i++)&#123;            dp[i] = min(dp[i-1]+abs(arr[i]-arr[i-1]),                        dp[i-2]+abs(arr[i]-arr[i-2]));        &#125;        cout&lt;&lt;dp[N-1]&lt;&lt;endl;    &#125;&#125;\nè¤‡é›œåº¦\n            é€™ä¸€é¡Œ$dp_i$åªæœƒè·Ÿå‰å…©é …æœ‰é—œä¿‚ï¼Œå¥½åƒå¯ä»¥ç”¨æ»¾å‹•DPä¾†å„ªåŒ–ç©ºé–“ï¼Œå¯ä»¥ä»¥å¾Œå˜—è©¦çœ‹çœ‹ï¼\n          \n","categories":["DPé¡Œè§£"],"tags":["é¡Œè§£","DP"]},{"title":"[é¡Œè§£]TIOJ 1097 .F.ç‡Ÿåœ°","url":"/dp2-3/","content":"tioj-1097 . F.ç‡Ÿåœ°\ntioj1097é¡Œåºleetcodeé¡Œåº\nå®šç¾©å®šç¾© dp[i][j] ç‚ºä»¥ç´¢å¼•(i,j)æ–¹æ ¼ç‚ºæ­£æ–¹å½¢å³ä¸‹è§’æ‰€å½¢æˆçš„æœ€å¤§æ­£æ–¹å½¢é‚Šé•·\nè½‰ç§»æ–¹å¼$dp(i,j)=min(dp(iâˆ’1,j),dp(iâˆ’1,jâˆ’1),dp(i,jâˆ’1))+1$çœ‹ä¸€å€‹æ ¼å­—æ˜¯å¦å¯ä»¥æ§‹æˆæ›´å¤§çš„æ­£æ–¹å½¢ï¼Œè¦ä»¥å®ƒä¸Šæ–¹ã€å·¦æ–¹ã€å·¦ä¸Šæ–¹çš„æ ¼å­ä¾†æ±ºå®šï¼ˆå·¦ã€å·¦ä¸Šã€ä¸Šè·Ÿå®ƒè‡ªå·±å‰›å¥½å¯ä»¥æ§‹æˆä¸€å€‹æ­£æ–¹å½¢ï¼‰\né‚Šç•Œæ¢ä»¶åˆå§‹åŒ–ç‚ºé¡Œç›®çµ¦å®šçš„0èˆ‡1ï¼ˆ0ä»£è¡¨ä¸èƒ½æ”¾ã€1è¡¨ç¤ºå¯ä»¥æ”¾ï¼‰\nç¨‹å¼ç¢¼leetcode 221\nclass Solution &#123;public:    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int row = matrix.size(),col = matrix[0].size(),ans = 0;;                for(int i=0;i&lt;row;i++)&#123;            for(int j=0;j&lt;col;j++)&#123;                matrix[i][j]-=&#x27;0&#x27;;                if(matrix[i][j]==1&amp;&amp; ans ==0)ans = 1;                if(i==0||j==0)continue;                                if(matrix[i][j]==1)&#123;                    matrix[i][j] = min(min(matrix[i-1][j],matrix[i][j-1]),                                       matrix[i-1][j-1])+1;                    ans = max((int)matrix[i][j],ans);                &#125;            &#125;          &#125;        return ans*ans;    &#125;&#125;;\ntioj 1097\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int L,W,dp[2][5005],ans;void input(int ind)&#123;    for(int k=0;k&lt;W;k++)&#123;            int temp;            cin&gt;&gt;temp;            if(temp == 2)dp[ind][k] = 0;            else dp[ind][k] = 1;            if(dp[ind][k]==1&amp;&amp;ans == 0)ans = 1;    &#125;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;L&gt;&gt;W)&#123;        ans = 0;        if(L==0 &amp;&amp; W==0)break;        input(0);                for(int i=0;i&lt;L-1;i++)&#123;            input(1);            for(int j=1;j&lt;W;j++)&#123;                if(dp[1][j]==1)&#123;                    dp[1][j] = min(dp[0][j],min(dp[0][j-1],dp[1][j-1]))+1;                    ans = max(ans,dp[1][j]);                &#125;            &#125;            for(int i=0;i&lt;W;i++)dp[0][i] = dp[1][i];        &#125;        cout&lt;&lt;ans*ans&lt;&lt;endl;    &#125;&#125;\nè¤‡é›œåº¦\n            å¯¦ä½œé‡åˆ°çš„ä¸€äº›å•é¡Œï¼šé™£åˆ—ç›´æ¥é–‹ç©ºé–“è¤‡é›œåº¦æœƒçˆ†æ‰ï¼Œæ‰€ä»¥è¦ç”¨åˆ°æ»¾å‹•DP ï¼ˆä¸ç„¶æœƒMLEï¼‰ç•¶i=0 èˆ‡j=0 æ™‚æœƒè¢«å¿½ç•¥æ‰ï¼Œå¦‚æœåªæœ‰åœ¨i=0 æˆ–j=0 å‡ºç¾1è€Œå…¶ä»–éƒ½æ˜¯0ï¼ˆä¸èƒ½æ”¾ï¼‰çš„æ™‚å€™ï¼Œå°±æœƒå‡ºç¾ç­”æ¡ˆç‚º0çš„æƒ…æ³ï¼Œåœ¨è¼¸å…¥æ™‚å°±è¦åšä¿®æ­£å› ç‚ºä½¿ç”¨äº†æ»¾å‹•DPï¼Œæ‰€ä»¥åœ¨ä¸€é–‹å§‹æœƒå…ˆè¼¸å…¥ç¬¬ä¸€æ’ï¼Œé€™æ™‚ç¸½å…±å‰©ä¸‹L-1æ’ï¼Œæ‰€ä»¥åœ¨ç¬¬24è¡Œè¦æ˜¯L-1æ¬¡ï¼Œæ‰ä¸æœƒéœ€è¦å¤šè¼¸å…¥ä¸€è¡Œã€‚\n          \n","categories":["DPé¡Œè§£"],"tags":["é¡Œè§£","DP"]},{"title":"[é¡Œè§£]TIOJ 1029 AéŠæˆ²","url":"/dp2-4/","content":"1029  AéŠæˆ²\ntioj1029leetcode877\n\næœ‰ä¸€ä¸²ç”±Nå€‹æ­£æ•´æ•¸æ‰€çµ„æˆçš„æ•¸åˆ—ï¼Œå…©å€‹ç©è€…è¼ªæµæ‹¿èµ°ä¸€å€‹æœ€å·¦é‚Šæˆ–æœ€å³é‚Šçš„æ•¸ï¼Œç›´åˆ°æœ€å¾Œæ‰€æœ‰çš„æ•¸éƒ½å–å®Œä¹‹å¾Œï¼Œå…©å€‹ç©è€…åˆ†åˆ¥æŠŠè‡ªå·±æ‰€å–åˆ°æ•¸åŠ ç¸½ï¼Œåˆ†æ•¸è¼ƒé«˜çš„äººç²å‹ã€‚ç¯„ä¾‹è¼¸å…¥64 7 2 9 5 2è¼¸å‡º 18 11\n\nå®šç¾©é€™ä¸€é¡Œç”¨åˆ°çš„æ˜¯å€é–“DPå®šç¾©dp[i][j]ç‚ºå€é–“$[i,j]$ä¸­å…ˆæ‰‹å¯ä»¥æ‹¿åˆ°çš„æœ€å¤§å€¼ï¼Œå› ç‚ºå…ˆå¾Œæ‰‹æ‹¿çš„ç¸½å’Œä¸è®Šï¼Œæ‰€ä»¥å¾Œæ‰‹åœ¨å€é–“$[i,j]$ å¯ä»¥æ‹¿åˆ°çš„æœ€å¤§å€¼ç‚º $sum[i,j]-dp[i][j]$ã€‚åŒæ™‚ï¼Œ$dp[i][i] = arr[i]$    (å…ˆæ‰‹å–)\nè½‰ç§»æ–¹å¼ç”±é¡Œç›®å¯çŸ¥ï¼Œå…ˆå¾Œæ‰‹éƒ½æ˜¯ä»¥æœ€ä½³ç­–ç•¥ä¾†ç©é€™å€‹éŠæˆ²ï¼Œè€Œå€é–“$[l,r]$ä¸­å…ˆæ‰‹åœ¨å€é–“$[l+1,r]$ ä¸­å°±è®Šæˆå¾Œæ‰‹ï¼ˆå°æ‰‹å…ˆæ‹¿ï¼‰ï¼Œå› æ­¤å¯ä»¥æ¨å¾—è½‰ç§»å¼ï¼š\ndp[i][j] = max(sum[i+1,j]-dp[i+1][j]+arr[i],\n                sum[i,j-1]-dp[i][j-1]+arr[j])ï¼ˆç¬¬ä¸€é …å–æœ€å·¦é‚Šï¼Œç¬¬äºŒé …ä»£è¡¨å–æœ€å³é‚Šï¼‰ä»¥æ­¤åœ–ç‚ºä¾‹ï¼Œä»¥iç‚ºæ©«è»¸ä»£è¡¨å‡ºç™¼é»ï¼Œjç‚ºç¸±è»¸ä»£è¡¨çµ‚é»ï¼Œç”±ä¸Šè€Œä¸‹ã€ç”±å³è€Œå·¦ä¾åºæŠŠå·¦ä¸‹è§’çš„è¡¨æ ¼å¡«æ»¿ã€‚æ‰€æ±‚å³ç‚º(i,j) = (1,6)ã€‚\né‚Šç•Œæ¢ä»¶$dp[i][i] = arr[i]$\nç¨‹å¼ç¢¼ä¸Šæ–¹çš„sumï¼Œå¯ä»¥é€éè¡¨æ ¼å„²å­˜å‰ç¶´å’Œï¼Œå¿«é€Ÿæ±‚å¾—\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);using namespace std;int n;int main()&#123;    ios    cin&gt;&gt;n;    int dp[n+1][n+1],pref[n+1],arr[n+1];    memset(dp,0,sizeof(dp));    pref[0] = 0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        dp[i][i] = arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    for(int i=n-1;i&gt;0;i--)&#123;        for(int j=i+1;j&lt;=n;j++)&#123;            dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+arr[i],//å³æ ¼                           pref[j-1]-pref[i-1]-dp[i][j-1]+arr[j]);//ä¸Šæ ¼        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;&quot; &quot;&lt;&lt;pref[n]-dp[1][n]&lt;&lt;endl;    //    for(int j=1;j&lt;n+1;j++)&#123;//        for(int i=1;i&lt;=n;i++)cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;//        cout&lt;&lt;endl;//å°å‡ºdp//    &#125;&#125;\n\n            Leetcode 877é€™è£¡æœ‰ä¸€ç³»åˆ—çš„stone game è®ŠåŒ–é¡Œclass Solution &#123;public:    bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;        int n = piles.size();        piles.insert(piles.begin(),0);        int dp[n+1][n+1],pref[n+1];        memset(dp,0,sizeof(dp));        memset(pref,0,sizeof(pref));        for(int i=1;i&lt;=n;i++)&#123;            dp[i][i] = piles[i];            pref[i] = pref[i-1]+piles[i];        &#125;                for(int i=n-1;i&gt;0;i--)&#123;            for(int j=i+1;j&lt;=n;j++)&#123;                dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+piles[i],                              pref[j-1]-pref[i-1]-dp[i][j-1]+piles[j]);            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;        if(dp[1][n]&gt;pref[n]/2)return true;        else return false;    &#125;&#125;;é€™ä¸€é¡Œæœ‰ä¸€å€‹æ•¸å­¸è§£ï¼Œå¯ä»¥ä¿è­‰ç­”æ¡ˆä¸€å®šæ˜¯trueã€‚We can extend this idea to N piles. Say the first, third, fifth, seventh, etc. piles are white, and the second, fourth, sixth, eighth, etc. piles are black. Alex can always take either all white piles or all black piles, and one of the colors must have a sum number of stones larger than the other color.ç°¡å–®ä¾†èªªï¼Œalexå¯ä»¥æ§åˆ¶å°æ–¹æ‹¿åˆ°çš„ä¸€å®šæ˜¯ç™½è‰²å †æˆ–æ˜¯é»‘è‰²å †ï¼Œå› æ­¤åªè¦åœ¨ä¸€é–‹å§‹é¸æ“‡æ•¸é‡è¼ƒå¤§çš„é¡è‰²å°±ä¿è­‰å¯ä»¥è´å¾—éŠæˆ²\n          \nè¤‡é›œåº¦$O(N^2)$\n            é€™ä¸€é¡Œé™¤äº†è½‰ç§»å¼æ¯”è¼ƒé›£æƒ³ä¹‹å¤–ï¼Œè¦æ€éº¼æ¨£è½‰ç§»ä¹Ÿæ˜¯ä¸€å€‹å•é¡Œã€‚è½‰ç§»æ–¹å¼å¯ä»¥é€éå°ç¯„åœæ¸¬è³‡è©¦è‘—æ‰¾è½‰ç§»çš„è¦å¾‹ï¼Œå¦‚ä½•è½‰ç§»å‰‡å¯ä»¥é€éç•«è¡¨æ ¼çš„æ–¹å¼ç†è§£ã€‚\n          \n","categories":["DPé¡Œè§£"],"tags":["é¡Œè§£","DP"]},{"title":"DPä¾‹é¡Œ","url":"/dp2/","content":"tioj-1354 æ± å¡˜è£¡çš„é’è›™é¡Œåºé€™æ˜¯ä¸€å€‹æ’åˆ—çµ„åˆçš„æ•¸å­¸é¡Œç›®ï¼Œé€éå‹•æ…‹è¦åŠƒç´€éŒ„å°å•é¡Œçš„ç­”æ¡ˆ\nå®šç¾©å®šç¾©$dp[i][0]$ç‚ºè·³iæ¬¡ä¸å›åˆ°Açš„æ–¹æ³•æ•¸ï¼Œ$dp[i][1]$ç‚ºè·³iæ¬¡å›åˆ°Açš„æ–¹æ³•æ•¸\nè½‰ç§»æ–¹å¼\n$dp[i][1]$ = $dp[i-1][0]$æ‡‰è©²ä¸é›£ç†è§£ï¼Œå›åˆ°Açš„æ–¹æ³•æ•¸ç‚ºä¸Šä¸€æ¬¡ä¸å›åˆ°Açš„æ–¹æ³•æ•¸ * 1\n$dp[i][0] = 3\\times dp[i-1][1]+2\\times dp[i-1][0]$ä¸å›åˆ°Aå¯ä»¥åˆ†ç‚º2ç¨®æƒ…æ³ï¼Œä¸Šä¸€æ¬¡å›åˆ°Aä¹‹å¾Œï¼Œå¯ä»¥å¾€B,C,Dï¼Œå…±ä¸‰ç¨®æƒ…æ³ã€‚ä¸Šä¸€æ¬¡ä¸å›åˆ°Açš„æƒ…æ³ä¸­ï¼Œæ¯ä¸€å€‹éƒ½æœ‰å…©å€‹å¯ä»¥å»çš„åœ°æ–¹ã€‚é‚Šç•Œæ¢ä»¶$dp[0][1] = 0, dp[0][0] = 1$ç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t,k;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;k;        int dp[k+1][2];        memset(dp, 0, sizeof(dp));        dp[0][0] = 0;dp[0][1] = 1;        for(int i=1;i&lt;=k;i++)&#123;            dp[i][1] = dp[i-1][0];            dp[i][0] = 3*dp[i-1][1]+2*dp[i-1][0];        &#125;        cout&lt;&lt;dp[k][1]&lt;&lt;endl;    &#125;&#125;\nè¤‡é›œåº¦\n            é€™ä¸€é¡Œå¾ˆè¨å­çš„ï¼Œæ²’æœ‰çµ¦å®šæ¸¬è³‡çš„ç¯„åœï¼Œä¸ç„¶æ‡‰è©²æ˜¯å¯ä»¥ç›´æ¥å»ºè¡¨ç„¶å¾Œç”¨O(1)çš„è¤‡é›œåº¦æ±‚ç­”æ¡ˆ\n          \n\n\ntioj-1019 Jumping Upé¡Œåº\nå®šç¾©å®šç¾© dp[i] ç‚ºç¬¬ 0 å€‹åˆ°ç¬¬ i å€‹éˆ´éºçš„æœ€å°ç§»å‹•æ°´å¹³è·é›¢ç¸½å’Œ\nè½‰ç§»æ–¹å¼ä»¤$a0,a_1â€¦a{n-1}$ç‚ºç›¸å°æ–¼è¢å¹•æ­£ä¸­å¤®çš„æ°´å¹³ä½ç§»ï¼Œé¸æ“‡è·³ä¸€æ ¼æˆ–è·³å…©æ ¼ã€‚\n$dp[i] = min(dp[i-1]+abs(ai-a{i-1}),dp[i-2]+abs(ai-a{i-2}))$\né‚Šç•Œæ¢ä»¶$dp[0] = 0,$ $dp[1] = abs(a_1-a_0)$\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int T,N;signed main()&#123;    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;N;        int arr[N+1],dp[N+1];        memset(arr, 0, sizeof(arr));        memset(dp, 0, sizeof(dp));                for(int i=0;i&lt;N;i++)cin&gt;&gt;arr[i];        dp[0] = 0;dp[1] = abs(arr[1]-arr[0]);                for(int i=2;i&lt;N;i++)&#123;            dp[i] = min(dp[i-1]+abs(arr[i]-arr[i-1]),                        dp[i-2]+abs(arr[i]-arr[i-2]));        &#125;        cout&lt;&lt;dp[N-1]&lt;&lt;endl;    &#125;&#125;\nè¤‡é›œåº¦\n            é€™ä¸€é¡Œ$dp_i$åªæœƒè·Ÿå‰å…©é …æœ‰é—œä¿‚ï¼Œå¥½åƒå¯ä»¥ç”¨æ»¾å‹•DPä¾†å„ªåŒ–ç©ºé–“ï¼Œå¯ä»¥ä»¥å¾Œå˜—è©¦çœ‹çœ‹ï¼\n          \ntioj-1097 . F.ç‡Ÿåœ°tioj1097é¡Œåºleetcodeé¡Œåº\nå®šç¾©å®šç¾© dp[i][j] ç‚ºä»¥ç´¢å¼•(i,j)æ–¹æ ¼ç‚ºæ­£æ–¹å½¢å³ä¸‹è§’æ‰€å½¢æˆçš„æœ€å¤§æ­£æ–¹å½¢é‚Šé•·\nè½‰ç§»æ–¹å¼$dp(i,j)=min(dp(iâˆ’1,j),dp(iâˆ’1,jâˆ’1),dp(i,jâˆ’1))+1$çœ‹ä¸€å€‹æ ¼å­—æ˜¯å¦å¯ä»¥æ§‹æˆæ›´å¤§çš„æ­£æ–¹å½¢ï¼Œè¦ä»¥å®ƒä¸Šæ–¹ã€å·¦æ–¹ã€å·¦ä¸Šæ–¹çš„æ ¼å­ä¾†æ±ºå®šï¼ˆå·¦ã€å·¦ä¸Šã€ä¸Šè·Ÿå®ƒè‡ªå·±å‰›å¥½å¯ä»¥æ§‹æˆä¸€å€‹æ­£æ–¹å½¢ï¼‰\né‚Šç•Œæ¢ä»¶åˆå§‹åŒ–ç‚ºé¡Œç›®çµ¦å®šçš„0èˆ‡1ï¼ˆ0ä»£è¡¨ä¸èƒ½æ”¾ã€1è¡¨ç¤ºå¯ä»¥æ”¾ï¼‰\nç¨‹å¼ç¢¼leetcode 221class Solution &#123;public:    int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123;        int row = matrix.size(),col = matrix[0].size(),ans = 0;;                for(int i=0;i&lt;row;i++)&#123;            for(int j=0;j&lt;col;j++)&#123;                matrix[i][j]-=&#x27;0&#x27;;                if(matrix[i][j]==1&amp;&amp; ans ==0)ans = 1;                if(i==0||j==0)continue;                                if(matrix[i][j]==1)&#123;                    matrix[i][j] = min(min(matrix[i-1][j],matrix[i][j-1]),                                       matrix[i-1][j-1])+1;                    ans = max((int)matrix[i][j],ans);                &#125;            &#125;          &#125;        return ans*ans;    &#125;&#125;;tioj 1097#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int L,W,dp[2][5005],ans;void input(int ind)&#123;    for(int k=0;k&lt;W;k++)&#123;            int temp;            cin&gt;&gt;temp;            if(temp == 2)dp[ind][k] = 0;            else dp[ind][k] = 1;            if(dp[ind][k]==1&amp;&amp;ans == 0)ans = 1;    &#125;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;L&gt;&gt;W)&#123;        ans = 0;        if(L==0 &amp;&amp; W==0)break;        input(0);                for(int i=0;i&lt;L-1;i++)&#123;            input(1);            for(int j=1;j&lt;W;j++)&#123;                if(dp[1][j]==1)&#123;                    dp[1][j] = min(dp[0][j],min(dp[0][j-1],dp[1][j-1]))+1;                    ans = max(ans,dp[1][j]);                &#125;            &#125;            for(int i=0;i&lt;W;i++)dp[0][i] = dp[1][i];        &#125;        cout&lt;&lt;ans*ans&lt;&lt;endl;    &#125;&#125;\nè¤‡é›œåº¦\n            å¯¦ä½œé‡åˆ°çš„ä¸€äº›å•é¡Œï¼šé™£åˆ—ç›´æ¥é–‹ç©ºé–“è¤‡é›œåº¦æœƒçˆ†æ‰ï¼Œæ‰€ä»¥è¦ç”¨åˆ°æ»¾å‹•DP ï¼ˆä¸ç„¶æœƒMLEï¼‰ç•¶i=0 èˆ‡j=0 æ™‚æœƒè¢«å¿½ç•¥æ‰ï¼Œå¦‚æœåªæœ‰åœ¨i=0 æˆ–j=0 å‡ºç¾1è€Œå…¶ä»–éƒ½æ˜¯0ï¼ˆä¸èƒ½æ”¾ï¼‰çš„æ™‚å€™ï¼Œå°±æœƒå‡ºç¾ç­”æ¡ˆç‚º0çš„æƒ…æ³ï¼Œåœ¨è¼¸å…¥æ™‚å°±è¦åšä¿®æ­£å› ç‚ºä½¿ç”¨äº†æ»¾å‹•DPï¼Œæ‰€ä»¥åœ¨ä¸€é–‹å§‹æœƒå…ˆè¼¸å…¥ç¬¬ä¸€æ’ï¼Œé€™æ™‚ç¸½å…±å‰©ä¸‹L-1æ’ï¼Œæ‰€ä»¥åœ¨ç¬¬24è¡Œè¦æ˜¯L-1æ¬¡ï¼Œæ‰ä¸æœƒéœ€è¦å¤šè¼¸å…¥ä¸€è¡Œã€‚\n          \n1029  AéŠæˆ²tioj1029leetcode877\n\næœ‰ä¸€ä¸²ç”±Nå€‹æ­£æ•´æ•¸æ‰€çµ„æˆçš„æ•¸åˆ—ï¼Œå…©å€‹ç©è€…è¼ªæµæ‹¿èµ°ä¸€å€‹æœ€å·¦é‚Šæˆ–æœ€å³é‚Šçš„æ•¸ï¼Œç›´åˆ°æœ€å¾Œæ‰€æœ‰çš„æ•¸éƒ½å–å®Œä¹‹å¾Œï¼Œå…©å€‹ç©è€…åˆ†åˆ¥æŠŠè‡ªå·±æ‰€å–åˆ°æ•¸åŠ ç¸½ï¼Œåˆ†æ•¸è¼ƒé«˜çš„äººç²å‹ã€‚ç¯„ä¾‹è¼¸å…¥64 7 2 9 5 2è¼¸å‡º 18 11\n\nå®šç¾©é€™ä¸€é¡Œç”¨åˆ°çš„æ˜¯å€é–“DPå®šç¾©dp[i][j]ç‚ºå€é–“$[i,j]$ä¸­å…ˆæ‰‹å¯ä»¥æ‹¿åˆ°çš„æœ€å¤§å€¼ï¼Œå› ç‚ºå…ˆå¾Œæ‰‹æ‹¿çš„ç¸½å’Œä¸è®Šï¼Œæ‰€ä»¥å¾Œæ‰‹åœ¨å€é–“$[i,j]$ å¯ä»¥æ‹¿åˆ°çš„æœ€å¤§å€¼ç‚º $sum[i,j]-dp[i][j]$ã€‚åŒæ™‚ï¼Œ$dp[i][i] = arr[i]$    (å…ˆæ‰‹å–)\nè½‰ç§»æ–¹å¼ç”±é¡Œç›®å¯çŸ¥ï¼Œå…ˆå¾Œæ‰‹éƒ½æ˜¯ä»¥æœ€ä½³ç­–ç•¥ä¾†ç©é€™å€‹éŠæˆ²ï¼Œè€Œå€é–“$[l,r]$ä¸­å…ˆæ‰‹åœ¨å€é–“$[l+1,r]$ ä¸­å°±è®Šæˆå¾Œæ‰‹ï¼ˆå°æ‰‹å…ˆæ‹¿ï¼‰ï¼Œå› æ­¤å¯ä»¥æ¨å¾—è½‰ç§»å¼ï¼š\ndp[i][j] = max(sum[i+1,j]-dp[i+1][j]+arr[i],\n                sum[i,j-1]-dp[i][j-1]+arr[j])ï¼ˆç¬¬ä¸€é …å–æœ€å·¦é‚Šï¼Œç¬¬äºŒé …ä»£è¡¨å–æœ€å³é‚Šï¼‰ä»¥æ­¤åœ–ç‚ºä¾‹ï¼Œä»¥iç‚ºæ©«è»¸ä»£è¡¨å‡ºç™¼é»ï¼Œjç‚ºç¸±è»¸ä»£è¡¨çµ‚é»ï¼Œç”±ä¸Šè€Œä¸‹ã€ç”±å³è€Œå·¦ä¾åºæŠŠå·¦ä¸‹è§’çš„è¡¨æ ¼å¡«æ»¿ã€‚æ‰€æ±‚å³ç‚º(i,j) = (1,6)ã€‚\né‚Šç•Œæ¢ä»¶$dp[i][i] = arr[i]$\nç¨‹å¼ç¢¼ä¸Šæ–¹çš„sumï¼Œå¯ä»¥é€éè¡¨æ ¼å„²å­˜å‰ç¶´å’Œï¼Œå¿«é€Ÿæ±‚å¾—#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);using namespace std;int n;int main()&#123;    ios    cin&gt;&gt;n;    int dp[n+1][n+1],pref[n+1],arr[n+1];    memset(dp,0,sizeof(dp));    pref[0] = 0;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        dp[i][i] = arr[i];        pref[i] = pref[i-1]+arr[i];    &#125;    for(int i=n-1;i&gt;0;i--)&#123;        for(int j=i+1;j&lt;=n;j++)&#123;            dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+arr[i],//å³æ ¼                           pref[j-1]-pref[i-1]-dp[i][j-1]+arr[j]);//ä¸Šæ ¼        &#125;    &#125;    cout&lt;&lt;dp[1][n]&lt;&lt;&quot; &quot;&lt;&lt;pref[n]-dp[1][n]&lt;&lt;endl;    //    for(int j=1;j&lt;n+1;j++)&#123;//        for(int i=1;i&lt;=n;i++)cout&lt;&lt;dp[i][j]&lt;&lt;&quot; &quot;;//        cout&lt;&lt;endl;//å°å‡ºdp//    &#125;&#125;\n            Leetcode 877é€™è£¡æœ‰ä¸€ç³»åˆ—çš„stone game è®ŠåŒ–é¡Œclass Solution &#123;public:    bool stoneGame(vector&lt;int&gt;&amp; piles) &#123;        int n = piles.size();        piles.insert(piles.begin(),0);        int dp[n+1][n+1],pref[n+1];        memset(dp,0,sizeof(dp));        memset(pref,0,sizeof(pref));        for(int i=1;i&lt;=n;i++)&#123;            dp[i][i] = piles[i];            pref[i] = pref[i-1]+piles[i];        &#125;                for(int i=n-1;i&gt;0;i--)&#123;            for(int j=i+1;j&lt;=n;j++)&#123;                dp[i][j] = max(pref[j]-pref[i]-dp[i+1][j]+piles[i],                              pref[j-1]-pref[i-1]-dp[i][j-1]+piles[j]);            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;        if(dp[1][n]&gt;pref[n]/2)return true;        else return false;    &#125;&#125;;é€™ä¸€é¡Œæœ‰ä¸€å€‹æ•¸å­¸è§£ï¼Œå¯ä»¥ä¿è­‰ç­”æ¡ˆä¸€å®šæ˜¯trueã€‚We can extend this idea to N piles. Say the first, third, fifth, seventh, etc. piles are white, and the second, fourth, sixth, eighth, etc. piles are black. Alex can always take either all white piles or all black piles, and one of the colors must have a sum number of stones larger than the other color.ç°¡å–®ä¾†èªªï¼Œalexå¯ä»¥æ§åˆ¶å°æ–¹æ‹¿åˆ°çš„ä¸€å®šæ˜¯ç™½è‰²å †æˆ–æ˜¯é»‘è‰²å †ï¼Œå› æ­¤åªè¦åœ¨ä¸€é–‹å§‹é¸æ“‡æ•¸é‡è¼ƒå¤§çš„é¡è‰²å°±ä¿è­‰å¯ä»¥è´å¾—éŠæˆ²\n          \nè¤‡é›œåº¦$O(N^2)$\n            é€™ä¸€é¡Œé™¤äº†è½‰ç§»å¼æ¯”è¼ƒé›£æƒ³ä¹‹å¤–ï¼Œè¦æ€éº¼æ¨£è½‰ç§»ä¹Ÿæ˜¯ä¸€å€‹å•é¡Œã€‚è½‰ç§»æ–¹å¼å¯ä»¥é€éå°ç¯„åœæ¸¬è³‡è©¦è‘—æ‰¾è½‰ç§»çš„è¦å¾‹ï¼Œå¦‚ä½•è½‰ç§»å‰‡å¯ä»¥é€éç•«è¡¨æ ¼çš„æ–¹å¼ç†è§£ã€‚\n          \n","categories":["C++åŸºç¤ä¸»é¡Œ","å‹•æ…‹è¦åŠƒ"],"tags":["DP","C++åŸºç¤ä¸»é¡Œ"]},{"title":"è¨ˆç®—å¹¾ä½•ï¼ˆComputational Geometryï¼‰","url":"/geo1/","content":"æš‘å‡å‰©æ²’å¤šå°‘å¤©äº†ï¼Œè¶•ç·Šè¿½é€²åº¦å•Šï¼\nèª²ç¨‹å…§å®¹åº§æ¨™èˆ‡å‘é‡\né•·åº¦ã€è§’åº¦ã€åº§æ¨™ã€å‘é‡\næœ€å¸¸ä»¥åº§æ¨™ã€å‘é‡è¡¨ç¤º\nDefine x first, y second\nå…§ç©Dotï¼š$A \\cdot B = A_xB_x+A_yB_y$\nå¤–ç©Crossï¼š$A \\times B = A_xB_y-A_yB_x$\né‹ç®—å­é‡è¼‰ï¼šåŠ æ¸›ä¹˜é™¤ã€å–ç´”é‡ï¼ˆ$abs()$ï¼‰\n\næœ‰å‘é¢ç©\nç”¨å¤–ç©ç®—é¢ç©ï¼ˆæœ‰æ­£è² ï¼šæœ‰å‘é¢ç©ï¼‰\né€†æ™‚é‡ç‚ºæ­£ã€é †æ™‚é‡ç‚ºè² \nå¤šé‚Šå½¢é¢ç©ï¼šä»»é¸å¹³é¢ä¸Šä¸€é»Aï¼Œå°‡æ‰€æœ‰é»èˆ‡Aé€£ç·š\né€éé †ã€é€†åŠ ç¸½æœ‰å‘é¢ç©ï¼ˆp0,p1â€¦pn,å…¶ä¸­p0=pnï¼‰\nAREA = $\\frac{1}{2}\\sum{i=0}^{N-1}\\vec{P_i}\\times\\vec{P{i+1}}$\n\nç·šæ®µç›¸äº¤\nç·šæ®µä¸å¹³è¡Œï¼š$P_1$ èˆ‡$P_2$ æœƒåœ¨ç·šæ®µ$P_3$ã€$P_4$ç•°å´ï¼ˆæ–¹å‘å‡½æ•¸ï¼‰\nç·šæ®µå¹³è¡Œï¼šæª¢é©—æ˜¯å¦å…±ç·šã€ä¸¦ç¢ºèªæŸä¸€å€‹é»æ˜¯å¦åœ¨ç·šæ®µä¸Š\n\nèª¤å·®åˆ†æï¼šEPS\nä½¿ç”¨äºŒé€²ä½å„²å­˜ï¼šå¿…ç”¢ç”Ÿèª¤å·®\nç²¾åº¦ï¼šfloat $10^{-7}$, double $10^{-16}$, long double $10^{-19}$\nèª¤å·®å®¹å¿å€¼$eps$ï¼Œå°‡ $x\\pm eps$è¦–ç‚º $x$\né‡è¼‰é‹ç®—å­ï¼š==ï¼ˆè¦–ç‚ºç›¸ç­‰ï¼‰,&gt;,&lt;ï¼ŒåŠ ä¸Šèª¤å·®ç¯„åœ\nEpså¤§å°ï¼šå¤šè½åœ¨ $10^{-6}$åˆ° $10^{-12}$ ä¹‹é–“\nèª¤å·®ï¼šåŠ æ¸›æ³•ï¼Œçµ•å°èª¤å·®ç›¸åŠ ï¼›ä¹˜é™¤æ³•ï¼Œç›¸å°èª¤å·®ç›¸åŠ \nä¸‹ç•Œï¼šæ•¸å­—ç¯„åœç‚ºVå…§æ™‚ï¼Œ$eps$ è‡³å°‘è¦VK ä¹˜ä¸Šè³‡æ–™å‹æ…‹æœ¬èº«èª¤å·®\nä¸Šç•Œï¼šé¡Œç›®ä¸€èˆ¬æœƒçµ¦\né¿å…èª¤å·®å¤§æ³•ï¼šéåˆ°æœ€å¾Œé—œé ­ï¼Œå¦å‰‡éƒ½ç”¨æ•´æ•¸é‹ç®—ï¼\n\nä¸‰è§’å‡½æ•¸\næ³°å‹’å±•é–‹å¼é€¼è¿‘ï¼Œæ™‚é–“ä¸¦éO(1)\n$atan2(y,x) = \\theta$ï¼Œå›å‚³å€¼åŸŸ$(-pi,pi]$\nå›å‚³long double ï¼šä½¿ç”¨$atan2l(y,x)$\nå¸¸æ•¸å¤§ï¼Œä¸å»ºè­°ä½¿ç”¨\n\nIEEE 754\nSign, Exponent, Mantissa\næ­£è² è™Ÿã€æŒ‡æ•¸éƒ¨åˆ†ã€å°æ•¸éƒ¨åˆ†\n\næ¥µè§’æ’åº\nçµ¦å®šå¾ˆå¤šé»ï¼Œä¾ç…§èˆ‡æŸç‰¹å®šé»ï¼ˆåŸé»ï¼‰çš„è§’åº¦é€²è¡Œæ’åº\nSort by crossï¼Œä¾ç…§å…§ç©æ’åº\né¡Œç›®ï¼šå¹³é¢ä¸Šnå€‹é»ï¼Œå•ä¸€æ¢ç›´ç·šæœ€å¤šé€šéå¹¾å€‹é»\n\nå‡¸åŒ…\nå¤šé‚Šå½¢ï¼šç°¡å–®å¤šé‚Šå½¢ï¼ˆé‚Šä¸ç›¸äº¤ï¼‰ã€å‡¸å¤šé‚Šå½¢ï¼ˆå…§è§’éƒ½â‰¤180ï¼‰ã€å‡¹å¤šé‚Šå½¢ï¼ˆæœ‰å…§è§’&gt;180ï¼‰\nèƒ½åŒ…ä½æ‰€æœ‰é»çš„å‡¸å¤šé‚Šå½¢\nå‡¸åŒ…æ±‚æ³•ï¼šMonotone Chainï¼ˆäºŒç¶­å¹³é¢ï¼‰ã€DCï¼ˆä¸‰ç¶­ï¼‰\nMonotone Chain\nå°‡æ‰€æœ‰é»æŒ‰ç…§(x,y)æ’åº\næŠŠä¸‹å‡¸åŒ…ã€ä¸Šå‡¸åŒ…ã€Œåœã€å‡ºä¾†\nåˆä½µä¸‹å‡¸åŒ…ã€ä¸Šå‡¸åŒ…\né–‹ä¸€å€‹vectorï¼ˆåŠŸèƒ½ç‚ºstackï¼‰ç´€éŒ„ç•¶å‰ä¸‹åŠå‡¸åŒ…\næª¢æŸ¥æ–°åŠ å…¥çš„é»æœƒè®“å“ªäº›é»ä¸å†æ˜¯å‡¸åŒ…ä¸Šçš„é»\n\n\n\næ¨¡æ“¬é€€ç«(SA)\nå°‹æ‰¾ç©ºé–“ä¸­è¿‘ä¼¼æœ€å„ªè§£\nä¸€å€‹éš¨æ©Ÿç®—æ³•\nä¾‹é¡Œï¼šçµ¦ä½ å¹³é¢ä¸Š N å€‹é»ï¼Œè«‹ä½ æ‰¾å‡ºä¸€å€‹é»ï¼Œä½¿å¾—é€™å€‹é»é€£åˆ°é€™ N å€‹é»çš„è·é›¢ç¸½å’Œæœ€çŸ­\n\nè¨ˆç®—å¹¾ä½•å‡½å¼æ¨¡æ¿è¨ˆç®—å¹¾ä½•æœ€é‡è¦çš„è«éæ–¼åº§æ¨™ä¸Šçš„é»ï¼Œå¯¦ä½œæ–¹å¼å¯ä»¥ç”¨ $std::pair$ æˆ–æ˜¯è‡ªå·±å®šç¾©ä¸€å€‹é¡åˆ¥ï¼Œå°‡é»çš„è³‡è¨Šä»¥åŠç›¸é—œçš„é‹ç®—å¼å®šç¾©å‡ºä¾†ã€‚æˆ‘å€‘ç¸½å…±éœ€è¦é‡è¼‰é»çš„å¤§æ–¼ã€ç­‰æ–¼ã€å°æ–¼çš„é‹ç®—å­ï¼Œä»¥åŠåŠ æ³•æ¸›æ³•ã€å‘é‡å¤–ç©å…§ç©ç­‰ï¼ŒåŒæ™‚é‚„æœ‰å¾ˆå¤šåŠŸèƒ½æ˜¯å¯ä»¥ç¹¼çºŒå®šç¾©ä¸‹å»ï¼Œä¾‹å¦‚å‘é‡ä¹˜ä¸Šä¸€å€‹å®šå€¼ï¼Œå¯ä»¥ç¹¼çºŒåŠ å…¥é¡åˆ¥ä¸­ã€‚\né»çš„æ¨¡æ¿åŠé‹ç®—å­é‡è¼‰struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(abs(x-b.x)&lt;=eps &amp;&amp; abs(y-b.y)&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;\nä»¥ä¸Šæ˜¯é è¨­é»çš„xåº§æ¨™yåº§æ¨™éƒ½æ˜¯æ•´æ•¸çš„æƒ…æ³ï¼Œå¦‚æœè¦æ”¹æˆä½¿ç”¨è‡ªå®šç¾©å‹åˆ¥ï¼Œå¯ä»¥æ”¹ç”¨æ¨£æ¿(Template)è‡ªå®šç¾©è³‡æ–™å‹åˆ¥ï¼Œæ ¹æ“šé¡Œç›®çš„è¦æ±‚ï¼Œä½¿ç”¨æ•´æ•¸æˆ–æ˜¯æµ®é»æ•¸é€²è¡Œé‹ç®—ã€‚\ntemplate &lt;typename T&gt;class pt&#123;    T x,y;    //ä¸‹æ–¹é‹ç®—å­é‡è¼‰èˆ‡ä¸Šæ–¹ç›¸åŒ&#125;pt&lt;int&gt; p[N];        //é»åº§æ¨™å®£å‘Šç‚ºæ•´æ•¸pt&lt;double&gt; pp[N];    //é»çš„ä¸åŒè³‡æ–™å‹åˆ¥å®£å‘Š\næ–¹å‘å‡½æ•¸é‡å° $\\vec a$ ä»¥åŠ $\\vec b$ å¤–ç©çš„çµæœï¼Œå¯ä»¥çŸ¥é“å…©è€…ä¹‹é–“ç›¸å°çš„æ–¹å‘ã€‚å¦‚æœ $\\vec a$ å’Œ $\\vec b$ å…±ç·šï¼Œå‰‡å›å‚³0ï¼Œ$\\vec a$ è½‰å‘ $\\vec b$ å¦‚æœæ˜¯é †æ™‚é‡å‰‡å›å‚³1ï¼Œå…¶é¤˜å›å‚³-1ã€‚\nint dir(pt a, pt b, pt o) &#123;                         //æ–¹å‘å‡½æ•¸    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;\né»èˆ‡ç·šæ®µé—œä¿‚ä»¥ä¸‹å‡½å¼å¯ä»¥åˆ¤æ–·é»oæ˜¯å¦åœ¨ $\\overline{AB}$ ä¸Šï¼Œé¦–å…ˆåˆ©ç”¨å¤–ç©æ˜¯å¦ç‚º0åˆ¤æ–·æ˜¯ $\\overline{OA}$ èˆ‡ $\\overline{OB}$ æ˜¯å¦å¹³è¡Œï¼›æ¥è‘—ä»¥å…§ç©åˆ¤æ–·æ˜¯å¦åœ¨ç·šæ®µä¸­ï¼Œè€Œéç·šæ®µçš„å…©å´ï¼ˆå¹³è¡Œçš„æ¢ä»¶ä¸‹å…§ç©åªå¯èƒ½æ˜¯1æˆ–æ˜¯-1ï¼‰ã€‚\nbool onseg(pt a, pt b, pt o)&#123;         //oæ˜¯å¦åœ¨abç·šæ®µä¸Š    int cross = (a - o) ^ (b - o);    //æ˜¯å¦å¹³è¡Œ    int dot = (a - o) * (b - o);      //æ˜¯å¦åœ¨ç·šæ®µä¸­    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;\nç·šæ®µç›¸äº¤ä»¥ä¸‹å‡½å¼ç‚ºçµ¦å®šå››å€‹é»$A,B,C,D$ï¼Œåˆ¤æ–· $\\overline{AB}$ æ˜¯å¦ç›¸äº¤æ–¼ $\\overline{CD}$ã€‚é¦–å…ˆæ˜¯ç‰¹ä¾‹çš„åˆ¤æ–·ï¼Œç·šæ®µçš„å…¶ä¸­ä¸€ç«¯é»åœ¨å¦ä¸€ç·šæ®µä¸Šï¼Œåˆ©ç”¨ä¸Šæ–¹é»èˆ‡ç·šæ®µé—œä¿‚çš„å‡½å¼å®Œæˆé€™å€‹åˆ¤æ–·ã€‚\nç‰¹ä¾‹åˆ¤æ–·å®Œæˆä¹‹å¾Œï¼Œæˆ‘å€‘éœ€è¦ç”¨åˆ°ä¸Šæ–¹æ–¹å‘å‡½å¼åˆ¤æ–·ç·šæ®µå…©ç«¯é»æ˜¯å¦åœ¨å¦ä¸€æ¢ç·šæ®µçš„ç•°å´ï¼Œå³ä»¥ä¸‹çš„é—œä¿‚å¼ï¼š\ndir(A,B,C)\\times dir(A,B,D) < 0æˆ‘å€‘è¦æª¢æŸ¥å…©æ¢ç·šæ®µï¼Œå…¶ç›¸ä¹˜çµæœå¿…é ˆçš†ç‚ºè² æ•¸ï¼Œè¡¨ç¤ºè™•æ–¼ç·šæ®µçš„ç•°å´ï¼æœ€å¾Œæ˜¯å¹³è¡Œç·šçš„åˆ¤æ–·ï¼Œå¦‚æœå…©ç·šå¹³è¡Œä¸”ç›¸äº¤ï¼Œè¡¨ç¤ºå…©ç·šå…±ç·šï¼Œé€™å¯ä»¥åœ¨ç‰¹ä¾‹æ™‚å°±è¢«åˆ¤æ–·å‡ºä¾†ã€‚\nbool Intersection(pt a, pt b, pt c, pt d)&#123;      //ç·šæ®µabæ˜¯å¦èˆ‡cdç›¸äº¤    if(onseg(a,b,c)||onseg(a,b,d))return true;  //é»cã€dæ˜¯å¦æ´½åœ¨ç·šæ®µabä¸Š    if(onseg(c,d,a)||onseg(c,d,b))return true;  //é»aã€bæ˜¯å¦æ´½åœ¨ç·šæ®µcdä¸Š    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                            //å°æ–¼ç·šæ®µå…©ç«¯é»çœ‹å¦å¤–å…©ç«¯é»å¿…é ˆæ–¹å‘ç›¸å    return false;&#125;\næ¥µè§’æ’åºåœ¨é€²è¡Œå…¨é»å°ç·šæ®µå…±ç·šå•é¡Œçš„åˆ¤æ–·æ™‚ï¼Œä½¿ç”¨æ¥µè§’æ’åºé€šå¸¸æœƒæ¯”å–®ç´”æš´åŠ›æšèˆ‰æ›´å¿«é€Ÿã€‚æ¥µè§’ä¹Ÿå°±æ˜¯æ¥µåº§æ¨™ä¸­æ¯ä¸€å€‹è·ŸåŸé»çš„å¤¾è§’ã€‚å¦‚æœå…©å€‹é»ä½åœ¨å·¦åŠå¹³èˆ‡å³åŠå¹³é¢ï¼Œå‰‡å…ˆå°‡å…¶åˆ¤æ–·å‡ºä¾†ï¼Œå¦‚æ­¤æ‰èƒ½ç¢ºå®šèµ·å§‹çš„è§’åº¦ç‚ºä½•ã€‚\nå¦‚æœä½åœ¨åŒä¸€å€‹å·¦å³åŠå¹³é¢ï¼Œå‰‡é€éå¤–ç©çš„æ–¹å¼æ¯”è¼ƒå…©å€‹å‘é‡çš„å…ˆå¾Œé †åºã€‚ä»¥ä¸‹ç¨‹å¼ç¢¼æ˜¯å¾åº§æ¨™å¹³é¢270åº¦çš„åœ°æ–¹é–‹å§‹é€†æ™‚é‡æƒä¸€åœˆä¾åºç¶“éçš„é»ã€‚\nbool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //é€†æ™‚é‡å°‡é»é€²è¡Œæ¥µè§’æ’åºï¼Œå¾270åº¦é–‹å§‹é€†æ™‚é‡&#125;sort(p.begin(),p.end(),cmp);     //ä»¥idç‚ºåŸé»é€²è¡Œæ¥µè§’æ’åº\nå‡¸åŒ…å‡½æ•¸ï¼ˆä½¿ç”¨Monotone Chainï¼‰é¦–å…ˆå…ˆå°‡æ‰€æœ‰é»ä¾ç…§xåº§æ¨™é€²è¡Œæ’åºï¼Œä¹‹å¾Œç”¨æƒæç·šç”±å·¦è€Œå³çš„å°‡ç¬¦åˆè¦æ±‚çš„é»æ¨å…¥ç¶­è­·çš„å–®èª¿å®¹å™¨ä¸­ï¼Œç¶­è­·ä¸‹å‡¸åŒ…ï¼Œæ¥è‘—åˆ©ç”¨reverse()å‡½æ•¸å°‡æ‰€æœ‰é»é€†åºï¼Œä¹Ÿå°±æ˜¯xåº§æ¨™ç”±å¤§åˆ°å°è®“æƒæç·šç”±å³è€Œå·¦æƒéä¸€éï¼Œå°‡ä¸Šå‡¸åŒ…ä¹Ÿåœèµ·ä¾†ã€‚æ™‚é–“è¤‡é›œåº¦ç‚º$O(n\\log n)$ã€‚\nbool check(pt a, pt b, pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa ^ bb) &gt;= 0;&#125;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //é¦–å…ˆå°xé€²è¡Œæ’åº    for(auto i : p)&#123;                   //ä¾åºèµ°è¨ªï¼Œå¦‚æœé‡åˆ°å¤–ç©&lt;0å‰‡ä¸åœ¨å‡¸åŒ…ä¸Š        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //åœ¨å‡¸åŒ…hullçš„æ¯ä¸€é»éƒ½ç¬¦åˆå¤–ç©å°æ–¼0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //xæœ€å¤§çš„é»æœƒåœ¨å‡¸åŒ…ä¸Šï¼Œä¸ç”¨åšå…©æ¬¡å…ˆpopä¸€æ¬¡    reverse(p.begin(),p.end());        //å°‡æ‰€æœ‰é»é€†åºä¹‹å¾Œåšä¸€æ¬¡ä¸Šé¢çš„å‡¸åŒ…    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //èµ·é»æœƒç¶“éå…©æ¬¡ï¼Œå‰›å¥½ä¾†ç®—æœ‰å‘é¢ç©&#125;\næ—‹è½‰å¡å°ºæ—‹è½‰å¡å°ºå¯ä»¥è¢«æ‡‰ç”¨åœ¨å°‹æ‰¾æœ€é é»å°ã€é¢ç©æœ€å¤§ä¸‰è§’å½¢ç­‰å•é¡Œã€‚åˆ©ç”¨å…©æ¢å¹³è¡Œçš„ç·šä¸­é–“å¤¾è‘—å‡¸åŒ…ï¼Œç¹ä¸€åœˆçš„éç¨‹ä¸­æ›´æ–°éœ€è¦æ±‚çš„æ•¸å€¼ã€‚å¯¦ä½œä¸Šä¾†èªªå°±æ˜¯ä½¿ç”¨å…©å€‹æŒ‡é‡ï¼Œåˆ†åˆ¥æŒ‡å‘æ—‹è½‰å¡å°ºçš„å¹³è¡Œç·šæ‰€åœ¨çš„å…©å€‹é»ï¼Œä¾ç…§æ—‹è½‰çš„æ–¹å‘é€²è¡Œå¢æ¸›çš„å‹•ä½œï¼\nbool check2(pt a,pt b,pt c,pt d)&#123;    int aa = abs((a - c)^(b - c));    int bb = abs((a - d)^(b - d));    return aa &lt; bb;&#125;void solve()&#123;    int ans = 0,d = h,sz = hull.size();    rep(i,0,sz-1)&#123;        while(check2(hull[i],hull[(i+1)%sz],hull[d],hull[(d+1)%sz]))            d = (d+1)%sz;        ans = max(ans,(hull[i]-hull[d]).dis());        ans = max(ans,(hull[(i+1)%sz]-hull[d]).dis());    &#125;&#125;\nåŸºæœ¬æ•¸å­¸çŸ¥è­˜è¨ˆç®—å¹¾ä½•åœç¹è‘—å¹¾å€‹ä¸»è»¸ï¼Œå‘é‡é‹ç®—ã€å…§ç©ã€å¤–ç©ï¼Œåˆ©ç”¨å®ƒå€‘é€²è¡Œè§’åº¦ã€å…±ç·šèˆ‡å¦ã€è·é›¢ç­‰ç­‰çš„åˆ¤æ–·ã€‚ä¹‹å‰æœ‰ç¨å¾®æ¥è§¸éå‘é‡ï¼Œä¸éå…§ç©èˆ‡å¤–ç©æ˜¯ç¬¬ä¸€æ¬¡ç¢°åˆ°çš„ä¸»é¡Œã€‚\nå› ç‚ºç›®å‰çµ•å¤§éƒ¨åˆ†çš„è¨è«–éƒ½æ˜¯åœ¨äºŒç¶­å¹³é¢ä¸Šé€²è¡Œï¼Œå› æ­¤ä»¥ä¸‹éƒ½æ˜¯ä»¥äºŒç¶­å¹³é¢ç‚ºå‰ææ‰€é€²è¡Œçš„è¨è«–ï¼\nå…§ç©ï¼ˆé»ç©ï¼‰å…§ç©è·Ÿ $\\cos\\theta$ æœ‰é—œï¼Œå› æ­¤ä¸»è¦å¯ä»¥å¹«åŠ©æˆ‘å€‘åˆ¤æ–·ç·šæ®µæ˜¯å¦å‚ç›´ï¼ˆç­‰æ–¼é›¶ï¼‰ã€ä»¥åŠå…±ç·šæ™‚é»ä½æ–¼æ­£å‘æˆ–æ˜¯åå‘çš„åˆ¤æ–·ï¼ˆç­‰æ–¼æ­£è² ä¸€ï¼‰ã€‚å…©å€‹å‘é‡ $\\vec u$ ä»¥åŠ $\\vec v$ çš„å…§ç©å¯ä»¥å¯«æˆä»¥ä¸‹é—œä¿‚å¼ï¼š\n\\vec u\\cdot \\vec v = |\\vec u||\\vec v|\\cos\\theta = u_1v_1 + u_2v_2å…©å€‹å‘é‡åšå…§ç©çš„æ­£è² è™Ÿæœƒè·Ÿé¤˜å¼¦å‡½æ•¸çš„æ­£è² è®ŠåŒ–ç›¸åŒï¼ˆå¦‚ä¸‹åœ–ï¼‰ï¼Œå€¼åŸŸç‚º $[-|\\vec u||\\vec v|,|\\vec u||\\vec v|]$ï¼Œä¸¦ä¸”åœ¨ $\\theta = 0,\\pi$ æœ‰æœ€å¤§æœ€å°å€¼ï¼Œ$\\theta = \\frac{\\pi}{2},\\frac{3\\pi}{2}$ çš„å€¼ç‚ºé›¶ã€‚\n\nå¤–ç©ï¼ˆå‰ç©ï¼‰å¤–ç©è·Ÿ $\\sin\\theta$ æœ‰é—œï¼Œä¸»è¦å¯ä»¥åˆ¤æ–·å…©å‘é‡æ–¹å‘é—œä¿‚ï¼ˆé †é€†æ™‚é‡æ—‹è½‰ï¼‰ã€æ˜¯å¦å¹³è¡Œã€æ¯”è¼ƒè§’åº¦å¤§å°ç­‰ã€‚å¤–ç©çš„æ‡‰ç”¨ååˆ†å»£æ³›ï¼Œæ‰¾å‡¸åŒ…ä»¥åŠæ—‹è½‰å¡å°ºéƒ½æœƒç”¨åˆ°å¤–ç©åˆ¤æ–·å…©å€‹å‘é‡è§’åº¦é—œä¿‚ã€‚å…©å€‹å‘é‡ $\\vec u$ ä»¥åŠ $\\vec v$ çš„å¤–ç©å¯ä»¥å¯«æˆä»¥ä¸‹é—œä¿‚å¼ï¼š\n\\vec u\\times \\vec v = |\\vec u||\\vec v|\\sin\\theta = \\begin{bmatrix}u_1&u_2\\\\v_1&v_2\\end{bmatrix}=u_1v_2 - u_2v_1ç”¨æ›´ç°¡å–®çš„æ–¹å¼ç†è§£å¤–ç© $\\vec u\\times \\vec v$ ï¼Œå…¶æ­£è² å€¼å¯ä»¥æƒ³åƒæˆ $\\vec u$ è½‰å‘ $\\vec v$ æ‰€ç¶“çš„åŠ£å¼§é †é€†æ™‚é˜æ–¹å‘ã€‚é †æ™‚é‡ç‚ºæ­£ã€é€†æ™‚é‡ç‚ºè² ã€‚\né—œæ–¼å¤–ç©çš„æ•¸å€¼è®ŠåŒ–ï¼Œèˆ‡æ­£å¼¦å‡½æ•¸çš„è®ŠåŒ–æ˜¯ä¸€æ¨£çš„ï¼ˆä¸‹åœ–ï¼‰ï¼Œå…¶å€¼åŸŸè·Ÿå…§ç©ä¸€æ¨£ï¼Œä¸éæœ€å¤§æœ€å°å€¼ç™¼ç”Ÿåœ¨ $\\theta = \\frac{\\pi}{2},\\frac{3\\pi}{2}$ï¼Œä¸¦åœ¨ $\\theta = 0,\\pi$ æ™‚å…©å‘é‡å‰ç©ç‚ºé›¶ã€‚\n\né¢ç©æ¸¬é‡å¸«å…¬å¼ï¼ˆè¡Œåˆ—å¼ï¼‰é€™æ˜¯ä¸€å€‹å¾çµ¦å®šå¤šé‚Šå½¢çš„åº§æ¨™æ¨å¾—é¢ç©çš„å…¬å¼ï¼Œå¯«æˆå¾ˆå¤šå€‹ä¸‰è§’å½¢æœ‰å‘é¢ç©çš„ç¸½å’Œã€‚ä»¥ä¸‹åœ–ä¾†èªªï¼Œ$\\triangle FBC$ã€$\\triangle FCD$ ã€$\\triangle FDE$ çš„æœ‰å‘é¢ç©çš†å¤§æ–¼é›¶ï¼Œè€Œ $\\triangle FAB$ã€$\\triangle FEA$ éƒ½æœƒå› ç‚ºæœ‰å‘é¢ç©æ˜¯è² çš„ï¼ˆé€†æ™‚é‡æ—‹è½‰ï¼‰è€Œè¢«æ‰£é™¤æ‰ï¼Œé‹ç®—çš„ç¸½å’Œå³æ˜¯å¤šé‚Šå½¢ $ABCDE$ çš„é¢ç©ï¼\n\nä¸€èˆ¬åŒ–çš„å…¬å¼ï¼Œå¤šé‚Šå½¢ä¸Šç¸½å…±æœ‰ $N$ å€‹é»ï¼Œä»¤ç¬¬ $N+1$ å€‹é»ç‚ºç¬¬1å€‹é»ï¼ˆç‚ºäº†è¦ç¹ä¸€åœˆè¨ˆç®—é¢ç©ï¼‰ï¼Œå¤šé‚Šå½¢é¢ç©ç‚ºï¼š\nAREA = \\frac{1}{2}\\sum_{i=1}^{N}\\vec{P_i}\\times\\vec{P_{i+1}}ä¸‰è§’å½¢å¤–ç©é¢ç©å…¬å¼ä¸‰è§’å½¢é¢ç©æœ‰éå¸¸å¤šç®—æ³•ï¼Œä¸éåˆ©ç”¨å¤–ç©çš„å…¬å¼é‚„æ˜¯ç¬¬ä¸€æ¬¡è½åˆ°ã€‚ä»¥ä¸‹æ˜¯å…¬å¼æ¨å°éç¨‹ï¼š\nå…ˆå¾é«˜ä¸­ä¸‰è§’å‡½æ•¸çš„ä¸‰è§’å½¢å…¬å¼é–‹å§‹ï¼š\n\\begin{split}\\triangle ABC &= \\frac{1}{2}\\overline{AB}\\,\\overline{AC}\\cdot\\sin A\n\\\\&=\\frac{1}{2}\\sqrt{\\overline{AB}^2\\,\\overline{AC}^2\\,(1-\\cos^2A)}\n\\\\&=\\frac{1}{2}\\sqrt{\\overline{AB}^2\\,\\overline{AC}^2-(\\overline{AB}\\cdot\\overline{AC})^2}\n\\\\&=\\frac{1}{2}\\sqrt{(x_1^2+y_1^2)(x_2^2+y_2^2)-(x_1\\,x_2+y_1\\,y_2)^2}\n\\\\&=\\frac{1}{2}\\sqrt{(x_1^2\\,y_2^2)+(x_2^2\\,y_1^2)-2x_1\\,y_2\\,x_2\\,y_1}\n\\\\&=\\frac{1}{2}\\sqrt{[(x_1\\,y_2)-(x_2\\,y_1)]^2}\n\\\\&=\\frac{1}{2}|\\overrightarrow{AB}\\times \\overrightarrow{AC}|\\end{split}å°‡ä¸‰è§’å½¢å…¶ä¸­ä¸€é»å°å¦å¤–å…©é»çš„å‘é‡åšå¤–ç©ï¼Œé™¤ä»¥2å³ç‚ºä¸‰è§’å½¢é¢ç©ã€‚é€™å€‹å…¬å¼æœƒåœ¨æ—‹è½‰å¡å°ºçš„åœ°æ–¹ä½¿ç”¨åˆ°ï¼\nå¹³è¡Œå››é‚Šå½¢é¢ç©æ ¹æ“šä¸Šé¢ä¸‰è§’å½¢é¢ç©å…¬å¼çš„æ¨å°ï¼Œå¯ä»¥ç›¸å°æ‡‰å¾—çŸ¥é“å…©å‘é‡æ‰€å¤¾å¹³è¡Œå››é‚Šå½¢é¢ç©å…¬å¼ï¼š\nAREA = |\\overrightarrow{AB}\\times \\overrightarrow{AC}|\n","categories":["C++é€²éšä¸»é¡Œ","è¨ˆç®—å¹¾ä½•"],"tags":["è¨ˆç®—å¹¾ä½•","æš‘æœŸç­†è¨˜"]},{"title":"[é¡Œè§£]NEOJ 398 å‘é‡åŠ æ³•","url":"/geo2-1/","content":"å‘é‡åŠ æ³•\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ï¼šçµ¦ä½ nå€‹æ•¸å­—ï¼ˆ0â‰¤i&lt;1ï¼Œå°æ•¸é»ç²¾åº¦åˆ°æœ«ä¹ä½ï¼‰ï¼Œæƒ³çŸ¥é“åˆ°åº•æœ‰å¤šå°‘çµ„ $(i,j,k)$ æ»¿è¶³ $v_i+v_j=v_k$ï¼Œå…¶ä¸­ $i,j,k$ å¯ä»¥é‡è¤‡ã€‚\n\né€™é¡Œå…¶å¯¦è·Ÿè¨ˆç®—å¹¾ä½•æ²’ä»€éº¼é—œä¿‚ï¼Œç›´æ¥ç”¨unordered_mapå»åšï¼ˆæœ‰é»åƒtwo sumï¼Œä¸éä¸‹é¢çš„codeå¥½åƒä¹Ÿä¸ç”¨é–‹åˆ°multiï¼‰ï¼Œç°¡å–®ï¼ä¸éæˆ‘åœ¨æµ®é»æ•¸çš„åœ°æ–¹åƒäº†ä¸€äº›WAï¼Œæœ€å¾Œç®—äº†ç›´æ¥æ”¹ç”¨å­—ä¸²è™•ç†é€™å€‹æƒ±äººçš„æ±è¥¿XD\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define int long long#define double long double#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rep2(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define eps (1e-9)#define INF 1e10#define N 2001#define ll long long#define ld long double#define int long longusing namespace std;int n;signed main()&#123;    cin&gt;&gt;n;    vector&lt;int&gt; vec(n);    rep2(i,0,n)&#123;        string s;cin&gt;&gt;s;        int num = 0,times = 1000000000;        for(int i=2;i&lt;=10;i++)&#123;            num += (s[i]-&#x27;0&#x27;)*times;            times/=10;        &#125;        vec[i] = num;    &#125;    unordered_multimap&lt;int,int&gt; mp;    for(int i=0;i&lt;n;i++)&#123;        mp.insert(&#123;vec[i],i&#125;);    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            ans += mp.count(vec[i] + vec[j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]TIOJ 1105 H.PS3","url":"/geo2-10/","content":"TIOJ 1105 H.PS3\né¡Œç›®é€£çµSubmission $O(n^2)$Submission $O(n\\log n)$\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å¹³é¢ä¸ŠNå€‹é»ï¼ˆNâ‰¤3000ï¼‰ï¼Œè«‹æ±‚å‡ºæœ€é é»å°çš„ç´¢å¼•å€¼ï¼ˆå°çš„åœ¨å‰ã€å¤§çš„åœ¨å¾Œï¼‰\n\næˆ‘åšäº†ä¸€ä»½æœ€è¿‘é»å°ï¼šä¸åŒè¤‡é›œåº¦ä¹‹è§£æ±ºæ–¹å¼çš„ç­†è¨˜ï¼Œå…±æœ‰å››ç¨®æ–¹æ³•å¯ä»¥è§£æ±ºé‚£å€‹å•é¡Œï¼Œé€™ä¸€é¡Œè¦æ±‚çš„æ˜¯æœ€é é»å°ï¼Œä½œæ³•èˆ‡æœ€è¿‘é»å°å…¶å¯¦å·®è »é çš„ã€‚ç”±ä¸Šå¹¾é¡ŒçŸ¥é“å‡¸åŒ…çš„æ±‚æ³•ï¼Œå› ç‚ºå‡¸åŒ…æ˜¯å¯ä»¥åœä½æ‰€æœ‰é»çš„å¤šé‚Šå½¢ï¼Œå› æ­¤æœ€é é»å°ä¹Ÿæ‡‰è©²åœ¨å‡¸åŒ…ä¸Šï¼Œè€Œä¸”æ‰€åœ¨çš„ä½ç½®æœƒç‚ºåœ¨å‡¸åŒ…çš„å…©å´ä¸Šï¼ˆå¦‚æœä¸è½åœ¨å‡¸åŒ…ä¸Šï¼Œä¸€å®šå¯ä»¥æŠŠé»å‘å…©å´å»¶ä¼¸åˆ°å‡¸åŒ…ä¸Šï¼Œä¸”ç§»å‹•éå¾Œçš„é»å°è·é›¢ä¸€å®šæ¯”åŸå§‹çš„é»å°è·é›¢å¤§ï¼‰ã€‚\næ‰¾å®Œå‡¸åŒ…ä¹‹å¾Œï¼Œå¯ä»¥ç”¨æ—‹è½‰å¡å°ºçš„æ–¹å¼å°‹æ‰¾æœ€é é»å°ã€‚æƒ³åƒå…©æ¢å¹³è¡Œç·šä¸­é–“å¤¾è‘—å‡¸åŒ…ï¼Œé€†æ™‚é˜æ—‹è½‰ç¹è¡Œå‡¸åŒ…ä¸€åœˆï¼Œéç¨‹ä¸æ–·æ›´æ–°æœ€é é»å°çš„è·é›¢ã€‚åœ¨å¯¦ä½œä¸Šå…©æ¢å¹³è¡Œç·šå¯ä»¥è¢«æƒ³åƒæˆç”± $Pi$ æŒ‡å‘ $P{i+1}$ çš„å‘é‡ï¼Œé€éå¤–ç©ä¸‰è§’å½¢é¢ç©å…¬å¼æ±ºå®šå¡å°ºè©²å¦‚ä½•ç§»å‹•ã€‚\nAREA = |\\overrightarrow{AB}\\times \\overrightarrow{AC}|ä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œæˆ‘å€‘è¦æ‰¾ $\\overline{HM}$ ç‚ºåº•å¯ä»¥å½¢æˆçš„æœ€å¤§ä¸‰è§’å½¢é¢ç©çš„é ‚é»ï¼Œå› ç‚ºåœ¨åŒåº•çš„æƒ…æ³ä¸‹é¢ç©å°±ä»£è¡¨é»èˆ‡é‚Šçš„å‚ç›´è·é›¢ï¼Œæœ€å¤§çš„å‚ç›´è·é›¢æ„å‘³è‘—é€™æ¢åº•é‚Šå¯ä»¥å‚ç›´å»¶ä¼¸çš„æœ€é è·é›¢ã€‚å› ç‚ºå‡¸åŒ…å¿…å®šæ˜¯å‡¸å¤šé‚Šå½¢ï¼Œå› æ­¤ä¸‰è§’å½¢çš„é¢ç©æœƒå‘ˆç¾å–®å³°å‡½æ•¸ï¼Œå› æ­¤åªéœ€è¦å¾ä¸‹ä¸€å€‹ä¸‰è§’å½¢é¢ç©çš„å¤§å°ï¼Œæ±ºå®šé›™æŒ‡é‡ä¸­æ¯”è¼ƒå¿«çš„æŒ‡æ¨™çš„ç§»å‹•æƒ…æ³ã€‚\n\nå¦‚æœä»”ç´°ä¾†çœ‹ï¼Œä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œç•¶å‰è¼ƒå¿«çš„æŒ‡æ¨™æŒ‡å‘çš„ä½ç½®æ˜¯ $D$ é»ï¼Œè€ƒæ…®ä¸€æ¢èˆ‡èˆ‡ $\\overline{HM}$ å¹³è¡Œçš„ç›´ç·šï¼Œè‹¥ä¸‹ä¸€å€‹é» $J$ åœ¨å¹³è¡Œç·šæ®µçš„å¦å¤–ä¸€å´ï¼Œå‰‡å°‡æŒ‡æ¨™ç§»å¾€ $J$ é»ã€‚å¯èƒ½æœƒæœ‰ä¸€å€‹ç–‘å•ï¼Œå¦‚æœæ¯”è¼ƒä¸‹åœ–çš„ç·šæ®µé•·åº¦ï¼Œæœƒç™¼ç¾åˆ° $\\overline{DH}$ çš„é•·åº¦æ¯”ç¶“é $J$ é»çš„å…©æ¢ç·šæ®µéƒ½é‚„è¦é•·ï¼Œé‚£ç‚ºä½•é‚„è¦æ›´æ–°è‡³ $J$ é»ï¼Ÿèˆ‰é€™å€‹ä¾‹å­ä¸å¤ªå¥½ï¼Œä¸éå¯ä»¥æƒ³åƒç•¶æ—‹è½‰å¡å°ºè½‰åˆ°ä»¥ $\\overline{FH}$ ç‚ºåº•çš„æ™‚å€™ï¼Œæœƒå°‡æœ€é é»å°çš„è·é›¢æ›´æ–°æˆ $\\overline{HD}$ çš„é•·åº¦ã€‚å¦‚æœä»Šå¤© $H$ çš„å·¦å´åˆå¤šåŠ äº†ä¸€å€‹æ–°é» $P$ï¼Œå‰‡æœ€é é»å°æœƒè®Šæˆ $\\overline{PD}$ çš„è·é›¢ã€‚\nç°¡å–®ä¾†èªªï¼Œæœ€é é»å°ä¸€å®šæœƒç™¼ç”Ÿå°è§’çš„å‡¸åŒ…é»ä¸Šé¢ï¼Œå³ä½¿ç¾åœ¨ä»¥ $\\overline{HM}$ ç‚ºåº•æœ€é é»ä¸¦é $J$ è€Œæ˜¯ $D$ ï¼Œä½†åœ¨æ—‹è½‰å¡å°ºæ—‹è½‰åˆ° $\\overline{FH}$ æ™‚å°±èƒ½å°‡è·é›¢æ›´æ–°æˆ $\\overline{HD}$ çš„è·é›¢ã€‚\n\n\n            å¯¦ä½œå°ç´°ç¯€é€™ä¸€é¡Œæœ‰é»éº»ç…©ï¼Œå› ç‚ºä»–è¦è¼¸å‡ºçš„æ˜¯æœ€é é»å°çš„ç´¢å¼•å€¼ï¼Œè€Œä¸æ˜¯æœ€é é»å°ä¹‹é–“çš„è·é›¢ã€‚åœ¨å°‹æ‰¾å‡¸åŒ…çš„éç¨‹ä¸­ï¼Œæœƒå°æ‰€æœ‰é»é€²è¡Œæ’åºï¼Œå› æ­¤åŸæœ‰çš„ç´¢å¼•å€¼é †åºæœƒè¢«æ‰“äº‚ï¼Œéœ€è¦åœ¨ä¸€é–‹å§‹è¼¸å…¥çš„æ™‚å¾Œå°±å¥½å¥½ç¶­è­·æ¯ä¸€å€‹åº§æ¨™çš„ç´¢å¼•å€¼ã€‚\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y,ind;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot    int dis() &#123;return x*x + y*y;&#125;&#125;;vector&lt;pt&gt; p,hull;pt pt_ans;int n,h;bool check(pt a, pt b, pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa ^ bb) &gt;= 0;&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    int aa = abs((a - c)^(b - c));    int bb = abs((a - d)^(b - d));    return aa &lt; bb;&#125;bool cmp(pt a, pt b)&#123;    if(a == b)return a.ind &lt; b.ind;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void convex_hull()&#123;    stable_sort(all(p),cmp);    rep(i,0,n-2)if(p[i] == p[i+1])p[i+1].ind = p[i].ind;    hull.clear();    for(auto i : p)&#123;        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    int sz = hull.size();    h = hull.size()-1;    hull.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(hull.size() &gt; sz &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int ans = 0,d = h,sz = hull.size();    rep(i,0,sz-1)&#123;        while(check2(hull[i],hull[(i+1)%sz],hull[d],hull[(d+1)%sz]))            d = (d+1)%sz;        if(ans &lt; (hull[i]-hull[d]).dis())&#123;            ans = (hull[i]-hull[d]).dis();            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[i]-hull[d]).dis())&#123;            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;        if(ans &lt; (hull[(i+1)%sz]-hull[d]).dis())&#123;            ans = (hull[(i+1)%sz]-hull[d]).dis();            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[(i+1)%sz]-hull[d]).dis())&#123;            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;    &#125;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        pt_ans = (pt)&#123;0,0&#125;;        p.resize(n,&#123;0,0&#125;);        rep(i,0,n-1)&#123;            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;            p[i].ind = i;        &#125;        convex_hull();        solve();        cout&lt;&lt;pt_ans.x&lt;&lt;&quot; &quot;&lt;&lt;pt_ans.y&lt;&lt;endl;    &#125;&#125;/*59 11 51 29 95 1 */\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]ZJ b288 å¤å­£å¤§ä¸‰è§’","url":"/geo2-11/","content":"ZJ b288: å¤å­£å¤§ä¸‰è§’\né¡Œç›®é€£çµè§£é¡Œå ±å‘Š\n\né¡Œç›®æ•˜è¿°è«‹è¼¸å‡ºåœ¨Nå€‹äºŒç¶­å¹³é¢çš„åº§æ¨™ï¼ŒæŒ‘é¸3é¡†å‡ºä¾†æˆçµ„æˆä¸‰è§’å½¢çš„æœ€å¤§é¢ç©\n\næ¯”è¼ƒä¸€ä¸‹å…©å€‹è¤‡é›œåº¦çš„ä½œæ³•ï¼Œç¬¬ä¸€å€‹æ˜¯ä½¿ç”¨ $O(n^3)$ æšèˆ‰æ‰€æœ‰çš„é»ä¸¦è¨ˆç®—é¢ç©ï¼Œæ‰€éœ€è¦çš„æ™‚é–“æ˜¯0.4secï¼Œè€Œä¸”éœ€è¦ç‰¹åˆ¥æ³¨æ„ä¸èƒ½ä½¿ç”¨åˆ°æµ·é¾å…¬å¼è¨ˆç®—é¢ç©ï¼Œå¦å‰‡æœ‰å¾ˆå¤§çš„æ©Ÿæœƒæœƒè¶…æ™‚ã€‚\n\nä»¥ä¸‹ä½œæ³•æ˜¯å…ˆé€²è¡Œ $O(n\\log n)$ æ‰¾å°‹å‡¸åŒ…ï¼Œå› ç‚ºé¢ç©æœ€å¤§çš„ä¸‰è§’å½¢å¿…å®šä¸‰å€‹é»éƒ½åœ¨å‡¸åŒ…ä¸Šï¼Œå› æ­¤ç”¨ $n^2$ çš„æ™‚é–“é€²è¡Œæšèˆ‰ï¼Œæ—‹è½‰å¡å°ºï¼ˆé¡ä¼¼æœ€é é»å°çš„ä½œæ³•ï¼‰æ‰¾é¢ç©æœ€å¤§çš„ç¬¬ä¸‰å€‹é»ï¼Œå°±èƒ½åœ¨ç¸½æ™‚é–“è¤‡é›œåº¦ $O(n^2)$ å®Œæˆï¼ï¼ˆæœƒå†æ›´å°‘ï¼Œå› ç‚ºåªè¦æšèˆ‰å‡¸åŒ…ä¸Šçš„é»ï¼‰\n\nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    ld x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(abs(x-b.x)&lt;=eps &amp;&amp; abs(y-b.y)&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    ld operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    ld operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p,hull;int n,t,h;ld ans;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //é€™è£¡å¾ˆé—œéµï¼Œåˆ¥åƒWA&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    ld aa = (a - c)^(b - c);    ld bb = (a - d)^(b - d);    return aa &lt; bb;&#125;ld area(pt a,pt b)&#123;    return abs(a^b)/2;&#125;void convex_hull()&#123;    hull.clear();    sort(p.begin(),p.end(),cmp);       //é¦–å…ˆå°xé€²è¡Œæ’åº    for(auto i : p)&#123;                   //ä¾åºèµ°è¨ªï¼Œå¦‚æœé‡åˆ°å¤–ç©&lt;0å‰‡ä¸åœ¨å‡¸åŒ…ä¸Š        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //åœ¨å‡¸åŒ…hullçš„æ¯ä¸€é»éƒ½ç¬¦åˆå¤–ç©å°æ–¼0    &#125;    int down_hull = hull.size();    h = down_hull-1;    hull.pop_back();                   //xæœ€å¤§çš„é»æœƒåœ¨å‡¸åŒ…ä¸Šï¼Œä¸ç”¨åšå…©æ¬¡å…ˆpopä¸€æ¬¡    reverse(p.begin(),p.end());        //å°‡æ‰€æœ‰é»é€†åºä¹‹å¾Œåšä¸€æ¬¡ä¸Šé¢çš„å‡¸åŒ…    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int d,sz = hull.size();    rep(i,0,sz-1)&#123;        rep(j,i+1,sz-1)&#123;            d = (j+1)%sz;            while(check2(hull[i],hull[(j)%sz],hull[d],hull[(d+1)%sz]))                d = (d+1)%sz;            ans = max(ans,area((hull[d]-hull[i]),(hull[d]-hull[j])));        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    convex_hull();    ans = 0;    solve();    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]TIOJ 1500 Clean up on aisle 3","url":"/geo2-12/","content":"TIOJ 1500 Clean up on aisle 3\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°å¹³é¢ä¸Šnå€‹é»æ‰¾æœ€è¿‘é»å°çš„è·é›¢\n\næœ€è¿‘é»å°çœŸçš„æœ‰è¶…å¤šç¨®ä½œæ³•çš„ï¼Œæšèˆ‰ã€æƒæç·šã€åˆ†æ²»ã€éš¨æ©Ÿéƒ½å¯ä»¥åšï¼é€™é‚Šæœ‰ä¸€ç¯‡ç­†è¨˜æ¯”è¼ƒå„ç¨®æ™‚é–“è¤‡é›œåº¦çš„æœ€è¿‘é»å°ä½œæ³•ï¼Œé€™é‚Šä¸å¤šåšè´…è¿°ï¼\nä»¥ä¸‹ç¨‹å¼ç¢¼æ˜¯æƒæç·šæ¼”ç®—æ³•ï¼Œæœ€å·®æƒ…æ³ä¸‹çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(n^2)$ï¼Œå› ç‚ºéœ€è¦æ’åºï¼Œæ‰€ä»¥ä¸‹é™ç‚º $\\Omega(n\\log n)$ï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p,p+n);        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                if(p[j].x &gt; p[i].x + d)break;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]TIOJ 1280 é ˜åœŸ (Territory)","url":"/geo2-13/","content":"TIOJ 1280 é ˜åœŸ (Territory)\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ä¸€å€‹åœ‹å®¶æœ‰ n å€‹å®‰å…¨å“¨ï¼Œæ¯ä¸€å€‹éƒ½æœ‰åº§æ¨™ $(x,y)$ ï¼Œä»£è¡¨åœ¨åº§æ¨™è»¸ä¸Šçš„ä½ç½®ã€‚è¼¸å‡ºè©²åœ‹å®‰å…¨å“¨æ‰€èƒ½åœå‡ºçš„æœ€å¤§é ˜åœŸã€‚\n\nnå€‹é»æ‰€èƒ½åœæˆçš„æœ€å¤§é¢ç©ï¼Œå…¶å¯¦ç­‰åƒ¹æ–¼å‡¸åŒ…çš„é¢ç©ã€‚èˆ‡å‰å¹¾é¡Œçš„æœ€å°å‡¸å¤šé‚Šå½¢æ˜¯ä¸€æ¨¡ä¸€æ¨£çš„é¡Œç›®ï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)&#123;        area += (hull[i]^hull[i+1]);    &#125;    cout&lt;&lt;((area%2)?(area/2)+1:(area/2))&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]ZJ a871 Museum Area","url":"/geo2-14/","content":"ZJ a871: Museum Area\né¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°nå€‹é»åœæˆçš„å¤šé‚Šå½¢ï¼Œæ±‚é¢ç©\n\næ°´é¡Œï¼Œç›´æ¥å¥—è¡Œåˆ—å¼å…¬å¼å³å¯ç®—å‡ºç­”æ¡ˆï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pdd pair&lt;double,double&gt;#define int long long#define ld long double#define N 15#define x first#define y secondusing namespace std;int n;pdd p[N];ld check(pdd a, pdd b)&#123;    return a.x*b.y - a.y*b.x;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ld area = 0.0;        rep(i,0,n-1)area += check(p[i],p[i+1]);        ld ans = (ld)area/2;        if(ans&lt;0)ans = -ans;        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]TIOJ 1678 å‰ªå¤šé‚Šå½¢ï¼ˆmoldingï¼‰","url":"/geo2-15/","content":"TIOJ 1678 å‰ªå¤šé‚Šå½¢ï¼ˆmoldingï¼‰\né¡Œç›®é€£çµTIOJTIOJ Submissioné¡Œç›®é€£çµZJ\n\né¡Œç›®æ•˜è¿°é–“å–®ä¾†èªªæ˜¯æ±‚å‡ºå¤šé‚Šå½¢é¢ç©ä»¥åŠå‡¸åŒ…é¢ç©çš„å·®ï¼Œè©³ç´°å¯ä»¥é»ä¸Šé¢é¡Œç›®é€£çµã€‚\n\né¡Œç›®èªªå¤šé‚Šå½¢éœ€è¦æ‰å‰ªä¸‹çš„é¢ç©ï¼Œæˆ‘å€‘å°±ç®—å‡¸åŒ…é¢ç©ä»¥åŠå¤šé‚Šå½¢é¢ç©ï¼Œå…©è€…çš„å·®å»é™¤ä¸Šé¡Œç›®çµ¦çš„è‰²å¡Šé¢ç©å³æ˜¯ç­”æ¡ˆï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,a,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;int Polygon()&#123;    vector&lt;pt&gt; temp(p);    temp.push_back(temp[0]);    int area = 0;    rep(i,0,n-1)area += (temp[i]^temp[i+1]);    return abs(area);&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;a;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    ld small = (ld)Polygon()/2;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)area += (hull[i]^hull[i+1]);    ld big = (ld)area/2;    int ans = ceil((big-small)/a);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]ZJ d269 11579 Triangle Trouble","url":"/geo2-16/","content":"ZJ d269: 11579 - Triangle Trouble\né¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°æœ‰ä¸€å€‹ä¸‰è§’å½¢å·¥å» æœ‰ä¸€å€‹å¾ˆå¤§çš„å•é¡Œã€‚çµ¦ä½ ä¸€äº›é‚Šçš„é‚Šé•·ï¼Œæƒ³è¾¦æ³•æ‰¾å‡ºç”¨é€™äº›é‚Šé•·åœå‡ºæœ€å¤§çš„ä¸‰è§’å½¢ã€‚\n\næ ¹æ“šæµ·é¾å…¬å¼ï¼Œä¸‰è§’å½¢é¢ç©ï¼š\n\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)}å¯ä»¥åˆ©ç”¨è²ªå©ªæ³•ï¼Œå°‡æ‰€æœ‰é‚Šé•·ç”±å¤§åˆ°å°é€²è¡Œæ’åºï¼Œæ¯ä¸€æ¬¡æ‹¿æœ€å¤§çš„ä¸‰å€‹é‚Šé•·é€²è¡Œæšèˆ‰ï¼Œå³å¯ç®—å‡ºæœ€å¤§çš„ä¸‰è§’å½¢é¢ç©ã€‚ä¸é›£ç†è§£ï¼Œç•¶æ›ä¸Šä¸€å€‹æ¯”è¼ƒå¤§çš„é‚Šï¼Œç®—å‡ºä¾†çš„sä¹Ÿæœƒæ¯”è¼ƒå¤§ï¼Œè·Ÿé‚Šç›¸æ¸›çš„å€¼ä¹Ÿæœƒæ¯”è¼ƒå¤§ï¼Œç¸½é¢ç©è‡ªç„¶è¼ƒå¤§ï¼ˆå¥½å•¦ï¼Œé€™æ˜¯éå¸¸ä¸åš´è¬¹çš„è­‰æ˜XDï¼‰\nåœ¨æƒ³é¡Œéç¨‹ä¸­ï¼Œæˆ‘æœ‰æ€è€ƒåˆ°ï¼Œå¦‚æœå‘¨é•·ä¸€æ¨£çš„æƒ…æ³ä¸‹ï¼Œåˆ°åº•ä½•ç¨®é¢ç©çš„ä¸‰è§’å½¢é¢ç©æœƒæ¯”è¼ƒå¤§ï¼Ÿç­”æ¡ˆæ˜¯æ­£ä¸‰è§’å½¢ï¼\n\n            ä¸‰è§’å½¢å‘¨é•·å›ºå®šä¸‹é¢ç©çš„æ¯”è¼ƒæ ¹æ“šæµ·é¾å…¬å¼ï¼šs = \\frac{1}{2}(a+b+c)æƒ³è¦æ¯”è¼ƒåœ¨å‘¨é•·å›ºå®šä¸‹ä¸‰è§’å½¢çš„é¢ç©ï¼Œå¯ä»¥ç”¨ç®—å¹¾ä¸ç­‰å¼æ¯”è¼ƒï¼Œå› ç‚º $s$ æ˜¯å®šå€¼ï¼Œæ‰€ä»¥å¯ä»¥åˆ—å‡ºä»¥ä¸‹å¼å­ï¼š\\frac{(s-a)+(s-b)+(s-c)}{3} â‰¥ \\sqrt[3]{(s-a)(s-b)(s-c)}ç­‰å¥½æˆç«‹æ™‚ï¼Œ$a=b=c$ã€‚å› ç‚º$s = \\frac{a+b+c}{2}$ï¼Œå› æ­¤ï¼š(\\frac{a}{2})^2 â‰¥ (s-a)(s-b)(s-c)å¾—åˆ°æµ·é¾å…¬å¼\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)} â‰¤ \\sqrt{\\frac{3a}{2}\\cdot\\frac{a^3}{8}}=\\frac{\\sqrt{3}}{4}a^2\n          \nä»¥ä¸‹æ˜¯ä½¿ç”¨è²ªå©ªæ³•çš„AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define ll long long#define ld double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;int t,n;vector&lt;ld&gt; p;ld area(ld a ,ld b, ld c)&#123;    if(a &gt; b + c)return -1;    ld p = (a+b+c)/2;    return p*(p-a)*(p-b)*(p-c);&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,0);        rep(i,0,n-1)cin&gt;&gt;p[i];        sort(all(p),greater&lt;&gt;());        ld ans = 0;        rep(i,0,n-3)            ans = max(ans,area(p[i],p[i+1],p[i+2]));        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;sqrt(ans)&lt;&lt;endl;    &#125;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]NEOJ 399 ç­‰é•·ç·šæ®µå°","url":"/geo2-2/","content":"ç­‰é•·ç·šæ®µå°\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ï¼šçµ¦å®šå¹³é¢ä¸Šå¾ˆå¤šå€‹é»ï¼Œæ±‚å‡ºæœ‰å¹¾å°ç·šæ®µç­‰é•·ï¼ˆè¼¸å…¥æœ‰é‡è¤‡çš„é»ï¼‰ã€‚\n\næ—¢ç„¶nâ‰¤500ï¼Œé‚£å°±ç›´æ¥æšèˆ‰å§ï¼Œæ²’å•¥ç‰¹åˆ¥é›£åº¦ã€‚\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a,i&lt;=b;i++)#define rep2(i,a,b) for(int i=a;i&lt;b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];int dist(pii a,pii b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return x*x+y*y;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep2(i,0,n)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    map&lt;int,int&gt;mp;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            int dis = dist(p[i],p[j]);            mp[dis]+=1;        &#125;    &#125;    int ans = 0;    for(auto i:mp)&#123;        int cnt = i.second;        ans+=((cnt*(cnt-1))/2);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]NEOJ 400 å‘å·¦è½‰å‘å³è½‰","url":"/geo2-3/","content":"å‘å·¦è½‰å‘å³è½‰\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å¹³é¢ä¸Šnå€‹é»ï¼Œä¾åºèµ°è¨ªæ¯ä¸€å€‹é»ï¼Œè©¦å•èµ°è¨ªéç¨‹ä¸­å…±åŸ·è¡Œå¹¾æ¬¡çš„å·¦è½‰ã€å³è½‰ä»¥åŠè¿´è½‰ã€‚\n\nå¾ˆç‰¹åˆ¥ï¼Œè¨ˆç®—å¹¾ä½•è®“é›»è…¦å¯ä»¥è™•ç†å¹³å¸¸æˆ‘å€‘æ‰€çœ‹åˆ°çš„å¹³é¢åœ–å½¢ï¼Œå¯ä»¥åˆ©ç”¨å‘é‡å…§ç©ã€å¤–ç©ç­‰æ–¹å¼åˆ¤æ–·æ–¹å‘ã€‚é€™ä¸€é¡Œæœ€é‡è¦çš„å°±æ˜¯æ–¹å‘å‡½æ•¸ã€‚å‚³å…¥3å€‹é»$(A,B,O)$ï¼Œæ–¹å‘å‡½æ•¸æœƒæœƒå›å‚³$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ çš„æ­£è² æ•¸å€¼ã€‚\nä¸‹åœ–ç‚ºå¤–ç©$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ çš„çµæœï¼Œç•¶ $\\sin\\theta$çš„çµæœç‚ºè² ï¼Œä¹Ÿå°±æ˜¯ä¸‹åœ–çš„æƒ…æ³ï¼Œå¾Bèµ°åˆ°Aå°±éœ€è¦å¾€å·¦é‚Šèµ°ï¼›åä¹‹äº¦ç„¶ã€‚\nè‡³æ–¼å¦‚ä½•åˆ¤æ–·ç•¶å…©å€‹å‘é‡çš„æ–¹å‘å‘ˆç¾ä¸€ç›´ç·šæ™‚ï¼Œä¹Ÿå°±æ˜¯å¤–ç©å›å‚³çš„å€¼ç‚º0æ™‚ï¼ˆ$\\sin\\theta = 0$ï¼‰ï¼Œæ‡‰è©²æ˜¯åŒå‘é‚„æ˜¯ç•°å‘å‘¢ï¼Ÿé€™æ™‚å€™å°±éœ€è¦æ­é…å‘é‡å…§ç©ï¼ˆé€™æˆ‘æƒ³äº†å¾ˆä¹…ï¼‰ï¼Œå› ç‚ºå…§ç©å…¬å¼æ˜¯$A\\cdot B = |A||B|\\cos\\theta$ï¼Œå°‡å…©å€‹å‘é‡å…§ç©ä¹‹å¾Œå°±å¯ä»¥å¾ˆæ˜ç¢ºçš„åˆ¤æ–·åˆ°åº•æ˜¯æœåŸæœ¬çš„æ–¹å‘èµ°ï¼Œé‚„æ˜¯åæ–¹å‘çš„è¡Œèµ°ï¼\n\n            å…§ç©ã€å¤–ç©å…¬å¼æœ‰ä¸€é»æ•¸å­¸ï¼Œä¸éè »æœ‰è¶£çš„ã€‚å¯ä»¥åˆ©ç”¨$\\sin$èˆ‡$\\cos$é”åˆ°è¨ˆç®—è§’åº¦çš„ç›®çš„ï¼Œåˆ©ç”¨å…©è€…ä¸åŒçš„å€¼åŸŸï¼Œäº’ç›¸æ­é…ï¼Œå°±å¯ä»¥æ›´è¼•é¬†çš„é€²è¡Œåˆ¤æ–·ï¼æ³¨æ„åˆ°å¤–ç©çš„æ­£è² å°±ä»£è¡¨è‘—Aåˆ°Bæ˜¯é †æ™‚é‡æˆ–æ˜¯é€†æ™‚é˜ã€‚A\\cdot B = |A||B|\\cos\\theta = A_xB_x+A_yB_y\\\\A\\times B = |A||B|\\sin\\theta = A_xB_y-A_yB_xæ–¹å‘å‡½æ•¸ç•¶æˆ‘å€‘è¦åˆ¤æ–·æ–¹å‘çš„æ™‚å€™ï¼Œæœƒåˆ©ç”¨æ­£å¼¦å‡½æ•¸ï¼Œé€†æ™‚é‡æ­£ã€é †æ™‚é‡ç‚ºè² é€²è¡Œåˆ¤æ–·ï¼int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;æ³¨æ„åˆ°æ­¤æ™‚åœ¨åˆ¤æ–·æ˜¯å¦ç‚ºå¹³è¡Œçš„æ™‚å€™ï¼ˆcross==0ï¼‰ï¼Œä½¿ç”¨åˆ°$fabs()$é€™å€‹å‡½æ•¸ï¼Œç›®çš„æ˜¯ç‚ºäº†é¿å…èª¤å·®è€Œå°è‡´åˆ¤æ–·éŒ¯èª¤ï¼Œå› æ­¤éœ€è¦é€²è¡Œèª¤å·®çš„è™•ç†ï¼ˆå…¶å¯¦ä¸ç”¨ä¹Ÿæ²’å·®å•¦ï¼Œåªæ˜¯é€™æ¨£åš´è¬¹ä¸€é»ï¼‰\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; a;int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;int n,t;signed main()&#123;    Orz;    cin&gt;&gt;n;    a.resize(n+2);    rep(i,1,n)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;    int right = 0,left = 0,turn = 0;    pt pre = a[1],from = a[2];    for(int i=3;i&lt;=n;i++)&#123;        int ori = dir(a[i],from,pre);        if(ori == 1)right+=1;        else if(ori == -1)left+=1;        else if(ori == 0 &amp;&amp; ((a[i]-from)*(from-pre))&lt;0)turn+=1;        pre = from;from = a[i];    &#125;    cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;&quot; &quot;&lt;&lt;turn&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]NEOJ 401 ç·šæ®µç›¸äº¤","url":"/geo2-4/","content":"ç·šæ®µç›¸äº¤\né¡Œç›®é€£çµSubmissionç·šæ®µç›¸äº¤ = ç·šæ®µé¦™è•‰ï¼Œè‡ªå‹•é¸å­—æ°¸é éƒ½æ˜¯é¦™è•‰ï¼Œæœ‰é»ç…©XDD\nå¦‚ä½•åˆ¤æ–·å…©ç·šæ®µæ˜¯å¦ç›¸äº¤ï¼Ÿé¦–å…ˆéœ€è¦ä¸€å€‹å‡½æ•¸å¯ä»¥åˆ¤æ–·é»æ˜¯å¦åœ¨ä¸€å€‹ç·šæ®µä¸Šï¼Œå¦‚æ­¤ä¸€ä¾†å°±å¯ä»¥åˆ¤æ–·ç«¯é»åœ¨å¦ä¸€æ¢ç·šæ®µä¸Šçš„ç‰¹æ®Šæƒ…æ³ã€‚ä»¥ä¸‹ç¨‹å¼ç¢¼ç‚ºåˆ¤æ–·é»$P_o$ æ˜¯å¦åœ¨ $\\overline{P_aP_b}$ ä¸Šã€‚åˆ©ç”¨å‘é‡å¤–ç©å¯ä»¥åˆ¤æ–·å…©ç·šæ®µæ˜¯å¦å¹³è¡Œï¼Œè€Œä½¿ç”¨å…§ç©å…¬å¼å¯ä»¥åˆ¤æ–·$P_o$æ˜¯å¦åœ¨ç·šæ®µä¸­ï¼Œè€Œéç·šæ®µçš„å…©å´ï¼\nbool onseg(pt a, pt b, pt o)&#123;       //oæ˜¯å¦åœ¨abç·šæ®µä¸Š    int cross = (a - o) ^ (b - o);  //æ˜¯å¦å¹³è¡Œ    int dot = (a - o) * (b - o);    //æ˜¯å¦åœ¨ç·šæ®µä¸­    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;\nèªªæ˜ï¼šç”±é»$P_o$æŒ‡å‘aå’Œbçš„å‘é‡å¿…é ˆå‘ˆç¾180åº¦è§’ï¼ˆä¹Ÿå°±æ˜¯ç•°å‘ï¼‰ï¼Œæ‰å¯ç¢ºä¿åœ¨abç·šæ®µä¸­ï¼ˆè·Ÿa,bé‡åˆä¹Ÿç®—æ˜¯è·Ÿabç·šæ®µç›¸äº¤ï¼‰ã€‚\næ¥ä¸‹ä¾†æ˜¯ä¸»è¦çš„éƒ¨åˆ†ï¼Œé¦–å…ˆå…ˆç¢ºèª4å€‹ç«¯é»æ˜¯å¦æ°å¥½åœ¨å¦å¤–ä¸€æ¢ç·šæ®µä¸Šï¼Œåˆ¤æ–·å®Œä¹‹å¾Œå°±æ˜¯è™•ç†ä¸€èˆ¬ç›¸äº¤çš„æƒ…æ³ã€‚è‹¥ç·šæ®µ $\\overline{P_1P_2}$ èˆ‡ $\\overline{P_3P_4}$ ç›¸äº¤ï¼Œå‰‡é» $P_1$ èˆ‡é» $P_2$ æœƒåœ¨ç·šæ®µ$\\overline{P_3P_4}$ çš„ç•°å´ã€‚ç”¨æ–¹å‘å‡½æ•¸è¡¨ç¤ºï¼š$dir(a,b,c)\\times dir(a,b,d)&lt;0$ã€‚ç¢ºèªå®Œå…©å€‹ç·šæ®µä¹‹å¾Œå³å®Œæˆç·šæ®µç›¸äº¤çš„åˆ¤æ–·ï¼\nbool Intersection(pt a, pt b, pt c, pt d)&#123;      //ç·šæ®µabæ˜¯å¦èˆ‡cdç›¸äº¤    if(onseg(a,b,c)||onseg(a,b,d))return true;  //é»cã€dæ˜¯å¦æ´½åœ¨ç·šæ®µabä¸Š    if(onseg(c,d,a)||onseg(c,d,b))return true;  //é»aã€bæ˜¯å¦æ´½åœ¨ç·šæ®µcdä¸Š    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                            //å°æ–¼ç·šæ®µå…©ç«¯é»çœ‹å¦å¤–å…©ç«¯é»å¿…é ˆæ–¹å‘ç›¸å    return false;&#125;\nç”±ä¸‹åœ–å¯ä»¥å¾—åˆ°ä¸Šé¢çš„çµè«–ï¼Œç•¶å…©ç·šæ®µç›¸äº¤æ™‚ï¼Œæ–¹å‘å‡½æ•¸å¾—åˆ°çš„å€¼ï¼ˆç”¨å¤–ç©ï¼Œä¹Ÿå°±æ˜¯ä¸‹åœ– $\\theta_1$ ä»¥åŠ $\\theta_2$ï¼‰çš„æ–¹å‘ï¼‰ï¼Œæœƒå‘ˆç¾ä¸€æ­£ä¸€è² ï¼Œå¾å…©å€‹ç›¸åçš„æ–¹å‘çœ‹åŒä¸€æ¢ç·šæ®µå¾—å‡ºä¾†çš„çµè«–ï¼\nAC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; point;int dir(pt a, pt b, pt o) &#123;                         //æ–¹å‘å‡½æ•¸    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;bool onseg(pt a, pt b, pt o)&#123;                       //oæ˜¯å¦åœ¨abç·šæ®µä¸Š    int cross = (a - o) ^ (b - o);                  //æ˜¯å¦å¹³è¡Œ    int dot = (a - o) * (b - o);                    //æ˜¯å¦åœ¨ç·šæ®µä¸­    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;bool Intersection(pt a, pt b, pt c, pt d)&#123;          //ç·šæ®µabæ˜¯å¦èˆ‡cdç›¸äº¤    if(onseg(a,b,c)||onseg(a,b,d))return true;      //é»cã€dæ˜¯å¦æ´½åœ¨ç·šæ®µabä¸Š    if(onseg(c,d,a)||onseg(c,d,b))return true;      //é»aã€bæ˜¯å¦æ´½åœ¨ç·šæ®µcdä¸Š    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                                //å°æ–¼ç·šæ®µå…©ç«¯é»çœ‹å¦å¤–å…©ç«¯é»å¿…é ˆæ–¹å‘ç›¸å    return false;&#125;int n,t;void solve()&#123;    point.assign(4,&#123;0,0&#125;);    rep(i,0,3)cin&gt;&gt;point[i].x&gt;&gt;point[i].y;    if(Intersection(point[0],point[1],point[2],point[3]))&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]TIOJ 1178 Convex Hull","url":"/geo2-5/","content":"TIOJ 1178 Convex Hull\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦å®šnå€‹äºŒç¶­å¹³é¢çš„é»ï¼Œæ‰¾å‡ºä½åœ¨å‡¸åŒ…ä¸Šçš„æ‰€æœ‰é»çš„å€‹æ•¸\n\næœ€å°å‡¸å¤šé‚Šå½¢ = å‡¸åŒ…ï¼Œè¦æ‰¾å‡ºèƒ½åŒ…ä½æ‰€æœ‰é»çš„æœ€å°å‡¸å¤šé‚Šå½¢ï¼Œç°¡ç¨±å‡¸åŒ…ã€‚è½èªªæœ€å¥½å¯«çš„å‡¸åŒ…æ¼”ç®—æ³•æ˜¯ï¼šAndrewâ€™s Monotone Chainï¼Œç¿»æˆä¸­æ–‡å«åšAndrewâ€™s å–®èª¿éŠï¼Ÿæœ‰ä¸€é»å–®èª¿+éŠçš„å‘³é“ã€‚ä¸‹åœ–æ˜¯æˆ‘ç”¨ç…§ç‰‡åˆæˆèµ·ä¾†çš„GIFï¼Œå¤§è‡´æ¨¡æ“¬å‡ºä½¿ç”¨Andrewâ€™s Monotone Chain æ‰¾å‡¸åŒ…çš„æ–¹æ³•ã€‚\n\n\n            Andrewâ€™s Monotone Chainé€™å€‹æ¼”ç®—æ³•çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(n\\log n)$ï¼Œç©ºé–“è¤‡é›œåº¦ $O(n)$ï¼Œè³‡æ–™èªªå®ƒå¯ä»¥è§£æ±ºäº†å‡¸åŒ…æœ‰é‡ç–Šçš„é»ã€å…±ç·šçš„é»ã€é€€åŒ–æˆç·šæ®µå’Œé»çš„æƒ…æ³ã€‚å®ƒçš„åå­—å«åšã€Œå–®èª¿éŠã€ï¼Œè¦ç¶­è­·ä¸€å€‹æœ‰é»åƒå–®èª¿éšŠåˆ—çš„æ±è¥¿ï¼Œå°æ–¼åœ¨å®¹å™¨ä¸­ç¬¬ $i$ å€‹ä½ç½®çš„é»éƒ½æ»¿è¶³ $\\stackrel\\longrightarrow{Pi P{i+1}}\\times \\stackrel\\longrightarrow{P{i+1} P{i+2}} &gt; 0$ ï¼Œå¦‚æœæœ‰é»åšå¤–ç©å¾Œçš„çµæœå°æ–¼ç­‰æ–¼0ï¼Œå‰‡å®ƒæœƒè¢«popæ‰ï¼ˆé€™æ˜¯ä¾ç…§ä¸Šåœ–é€†æ™‚é‡å®Œæˆå‡¸åŒ…çš„æè¿°ï¼Œå¦‚æœæ–¹å‘ç›¸åå‰‡æœƒè®Šè™Ÿï¼‰ã€‚ä»¥ä¸‹æ˜¯æ­¤æ¼”ç®—æ³•çš„åŸ·è¡Œæ­¥é©Ÿï¼šå…ˆæŠŠæ‰€æœ‰çš„é»æŒ‰ç…§ $(x,y)$ æ’åºå°‡ä¸‹å‡¸åŒ…åœå‡ºä¾†ï¼Œæœ‰é»åƒç¶­è­·å–®èª¿éšŠåˆ—ï¼Œå°æ‰€æœ‰æ–°åŠ å…¥çš„é»iè¨ˆç®—é»i-2ã€i-1èˆ‡iä¹‹é–“çš„å¤–ç©ï¼Œå¦‚æœä¸ç¬¦åˆæƒ…æ³ä»£è¡¨åœä¸åˆ°æ–°åŠ å…¥çš„é»ï¼Œéœ€è¦å°‡èˆŠçš„é»popå‡ºä¾†å°‡åŸæœ¬å·²ç¶“æ’åºå¥½çš„é»é€†åºå†æŠŠä¸Šå‡¸åŒ…ç”±xåº§æ¨™å¤§åˆ°å°åœå‡ºä¾†ï¼Œå°‡ä¸Šä¸‹åˆä½µå°±æ˜¯å‡¸åŒ…äº†ï¼ˆå¿…é ˆæ³¨æ„èµ·çµ‚é»è¢«pushçš„æ¬¡æ•¸å•é¡Œï¼‰ï¼\n          \nä¸€èˆ¬æœƒç”¨ä¸€å€‹vectorå„²å­˜åœ¨å‡¸åŒ…ä¸Šé¢çš„é»ï¼ˆä¸åŒ…å«åœ¨é‚Šä¸Šçš„é»ï¼Œåªæœ‰ä½æ–¼è½‰æŠ˜é»çš„é»ï¼‰ï¼Œåœ¨é ­å°¾çš„éƒ¨åˆ†ï¼ˆxåº§æ¨™æœ€å¤§èˆ‡æœ€å°ï¼‰éœ€è¦ç‰¹åˆ¥è™•ç†ï¼Œè®“æ¯ä¸€å€‹é»æœ€å¤šè¿‘åˆ°vectorä¸€æ¬¡ã€‚\n\n            å¯¦ä½œç´°ç¯€ä»¥ä¸‹æ˜¯ç¢ºèªæ˜¯å¦éœ€è¦å°‡vectorä¸­å…ƒç´ popå‡ºä¾†çš„é—œéµï¼Œå°å‘é‡$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ åšå¤–ç©çš„çµæœï¼Œå¿…é ˆæ’é™¤å¤–ç©çµæœç‚º0çš„æƒ…æ³ï¼Œå¦‚æœå°‡0ä¹Ÿç´å…¥ï¼Œæœƒé€ æˆä¸€å€‹é»è¢«pushé€²å»å¾ˆå¤šæ¬¡ï¼Œåœ¨æ•¸é‡å’Œè¨ˆç®—ä¸Šå‡ºç¾å•é¡Œã€‚bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;         //é€™è£¡å¾ˆé—œéµï¼Œåˆ¥åƒWA&#125;é™¤æ­¤ä¹‹å¤–ï¼Œä¸Šå‡¸åŒ…åœ¨ç¯„åœé™åˆ¶ä¸Šæ˜¯éœ€è¦æ³¨æ„çš„ã€‚å‡è¨­xåº§æ¨™æœ€å¤§çš„é»iï¼Œç•¶åœ¨åœä¸Šå‡¸åŒ…çš„éç¨‹ä¸­iæ˜¯ä¸å¯ä»¥è¢«popå‡ºå»çš„ï¼Œå› æ­¤vectorçš„å¤§å°å¿…é ˆå¤§æ–¼ä¸‹å‡¸åŒ…çš„å¤§å°ã€‚å‡¸åŒ…ä½¿ç”¨ç¬¬i-1è·Ÿç¬¬iå€‹é»çš„å‘é‡å»çœ‹ç¬¬iåˆ°ç¬¬i+1å€‹é»çš„å‘é‡ï¼Œæ±ºå®šä¸€å€‹é»è¦ä¸è¦è¢«æ¨å…¥vectorä¸­ã€‚ç•¶æˆ‘å€‘é€†åºå¾xåº§æ¨™æœ€å¤§çš„é»å¾€å‰çœ‹æ™‚ï¼Œè¦ç¢ºä¿æ¯ä¸€è¼ªçµæŸä¹‹å¾Œåœ¨ié»å¾Œéƒ½å¿…é ˆè¦æœ‰è‡³å°‘ä¸€å€‹é»ï¼Œè¨­å®šhull.size() &gt; down_hullçš„åŸå› æ˜¯é˜²æ­¢åœ¨ä¸‹å‡¸åŒ…çš„é»è¢«åœä¸Šå‡¸åŒ…çš„éç¨‹æ›´æ–°åˆ°ã€‚int down_hull = hull.size();    //åœä¸Šå‡¸åŒ…çš„ç¨‹å¼ç¢¼ç‰‡æ®µfor(auto i: p)&#123;    while(hull.size() &gt; down_hull         &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;        hull.pop_back();    &#125;    hull.push_back(i);&#125;\n          \nä»¥ä¸‹æ˜¯AC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //é€™è£¡å¾ˆé—œéµï¼Œåˆ¥åƒWA&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //é¦–å…ˆå°xé€²è¡Œæ’åº    for(auto i : p)&#123;                   //ä¾åºèµ°è¨ªï¼Œå¦‚æœé‡åˆ°å¤–ç©&lt;0å‰‡ä¸åœ¨å‡¸åŒ…ä¸Š        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //åœ¨å‡¸åŒ…hullçš„æ¯ä¸€é»éƒ½ç¬¦åˆå¤–ç©å°æ–¼0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //xæœ€å¤§çš„é»æœƒåœ¨å‡¸åŒ…ä¸Šï¼Œä¸ç”¨åšå…©æ¬¡å…ˆpopä¸€æ¬¡    reverse(p.begin(),p.end());        //å°‡æ‰€æœ‰é»é€†åºä¹‹å¾Œåšä¸€æ¬¡ä¸Šé¢çš„å‡¸åŒ…    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //èµ·é»æœƒç¶“éå…©æ¬¡ï¼Œå‰›å¥½ä¾†ç®—æœ‰å‘é¢ç©&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = convex_hull();    cout&lt;&lt;hull.size()-1&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]NEOJ 402 æœ€å°å‡¸å¤šé‚Šå½¢","url":"/geo2-6/","content":"æœ€å°å‡¸å¤šé‚Šå½¢\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°æ‰¾å‡ºäºŒç¶­å¹³é¢ä¸Šnå€‹é»çš„å‡¸åŒ…æ‰€åœå‡ºä¾†çš„é¢ç©ç‚ºä½•ï¼Ÿ\n\nè·Ÿä¸Šä¸€é¡Œé¡ä¼¼ï¼Œåœ¨æ‰¾åˆ°å…¨éƒ¨åœ¨å‡¸åŒ…ä¸Šé¢çš„é»å¾Œï¼Œå°±å¯ä»¥åˆ©ç”¨æœ‰å‘é¢ç©æŠŠå‡¸åŒ…é¢ç©ç®—å‡ºä¾†ï¼Œæœ‰ä¸€å€‹å…¬å¼å¯ä»¥è¨ˆç®—å¤šé‚Šå½¢é¢ç©ï¼Œåˆ©ç”¨å¤–ç©å¾—åˆ°æ­£è² å€¼ï¼Œè½‰ä¸€åœˆå¾Œå¾—åˆ°é¢ç©ï¼å°æ–¼å¤šé‚Šå½¢çš„é ‚é» $P0,P_1,â€¦,P{n-1},P_n=P_0$ çš„é¢ç©å¦‚ä¸‹ï¼š\nArea = \\frac{1}{2}\\sum_{i=0}^{n-1}\\stackrel\\longrightarrow{P_i}\\times \\stackrel\\longrightarrow{P_{i+1}}å…¶ä¸­æœ€å¾Œä¸€å€‹é»æœƒå›åˆ°èµ·é»ï¼Œå½¢æˆä¸€å€‹å°é–‰çš„è¿´è·¯ã€‚\nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //é¦–å…ˆå°xé€²è¡Œæ’åº    for(auto i : p)&#123;                   //ä¾åºèµ°è¨ªï¼Œå¦‚æœé‡åˆ°å¤–ç©&lt;0å‰‡ä¸åœ¨å‡¸åŒ…ä¸Š        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //åœ¨å‡¸åŒ…hullçš„æ¯ä¸€é»éƒ½ç¬¦åˆå¤–ç©å°æ–¼0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //xæœ€å¤§çš„é»æœƒåœ¨å‡¸åŒ…ä¸Šï¼Œä¸ç”¨åšå…©æ¬¡å…ˆpopä¸€æ¬¡    reverse(p.begin(),p.end());        //å°‡æ‰€æœ‰é»é€†åºä¹‹å¾Œåšä¸€æ¬¡ä¸Šé¢çš„å‡¸åŒ…    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //èµ·é»æœƒç¶“éå…©æ¬¡ï¼Œå‰›å¥½ä¾†ç®—æœ‰å‘é¢ç©&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        vector&lt;pt&gt; hull = convex_hull();        int area = 0,len = hull.size();        for(int i=0;i&lt;len-1;i++)area += (hull[i]^hull[i+1]);        cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;((ld)area/2)&lt;&lt;endl;    &#125;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]NEOJ 790 ä¾†å§ï¼ŒéŠæˆ²é–‹å§‹äº†","url":"/geo2-7/","content":"ä¾†å§ï¼ŒéŠæˆ²é–‹å§‹äº†\né¡Œç›®é€£çµSubmissionGGBæ¨¡æ“¬\n\né¡Œç›®æ•˜è¿°çµ¦ä½ äºŒç¶­å¹³é¢ä¸Šnå€‹é»(nâ‰¤2400)ï¼Œæ¯ä¸€å€‹é»åº§æ¨™çš†ä¸ç›¸åŒï¼Œæ±‚å‡ºç¸½å…±å¯ä»¥åœå‡ºå¤šå°‘å€‹ä¸‰è§’å½¢ï¼Ÿ\n\né€™æ˜¯NEOJä¸Šçš„åŠ åˆ†é¡Œï¼Œå¥½åƒæ˜¯ä¸€å€‹é¡Œçµ„å§ï¼Œåæ­£ç¸½å…±æœ‰ä¸‰é¡Œï¼Œé€™æ˜¯ç¬¬ä¸€é¡Œã€‚å¦‚æœ $O(n^3)$ çš„æšèˆ‰ï¼Œè¤‡é›œåº¦æœƒçˆ†ç‚¸ï¼ˆé‡ç´šç´„$10^{10}$ï¼‰ï¼Œæ ¹æ“šé›»ç¥çš„èªªæ³•ï¼Œé€™ä¸€é¡Œè¦ç”¨æ¥µè§’æ’åºä»¥åŠé›™æŒ‡æ¨™æ‰¾åˆ°å…±ç·šï¼Œæ¥è‘—å°±å¯ä»¥åˆ©ç”¨æ’åˆ—çµ„åˆæŠŠå› ç‚ºå…±ç·šè€Œä¸èƒ½å½¢æˆä¸‰è§’å½¢çš„çµ„åˆæ‰£æ‰ï¼Œå°±æ˜¯ç­”æ¡ˆäº†ã€‚\n\né€™ä¸€é¡Œçš„æ ¸å¿ƒæ¦‚å¿µæ˜¯æ‰¾å…±ç·šï¼Œå…·é«”ä¾†èªªçš„ä½œæ³•æ˜¯æšèˆ‰æ¯ä¸€å€‹é»çš„åŒæ™‚ï¼Œä»¥å®ƒç‚ºåŸé»å°å…¶ä»–çš„é»é€²è¡Œæ’åºï¼Œå¦‚æœé‡åˆ°æœ‰ç›¸åŒçš„æ¥µè§’åº§æ¨™è¡¨ç¤ºé€™äº›é»å…±ç·šï¼ŒåŒæ™‚åˆ©ç”¨é™£åˆ—cnt[x]çµ±è¨ˆå…±ç·šé»æ•¸ç‚ºxçš„ç·šæ®µç¸½å…±æœ‰å¹¾æ¢ã€‚\nä»¥ä¸‹çš„GIFå°±æ˜¯å¤§è‡´ä¸Šç¨‹å¼åŸ·è¡Œçš„æ¨£å­ã€‚å› ç‚ºä¸€æ¢é•·åº¦ç‚ºxçš„ç·šæ®µæœƒå› ç‚ºæšèˆ‰xæ¬¡çš„é—œä¿‚ï¼Œåœ¨æœ€å¾Œæ‰£æ‰çš„æƒ…æ³æœƒé‡è¤‡xæ¬¡å› æ­¤éœ€è¦é™¤æ‰ã€‚\n\n\n            å…±ç·šèˆ‡ä¸‰è§’å½¢ä¸€èˆ¬æƒ…æ³ä¸‹ï¼ˆä»»ä¸‰é»ä¸å…±ç·šï¼‰ï¼Œç¸½å…±å¯ä»¥å½¢æˆ $C^n_3$ å€‹ä¸‰è§’å½¢ï¼Œå¦‚æœæœ‰ä¸€æ¢må€‹é»å…±ç·šçš„æƒ…æ³ä¸‹ï¼ˆå…¶ä»–é»ä¸å…±ç·šï¼‰ï¼Œå‰‡å¯ä»¥å½¢æˆçš„ä¸‰è§’å½¢æ•¸é‡å°±å¿…é ˆæ‰£é™¤å…±ç·šé™åˆ¶çš„æƒ…æ³ï¼Œè®Šæˆ $C^n_3-C^m_3$ å€‹ä¸‰è§’å½¢ã€‚\n          \næ™‚é–“è¤‡é›œåº¦ç‚ºï¼šæšèˆ‰æ¯ä¸€å€‹é» $O(n)$ï¼Œæ¥µè§’æ’åº $O(n\\log n)$ï¼Œç¸½æ™‚é–“è¤‡é›œåº¦ $O(n^2\\log n)$\n\n            å¯¦ä½œå°ç´°ç¯€1. ç¶­è­·å…±ç·šé€£çºŒå€é–“æˆ‘å€‘è¦æƒ³è¾¦æ³•è®“æœ‰å…±ç·šçš„é»å€‘æ‰€åœ¨ä½ç½®æ˜¯ä¸€å€‹é€£çºŒçš„ä½ç½®ã€‚ä¸‰å€‹é»å…±ç·šå¯èƒ½ç‚ºåœ¨å°è§’ç·šçš„è±¡é™ä¸­ï¼Œä¹Ÿå°±æ˜¯é»å·®äº†180åº¦ï¼Œå¦‚æ­¤ä¸€ä¾†å°±æ²’è¾¦æ³•è®“å…±ç·šçš„é»ç‚ºåœ¨é€£çºŒçš„å€é–“ã€‚ç‚ºäº†é”åˆ°é€™å€‹ç›®çš„ï¼Œæˆ‘å€‘å°‡æ‰€æœ‰ä½æ–¼ä¸‹åŠå¹³é¢çš„é»éƒ½ç§»åˆ°ä¸ŠåŠå¹³é¢ï¼ˆåœ¨ä¸ŠåŠå¹³é¢æ‰¾åˆ°æœ‰ç›¸åŒ $\\tan\\theta$ å€¼çš„ä½ç½®ï¼‰ï¼Œæ¥è‘—å°±èƒ½åˆ©ç”¨é›™æŒ‡é‡æ‰¾æ¥µè§’åº§æ¨™æ’åºå¾Œæœ‰ç›¸åŒæ¥µè§’çš„å€é–“ä¹‹æœ€å¤§å€¼ï¼2. ç‰¹ä¾‹åˆ¤æ–·å¦‚æœæœ‰ä¸€é»yåº§æ¨™ç‚º0ä½†xåº§æ¨™ç‚ºè² ï¼Œè¦å°‡å…¶ç§»åˆ°xè»¸æ­£å‘çš„åœ°æ–¹ï¼Œä¸èƒ½æŠŠé€™ç¨®æƒ…æ³æ¶µè“‹ç‚ºä¸€èˆ¬æƒ…æ³ï¼Œå¦å‰‡åŸæœ¬åœ¨xè»¸æ­£å‘çš„é»æœƒè¢«ç§»åˆ°xè»¸è² å‘ï¼Œæ²’æœ‰é”åˆ°é æœŸçš„æ•ˆæœã€‚\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt; cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //é€†æ™‚é‡å°‡é»é€²è¡Œæ¥µè§’æ’åºï¼Œå¾270åº¦é–‹å§‹é€†æ™‚é‡&#125;//ç”¨cnt[i]çµ±è¨ˆå€é–“é•·åº¦ç‚ºiçš„ç·šæ®µæ•¸é‡void solve(pt id)&#123;    vector&lt;pt&gt; pp;    for(auto i : p)&#123;                         //ä»¥idç‚ºåŸé»        pt cur = i-id;        if(cur == pt&#123;0,0&#125;)continue;        if(cur.y &lt; 0)&#123;cur.x = -cur.x;cur.y = -cur.y;&#125;        if(cur.x &lt; 0 &amp;&amp; cur.y==0)&#123;cur.x = -cur.x;&#125;        pp.push_back(cur);    &#125;    sort(all(pp),cmp);                      //å°‡idç•¶ä½œåŸé»é€²è¡Œæ’åº    int p1 = 0,p2 = 0,len = pp.size();      //é›™æŒ‡é‡æ‰¾å…±ç·šå€é–“    while(p1 &lt; n-1)&#123;                        //æœ€å¤§åŒ–å€é–“        while(p2+1 &lt; len &amp;&amp; (pp[p1]^pp[p2+1]) == 0)p2++;        cnt[p2-p1+2]+=1;        p1 = p2+1;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    cnt.resize(n+1,0);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    rep(i,0,n-1)solve(p[i]);    int ans = (n*(n-1)*(n-2))/6;    rep(i,3,n)ans-=(cnt[i]*(i-1)*(i-2))/6;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]NEOJ 792 éŠæˆ²ï¼šæœ€çµ‚å›","url":"/geo2-8/","content":"éŠæˆ²ï¼šæœ€çµ‚å›\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°å…±æœ‰nå€‹äºŒç¶­å¹³é¢ä¸Šçš„æ ¼å­é»ï¼Œé€™äº›é»æœƒå½¢æˆç°¡å–®å¤šé‚Šå½¢ã€‚è©¦æ±‚æˆ–åœ¨ç°¡å–®å¤šé‚Šå½¢å…§éƒ¨çš„æ ¼ç·šç¸½é•·ï¼ˆåŒ…æ‹¬å‚ç›´èˆ‡æ°´å¹³æ ¼ç·šï¼‰ã€‚\n\né€™é‚Šæœ‰ä¸€å€‹ä¸åš´è¬¹çš„æ¨å°æ–¹å¼ï¼Œä¸éä»–æ˜¯æ­£ç¢ºçš„ã€‚ä»¤å¤šé‚Šå½¢å…§éƒ¨æ ¼ç·šé•·åº¦ç‚ºSï¼Œå¤šé‚Šå½¢çš„é‚Šè½åœ¨çš„æ ¼ç·šé•·åº¦ç‚ºTï¼Œå¤šé‚Šå½¢é¢ç©Tï¼Œå‰‡æœ‰ä»¥ä¸‹é—œä¿‚å¼ï¼š\nS = 2A-\\frac{T}{2}è©³ç´°çš„å…¬å¼æ¨å°å¯ä»¥å¯ä»¥åƒé–±ä¸‹åœ–ï¼Œå¹³è¡Œå››é‚Šå½¢ï¼ˆæ–œç·šéƒ¨åˆ†ï¼‰å…§éƒ¨å‚ç›´çš„æ ¼ç·šé•·åº¦ç‚ºï¼š å¤§çŸ©å½¢ $(x_1+x_2)(y_1+y_2)$ æ‰£æ‰å·¦å³ä¸Šä¸‹å…±å››å€‹ä¸‰è§’å½¢å…©å…©æ‹¼æˆä¸€å€‹çŸ©å½¢ $x_1y_1$ ä»¥åŠ $x_2y_2$ï¼Œé‚„æœ‰å·¦ä¸Šå³ä¸‹å…©å€‹æ­£æ–¹å½¢ $2x_2y_1$ï¼Œæ•´ç†ä¹‹å¾Œæœƒç™¼ç¾å…¶å¯¦è·Ÿé¢ç©æ˜¯ä¸€æ¨£çš„ã€‚å°æ–¼å‚ç›´éƒ¨åˆ†ä¹Ÿæ˜¯é¡ä¼¼çš„æƒ…æ³ã€‚\n\nå¥½åƒéš±ç´„ç™¼ç¾åˆ°é¢ç©èˆ‡æ ¼ç·šé•·åº¦æœ‰ååˆ†å¯†åˆ‡çš„é—œä¿‚ï¼Œç®—å‡ºé¢ç©ï¼ŒæŠŠåœ¨æ ¼ç·šä¸Šçš„é‚Šé€²è¡Œç‰¹åˆ¤æ‰£æ‰ï¼Œå°±å¯ä»¥å¾—åˆ°æ ¼ç·šé•·åº¦ã€‚\né€™ä¸€é¡Œæˆ‘æƒ³äº†å¾ˆä¹…ï¼Œä¸€ç›´çœ‹ä¸å‡ºä¾†é—œä¿‚å¼åˆ°åº•é•·æ€æ¨£ï¼Œç›´åˆ°å¤§ç¥æé»æ‰ç™¼ç¾åŸä¾†æœ‰é€™æ¨£çš„é—œä¿‚ï¼Œæˆ‘åæ‡‰å¥½é²éˆ:cry:\n\nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt;  cnt;int n,edge,ans;int solve()&#123;    int area = 0;    rep(i,0,n-1)&#123;        area += (p[i]^p[i+1]);        if(p[i].y == p[i+1].y)edge += abs(p[i].x-p[i+1].x);        if(p[i].x == p[i+1].x)edge += abs(p[i].y-p[i+1].y);    &#125;    area = abs(area);    return area;&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(1);    while(cin&gt;&gt;n)&#123;        p.assign(n+1,&#123;0,0&#125;);        edge = 0;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ans = solve();        cout&lt;&lt;ans-((ld)edge/2)&lt;&lt;endl;    &#125;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]TIOJ 1205 ç›´è§’ä¸‰è§’å½¢","url":"/geo2-9/","content":"TIOJ 1205 ç›´è§’ä¸‰è§’å½¢\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ Nï¼ˆNâ‰¤1500ï¼‰å€‹åº§æ¨™å¹³é¢ä¸Šçš„é»ï¼Œè«‹å•ç¸½å…±å¯å½¢æˆå¤šå°‘å€‹ç›´è§’ä¸‰è§’å½¢å‘¢ï¼Ÿ\n\nå¾æ¥µè§’æ’åºå¾Œçš„ç¬¬ä¸€å€‹é»é–‹å§‹é€†æ™‚é‡é€²è¡Œé›™æŒ‡é‡çš„æšèˆ‰ã€‚é€™é‚Šä½¿ç”¨åˆ°ä¸€å€‹å¾ˆç‰¹åˆ¥çš„æ‰‹æ³•ï¼Œå°æ–¼å…±ç·šçš„æƒ…æ³æˆ‘å€‘å…ˆé€éé è™•ç†çš„æ–¹å¼å°‡å…±ç·šçš„é»åˆä½µèµ·ä¾†ï¼Œä¸¦ç”¨cnt[x]é™£åˆ—ç´€éŒ„ç¬¬xå€‹é»æ˜¯ç”±å¹¾å€‹é»æ‰€åˆä½µèµ·ä¾†çš„ï¼Œå¦‚æ­¤ä¸€ä¾†ï¼Œåœ¨é€²è¡Œè¨ˆç®—çš„æ™‚å€™å°±ä¸æœƒæœ‰å…±ç·šè¦åˆ†åˆ¥è™•ç†çš„å•é¡Œï¼ˆä¸éœ€æ“”å¿ƒæ˜¯ä¸æ˜¯å¯ä»¥è·Ÿä¹‹å‰çš„é»å½¢æˆç›´è§’ä¸‰è§’å½¢ï¼Œå› ç‚ºç›¸åŒæ–œç‡çš„é»å·²ç¶“è¢«åˆä½µå‰©ä¸‹ä¸€å€‹ï¼‰ï¼Œç›´æ¥å°‡æ•¸é‡ç›¸ä¹˜å°±å¯ä»¥çŸ¥é“ç›´è§’ä¸‰è§’å½¢çš„æ•¸é‡ï¼\næ™‚é–“è¤‡é›œåº¦ï¼šæšèˆ‰æ‰€æœ‰é» $O(n)\\times$ é€²è¡Œæ¥µè§’æ’åº$O(n\\log n)$ ä»¥åŠé›™æŒ‡æ¨™$O(n)$ï¼Œç¸½æ™‚é–“è¤‡é›œåº¦ç‚º $O(n^2\\log n)$ã€‚\n\n            å¯¦ä½œå°ç´°ç¯€é›™æŒ‡é‡é€²è¡Œæšèˆ‰çš„éç¨‹ä¸­ï¼Œå¾ˆæœ‰å¯èƒ½æœƒæŒ‡æ¨™æŒ‡å‘çš„ç´¢å¼•å€¼æœƒè¶…å‡ºç¯„åœã€‚è§£æ±ºçš„æ–¹æ³•æœ‰å…©ç¨®ï¼šè¶…å‡ºäº†å³ä»£è¡¨ç¹äº†ä¸€åœˆï¼Œåªéœ€è¦å°ç´¢å¼•å€¼å–é¤˜æ•¸å³å¯ã€‚é™¤äº†å–é¤˜æ•¸çš„æ–¹æ³•ä¹‹å¤–ï¼Œå…¶å¯¦ä¹Ÿå¯ä»¥ç›´æ¥åœ¨é»é›†å¾Œé¢å°‡æ‰€æœ‰é»å†æ¨å…¥ä¸€æ¬¡ï¼Œè®“è§’åº¦å¾360å»¶ä¼¸æˆ720åº¦ï¼Œå°±ä¸æœƒæœ‰è¶…å‡ºç¯„åœçš„å•é¡Œï¼\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //é€†æ™‚é‡å°‡é»é€²è¡Œæ¥µè§’æ’åºï¼Œå¾270åº¦é–‹å§‹é€†æ™‚é‡&#125;//O(n)æšèˆ‰æ¯å€‹é»ç•¶ç›´è§’æƒ…æ³int solve(pt id)&#123;    pp.clear();cnt.clear();temp.clear();    for(pt i : p)&#123;        pt cur = i - id;        if(cur == pt&#123;0,0&#125;)continue;        temp.push_back(cur);    &#125;    sort(all(temp),cmp);            //ä»¥idç‚ºåŸé»é€²è¡Œæ¥µè§’æ’åº    pp.push_back(temp[0]);          //ppæ¯ä¸€è§’åº¦åªå­˜è‡³å¤šä¸€å€‹é»    cnt.push_back(1);               //è€ƒæ…®æ¯å€‹é»å…±ç·šæƒ…æ³    int len = temp.size();    rep(i,1,len-1)&#123;        int cross = temp[i]^temp[i-1],dot = temp[i]*temp[i-1];        if(cross == 0 &amp;&amp; dot &gt;= 0)cnt[cnt.size()-1] += 1;   //å…±ç·šæ•¸é‡+=1        else &#123;pp.push_back(temp[i]);cnt.push_back(1);&#125;      //éå…±ç·šè¨­å®šæ•¸é‡ç‚º1    &#125;    len = pp.size();            //è€ƒæ…®æ©«è·¨ä¸€å‘¨çš„æƒ…æ³    rep(i,0,len-1)&#123;             //é›™æŒ‡é‡i,p1å¯èƒ½æœƒè¶…éä¸€åœˆ        pp.push_back(pp[i]);    //å°‡é»å†ç¹ä¸€åœˆ        cnt.push_back(cnt[i]);    &#125;    int ans = 0,p1 = 0;    rep(i, 0, len-1)&#123;        while(p1 &lt; i+len &amp;&amp; (pp[i]^pp[p1]) &gt;= 0 &amp;&amp; (pp[i]*pp[p1]) &gt; 0)p1 += 1;        //å¤¾éŠ³è§’çš„æƒ…æ³è¦p1+=1        if((pp[i]^pp[p1]) &gt; 0 &amp;&amp; (pp[i]*pp[p1]) == 0)ans += cnt[i]*cnt[p1];        //æ­£å‘çš„ç›´è§’ä¸‰è§’å½¢ï¼Œè‹¥å…±ç·šå‰‡å…©è€…æ•¸é‡ç›¸ä¹˜    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;                int ans = 0;        rep(i,0,n-1)&#123;            ans += solve(p[i]);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è¨ˆç®—å¹¾ä½•é¡Œè§£"],"tags":["é¡Œè§£","è¨ˆç®—å¹¾ä½•"]},{"title":"[é¡Œè§£]Leetcode 149 Max Points on a Line","url":"/geo3-1/","content":"149 Max Points on a Line\né¡Œç›®é€£çµ\nclass Solution &#123;public:        int gcd(int a,int b)&#123;        if(a &gt; b)swap(a,b);        if(a == 0)return b;        return gcd(b % a, a);    &#125;        int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            map&lt;pair&lt;int,int&gt;,int&gt; mp;            int same = 0,hori = 0;            for(int j = i+1;j &lt; n;j++)&#123;                int dx = points[i][0] - points[j][0];                int dy = points[i][1] - points[j][1];                if(dx == 0 &amp;&amp; dy == 0)&#123;same++;continue;&#125;                if(dx == 0 &amp;&amp; dy != 0)&#123;hori++;continue;&#125;                int g = gcd(abs(dx),abs(dy));                if(dy &lt; 0 || (dy == 0 &amp;&amp; dx &lt; 0))&#123;dx = -dx;dy = -dy;&#125;                mp[&#123;dx/g,dy/g&#125;]++;            &#125;            int sum = hori + same + 1;            for(auto it : mp)sum = max(sum,it.second + 1);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 883 Projection Area of 3D Shapes","url":"/geo3-10/","content":"883 Projection Area of 3D Shapes\né¡Œç›®é€£çµ\nä¸‰ç¨®ä¸åŒçš„æŠ•å½±å°æ‡‰åˆ°ä¸‰ç¨®ä¸åŒçš„è§’åº¦çœ‹åœ–å½¢ã€‚x-yçš„é¢ç©å³ç‚ºç”±ä¸Šè€Œä¸‹çœ‹æœ‰æ–¹æ ¼çš„å€‹æ•¸ã€‚x-zæ˜¯å¾å‰æ–¹çœ‹ï¼Œå› æ­¤å°æ‡‰åˆ°çš„æ˜¯æ¯ä¸€è¡Œçš„æœ€å¤§æ–¹å¡Šå€‹æ•¸ã€‚\nclass Solution &#123;public:    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int n = grid.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            int maxR = 0,maxC = 0;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans++;        //ç”±ä¸Šå¾€ä¸‹çœ‹                maxR = max(maxR,grid[i][j]);    //ç”±å´é‚Šçœ‹                maxC = max(maxC,grid[j][i]);    //ç”±å‰é¢çœ‹            &#125;            ans += maxR + maxC;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"è¨ˆç®—å¹¾ä½•ä¾‹é¡Œï¼ˆComputational Geometry Problemsï¼‰","url":"/geo2/","content":"é¡Œç›®ç›®éŒ„\nå‘é‡åŠ æ³•\nç­‰é•·ç·šæ®µå°\nå‘å·¦è½‰å‘å³è½‰\nç·šæ®µç›¸äº¤\næœ€å°å‡¸å¤šé‚Šå½¢\nTIOJ 1178 Convex Hull\nä¾†å§ï¼ŒéŠæˆ²é–‹å§‹äº†\néŠæˆ²ï¼šæœ€çµ‚å›\nTIOJ 1205 ç›´è§’ä¸‰è§’å½¢\nTIOJ 1105 H.PS3\nZJ b288: å¤å­£å¤§ä¸‰è§’\nTIOJ 1500 Clean up on aisle 3\nZJ a871: Museum Area\nTIOJ 1280 é ˜åœŸ (Territory)\nTIOJ 1678 å‰ªå¤šé‚Šå½¢ï¼ˆmoldingï¼‰\nZJ d269: 11579 - Triangle Trouble\n\nå‘é‡åŠ æ³•é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ï¼šçµ¦ä½ nå€‹æ•¸å­—ï¼ˆ0â‰¤i&lt;1ï¼Œå°æ•¸é»ç²¾åº¦åˆ°æœ«ä¹ä½ï¼‰ï¼Œæƒ³çŸ¥é“åˆ°åº•æœ‰å¤šå°‘çµ„ $(i,j,k)$ æ»¿è¶³ $v_i+v_j=v_k$ï¼Œå…¶ä¸­ $i,j,k$ å¯ä»¥é‡è¤‡ã€‚\n\né€™é¡Œå…¶å¯¦è·Ÿè¨ˆç®—å¹¾ä½•æ²’ä»€éº¼é—œä¿‚ï¼Œç›´æ¥ç”¨unordered_mapå»åšï¼ˆæœ‰é»åƒtwo sumï¼Œä¸éä¸‹é¢çš„codeå¥½åƒä¹Ÿä¸ç”¨é–‹åˆ°multiï¼‰ï¼Œç°¡å–®ï¼ä¸éæˆ‘åœ¨æµ®é»æ•¸çš„åœ°æ–¹åƒäº†ä¸€äº›WAï¼Œæœ€å¾Œç®—äº†ç›´æ¥æ”¹ç”¨å­—ä¸²è™•ç†é€™å€‹æƒ±äººçš„æ±è¥¿XD\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define int long long#define double long double#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rep2(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define eps (1e-9)#define INF 1e10#define N 2001#define ll long long#define ld long double#define int long longusing namespace std;int n;signed main()&#123;    cin&gt;&gt;n;    vector&lt;int&gt; vec(n);    rep2(i,0,n)&#123;        string s;cin&gt;&gt;s;        int num = 0,times = 1000000000;        for(int i=2;i&lt;=10;i++)&#123;            num += (s[i]-&#x27;0&#x27;)*times;            times/=10;        &#125;        vec[i] = num;    &#125;    unordered_multimap&lt;int,int&gt; mp;    for(int i=0;i&lt;n;i++)&#123;        mp.insert(&#123;vec[i],i&#125;);    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            ans += mp.count(vec[i] + vec[j]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nç­‰é•·ç·šæ®µå°é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ï¼šçµ¦å®šå¹³é¢ä¸Šå¾ˆå¤šå€‹é»ï¼Œæ±‚å‡ºæœ‰å¹¾å°ç·šæ®µç­‰é•·ï¼ˆè¼¸å…¥æœ‰é‡è¤‡çš„é»ï¼‰ã€‚\n\næ—¢ç„¶nâ‰¤500ï¼Œé‚£å°±ç›´æ¥æšèˆ‰å§ï¼Œæ²’å•¥ç‰¹åˆ¥é›£åº¦ã€‚\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a,i&lt;=b;i++)#define rep2(i,a,b) for(int i=a;i&lt;b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];int dist(pii a,pii b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return x*x+y*y;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep2(i,0,n)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    map&lt;int,int&gt;mp;    for(int i=0;i&lt;n;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            int dis = dist(p[i],p[j]);            mp[dis]+=1;        &#125;    &#125;    int ans = 0;    for(auto i:mp)&#123;        int cnt = i.second;        ans+=((cnt*(cnt-1))/2);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nå‘å·¦è½‰å‘å³è½‰é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å¹³é¢ä¸Šnå€‹é»ï¼Œä¾åºèµ°è¨ªæ¯ä¸€å€‹é»ï¼Œè©¦å•èµ°è¨ªéç¨‹ä¸­å…±åŸ·è¡Œå¹¾æ¬¡çš„å·¦è½‰ã€å³è½‰ä»¥åŠè¿´è½‰ã€‚\n\nå¾ˆç‰¹åˆ¥ï¼Œè¨ˆç®—å¹¾ä½•è®“é›»è…¦å¯ä»¥è™•ç†å¹³å¸¸æˆ‘å€‘æ‰€çœ‹åˆ°çš„å¹³é¢åœ–å½¢ï¼Œå¯ä»¥åˆ©ç”¨å‘é‡å…§ç©ã€å¤–ç©ç­‰æ–¹å¼åˆ¤æ–·æ–¹å‘ã€‚é€™ä¸€é¡Œæœ€é‡è¦çš„å°±æ˜¯æ–¹å‘å‡½æ•¸ã€‚å‚³å…¥3å€‹é»$(A,B,O)$ï¼Œæ–¹å‘å‡½æ•¸æœƒæœƒå›å‚³$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ çš„æ­£è² æ•¸å€¼ã€‚\nä¸‹åœ–ç‚ºå¤–ç©$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ çš„çµæœï¼Œç•¶ $\\sin\\theta$çš„çµæœç‚ºè² ï¼Œä¹Ÿå°±æ˜¯ä¸‹åœ–çš„æƒ…æ³ï¼Œå¾Bèµ°åˆ°Aå°±éœ€è¦å¾€å·¦é‚Šèµ°ï¼›åä¹‹äº¦ç„¶ã€‚\nè‡³æ–¼å¦‚ä½•åˆ¤æ–·ç•¶å…©å€‹å‘é‡çš„æ–¹å‘å‘ˆç¾ä¸€ç›´ç·šæ™‚ï¼Œä¹Ÿå°±æ˜¯å¤–ç©å›å‚³çš„å€¼ç‚º0æ™‚ï¼ˆ$\\sin\\theta = 0$ï¼‰ï¼Œæ‡‰è©²æ˜¯åŒå‘é‚„æ˜¯ç•°å‘å‘¢ï¼Ÿé€™æ™‚å€™å°±éœ€è¦æ­é…å‘é‡å…§ç©ï¼ˆé€™æˆ‘æƒ³äº†å¾ˆä¹…ï¼‰ï¼Œå› ç‚ºå…§ç©å…¬å¼æ˜¯$A\\cdot B = |A||B|\\cos\\theta$ï¼Œå°‡å…©å€‹å‘é‡å…§ç©ä¹‹å¾Œå°±å¯ä»¥å¾ˆæ˜ç¢ºçš„åˆ¤æ–·åˆ°åº•æ˜¯æœåŸæœ¬çš„æ–¹å‘èµ°ï¼Œé‚„æ˜¯åæ–¹å‘çš„è¡Œèµ°ï¼\n\n            å…§ç©ã€å¤–ç©å…¬å¼æœ‰ä¸€é»æ•¸å­¸ï¼Œä¸éè »æœ‰è¶£çš„ã€‚å¯ä»¥åˆ©ç”¨$\\sin$èˆ‡$\\cos$é”åˆ°è¨ˆç®—è§’åº¦çš„ç›®çš„ï¼Œåˆ©ç”¨å…©è€…ä¸åŒçš„å€¼åŸŸï¼Œäº’ç›¸æ­é…ï¼Œå°±å¯ä»¥æ›´è¼•é¬†çš„é€²è¡Œåˆ¤æ–·ï¼æ³¨æ„åˆ°å¤–ç©çš„æ­£è² å°±ä»£è¡¨è‘—Aåˆ°Bæ˜¯é †æ™‚é‡æˆ–æ˜¯é€†æ™‚é˜ã€‚A\\cdot B = |A||B|\\cos\\theta = A_xB_x+A_yB_y\\\\A\\times B = |A||B|\\sin\\theta = A_xB_y-A_yB_xæ–¹å‘å‡½æ•¸ç•¶æˆ‘å€‘è¦åˆ¤æ–·æ–¹å‘çš„æ™‚å€™ï¼Œæœƒåˆ©ç”¨æ­£å¼¦å‡½æ•¸ï¼Œé€†æ™‚é‡æ­£ã€é †æ™‚é‡ç‚ºè² é€²è¡Œåˆ¤æ–·ï¼int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;æ³¨æ„åˆ°æ­¤æ™‚åœ¨åˆ¤æ–·æ˜¯å¦ç‚ºå¹³è¡Œçš„æ™‚å€™ï¼ˆcross==0ï¼‰ï¼Œä½¿ç”¨åˆ°$fabs()$é€™å€‹å‡½æ•¸ï¼Œç›®çš„æ˜¯ç‚ºäº†é¿å…èª¤å·®è€Œå°è‡´åˆ¤æ–·éŒ¯èª¤ï¼Œå› æ­¤éœ€è¦é€²è¡Œèª¤å·®çš„è™•ç†ï¼ˆå…¶å¯¦ä¸ç”¨ä¹Ÿæ²’å·®å•¦ï¼Œåªæ˜¯é€™æ¨£åš´è¬¹ä¸€é»ï¼‰\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; a;int dir(pt a, pt b, pt o) &#123;    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;int n,t;signed main()&#123;    Orz;    cin&gt;&gt;n;    a.resize(n+2);    rep(i,1,n)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;    int right = 0,left = 0,turn = 0;    pt pre = a[1],from = a[2];    for(int i=3;i&lt;=n;i++)&#123;        int ori = dir(a[i],from,pre);        if(ori == 1)right+=1;        else if(ori == -1)left+=1;        else if(ori == 0 &amp;&amp; ((a[i]-from)*(from-pre))&lt;0)turn+=1;        pre = from;from = a[i];    &#125;    cout&lt;&lt;left&lt;&lt;&quot; &quot;&lt;&lt;right&lt;&lt;&quot; &quot;&lt;&lt;turn&lt;&lt;endl;&#125;\nç·šæ®µç›¸äº¤é¡Œç›®é€£çµSubmissionç·šæ®µç›¸äº¤ = ç·šæ®µé¦™è•‰ï¼Œè‡ªå‹•é¸å­—æ°¸é éƒ½æ˜¯é¦™è•‰ï¼Œæœ‰é»ç…©XDD\nå¦‚ä½•åˆ¤æ–·å…©ç·šæ®µæ˜¯å¦ç›¸äº¤ï¼Ÿé¦–å…ˆéœ€è¦ä¸€å€‹å‡½æ•¸å¯ä»¥åˆ¤æ–·é»æ˜¯å¦åœ¨ä¸€å€‹ç·šæ®µä¸Šï¼Œå¦‚æ­¤ä¸€ä¾†å°±å¯ä»¥åˆ¤æ–·ç«¯é»åœ¨å¦ä¸€æ¢ç·šæ®µä¸Šçš„ç‰¹æ®Šæƒ…æ³ã€‚ä»¥ä¸‹ç¨‹å¼ç¢¼ç‚ºåˆ¤æ–·é»$P_o$ æ˜¯å¦åœ¨ $\\overline{P_aP_b}$ ä¸Šã€‚åˆ©ç”¨å‘é‡å¤–ç©å¯ä»¥åˆ¤æ–·å…©ç·šæ®µæ˜¯å¦å¹³è¡Œï¼Œè€Œä½¿ç”¨å…§ç©å…¬å¼å¯ä»¥åˆ¤æ–·$P_o$æ˜¯å¦åœ¨ç·šæ®µä¸­ï¼Œè€Œéç·šæ®µçš„å…©å´ï¼\nbool onseg(pt a, pt b, pt o)&#123;       //oæ˜¯å¦åœ¨abç·šæ®µä¸Š    int cross = (a - o) ^ (b - o);  //æ˜¯å¦å¹³è¡Œ    int dot = (a - o) * (b - o);    //æ˜¯å¦åœ¨ç·šæ®µä¸­    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;\nèªªæ˜ï¼šç”±é»$P_o$æŒ‡å‘aå’Œbçš„å‘é‡å¿…é ˆå‘ˆç¾180åº¦è§’ï¼ˆä¹Ÿå°±æ˜¯ç•°å‘ï¼‰ï¼Œæ‰å¯ç¢ºä¿åœ¨abç·šæ®µä¸­ï¼ˆè·Ÿa,bé‡åˆä¹Ÿç®—æ˜¯è·Ÿabç·šæ®µç›¸äº¤ï¼‰ã€‚\næ¥ä¸‹ä¾†æ˜¯ä¸»è¦çš„éƒ¨åˆ†ï¼Œé¦–å…ˆå…ˆç¢ºèª4å€‹ç«¯é»æ˜¯å¦æ°å¥½åœ¨å¦å¤–ä¸€æ¢ç·šæ®µä¸Šï¼Œåˆ¤æ–·å®Œä¹‹å¾Œå°±æ˜¯è™•ç†ä¸€èˆ¬ç›¸äº¤çš„æƒ…æ³ã€‚è‹¥ç·šæ®µ $\\overline{P_1P_2}$ èˆ‡ $\\overline{P_3P_4}$ ç›¸äº¤ï¼Œå‰‡é» $P_1$ èˆ‡é» $P_2$ æœƒåœ¨ç·šæ®µ$\\overline{P_3P_4}$ çš„ç•°å´ã€‚ç”¨æ–¹å‘å‡½æ•¸è¡¨ç¤ºï¼š$dir(a,b,c)\\times dir(a,b,d)&lt;0$ã€‚ç¢ºèªå®Œå…©å€‹ç·šæ®µä¹‹å¾Œå³å®Œæˆç·šæ®µç›¸äº¤çš„åˆ¤æ–·ï¼\nbool Intersection(pt a, pt b, pt c, pt d)&#123;      //ç·šæ®µabæ˜¯å¦èˆ‡cdç›¸äº¤    if(onseg(a,b,c)||onseg(a,b,d))return true;  //é»cã€dæ˜¯å¦æ´½åœ¨ç·šæ®µabä¸Š    if(onseg(c,d,a)||onseg(c,d,b))return true;  //é»aã€bæ˜¯å¦æ´½åœ¨ç·šæ®µcdä¸Š    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                            //å°æ–¼ç·šæ®µå…©ç«¯é»çœ‹å¦å¤–å…©ç«¯é»å¿…é ˆæ–¹å‘ç›¸å    return false;&#125;\nç”±ä¸‹åœ–å¯ä»¥å¾—åˆ°ä¸Šé¢çš„çµè«–ï¼Œç•¶å…©ç·šæ®µç›¸äº¤æ™‚ï¼Œæ–¹å‘å‡½æ•¸å¾—åˆ°çš„å€¼ï¼ˆç”¨å¤–ç©ï¼Œä¹Ÿå°±æ˜¯ä¸‹åœ– $\\theta_1$ ä»¥åŠ $\\theta_2$ï¼‰çš„æ–¹å‘ï¼‰ï¼Œæœƒå‘ˆç¾ä¸€æ­£ä¸€è² ï¼Œå¾å…©å€‹ç›¸åçš„æ–¹å‘çœ‹åŒä¸€æ¢ç·šæ®µå¾—å‡ºä¾†çš„çµè«–ï¼\nAC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 1003#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; point;int dir(pt a, pt b, pt o) &#123;                         //æ–¹å‘å‡½æ•¸    int cross = (a - o) ^ (b - o);    if(fabs(cross) &lt;= eps) return 0;    else if(cross &gt; 0) return 1;    else return -1;&#125;bool onseg(pt a, pt b, pt o)&#123;                       //oæ˜¯å¦åœ¨abç·šæ®µä¸Š    int cross = (a - o) ^ (b - o);                  //æ˜¯å¦å¹³è¡Œ    int dot = (a - o) * (b - o);                    //æ˜¯å¦åœ¨ç·šæ®µä¸­    return (cross == 0)&amp;&amp;(dot &lt;= 0);&#125;bool Intersection(pt a, pt b, pt c, pt d)&#123;          //ç·šæ®µabæ˜¯å¦èˆ‡cdç›¸äº¤    if(onseg(a,b,c)||onseg(a,b,d))return true;      //é»cã€dæ˜¯å¦æ´½åœ¨ç·šæ®µabä¸Š    if(onseg(c,d,a)||onseg(c,d,b))return true;      //é»aã€bæ˜¯å¦æ´½åœ¨ç·šæ®µcdä¸Š    if(dir(a,b,c)*dir(a,b,d)==-1 &amp;&amp; dir(c,d,a)*dir(c,d,b)==-1)        return true;                                //å°æ–¼ç·šæ®µå…©ç«¯é»çœ‹å¦å¤–å…©ç«¯é»å¿…é ˆæ–¹å‘ç›¸å    return false;&#125;int n,t;void solve()&#123;    point.assign(4,&#123;0,0&#125;);    rep(i,0,3)cin&gt;&gt;point[i].x&gt;&gt;point[i].y;    if(Intersection(point[0],point[1],point[2],point[3]))&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\nTIOJ 1178 Convex Hullé¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦å®šnå€‹äºŒç¶­å¹³é¢çš„é»ï¼Œæ‰¾å‡ºä½åœ¨å‡¸åŒ…ä¸Šçš„æ‰€æœ‰é»çš„å€‹æ•¸\n\næœ€å°å‡¸å¤šé‚Šå½¢ = å‡¸åŒ…ï¼Œè¦æ‰¾å‡ºèƒ½åŒ…ä½æ‰€æœ‰é»çš„æœ€å°å‡¸å¤šé‚Šå½¢ï¼Œç°¡ç¨±å‡¸åŒ…ã€‚è½èªªæœ€å¥½å¯«çš„å‡¸åŒ…æ¼”ç®—æ³•æ˜¯ï¼šAndrewâ€™s Monotone Chainï¼Œç¿»æˆä¸­æ–‡å«åšAndrewâ€™s å–®èª¿éŠï¼Ÿæœ‰ä¸€é»å–®èª¿+éŠçš„å‘³é“ã€‚ä¸‹åœ–æ˜¯æˆ‘ç”¨ç…§ç‰‡åˆæˆèµ·ä¾†çš„GIFï¼Œå¤§è‡´æ¨¡æ“¬å‡ºä½¿ç”¨Andrewâ€™s Monotone Chain æ‰¾å‡¸åŒ…çš„æ–¹æ³•ã€‚\n\n\n            Andrewâ€™s Monotone Chainé€™å€‹æ¼”ç®—æ³•çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(n\\log n)$ï¼Œç©ºé–“è¤‡é›œåº¦ $O(n)$ï¼Œè³‡æ–™èªªå®ƒå¯ä»¥è§£æ±ºäº†å‡¸åŒ…æœ‰é‡ç–Šçš„é»ã€å…±ç·šçš„é»ã€é€€åŒ–æˆç·šæ®µå’Œé»çš„æƒ…æ³ã€‚å®ƒçš„åå­—å«åšã€Œå–®èª¿éŠã€ï¼Œè¦ç¶­è­·ä¸€å€‹æœ‰é»åƒå–®èª¿éšŠåˆ—çš„æ±è¥¿ï¼Œå°æ–¼åœ¨å®¹å™¨ä¸­ç¬¬ $i$ å€‹ä½ç½®çš„é»éƒ½æ»¿è¶³ $\\stackrel\\longrightarrow{Pi P{i+1}}\\times \\stackrel\\longrightarrow{P{i+1} P{i+2}} &gt; 0$ ï¼Œå¦‚æœæœ‰é»åšå¤–ç©å¾Œçš„çµæœå°æ–¼ç­‰æ–¼0ï¼Œå‰‡å®ƒæœƒè¢«popæ‰ï¼ˆé€™æ˜¯ä¾ç…§ä¸Šåœ–é€†æ™‚é‡å®Œæˆå‡¸åŒ…çš„æè¿°ï¼Œå¦‚æœæ–¹å‘ç›¸åå‰‡æœƒè®Šè™Ÿï¼‰ã€‚ä»¥ä¸‹æ˜¯æ­¤æ¼”ç®—æ³•çš„åŸ·è¡Œæ­¥é©Ÿï¼šå…ˆæŠŠæ‰€æœ‰çš„é»æŒ‰ç…§ $(x,y)$ æ’åºå°‡ä¸‹å‡¸åŒ…åœå‡ºä¾†ï¼Œæœ‰é»åƒç¶­è­·å–®èª¿éšŠåˆ—ï¼Œå°æ‰€æœ‰æ–°åŠ å…¥çš„é»iè¨ˆç®—é»i-2ã€i-1èˆ‡iä¹‹é–“çš„å¤–ç©ï¼Œå¦‚æœä¸ç¬¦åˆæƒ…æ³ä»£è¡¨åœä¸åˆ°æ–°åŠ å…¥çš„é»ï¼Œéœ€è¦å°‡èˆŠçš„é»popå‡ºä¾†å°‡åŸæœ¬å·²ç¶“æ’åºå¥½çš„é»é€†åºå†æŠŠä¸Šå‡¸åŒ…ç”±xåº§æ¨™å¤§åˆ°å°åœå‡ºä¾†ï¼Œå°‡ä¸Šä¸‹åˆä½µå°±æ˜¯å‡¸åŒ…äº†ï¼ˆå¿…é ˆæ³¨æ„èµ·çµ‚é»è¢«pushçš„æ¬¡æ•¸å•é¡Œï¼‰ï¼\n          \nä¸€èˆ¬æœƒç”¨ä¸€å€‹vectorå„²å­˜åœ¨å‡¸åŒ…ä¸Šé¢çš„é»ï¼ˆä¸åŒ…å«åœ¨é‚Šä¸Šçš„é»ï¼Œåªæœ‰ä½æ–¼è½‰æŠ˜é»çš„é»ï¼‰ï¼Œåœ¨é ­å°¾çš„éƒ¨åˆ†ï¼ˆxåº§æ¨™æœ€å¤§èˆ‡æœ€å°ï¼‰éœ€è¦ç‰¹åˆ¥è™•ç†ï¼Œè®“æ¯ä¸€å€‹é»æœ€å¤šè¿‘åˆ°vectorä¸€æ¬¡ã€‚\n\n            å¯¦ä½œç´°ç¯€ä»¥ä¸‹æ˜¯ç¢ºèªæ˜¯å¦éœ€è¦å°‡vectorä¸­å…ƒç´ popå‡ºä¾†çš„é—œéµï¼Œå°å‘é‡$\\stackrel\\longrightarrow{OA}\\times \\stackrel\\longrightarrow{OB}$ åšå¤–ç©çš„çµæœï¼Œå¿…é ˆæ’é™¤å¤–ç©çµæœç‚º0çš„æƒ…æ³ï¼Œå¦‚æœå°‡0ä¹Ÿç´å…¥ï¼Œæœƒé€ æˆä¸€å€‹é»è¢«pushé€²å»å¾ˆå¤šæ¬¡ï¼Œåœ¨æ•¸é‡å’Œè¨ˆç®—ä¸Šå‡ºç¾å•é¡Œã€‚bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;         //é€™è£¡å¾ˆé—œéµï¼Œåˆ¥åƒWA&#125;é™¤æ­¤ä¹‹å¤–ï¼Œä¸Šå‡¸åŒ…åœ¨ç¯„åœé™åˆ¶ä¸Šæ˜¯éœ€è¦æ³¨æ„çš„ã€‚å‡è¨­xåº§æ¨™æœ€å¤§çš„é»iï¼Œç•¶åœ¨åœä¸Šå‡¸åŒ…çš„éç¨‹ä¸­iæ˜¯ä¸å¯ä»¥è¢«popå‡ºå»çš„ï¼Œå› æ­¤vectorçš„å¤§å°å¿…é ˆå¤§æ–¼ä¸‹å‡¸åŒ…çš„å¤§å°ã€‚å‡¸åŒ…ä½¿ç”¨ç¬¬i-1è·Ÿç¬¬iå€‹é»çš„å‘é‡å»çœ‹ç¬¬iåˆ°ç¬¬i+1å€‹é»çš„å‘é‡ï¼Œæ±ºå®šä¸€å€‹é»è¦ä¸è¦è¢«æ¨å…¥vectorä¸­ã€‚ç•¶æˆ‘å€‘é€†åºå¾xåº§æ¨™æœ€å¤§çš„é»å¾€å‰çœ‹æ™‚ï¼Œè¦ç¢ºä¿æ¯ä¸€è¼ªçµæŸä¹‹å¾Œåœ¨ié»å¾Œéƒ½å¿…é ˆè¦æœ‰è‡³å°‘ä¸€å€‹é»ï¼Œè¨­å®šhull.size() &gt; down_hullçš„åŸå› æ˜¯é˜²æ­¢åœ¨ä¸‹å‡¸åŒ…çš„é»è¢«åœä¸Šå‡¸åŒ…çš„éç¨‹æ›´æ–°åˆ°ã€‚int down_hull = hull.size();    //åœä¸Šå‡¸åŒ…çš„ç¨‹å¼ç¢¼ç‰‡æ®µfor(auto i: p)&#123;    while(hull.size() &gt; down_hull         &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;        hull.pop_back();    &#125;    hull.push_back(i);&#125;\n          \nä»¥ä¸‹æ˜¯AC Code:\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //é€™è£¡å¾ˆé—œéµï¼Œåˆ¥åƒWA&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //é¦–å…ˆå°xé€²è¡Œæ’åº    for(auto i : p)&#123;                   //ä¾åºèµ°è¨ªï¼Œå¦‚æœé‡åˆ°å¤–ç©&lt;0å‰‡ä¸åœ¨å‡¸åŒ…ä¸Š        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //åœ¨å‡¸åŒ…hullçš„æ¯ä¸€é»éƒ½ç¬¦åˆå¤–ç©å°æ–¼0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //xæœ€å¤§çš„é»æœƒåœ¨å‡¸åŒ…ä¸Šï¼Œä¸ç”¨åšå…©æ¬¡å…ˆpopä¸€æ¬¡    reverse(p.begin(),p.end());        //å°‡æ‰€æœ‰é»é€†åºä¹‹å¾Œåšä¸€æ¬¡ä¸Šé¢çš„å‡¸åŒ…    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //èµ·é»æœƒç¶“éå…©æ¬¡ï¼Œå‰›å¥½ä¾†ç®—æœ‰å‘é¢ç©&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = convex_hull();    cout&lt;&lt;hull.size()-1&lt;&lt;endl;&#125;\næœ€å°å‡¸å¤šé‚Šå½¢é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°æ‰¾å‡ºäºŒç¶­å¹³é¢ä¸Šnå€‹é»çš„å‡¸åŒ…æ‰€åœå‡ºä¾†çš„é¢ç©ç‚ºä½•ï¼Ÿ\n\nè·Ÿä¸Šä¸€é¡Œé¡ä¼¼ï¼Œåœ¨æ‰¾åˆ°å…¨éƒ¨åœ¨å‡¸åŒ…ä¸Šé¢çš„é»å¾Œï¼Œå°±å¯ä»¥åˆ©ç”¨æœ‰å‘é¢ç©æŠŠå‡¸åŒ…é¢ç©ç®—å‡ºä¾†ï¼Œæœ‰ä¸€å€‹å…¬å¼å¯ä»¥è¨ˆç®—å¤šé‚Šå½¢é¢ç©ï¼Œåˆ©ç”¨å¤–ç©å¾—åˆ°æ­£è² å€¼ï¼Œè½‰ä¸€åœˆå¾Œå¾—åˆ°é¢ç©ï¼å°æ–¼å¤šé‚Šå½¢çš„é ‚é» $P0,P_1,â€¦,P{n-1},P_n=P_0$ çš„é¢ç©å¦‚ä¸‹ï¼š\nArea = \\frac{1}{2}\\sum_{i=0}^{n-1}\\stackrel\\longrightarrow{P_i}\\times \\stackrel\\longrightarrow{P_{i+1}}å…¶ä¸­æœ€å¾Œä¸€å€‹é»æœƒå›åˆ°èµ·é»ï¼Œå½¢æˆä¸€å€‹å°é–‰çš„è¿´è·¯ã€‚\nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x&lt;=eps &amp;&amp; y-b.y&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;&#125;int n,t;vector&lt;pt&gt; convex_hull()&#123;    vector&lt;pt&gt; hull;    sort(p.begin(),p.end(),cmp);       //é¦–å…ˆå°xé€²è¡Œæ’åº    for(auto i : p)&#123;                   //ä¾åºèµ°è¨ªï¼Œå¦‚æœé‡åˆ°å¤–ç©&lt;0å‰‡ä¸åœ¨å‡¸åŒ…ä¸Š        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //åœ¨å‡¸åŒ…hullçš„æ¯ä¸€é»éƒ½ç¬¦åˆå¤–ç©å°æ–¼0    &#125;    int down_hull = hull.size();    hull.pop_back();                   //xæœ€å¤§çš„é»æœƒåœ¨å‡¸åŒ…ä¸Šï¼Œä¸ç”¨åšå…©æ¬¡å…ˆpopä¸€æ¬¡    reverse(p.begin(),p.end());        //å°‡æ‰€æœ‰é»é€†åºä¹‹å¾Œåšä¸€æ¬¡ä¸Šé¢çš„å‡¸åŒ…    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    return hull;                       //èµ·é»æœƒç¶“éå…©æ¬¡ï¼Œå‰›å¥½ä¾†ç®—æœ‰å‘é¢ç©&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        vector&lt;pt&gt; hull = convex_hull();        int area = 0,len = hull.size();        for(int i=0;i&lt;len-1;i++)area += (hull[i]^hull[i+1]);        cout&lt;&lt;fixed&lt;&lt;setprecision(1)&lt;&lt;((ld)area/2)&lt;&lt;endl;    &#125;&#125;\nä¾†å§ï¼ŒéŠæˆ²é–‹å§‹äº†é¡Œç›®é€£çµSubmissionGGBæ¨¡æ“¬\n\né¡Œç›®æ•˜è¿°çµ¦ä½ äºŒç¶­å¹³é¢ä¸Šnå€‹é»(nâ‰¤2400)ï¼Œæ¯ä¸€å€‹é»åº§æ¨™çš†ä¸ç›¸åŒï¼Œæ±‚å‡ºç¸½å…±å¯ä»¥åœå‡ºå¤šå°‘å€‹ä¸‰è§’å½¢ï¼Ÿ\n\né€™æ˜¯NEOJä¸Šçš„åŠ åˆ†é¡Œï¼Œå¥½åƒæ˜¯ä¸€å€‹é¡Œçµ„å§ï¼Œåæ­£ç¸½å…±æœ‰ä¸‰é¡Œï¼Œé€™æ˜¯ç¬¬ä¸€é¡Œã€‚å¦‚æœ $O(n^3)$ çš„æšèˆ‰ï¼Œè¤‡é›œåº¦æœƒçˆ†ç‚¸ï¼ˆé‡ç´šç´„$10^{10}$ï¼‰ï¼Œæ ¹æ“šé›»ç¥çš„èªªæ³•ï¼Œé€™ä¸€é¡Œè¦ç”¨æ¥µè§’æ’åºä»¥åŠé›™æŒ‡æ¨™æ‰¾åˆ°å…±ç·šï¼Œæ¥è‘—å°±å¯ä»¥åˆ©ç”¨æ’åˆ—çµ„åˆæŠŠå› ç‚ºå…±ç·šè€Œä¸èƒ½å½¢æˆä¸‰è§’å½¢çš„çµ„åˆæ‰£æ‰ï¼Œå°±æ˜¯ç­”æ¡ˆäº†ã€‚\n\né€™ä¸€é¡Œçš„æ ¸å¿ƒæ¦‚å¿µæ˜¯æ‰¾å…±ç·šï¼Œå…·é«”ä¾†èªªçš„ä½œæ³•æ˜¯æšèˆ‰æ¯ä¸€å€‹é»çš„åŒæ™‚ï¼Œä»¥å®ƒç‚ºåŸé»å°å…¶ä»–çš„é»é€²è¡Œæ’åºï¼Œå¦‚æœé‡åˆ°æœ‰ç›¸åŒçš„æ¥µè§’åº§æ¨™è¡¨ç¤ºé€™äº›é»å…±ç·šï¼ŒåŒæ™‚åˆ©ç”¨é™£åˆ—cnt[x]çµ±è¨ˆå…±ç·šé»æ•¸ç‚ºxçš„ç·šæ®µç¸½å…±æœ‰å¹¾æ¢ã€‚\nä»¥ä¸‹çš„GIFå°±æ˜¯å¤§è‡´ä¸Šç¨‹å¼åŸ·è¡Œçš„æ¨£å­ã€‚å› ç‚ºä¸€æ¢é•·åº¦ç‚ºxçš„ç·šæ®µæœƒå› ç‚ºæšèˆ‰xæ¬¡çš„é—œä¿‚ï¼Œåœ¨æœ€å¾Œæ‰£æ‰çš„æƒ…æ³æœƒé‡è¤‡xæ¬¡å› æ­¤éœ€è¦é™¤æ‰ã€‚\n\n\n            å…±ç·šèˆ‡ä¸‰è§’å½¢ä¸€èˆ¬æƒ…æ³ä¸‹ï¼ˆä»»ä¸‰é»ä¸å…±ç·šï¼‰ï¼Œç¸½å…±å¯ä»¥å½¢æˆ $C^n_3$ å€‹ä¸‰è§’å½¢ï¼Œå¦‚æœæœ‰ä¸€æ¢må€‹é»å…±ç·šçš„æƒ…æ³ä¸‹ï¼ˆå…¶ä»–é»ä¸å…±ç·šï¼‰ï¼Œå‰‡å¯ä»¥å½¢æˆçš„ä¸‰è§’å½¢æ•¸é‡å°±å¿…é ˆæ‰£é™¤å…±ç·šé™åˆ¶çš„æƒ…æ³ï¼Œè®Šæˆ $C^n_3-C^m_3$ å€‹ä¸‰è§’å½¢ã€‚\n          \næ™‚é–“è¤‡é›œåº¦ç‚ºï¼šæšèˆ‰æ¯ä¸€å€‹é» $O(n)$ï¼Œæ¥µè§’æ’åº $O(n\\log n)$ï¼Œç¸½æ™‚é–“è¤‡é›œåº¦ $O(n^2\\log n)$\n\n            å¯¦ä½œå°ç´°ç¯€1. ç¶­è­·å…±ç·šé€£çºŒå€é–“æˆ‘å€‘è¦æƒ³è¾¦æ³•è®“æœ‰å…±ç·šçš„é»å€‘æ‰€åœ¨ä½ç½®æ˜¯ä¸€å€‹é€£çºŒçš„ä½ç½®ã€‚ä¸‰å€‹é»å…±ç·šå¯èƒ½ç‚ºåœ¨å°è§’ç·šçš„è±¡é™ä¸­ï¼Œä¹Ÿå°±æ˜¯é»å·®äº†180åº¦ï¼Œå¦‚æ­¤ä¸€ä¾†å°±æ²’è¾¦æ³•è®“å…±ç·šçš„é»ç‚ºåœ¨é€£çºŒçš„å€é–“ã€‚ç‚ºäº†é”åˆ°é€™å€‹ç›®çš„ï¼Œæˆ‘å€‘å°‡æ‰€æœ‰ä½æ–¼ä¸‹åŠå¹³é¢çš„é»éƒ½ç§»åˆ°ä¸ŠåŠå¹³é¢ï¼ˆåœ¨ä¸ŠåŠå¹³é¢æ‰¾åˆ°æœ‰ç›¸åŒ $\\tan\\theta$ å€¼çš„ä½ç½®ï¼‰ï¼Œæ¥è‘—å°±èƒ½åˆ©ç”¨é›™æŒ‡é‡æ‰¾æ¥µè§’åº§æ¨™æ’åºå¾Œæœ‰ç›¸åŒæ¥µè§’çš„å€é–“ä¹‹æœ€å¤§å€¼ï¼2. ç‰¹ä¾‹åˆ¤æ–·å¦‚æœæœ‰ä¸€é»yåº§æ¨™ç‚º0ä½†xåº§æ¨™ç‚ºè² ï¼Œè¦å°‡å…¶ç§»åˆ°xè»¸æ­£å‘çš„åœ°æ–¹ï¼Œä¸èƒ½æŠŠé€™ç¨®æƒ…æ³æ¶µè“‹ç‚ºä¸€èˆ¬æƒ…æ³ï¼Œå¦å‰‡åŸæœ¬åœ¨xè»¸æ­£å‘çš„é»æœƒè¢«ç§»åˆ°xè»¸è² å‘ï¼Œæ²’æœ‰é”åˆ°é æœŸçš„æ•ˆæœã€‚\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt; cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //é€†æ™‚é‡å°‡é»é€²è¡Œæ¥µè§’æ’åºï¼Œå¾270åº¦é–‹å§‹é€†æ™‚é‡&#125;//ç”¨cnt[i]çµ±è¨ˆå€é–“é•·åº¦ç‚ºiçš„ç·šæ®µæ•¸é‡void solve(pt id)&#123;    vector&lt;pt&gt; pp;    for(auto i : p)&#123;                         //ä»¥idç‚ºåŸé»        pt cur = i-id;        if(cur == pt&#123;0,0&#125;)continue;        if(cur.y &lt; 0)&#123;cur.x = -cur.x;cur.y = -cur.y;&#125;        if(cur.x &lt; 0 &amp;&amp; cur.y==0)&#123;cur.x = -cur.x;&#125;        pp.push_back(cur);    &#125;    sort(all(pp),cmp);                      //å°‡idç•¶ä½œåŸé»é€²è¡Œæ’åº    int p1 = 0,p2 = 0,len = pp.size();      //é›™æŒ‡é‡æ‰¾å…±ç·šå€é–“    while(p1 &lt; n-1)&#123;                        //æœ€å¤§åŒ–å€é–“        while(p2+1 &lt; len &amp;&amp; (pp[p1]^pp[p2+1]) == 0)p2++;        cnt[p2-p1+2]+=1;        p1 = p2+1;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    cnt.resize(n+1,0);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    rep(i,0,n-1)solve(p[i]);    int ans = (n*(n-1)*(n-2))/6;    rep(i,3,n)ans-=(cnt[i]*(i-1)*(i-2))/6;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\néŠæˆ²ï¼šæœ€çµ‚å›é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°å…±æœ‰nå€‹äºŒç¶­å¹³é¢ä¸Šçš„æ ¼å­é»ï¼Œé€™äº›é»æœƒå½¢æˆç°¡å–®å¤šé‚Šå½¢ã€‚è©¦æ±‚æˆ–åœ¨ç°¡å–®å¤šé‚Šå½¢å…§éƒ¨çš„æ ¼ç·šç¸½é•·ï¼ˆåŒ…æ‹¬å‚ç›´èˆ‡æ°´å¹³æ ¼ç·šï¼‰ã€‚\n\né€™é‚Šæœ‰ä¸€å€‹ä¸åš´è¬¹çš„æ¨å°æ–¹å¼ï¼Œä¸éä»–æ˜¯æ­£ç¢ºçš„ã€‚ä»¤å¤šé‚Šå½¢å…§éƒ¨æ ¼ç·šé•·åº¦ç‚ºSï¼Œå¤šé‚Šå½¢çš„é‚Šè½åœ¨çš„æ ¼ç·šé•·åº¦ç‚ºTï¼Œå¤šé‚Šå½¢é¢ç©Tï¼Œå‰‡æœ‰ä»¥ä¸‹é—œä¿‚å¼ï¼š\nS = 2A-\\frac{T}{2}è©³ç´°çš„å…¬å¼æ¨å°å¯ä»¥å¯ä»¥åƒé–±ä¸‹åœ–ï¼Œå¹³è¡Œå››é‚Šå½¢ï¼ˆæ–œç·šéƒ¨åˆ†ï¼‰å…§éƒ¨å‚ç›´çš„æ ¼ç·šé•·åº¦ç‚ºï¼š å¤§çŸ©å½¢ $(x_1+x_2)(y_1+y_2)$ æ‰£æ‰å·¦å³ä¸Šä¸‹å…±å››å€‹ä¸‰è§’å½¢å…©å…©æ‹¼æˆä¸€å€‹çŸ©å½¢ $x_1y_1$ ä»¥åŠ $x_2y_2$ï¼Œé‚„æœ‰å·¦ä¸Šå³ä¸‹å…©å€‹æ­£æ–¹å½¢ $2x_2y_1$ï¼Œæ•´ç†ä¹‹å¾Œæœƒç™¼ç¾å…¶å¯¦è·Ÿé¢ç©æ˜¯ä¸€æ¨£çš„ã€‚å°æ–¼å‚ç›´éƒ¨åˆ†ä¹Ÿæ˜¯é¡ä¼¼çš„æƒ…æ³ã€‚\n\nå¥½åƒéš±ç´„ç™¼ç¾åˆ°é¢ç©èˆ‡æ ¼ç·šé•·åº¦æœ‰ååˆ†å¯†åˆ‡çš„é—œä¿‚ï¼Œç®—å‡ºé¢ç©ï¼ŒæŠŠåœ¨æ ¼ç·šä¸Šçš„é‚Šé€²è¡Œç‰¹åˆ¤æ‰£æ‰ï¼Œå°±å¯ä»¥å¾—åˆ°æ ¼ç·šé•·åº¦ã€‚\né€™ä¸€é¡Œæˆ‘æƒ³äº†å¾ˆä¹…ï¼Œä¸€ç›´çœ‹ä¸å‡ºä¾†é—œä¿‚å¼åˆ°åº•é•·æ€æ¨£ï¼Œç›´åˆ°å¤§ç¥æé»æ‰ç™¼ç¾åŸä¾†æœ‰é€™æ¨£çš„é—œä¿‚ï¼Œæˆ‘åæ‡‰å¥½é²éˆ:cry:\n\nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p;vector&lt;int&gt;  cnt;int n,edge,ans;int solve()&#123;    int area = 0;    rep(i,0,n-1)&#123;        area += (p[i]^p[i+1]);        if(p[i].y == p[i+1].y)edge += abs(p[i].x-p[i+1].x);        if(p[i].x == p[i+1].x)edge += abs(p[i].y-p[i+1].y);    &#125;    area = abs(area);    return area;&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(1);    while(cin&gt;&gt;n)&#123;        p.assign(n+1,&#123;0,0&#125;);        edge = 0;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ans = solve();        cout&lt;&lt;ans-((ld)edge/2)&lt;&lt;endl;    &#125;&#125;\nTIOJ 1205 ç›´è§’ä¸‰è§’å½¢é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ Nï¼ˆNâ‰¤1500ï¼‰å€‹åº§æ¨™å¹³é¢ä¸Šçš„é»ï¼Œè«‹å•ç¸½å…±å¯å½¢æˆå¤šå°‘å€‹ç›´è§’ä¸‰è§’å½¢å‘¢ï¼Ÿ\n\nå¾æ¥µè§’æ’åºå¾Œçš„ç¬¬ä¸€å€‹é»é–‹å§‹é€†æ™‚é‡é€²è¡Œé›™æŒ‡é‡çš„æšèˆ‰ã€‚é€™é‚Šä½¿ç”¨åˆ°ä¸€å€‹å¾ˆç‰¹åˆ¥çš„æ‰‹æ³•ï¼Œå°æ–¼å…±ç·šçš„æƒ…æ³æˆ‘å€‘å…ˆé€éé è™•ç†çš„æ–¹å¼å°‡å…±ç·šçš„é»åˆä½µèµ·ä¾†ï¼Œä¸¦ç”¨cnt[x]é™£åˆ—ç´€éŒ„ç¬¬xå€‹é»æ˜¯ç”±å¹¾å€‹é»æ‰€åˆä½µèµ·ä¾†çš„ï¼Œå¦‚æ­¤ä¸€ä¾†ï¼Œåœ¨é€²è¡Œè¨ˆç®—çš„æ™‚å€™å°±ä¸æœƒæœ‰å…±ç·šè¦åˆ†åˆ¥è™•ç†çš„å•é¡Œï¼ˆä¸éœ€æ“”å¿ƒæ˜¯ä¸æ˜¯å¯ä»¥è·Ÿä¹‹å‰çš„é»å½¢æˆç›´è§’ä¸‰è§’å½¢ï¼Œå› ç‚ºç›¸åŒæ–œç‡çš„é»å·²ç¶“è¢«åˆä½µå‰©ä¸‹ä¸€å€‹ï¼‰ï¼Œç›´æ¥å°‡æ•¸é‡ç›¸ä¹˜å°±å¯ä»¥çŸ¥é“ç›´è§’ä¸‰è§’å½¢çš„æ•¸é‡ï¼\næ™‚é–“è¤‡é›œåº¦ï¼šæšèˆ‰æ‰€æœ‰é» $O(n)\\times$ é€²è¡Œæ¥µè§’æ’åº$O(n\\log n)$ ä»¥åŠé›™æŒ‡æ¨™$O(n)$ï¼Œç¸½æ™‚é–“è¤‡é›œåº¦ç‚º $O(n^2\\log n)$ã€‚\n\n            å¯¦ä½œå°ç´°ç¯€é›™æŒ‡é‡é€²è¡Œæšèˆ‰çš„éç¨‹ä¸­ï¼Œå¾ˆæœ‰å¯èƒ½æœƒæŒ‡æ¨™æŒ‡å‘çš„ç´¢å¼•å€¼æœƒè¶…å‡ºç¯„åœã€‚è§£æ±ºçš„æ–¹æ³•æœ‰å…©ç¨®ï¼šè¶…å‡ºäº†å³ä»£è¡¨ç¹äº†ä¸€åœˆï¼Œåªéœ€è¦å°ç´¢å¼•å€¼å–é¤˜æ•¸å³å¯ã€‚é™¤äº†å–é¤˜æ•¸çš„æ–¹æ³•ä¹‹å¤–ï¼Œå…¶å¯¦ä¹Ÿå¯ä»¥ç›´æ¥åœ¨é»é›†å¾Œé¢å°‡æ‰€æœ‰é»å†æ¨å…¥ä¸€æ¬¡ï¼Œè®“è§’åº¦å¾360å»¶ä¼¸æˆ720åº¦ï¼Œå°±ä¸æœƒæœ‰è¶…å‡ºç¯„åœçš„å•é¡Œï¼\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    bool f1 = a &lt; pt&#123;0,0&#125;;    bool f2 = b &lt; pt&#123;0,0&#125;;    if(f1 != f2)return f1 &lt; f2;    return (a ^ b) &gt; 0;    //é€†æ™‚é‡å°‡é»é€²è¡Œæ¥µè§’æ’åºï¼Œå¾270åº¦é–‹å§‹é€†æ™‚é‡&#125;//O(n)æšèˆ‰æ¯å€‹é»ç•¶ç›´è§’æƒ…æ³int solve(pt id)&#123;    pp.clear();cnt.clear();temp.clear();    for(pt i : p)&#123;        pt cur = i - id;        if(cur == pt&#123;0,0&#125;)continue;        temp.push_back(cur);    &#125;    sort(all(temp),cmp);            //ä»¥idç‚ºåŸé»é€²è¡Œæ¥µè§’æ’åº    pp.push_back(temp[0]);          //ppæ¯ä¸€è§’åº¦åªå­˜è‡³å¤šä¸€å€‹é»    cnt.push_back(1);               //è€ƒæ…®æ¯å€‹é»å…±ç·šæƒ…æ³    int len = temp.size();    rep(i,1,len-1)&#123;        int cross = temp[i]^temp[i-1],dot = temp[i]*temp[i-1];        if(cross == 0 &amp;&amp; dot &gt;= 0)cnt[cnt.size()-1] += 1;   //å…±ç·šæ•¸é‡+=1        else &#123;pp.push_back(temp[i]);cnt.push_back(1);&#125;      //éå…±ç·šè¨­å®šæ•¸é‡ç‚º1    &#125;    len = pp.size();            //è€ƒæ…®æ©«è·¨ä¸€å‘¨çš„æƒ…æ³    rep(i,0,len-1)&#123;             //é›™æŒ‡é‡i,p1å¯èƒ½æœƒè¶…éä¸€åœˆ        pp.push_back(pp[i]);    //å°‡é»å†ç¹ä¸€åœˆ        cnt.push_back(cnt[i]);    &#125;    int ans = 0,p1 = 0;    rep(i, 0, len-1)&#123;        while(p1 &lt; i+len &amp;&amp; (pp[i]^pp[p1]) &gt;= 0 &amp;&amp; (pp[i]*pp[p1]) &gt; 0)p1 += 1;        //å¤¾éŠ³è§’çš„æƒ…æ³è¦p1+=1        if((pp[i]^pp[p1]) &gt; 0 &amp;&amp; (pp[i]*pp[p1]) == 0)ans += cnt[i]*cnt[p1];        //æ­£å‘çš„ç›´è§’ä¸‰è§’å½¢ï¼Œè‹¥å…±ç·šå‰‡å…©è€…æ•¸é‡ç›¸ä¹˜    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        p.assign(n,&#123;0,0&#125;);        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;                int ans = 0;        rep(i,0,n-1)&#123;            ans += solve(p[i]);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nTIOJ 1105 H.PS3é¡Œç›®é€£çµSubmission $O(n^2)$Submission $O(n\\log n)$\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å¹³é¢ä¸ŠNå€‹é»ï¼ˆNâ‰¤3000ï¼‰ï¼Œè«‹æ±‚å‡ºæœ€é é»å°çš„ç´¢å¼•å€¼ï¼ˆå°çš„åœ¨å‰ã€å¤§çš„åœ¨å¾Œï¼‰\n\næˆ‘åšäº†ä¸€ä»½æœ€è¿‘é»å°ï¼šä¸åŒè¤‡é›œåº¦ä¹‹è§£æ±ºæ–¹å¼çš„ç­†è¨˜ï¼Œå…±æœ‰å››ç¨®æ–¹æ³•å¯ä»¥è§£æ±ºé‚£å€‹å•é¡Œï¼Œé€™ä¸€é¡Œè¦æ±‚çš„æ˜¯æœ€é é»å°ï¼Œä½œæ³•èˆ‡æœ€è¿‘é»å°å…¶å¯¦å·®è »é çš„ã€‚ç”±ä¸Šå¹¾é¡ŒçŸ¥é“å‡¸åŒ…çš„æ±‚æ³•ï¼Œå› ç‚ºå‡¸åŒ…æ˜¯å¯ä»¥åœä½æ‰€æœ‰é»çš„å¤šé‚Šå½¢ï¼Œå› æ­¤æœ€é é»å°ä¹Ÿæ‡‰è©²åœ¨å‡¸åŒ…ä¸Šï¼Œè€Œä¸”æ‰€åœ¨çš„ä½ç½®æœƒç‚ºåœ¨å‡¸åŒ…çš„å…©å´ä¸Šï¼ˆå¦‚æœä¸è½åœ¨å‡¸åŒ…ä¸Šï¼Œä¸€å®šå¯ä»¥æŠŠé»å‘å…©å´å»¶ä¼¸åˆ°å‡¸åŒ…ä¸Šï¼Œä¸”ç§»å‹•éå¾Œçš„é»å°è·é›¢ä¸€å®šæ¯”åŸå§‹çš„é»å°è·é›¢å¤§ï¼‰ã€‚\næ‰¾å®Œå‡¸åŒ…ä¹‹å¾Œï¼Œå¯ä»¥ç”¨æ—‹è½‰å¡å°ºçš„æ–¹å¼å°‹æ‰¾æœ€é é»å°ã€‚æƒ³åƒå…©æ¢å¹³è¡Œç·šä¸­é–“å¤¾è‘—å‡¸åŒ…ï¼Œé€†æ™‚é˜æ—‹è½‰ç¹è¡Œå‡¸åŒ…ä¸€åœˆï¼Œéç¨‹ä¸æ–·æ›´æ–°æœ€é é»å°çš„è·é›¢ã€‚åœ¨å¯¦ä½œä¸Šå…©æ¢å¹³è¡Œç·šå¯ä»¥è¢«æƒ³åƒæˆç”± $Pi$ æŒ‡å‘ $P{i+1}$ çš„å‘é‡ï¼Œé€éå¤–ç©ä¸‰è§’å½¢é¢ç©å…¬å¼æ±ºå®šå¡å°ºè©²å¦‚ä½•ç§»å‹•ã€‚\nAREA = |\\overrightarrow{AB}\\times \\overrightarrow{AC}|ä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œæˆ‘å€‘è¦æ‰¾ $\\overline{HM}$ ç‚ºåº•å¯ä»¥å½¢æˆçš„æœ€å¤§ä¸‰è§’å½¢é¢ç©çš„é ‚é»ï¼Œå› ç‚ºåœ¨åŒåº•çš„æƒ…æ³ä¸‹é¢ç©å°±ä»£è¡¨é»èˆ‡é‚Šçš„å‚ç›´è·é›¢ï¼Œæœ€å¤§çš„å‚ç›´è·é›¢æ„å‘³è‘—é€™æ¢åº•é‚Šå¯ä»¥å‚ç›´å»¶ä¼¸çš„æœ€é è·é›¢ã€‚å› ç‚ºå‡¸åŒ…å¿…å®šæ˜¯å‡¸å¤šé‚Šå½¢ï¼Œå› æ­¤ä¸‰è§’å½¢çš„é¢ç©æœƒå‘ˆç¾å–®å³°å‡½æ•¸ï¼Œå› æ­¤åªéœ€è¦å¾ä¸‹ä¸€å€‹ä¸‰è§’å½¢é¢ç©çš„å¤§å°ï¼Œæ±ºå®šé›™æŒ‡é‡ä¸­æ¯”è¼ƒå¿«çš„æŒ‡æ¨™çš„ç§»å‹•æƒ…æ³ã€‚\n\nå¦‚æœä»”ç´°ä¾†çœ‹ï¼Œä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œç•¶å‰è¼ƒå¿«çš„æŒ‡æ¨™æŒ‡å‘çš„ä½ç½®æ˜¯ $D$ é»ï¼Œè€ƒæ…®ä¸€æ¢èˆ‡èˆ‡ $\\overline{HM}$ å¹³è¡Œçš„ç›´ç·šï¼Œè‹¥ä¸‹ä¸€å€‹é» $J$ åœ¨å¹³è¡Œç·šæ®µçš„å¦å¤–ä¸€å´ï¼Œå‰‡å°‡æŒ‡æ¨™ç§»å¾€ $J$ é»ã€‚å¯èƒ½æœƒæœ‰ä¸€å€‹ç–‘å•ï¼Œå¦‚æœæ¯”è¼ƒä¸‹åœ–çš„ç·šæ®µé•·åº¦ï¼Œæœƒç™¼ç¾åˆ° $\\overline{DH}$ çš„é•·åº¦æ¯”ç¶“é $J$ é»çš„å…©æ¢ç·šæ®µéƒ½é‚„è¦é•·ï¼Œé‚£ç‚ºä½•é‚„è¦æ›´æ–°è‡³ $J$ é»ï¼Ÿèˆ‰é€™å€‹ä¾‹å­ä¸å¤ªå¥½ï¼Œä¸éå¯ä»¥æƒ³åƒç•¶æ—‹è½‰å¡å°ºè½‰åˆ°ä»¥ $\\overline{FH}$ ç‚ºåº•çš„æ™‚å€™ï¼Œæœƒå°‡æœ€é é»å°çš„è·é›¢æ›´æ–°æˆ $\\overline{HD}$ çš„é•·åº¦ã€‚å¦‚æœä»Šå¤© $H$ çš„å·¦å´åˆå¤šåŠ äº†ä¸€å€‹æ–°é» $P$ï¼Œå‰‡æœ€é é»å°æœƒè®Šæˆ $\\overline{PD}$ çš„è·é›¢ã€‚\nç°¡å–®ä¾†èªªï¼Œæœ€é é»å°ä¸€å®šæœƒç™¼ç”Ÿå°è§’çš„å‡¸åŒ…é»ä¸Šé¢ï¼Œå³ä½¿ç¾åœ¨ä»¥ $\\overline{HM}$ ç‚ºåº•æœ€é é»ä¸¦é $J$ è€Œæ˜¯ $D$ ï¼Œä½†åœ¨æ—‹è½‰å¡å°ºæ—‹è½‰åˆ° $\\overline{FH}$ æ™‚å°±èƒ½å°‡è·é›¢æ›´æ–°æˆ $\\overline{HD}$ çš„è·é›¢ã€‚\n\n\n            å¯¦ä½œå°ç´°ç¯€é€™ä¸€é¡Œæœ‰é»éº»ç…©ï¼Œå› ç‚ºä»–è¦è¼¸å‡ºçš„æ˜¯æœ€é é»å°çš„ç´¢å¼•å€¼ï¼Œè€Œä¸æ˜¯æœ€é é»å°ä¹‹é–“çš„è·é›¢ã€‚åœ¨å°‹æ‰¾å‡¸åŒ…çš„éç¨‹ä¸­ï¼Œæœƒå°æ‰€æœ‰é»é€²è¡Œæ’åºï¼Œå› æ­¤åŸæœ‰çš„ç´¢å¼•å€¼é †åºæœƒè¢«æ‰“äº‚ï¼Œéœ€è¦åœ¨ä¸€é–‹å§‹è¼¸å…¥çš„æ™‚å¾Œå°±å¥½å¥½ç¶­è­·æ¯ä¸€å€‹åº§æ¨™çš„ç´¢å¼•å€¼ã€‚\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y,ind;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot    int dis() &#123;return x*x + y*y;&#125;&#125;;vector&lt;pt&gt; p,hull;pt pt_ans;int n,h;bool check(pt a, pt b, pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa ^ bb) &gt;= 0;&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    int aa = abs((a - c)^(b - c));    int bb = abs((a - d)^(b - d));    return aa &lt; bb;&#125;bool cmp(pt a, pt b)&#123;    if(a == b)return a.ind &lt; b.ind;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void convex_hull()&#123;    stable_sort(all(p),cmp);    rep(i,0,n-2)if(p[i] == p[i+1])p[i+1].ind = p[i].ind;    hull.clear();    for(auto i : p)&#123;        while(hull.size() &gt; 1 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    int sz = hull.size();    h = hull.size()-1;    hull.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(hull.size() &gt; sz &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))            hull.pop_back();        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int ans = 0,d = h,sz = hull.size();    rep(i,0,sz-1)&#123;        while(check2(hull[i],hull[(i+1)%sz],hull[d],hull[(d+1)%sz]))            d = (d+1)%sz;        if(ans &lt; (hull[i]-hull[d]).dis())&#123;            ans = (hull[i]-hull[d]).dis();            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[i]-hull[d]).dis())&#123;            int a = hull[i].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;        if(ans &lt; (hull[(i+1)%sz]-hull[d]).dis())&#123;            ans = (hull[(i+1)%sz]-hull[d]).dis();            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            pt_ans = &#123;a,b&#125;;        &#125;        else if(ans == (hull[(i+1)%sz]-hull[d]).dis())&#123;            int a = hull[(i+1)%sz].ind,b = hull[d].ind;if(a &gt; b)swap(a,b);            if(pt_ans &gt; (pt)&#123;a,b&#125;)pt_ans = &#123;a,b&#125;;        &#125;    &#125;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        if(n == 0)break;        pt_ans = (pt)&#123;0,0&#125;;        p.resize(n,&#123;0,0&#125;);        rep(i,0,n-1)&#123;            cin&gt;&gt;p[i].x&gt;&gt;p[i].y;            p[i].ind = i;        &#125;        convex_hull();        solve();        cout&lt;&lt;pt_ans.x&lt;&lt;&quot; &quot;&lt;&lt;pt_ans.y&lt;&lt;endl;    &#125;&#125;/*59 11 51 29 95 1 */\nZJ b288: å¤å­£å¤§ä¸‰è§’é¡Œç›®é€£çµè§£é¡Œå ±å‘Š\n\né¡Œç›®æ•˜è¿°è«‹è¼¸å‡ºåœ¨Nå€‹äºŒç¶­å¹³é¢çš„åº§æ¨™ï¼ŒæŒ‘é¸3é¡†å‡ºä¾†æˆçµ„æˆä¸‰è§’å½¢çš„æœ€å¤§é¢ç©\n\næ¯”è¼ƒä¸€ä¸‹å…©å€‹è¤‡é›œåº¦çš„ä½œæ³•ï¼Œç¬¬ä¸€å€‹æ˜¯ä½¿ç”¨ $O(n^3)$ æšèˆ‰æ‰€æœ‰çš„é»ä¸¦è¨ˆç®—é¢ç©ï¼Œæ‰€éœ€è¦çš„æ™‚é–“æ˜¯0.4secï¼Œè€Œä¸”éœ€è¦ç‰¹åˆ¥æ³¨æ„ä¸èƒ½ä½¿ç”¨åˆ°æµ·é¾å…¬å¼è¨ˆç®—é¢ç©ï¼Œå¦å‰‡æœ‰å¾ˆå¤§çš„æ©Ÿæœƒæœƒè¶…æ™‚ã€‚\n\nä»¥ä¸‹ä½œæ³•æ˜¯å…ˆé€²è¡Œ $O(n\\log n)$ æ‰¾å°‹å‡¸åŒ…ï¼Œå› ç‚ºé¢ç©æœ€å¤§çš„ä¸‰è§’å½¢å¿…å®šä¸‰å€‹é»éƒ½åœ¨å‡¸åŒ…ä¸Šï¼Œå› æ­¤ç”¨ $n^2$ çš„æ™‚é–“é€²è¡Œæšèˆ‰ï¼Œæ—‹è½‰å¡å°ºï¼ˆé¡ä¼¼æœ€é é»å°çš„ä½œæ³•ï¼‰æ‰¾é¢ç©æœ€å¤§çš„ç¬¬ä¸‰å€‹é»ï¼Œå°±èƒ½åœ¨ç¸½æ™‚é–“è¤‡é›œåº¦ $O(n^2)$ å®Œæˆï¼ï¼ˆæœƒå†æ›´å°‘ï¼Œå› ç‚ºåªè¦æšèˆ‰å‡¸åŒ…ä¸Šçš„é»ï¼‰\n\nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    ld x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(abs(x-b.x)&lt;=eps &amp;&amp; abs(y-b.y)&lt;=eps)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    ld operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    ld operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;vector&lt;pt&gt; p,hull;int n,t,h;ld ans;bool check(pt a,pt b,pt o)&#123;    int cross = (a - o)^(b - o);    return cross &gt;= 0;                              //é€™è£¡å¾ˆé—œéµï¼Œåˆ¥åƒWA&#125;bool check2(pt a,pt b,pt c,pt d)&#123;    ld aa = (a - c)^(b - c);    ld bb = (a - d)^(b - d);    return aa &lt; bb;&#125;ld area(pt a,pt b)&#123;    return abs(a^b)/2;&#125;void convex_hull()&#123;    hull.clear();    sort(p.begin(),p.end(),cmp);       //é¦–å…ˆå°xé€²è¡Œæ’åº    for(auto i : p)&#123;                   //ä¾åºèµ°è¨ªï¼Œå¦‚æœé‡åˆ°å¤–ç©&lt;0å‰‡ä¸åœ¨å‡¸åŒ…ä¸Š        while(hull.size()&gt;=2 &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);             //åœ¨å‡¸åŒ…hullçš„æ¯ä¸€é»éƒ½ç¬¦åˆå¤–ç©å°æ–¼0    &#125;    int down_hull = hull.size();    h = down_hull-1;    hull.pop_back();                   //xæœ€å¤§çš„é»æœƒåœ¨å‡¸åŒ…ä¸Šï¼Œä¸ç”¨åšå…©æ¬¡å…ˆpopä¸€æ¬¡    reverse(p.begin(),p.end());        //å°‡æ‰€æœ‰é»é€†åºä¹‹å¾Œåšä¸€æ¬¡ä¸Šé¢çš„å‡¸åŒ…    for(auto i: p)&#123;        while(hull.size() &gt; down_hull &amp;&amp; check(i,hull[hull.size()-1],hull[hull.size()-2]))&#123;            hull.pop_back();        &#125;        hull.push_back(i);    &#125;    hull.pop_back();&#125;void solve()&#123;    int d,sz = hull.size();    rep(i,0,sz-1)&#123;        rep(j,i+1,sz-1)&#123;            d = (j+1)%sz;            while(check2(hull[i],hull[(j)%sz],hull[d],hull[(d+1)%sz]))                d = (d+1)%sz;            ans = max(ans,area((hull[d]-hull[i]),(hull[d]-hull[j])));        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.assign(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    convex_hull();    ans = 0;    solve();    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nTIOJ 1500 Clean up on aisle 3é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°å¹³é¢ä¸Šnå€‹é»æ‰¾æœ€è¿‘é»å°çš„è·é›¢\n\næœ€è¿‘é»å°çœŸçš„æœ‰è¶…å¤šç¨®ä½œæ³•çš„ï¼Œæšèˆ‰ã€æƒæç·šã€åˆ†æ²»ã€éš¨æ©Ÿéƒ½å¯ä»¥åšï¼é€™é‚Šæœ‰ä¸€ç¯‡ç­†è¨˜æ¯”è¼ƒå„ç¨®æ™‚é–“è¤‡é›œåº¦çš„æœ€è¿‘é»å°ä½œæ³•ï¼Œé€™é‚Šä¸å¤šåšè´…è¿°ï¼\nä»¥ä¸‹ç¨‹å¼ç¢¼æ˜¯æƒæç·šæ¼”ç®—æ³•ï¼Œæœ€å·®æƒ…æ³ä¸‹çš„æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(n^2)$ï¼Œå› ç‚ºéœ€è¦æ’åºï¼Œæ‰€ä»¥ä¸‹é™ç‚º $\\Omega(n\\log n)$ï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p,p+n);        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                if(p[j].x &gt; p[i].x + d)break;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\nTIOJ 1280 é ˜åœŸ (Territory)é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ä¸€å€‹åœ‹å®¶æœ‰ n å€‹å®‰å…¨å“¨ï¼Œæ¯ä¸€å€‹éƒ½æœ‰åº§æ¨™ $(x,y)$ ï¼Œä»£è¡¨åœ¨åº§æ¨™è»¸ä¸Šçš„ä½ç½®ã€‚è¼¸å‡ºè©²åœ‹å®‰å…¨å“¨æ‰€èƒ½åœå‡ºçš„æœ€å¤§é ˜åœŸã€‚\n\nnå€‹é»æ‰€èƒ½åœæˆçš„æœ€å¤§é¢ç©ï¼Œå…¶å¯¦ç­‰åƒ¹æ–¼å‡¸åŒ…çš„é¢ç©ã€‚èˆ‡å‰å¹¾é¡Œçš„æœ€å°å‡¸å¤šé‚Šå½¢æ˜¯ä¸€æ¨¡ä¸€æ¨£çš„é¡Œç›®ï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)&#123;        area += (hull[i]^hull[i+1]);    &#125;    cout&lt;&lt;((area%2)?(area/2)+1:(area/2))&lt;&lt;endl;&#125;\nZJ a871: Museum Areaé¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°nå€‹é»åœæˆçš„å¤šé‚Šå½¢ï¼Œæ±‚é¢ç©\n\næ°´é¡Œï¼Œç›´æ¥å¥—è¡Œåˆ—å¼å…¬å¼å³å¯ç®—å‡ºç­”æ¡ˆï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pdd pair&lt;double,double&gt;#define int long long#define ld long double#define N 15#define x first#define y secondusing namespace std;int n;pdd p[N];ld check(pdd a, pdd b)&#123;    return a.x*b.y - a.y*b.x;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        p[n] = p[0];        ld area = 0.0;        rep(i,0,n-1)area += check(p[i],p[i+1]);        ld ans = (ld)area/2;        if(ans&lt;0)ans = -ans;        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nTIOJ 1678 å‰ªå¤šé‚Šå½¢ï¼ˆmoldingï¼‰é¡Œç›®é€£çµTIOJTIOJ Submissioné¡Œç›®é€£çµZJ\n\né¡Œç›®æ•˜è¿°é–“å–®ä¾†èªªæ˜¯æ±‚å‡ºå¤šé‚Šå½¢é¢ç©ä»¥åŠå‡¸åŒ…é¢ç©çš„å·®ï¼Œè©³ç´°å¯ä»¥é»ä¸Šé¢é¡Œç›®é€£çµã€‚\n\né¡Œç›®èªªå¤šé‚Šå½¢éœ€è¦æ‰å‰ªä¸‹çš„é¢ç©ï¼Œæˆ‘å€‘å°±ç®—å‡¸åŒ…é¢ç©ä»¥åŠå¤šé‚Šå½¢é¢ç©ï¼Œå…©è€…çš„å·®å»é™¤ä¸Šé¡Œç›®çµ¦çš„è‰²å¡Šé¢ç©å³æ˜¯ç­”æ¡ˆï¼\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;struct pt&#123;    int x,y;    bool operator &lt; (pt b)&#123;        if(x == b.x)return y &lt; b.y;        return x &lt; b.x;    &#125;    bool operator &gt; (pt b)&#123;        if(x == b.x)return y &gt; b.y;        return x &gt; b.x;    &#125;    bool operator == (pt b)&#123;        if(x-b.x == 0 &amp;&amp; y-b.y == 0)return true;        return false;    &#125;    pt operator+(pt b) &#123;return &#123;x + b.x, y + b.y&#125;;&#125; //å‘é‡ç›¸åŠ     pt operator-(pt b) &#123;return &#123;x - b.x, y - b.y&#125;;&#125; //å‘é‡ç›¸æ¸›    int operator^(pt b) &#123;return x * b.y - y * b.x;&#125; //å‘é‡å¤–ç©cross    int operator*(pt b) &#123;return x * b.x + y * b.y;&#125; //å‘é‡å…§ç©dot&#125;;vector&lt;pt&gt; p,temp,pp;vector&lt;int&gt;  cnt;int n,a,ans = 0;bool cmp(pt a, pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;bool check(pt a,pt b,pt o)&#123;    pt aa = a - o;    pt bb = b - o;    return (aa^bb) &gt;= 0;&#125;vector&lt;pt&gt; solve()&#123;    sort(all(p),cmp);    vector&lt;pt&gt; h;    for(pt i : p)&#123;        while(h.size()&gt;=2 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    int sz = h.size();    h.pop_back();    reverse(all(p));    for(auto i : p)&#123;        while(h.size()&gt;sz &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))            h.pop_back();        h.push_back(i);    &#125;    return h;&#125;int Polygon()&#123;    vector&lt;pt&gt; temp(p);    temp.push_back(temp[0]);    int area = 0;    rep(i,0,n-1)area += (temp[i]^temp[i+1]);    return abs(area);&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;a;    p.resize(n,&#123;0,0&#125;);    rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;    ld small = (ld)Polygon()/2;    vector&lt;pt&gt; hull = solve();    int area = 0,sz = hull.size();    rep(i,0,sz-2)area += (hull[i]^hull[i+1]);    ld big = (ld)area/2;    int ans = ceil((big-small)/a);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nZJ d269: 11579 - Triangle Troubleé¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°æœ‰ä¸€å€‹ä¸‰è§’å½¢å·¥å» æœ‰ä¸€å€‹å¾ˆå¤§çš„å•é¡Œã€‚çµ¦ä½ ä¸€äº›é‚Šçš„é‚Šé•·ï¼Œæƒ³è¾¦æ³•æ‰¾å‡ºç”¨é€™äº›é‚Šé•·åœå‡ºæœ€å¤§çš„ä¸‰è§’å½¢ã€‚\n\næ ¹æ“šæµ·é¾å…¬å¼ï¼Œä¸‰è§’å½¢é¢ç©ï¼š\n\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)}å¯ä»¥åˆ©ç”¨è²ªå©ªæ³•ï¼Œå°‡æ‰€æœ‰é‚Šé•·ç”±å¤§åˆ°å°é€²è¡Œæ’åºï¼Œæ¯ä¸€æ¬¡æ‹¿æœ€å¤§çš„ä¸‰å€‹é‚Šé•·é€²è¡Œæšèˆ‰ï¼Œå³å¯ç®—å‡ºæœ€å¤§çš„ä¸‰è§’å½¢é¢ç©ã€‚ä¸é›£ç†è§£ï¼Œç•¶æ›ä¸Šä¸€å€‹æ¯”è¼ƒå¤§çš„é‚Šï¼Œç®—å‡ºä¾†çš„sä¹Ÿæœƒæ¯”è¼ƒå¤§ï¼Œè·Ÿé‚Šç›¸æ¸›çš„å€¼ä¹Ÿæœƒæ¯”è¼ƒå¤§ï¼Œç¸½é¢ç©è‡ªç„¶è¼ƒå¤§ï¼ˆå¥½å•¦ï¼Œé€™æ˜¯éå¸¸ä¸åš´è¬¹çš„è­‰æ˜XDï¼‰\nåœ¨æƒ³é¡Œéç¨‹ä¸­ï¼Œæˆ‘æœ‰æ€è€ƒåˆ°ï¼Œå¦‚æœå‘¨é•·ä¸€æ¨£çš„æƒ…æ³ä¸‹ï¼Œåˆ°åº•ä½•ç¨®é¢ç©çš„ä¸‰è§’å½¢é¢ç©æœƒæ¯”è¼ƒå¤§ï¼Ÿç­”æ¡ˆæ˜¯æ­£ä¸‰è§’å½¢ï¼\n\n            ä¸‰è§’å½¢å‘¨é•·å›ºå®šä¸‹é¢ç©çš„æ¯”è¼ƒæ ¹æ“šæµ·é¾å…¬å¼ï¼šs = \\frac{1}{2}(a+b+c)æƒ³è¦æ¯”è¼ƒåœ¨å‘¨é•·å›ºå®šä¸‹ä¸‰è§’å½¢çš„é¢ç©ï¼Œå¯ä»¥ç”¨ç®—å¹¾ä¸ç­‰å¼æ¯”è¼ƒï¼Œå› ç‚º $s$ æ˜¯å®šå€¼ï¼Œæ‰€ä»¥å¯ä»¥åˆ—å‡ºä»¥ä¸‹å¼å­ï¼š\\frac{(s-a)+(s-b)+(s-c)}{3} â‰¥ \\sqrt[3]{(s-a)(s-b)(s-c)}ç­‰å¥½æˆç«‹æ™‚ï¼Œ$a=b=c$ã€‚å› ç‚º$s = \\frac{a+b+c}{2}$ï¼Œå› æ­¤ï¼š(\\frac{a}{2})^2 â‰¥ (s-a)(s-b)(s-c)å¾—åˆ°æµ·é¾å…¬å¼\\triangle ABC = \\sqrt{s\\cdot(s-a)\\cdot(s-b)\\cdot(s-c)} â‰¤ \\sqrt{\\frac{3a}{2}\\cdot\\frac{a^3}{8}}=\\frac{\\sqrt{3}}{4}a^2\n          \nä»¥ä¸‹æ˜¯ä½¿ç”¨è²ªå©ªæ³•çš„AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define ll long long#define ld double#define N 100001#define all(x) x.begin(),x.end()#define eps 1e-9#define x first#define y secondusing namespace std;int t,n;vector&lt;ld&gt; p;ld area(ld a ,ld b, ld c)&#123;    if(a &gt; b + c)return -1;    ld p = (a+b+c)/2;    return p*(p-a)*(p-b)*(p-c);&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        p.assign(n,0);        rep(i,0,n-1)cin&gt;&gt;p[i];        sort(all(p),greater&lt;&gt;());        ld ans = 0;        rep(i,0,n-3)            ans = max(ans,area(p[i],p[i+1],p[i+2]));        cout&lt;&lt;fixed&lt;&lt;setprecision(2);        cout&lt;&lt;sqrt(ans)&lt;&lt;endl;    &#125;&#125;\nå¿ƒå¾—è¨ˆç®—å¹¾ä½•ï¼Œé¡§åæ€ç¾©å°±æ˜¯åœ¨é›»è…¦å®Œæˆå¹¾ä½•çš„é‹ç®—ï¼Œè¦æ€éº¼æŠŠå¹³é¢çš„æ±è¥¿è½‰åŒ–æˆé›»è…¦çœ‹å¾—æ‡‚çš„æ±è¥¿å°±æ˜¯è¨ˆç®—å¹¾ä½•åœ¨åšçš„äº‹æƒ…ã€‚å¸¸å¸¸æˆ‘å€‘è¦ºå¾—å¾ˆå®¹æ˜“åˆ¤æ–·çš„äº‹æƒ…ï¼Œä¾‹å¦‚åˆ¤æ–·ç·šæ®µæ˜¯å¦ç›¸äº¤ï¼Œæˆ‘å€‘å¯ä»¥åˆ©ç”¨è‚‰çœ¼ç›´è¼•æ˜“åˆ¤æ–·å‡ºä¾†ï¼Œå› ç‚ºæˆ‘å€‘æœ‰å¼·å¤§çš„ç©ºé–“æ„Ÿå¹«åŠ©æˆ‘å€‘é€²è¡Œåˆ¤æ–·ï¼Œä½†æ›ä½œæ˜¯é›»è…¦å°±å¿…é ˆç”¨ä¸€äº›æ•¸å­¸çš„æŠ€å·§ï¼Œå°æ–¼ä¸åŒçš„æƒ…æ³åšå„è‡ªçš„åˆ¤æ–·ï¼Œæ‰èƒ½è®“é›»è…¦æ­£ç¢ºå›ç­”å…©æ¢ç·šæ®µçš„ç›¸äº¤æƒ…å½¢ã€‚\né™¤æ­¤ä¹‹å¤–ï¼Œåœ¨å¯«é¡Œéç¨‹ä¸­ï¼Œä½¿ç”¨åˆ°ggbé€²è¡Œè¼”åŠ©ï¼Œè®“æˆ‘å¯ä»¥å°ç¨‹å¼çš„åŸ·è¡Œéç¨‹æœ‰æ›´æ˜¯è¦ºåŒ–çš„æ¦‚å¿µï¼Œä¹Ÿå¹«åŠ©æˆ‘åœ¨è§£é¡Œæ™‚èƒ½æ›´ç†è§£è§£é¡Œçš„ç­–ç•¥ï¼ä¸Šé¢ä¸€é¡Œä¸‰è§’å½¢å€‹æ•¸çš„åˆ¤æ–·ï¼Œå°±ä½¿ç”¨äº†ggbåˆ¤å®šå°‡é»æ¬ç§»çš„æ‰€æœ‰æƒ…æ³ã€‚åˆ©ç”¨å®ƒæˆ‘æŠ“åˆ°äº†ç•¶é»çš„yåº§æ¨™ç‚ºé›¶æ™‚ä¸¦æ²’é€²è¡Œå¥½ç‰¹æ®Šæƒ…æ³çš„åˆ¤æ–·ï¼Œé€™ä¹Ÿæ˜¯ä¸€å€‹è¦–è¦ºåŒ–ä¹‹å¾Œçš„å¥½è™•ï¼\næœ‰ä¸€é¡Œæ²’æœ‰åšçš„æ˜¯æ¨¡æ“¬é€€ç«çš„é¡Œç›®å¯¦ä½œï¼Œè¦æ±‚åœ“èˆ‡ä¸‰è§’å½¢çš„äº¤é›†é¢ç©ï¼Œæ„Ÿè¦ºè¶…ç´šè¤‡é›œï¼Œä»¥å¾Œæœ‰æ™‚é–“ä¾†æ…¢æ…¢å¯¦ä½œï¼\n","categories":["C++é€²éšä¸»é¡Œ","è¨ˆç®—å¹¾ä½•"],"tags":["è¨ˆç®—å¹¾ä½•","æš‘æœŸç­†è¨˜"]},{"title":"[é¡Œè§£]Leetcode 892 Surface Area of 3D Shapes","url":"/geo3-11/","content":"892 Surface Area of 3D Shapes\né¡Œç›®é€£çµ\nclass Solution &#123;public:    int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans = 0,n = grid.size();        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans += 4 * grid[i][j] + 2;                if(i &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i+1][j])*2;                &#125;                if(j &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i][j+1])*2;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 939 Minimum Area Rectangle","url":"/geo3-12/","content":"939 Minimum Area Rectangle\né¡Œç›®é€£çµ\nclass Solution &#123;public:    int minAreaRect(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        vector&lt;vector&lt;int&gt;&gt;p = points;        int n = points.size();        set&lt;pair&lt;int,int&gt;&gt;s;        for(int i=0;i&lt;n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        int ans = INT_MAX;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(s.find(&#123;p[i][0],p[j][1]&#125;)!=s.end()                    &amp;&amp; s.find(&#123;p[j][0],p[i][1]&#125;)!=s.end())&#123;                    if(p[i][0] == p[j][0] || p[i][1] == p[j][1])continue;                    ans = min(ans,abs(p[i][0]-p[j][0])*abs(p[i][1]-p[j][1]));                &#125;            &#125;        &#125;        if(ans == INT_MAX)return 0;        else return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 963 Minimum Area Rectangle II","url":"/geo3-13/","content":"963 Minimum Area Rectangle II\né¡Œç›®é€£çµ\nclass Solution &#123;public:    double minAreaFreeRect(vector&lt;vector&lt;int&gt;&gt;&amp; p)&#123;        set&lt;pair&lt;int,int&gt;&gt; s;        int n = p.size();        for(int i = 0;i &lt; n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        double ans = 1e9;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                int x1 = p[j][0] - p[i][0];                int y1 = p[j][1] - p[i][1];                for(int k = j+1;k &lt; n;k++)&#123;                    int x2 = p[k][0] - p[i][0];                    int y2 = p[k][1] - p[i][1];                    if(x1 * x2 + y1 * y2 != 0)continue;                    int nx = p[k][0] + x1,ny = p[k][1] + y1;                    if(s.find(&#123;nx,ny&#125;) != s.end())&#123;                        ans = min(ans,sqrt(x1*x1+y1*y1) * sqrt(x2*x2+y2*y2));                    &#125;                &#125;            &#125;        &#125;        if(ans == 1e9)return 0;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 973 K Closest Points to Origin","url":"/geo3-14/","content":"973 K Closest Points to Origin\né¡Œç›®é€£çµ\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123;        int n = points.size();        multimap&lt;int,int&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            int x = points[i][0];            int y = points[i][1];            mp.insert(&#123;x * x + y * y,i&#125;);        &#125;        auto it = mp.begin();        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;k;i++)&#123;            int id = it-&gt;second;            ans.push_back(points[id]);            it++;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1030 Matrix Cells in Distance Order","url":"/geo3-15/","content":"1030 Matrix Cells in Distance Order\né¡Œç›®é€£çµ\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) &#123;        int n = rows,m = cols;        multimap&lt;int,pair&lt;int,int&gt;&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; m;j++)&#123;                int dis = abs(i - rCenter) + abs(j - cCenter);                mp.insert(&#123;dis,&#123;i,j&#125;&#125;);            &#125;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n*m);        for(int i=0;i&lt;n*m;i++)ans[i].resize(2,0);        int id = 0;        for(auto it : mp)&#123;            ans[id][0] = (it.second.first);            ans[id][1] = (it.second.second);            id++;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1037 Valid Boomerang","url":"/geo3-16/","content":"1037 Valid Boomerang\né¡Œç›®é€£çµ\nclass Solution &#123;public:    bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int x1 = points[1][0]-points[0][0],y1 = points[1][1]-points[0][1];        int x2 = points[2][0]-points[1][0],y2 = points[2][1]-points[1][1];        int cross = x1 * y2 - x2 * y1;        if(cross == 0)return false;        return true;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1266 Minimum Time Visiting All Points","url":"/geo3-18/","content":"1266 Minimum Time Visiting All Points\né¡Œç›®é€£çµ\nclass Solution &#123;public:    int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        vector&lt;vector&lt;int&gt;&gt; p = points;        for(int i = 0;i &lt; n-1;i++)&#123;            ans += max(abs(p[i+1][0] - p[i][0]),abs(p[i+1][1] - p[i][1]));        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1401 Circle and Rectangle Overlapping","url":"/geo3-19/","content":"1401 Circle and Rectangle Overlapping\né¡Œç›®é€£çµ\nclass Solution &#123;public:    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) &#123;        int x = clamp(x_center,x1,x2) - x_center;        int y = clamp(y_center,y1,y2) - y_center;        return x*x + y*y &lt;= radius * radius;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1232 Check If It Is a Straight Line","url":"/geo3-17/","content":"1232 Check If It Is a Straight Line\né¡Œç›®é€£çµ\nclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        vector&lt;vector&lt;int&gt;&gt; p = coordinates;        int n = p.size();        for(int i = 0;i &lt; n-2;i++)&#123;            int x1 = p[i+1][0] - p[i][0],y1 = p[i+1][1] - p[i][1];            int x2 = p[i+2][0] - p[i+1][0],y2 = p[i+2][1] - p[i+1][1];            if(x1 * y2 != x2 * y1)return false;        &#125;        return true;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1453 Maximum Number of Darts Inside of a Circular Dartboard","url":"/geo3-20/","content":"1453 Maximum Number of Darts Inside of a Circular Dartboard\né¡Œç›®é€£çµ\n#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y second#define exp 1e-6class Solution &#123;public:        double dis(pdd a,pdd b)&#123;        ld x = a.x - b.x,y = a.y - b.y;        return sqrt(x * x + y * y);    &#125;        pair&lt;pdd,pdd&gt; get_center(pdd a,pdd b,ld R)&#123;        pdd mid = &#123;(a.x + b.x) / 2,(a.y + b.y) / 2&#125;;        ld theta = atan2(a.y - b.y, b.x - a.x);        ld tmp = dis(a,b) / 2, d = sqrt(R * R - tmp * tmp);                pair&lt;pdd,pdd&gt; ans;        ans.x = &#123;mid.x - d * sin(theta),mid.y - d * cos(theta)&#125;;        ans.y = &#123;mid.x + d * sin(theta),mid.y + d * cos(theta)&#125;;        return ans;    &#125;        int numPoints(vector&lt;vector&lt;int&gt;&gt;&amp; point, int R) &#123;        int n = point.size(),ans = 1;        pdd p[n];for(int i=0;i&lt;n;i++)&#123;p[i] = &#123;point[i][0],point[i][1]&#125;;&#125;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(dis(p[i],p[j]) - 2.0 * R &gt;= exp)continue;                pair&lt;pdd,pdd&gt; cur = get_center(p[i],p[j],R);                int cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.x) - R&lt;= exp)cnt ++;                ans = max(ans, cnt);cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.y) - R &lt;= exp)cnt ++;                ans = max(ans, cnt);            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1610 Maximum Number of Visible Points","url":"/geo3-22/","content":"1610 Maximum Number of Visible Points\né¡Œç›®é€£çµ\n#define ld long doubleconst int N = 1e5+5;class Solution &#123;public:    int visiblePoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int angle, vector&lt;int&gt;&amp; loc) &#123;        vector&lt;ld&gt; ang;        int overlap = 0,n = points.size(),ans = 0;        for(auto p : points)&#123;            if(p[0] == loc[0] &amp;&amp; p[1] == loc[1])overlap++;            else ang.push_back(atan2l(p[1]-loc[1],p[0]-loc[0]) * 180 / (ld)M_PI);        &#125;        int sz = ang.size();        for(int i = 0;i &lt; sz;i++)ang.push_back(ang[i] + 360);        sort(ang.begin(),ang.end());        sz = ang.size();        for(int i = 0,it2 = 0;i &lt; sz;i++)&#123;            while(it2 &lt; sz &amp;&amp; ang[it2] - ang[i] &lt;= angle)it2++;            ans = max(ans,it2 - i);        &#125;        return ans + overlap;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1515 Best Position for a Service Centre","url":"/geo3-21/","content":"1515 Best Position for a Service Centre\né¡Œç›®é€£çµ\né€™ä¸€é¡Œæ˜¯æ¨¡æ“¬é€€ç«ï¼Œéå¸¸é…·ï¼Œä¹‹å‰æ²’æœ‰å¯«éçš„æ±è¥¿ã€‚\n#define eps 1e-6#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 100;        ld dx[4] = &#123;1.0,0.0,-1.0,0.0&#125;,dy[4] = &#123;0.0,1.0,0.0,-1.0&#125;;        bool flag = 0;        while(test_size &gt; eps)&#123;            flag = 0;            for(int i = 0;i &lt; 4;i++)&#123;                pdd newp = cur;                newp.x += dx[i] * test_size;                newp.y += dy[i] * test_size;                ld new_dis = dis_all(newp);                if(new_dis &lt; mid_dis)&#123;                    mid_dis = new_dis;                    cur = newp;                    flag = 1;                    break;                &#125;            &#125;            if(flag == 0)test_size /= 2.0;        &#125;        return mid_dis;    &#125;&#125;;\næ›å¦å¤–ä¸€ç¨®è¿­ä»£æ–¹å¼\n#define eps 1e-8#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        srand(time(NULL));        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 150.0;        while(test_size &gt; eps)&#123;            pdd newp = cur;            int temp = rand();            newp.x += cos(temp) * test_size;            newp.y += sin(temp) * test_size;            ld new_dis = dis_all(newp);            if(new_dis &lt; mid_dis)&#123;                mid_dis = new_dis;                cur = newp;            &#125;            else test_size *= 0.99;        &#125;        return mid_dis;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 2101 Detonate the Maximum Bombs","url":"/geo3-24/","content":"2101. Detonate the Maximum Bombs\né¡Œç›®é€£çµ\næŠŠåœ–å½¢è€ƒæ…®æˆä¸€å¼µåœ–ï¼Œç¬¦åˆæ¢ä»¶çš„å°±å¢åŠ ä¸€æ¢æœ‰å‘é‚Šï¼Œæ¥è‘—å°æ¯ä¸€å€‹é»åšä¸€æ¬¡DFSå³å¯ã€‚æ™‚é–“ $O(n^2)$ã€‚\n#define pii pair&lt;int,int&gt;#define ld long doubleclass Solution &#123;public:        vector&lt;int&gt; E[105];    ld dis(pii a,pii b)&#123;        int x = a.first - b.first,y = a.second - b.second;        return sqrt((long long)x * x + (long long)y * y);    &#125;    int sum = 1;    bool vis[105];    void dfs(int now)&#123;        vis[now] = 1;        for(auto i : E[now])&#123;            if(vis[i])continue;            sum++;vis[i] = 1;            dfs(i);        &#125;    &#125;        int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bomb) &#123;        int n = bomb.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                pii a = &#123;bomb[i][0],bomb[i][1]&#125;,b = &#123;bomb[j][0],bomb[j][1]&#125;;                int r1 = bomb[i][2],r2 = bomb[j][2];                ld d = dis(a,b);                if(r1 &gt;= d)E[i].push_back(j);                if(r2 &gt;= d)E[j].push_back(i);            &#125;        &#125;        for(int i = 0;i &lt; n;i++)&#123;            fill(vis,vis+105,0);            sum = 1;            dfs(i);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 335 Self Crossing","url":"/geo3-3/","content":"335 Self Crossing\né¡Œç›®é€£çµ\nclass Solution &#123;public:    bool isSelfCrossing(vector&lt;int&gt;&amp; d) &#123;        int n = d.size();        if(n &lt;= 3)return false;        for(int i = 3;i &lt; n;i++)&#123;            //ç¬¬å››æ¢ã€ç¬¬äº”æ¢ã€ç¬¬å…­æ¢äº¤ç¬¬ä¸€æ¢            if(d[i] &gt;= d[i-2] &amp;&amp; d[i-1] &lt;= d[i-3])return true;            if(i &gt;= 4 &amp;&amp; d[i-1] == d[i-3] &amp;&amp; d[i] + d[i-4] &gt;= d[i-2])return true;            if(i &gt;= 5 &amp;&amp; d[i-2] &gt;= d[i-4] &amp;&amp; d[i] &gt;= d[i-2] - d[i-4]              &amp;&amp; d[i-1] &gt;= d[i-3]-d[i-5] &amp;&amp; d[i-1] &lt;= d[i-3])return true;                    &#125;        return false;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 587 Erect the Fence","url":"/geo3-4/","content":"587 Erect the Fence\né¡Œç›®é€£çµ\n#define pii pair&lt;int,int&gt;#define ff first#define ss secondclass Solution &#123;public:        bool check(pii a,pii b,pii o)&#123;        pii aa = &#123;a.ff - o.ff,a.ss - o.ss&#125;;        pii bb = &#123;b.ff - o.ff,b.ss - o.ss&#125;;        int cross = aa.ff * bb.ss - aa.ss * bb.ff;        return cross &gt; 0;    &#125;        vector&lt;vector&lt;int&gt;&gt; outerTrees(vector&lt;vector&lt;int&gt;&gt;&amp; point) &#123;        vector&lt;pii&gt; h;        int n = point.size();        vector&lt;pii&gt; p(n);        for(int i = 0;i &lt; n;i++)p[i] = &#123;point[i][0],point[i][1]&#125;;        sort(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; 1 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        int down = h.size();        h.pop_back();        reverse(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; down &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        set&lt;pii&gt; s;for(auto i : h)s.insert(i);        n = s.size();        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n);        for(int i=0;i&lt;n;i++)ans[i].resize(2);        int id = 0;        for(auto i : s)&#123;ans[id][0] = i.ff;ans[id][1] = i.ss;id++;&#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 223 Rectangle Area","url":"/geo3-2/","content":"223 Rectangle Area\né¡Œç›®é€£çµ\nclass Solution &#123;public:    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) &#123;        int x = max(min(ax2,bx2) - max(ax1,bx1),0);        int y = max(min(ay2,by2) - max(ay1,by1),0);        int ans = (ax2 - ax1)*(ay2 - ay1)+(bx2 - bx1)*(by2 - by1)-x * y;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 1828 Queries on Number of Points Inside a Circle","url":"/geo3-23/","content":"1828 Queries on Number of Points Inside a Circle\né¡Œç›®é€£çµ\nclass Solution &#123;public:    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        int n = queries.size(),m = points.size();        vector&lt;int&gt; ans;ans.resize(n);        for(int i = 0;i &lt; n;i++)&#123;            int rx = queries[i][0],ry = queries[i][1],sum = 0;            for(int j = 0;j &lt; m;j++)&#123;                int x = points[j][0] - rx,y = points[j][1] - ry;                if(x * x + y * y &lt;= queries[i][2] * queries[i][2])sum++;            &#125;            ans[i] = sum;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 593 Valid Square","url":"/geo3-5/","content":"593 Valid Square\né¡Œç›®é€£çµ\nclass Solution &#123;public:        int dis(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2)&#123;        int x = p1[0] - p2[0],y = p1[1] - p2[1];        return x * x + y * y;    &#125;        bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) &#123;        map&lt;int,int&gt;mp;     //é•·åº¦ã€å€‹æ•¸        mp[dis(p1,p2)]++;        mp[dis(p1,p3)]++;        mp[dis(p1,p4)]++;        mp[dis(p2,p3)]++;        mp[dis(p2,p4)]++;        mp[dis(p3,p4)]++;        return mp.size() == 2 &amp;&amp; mp.begin()-&gt;second == 4;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 858 Mirror Reflection","url":"/geo3-8/","content":"858 Mirror Reflection\né¡Œç›®é€£çµ\nclass Solution &#123;public:    int gcd(int a,int b)&#123;        if(a == 0)return b;        return gcd(b % a,a);    &#125;        int mirrorReflection(int p, int q) &#123;        int len = p * q / gcd(q,p);        int a = (len / p) % 2,b = (len / q) % 2;        if(a == 0 &amp;&amp; b == 1)return 0;        else if(a == 1 &amp;&amp; b == 1)return 1;        else return 2;            &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 812\tLargest Triangle Area","url":"/geo3-6/","content":"812 Largest Triangle Area\né¡Œç›®é€£çµ\nclass Solution &#123;public:        int cross(int x1,int y1,int x2,int y2)&#123;        return x1 * y2 - x2 * y1;    &#125;        double area(int a,int b,int c,int d,int e,int f)&#123;        double sum = 0;        sum += cross(a,b,c,d);        sum += cross(c,d,e,f);        sum += cross(e,f,a,b);        return abs(sum / 2.0);    &#125;        double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size();        double ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i + 1;j &lt; n;j++)&#123;                for(int p = j + 1;p &lt; n;p++)&#123;                    ans = max(ans,area(points[i][0],points[i][1]                                      ,points[j][0],points[j][1]                                      ,points[p][0],points[p][1]));                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 836 Rectangle Overlap","url":"/geo3-7/","content":"836 Rectangle Overlap\né¡Œç›®é€£çµ\nclass Solution &#123;public:    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123;        //æœ€å°çš„å³ç«¯é» - æœ€å¤§çš„å·¦ç«¯é»        int x = min(rec1[2],rec2[2]) - max(rec1[0],rec2[0]);        //æœ€å°çš„ä¸Šç«¯é» - æœ€å¤§çš„ä¸‹ç«¯é»        int y = min(rec1[3],rec2[3]) - max(rec1[1],rec2[1]);        return x &gt; 0 &amp;&amp; y &gt; 0;    &#125;&#125;;\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"[é¡Œè§£]Leetcode 478 Generate Random Point in a Circle","url":"/geo3-9/","content":"478 Generate Random Point in a Circle\né¡Œç›®é€£çµ\nç›´æ¥RandomåŠå¾‘æœƒå‡ºäº‹ï¼ˆå¯èƒ½ä¸å¤ äº‚ï¼Œæˆ–æ˜¯åŠå¾‘å¤ªå°ï¼‰ï¼Œå¦‚æœrandomé¢ç©ä¹‹å¾Œç®—åŠå¾‘æ‰OKã€‚\nclass Solution &#123;public:    double R,X,Y;    Solution(double radius, double x_center, double y_center) &#123;        R = radius;X = x_center;Y = y_center;        srand(time(NULL));    &#125;        vector&lt;double&gt; randPoint() &#123;        double Area = rand() * R * R * M_PI / (RAND_MAX + 1.0);        double r = sqrt(Area / M_PI);        double theta = 2.0 * M_PI * rand() / (RAND_MAX + 1.0);        vector&lt;double&gt; ans;        ans.push_back(X + r * cos(theta));        ans.push_back(Y + r * sin(theta));        return ans;    &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(radius, x_center, y_center); * vector&lt;double&gt; param_1 = obj-&gt;randPoint(); */\n","categories":["Leetcodeé¡Œè§£"],"tags":["é¡Œè§£","Leetcode"]},{"title":"Manimå­¸ç¿’ç­†è¨˜","url":"/manim/","content":"Manimå®‰è£\nManim is an animation engine for explanatory math videos.\n\nåˆ©ç”¨Manimå¯ä»¥ç”Ÿæˆè¨±å¤šæ•¸å­¸é¡çš„å‹•ç•«å½±ç‰‡ã€ä»¥åŠè£½ä½œä¸€äº›å‹•ç•«æ¨¡æ“¬ï¼\næˆ‘æ˜¯åˆ©ç”¨Macå®‰è£Manimï¼Œåªè¦æŒ‰ç…§é€™ä¸€ç¯‡çš„èªªæ˜ä¸€æ­¥æ­¥å®Œæˆå³å¯ï¼Œä¸è¦ä¸Šç¶²æ‰¾æ•™å­¸å½±ç‰‡ï¼Œå› ç‚ºå¾ˆå¤šéƒ½æ˜¯éæ™‚çš„ï¼Œåœ¨å®‰è£ä¸Šæœƒå‡ºç¾ä¸€äº›å•é¡Œã€‚\nè‡³æ–¼ä½¿ç”¨æ•™å­¸çš„éƒ¨åˆ†ï¼Œå¯ä»¥åƒè€ƒé€™ä¸€ç¯‡å®˜æ–¹ä½¿ç”¨æ‰‹å†Šã€‚Manimç¸½å…±æœ‰ä¸‰ç¨®ç‰ˆæœ¬ï¼Œå»ºè­°ä½¿ç”¨Manim Communityæ¯”è¼ƒæ–¹ä¾¿ï¼Œè³‡æºæ¯”è¼ƒå¤šï¼\n\nèªæ³•ç­†è¨˜æ¶æ§‹ç¨‹å¼ç¢¼from manim import *class Test(Scene):    def construct(self):        #ç¨‹å¼ç¢¼å€å¡Š\nçµ‚ç«¯æŒ‡ä»¤\nmp4:    manim test.py Test -pqm\ngif: manim test.py Test -pqm -i\n\nå½±ç‰‡å“è³ªè¨­å®šï¼š-pql,-pqm,-pqh\nUpdatesfrom manim import *class Test(Scene):    def construct(self):        rec = Rectangle(color = WHITE,width = 2,height = 2.5).to_edge(UL)        circ = Circle().to_edge(DOWN)        arr = always_redraw(            lambda: Line(                start = rec.get_bottom(),end = circ.get_top(),buff = 0.5            ).add_tip()        )        self.play(Create(VGroup(rec,circ,arr)))        self.wait()        self.play(rec.animate.to_edge(UR),circ.animate.scale(0.5),run_time = 3)\nValue Trackerfrom manim import *class Updaters(Scene):    def construct(self):                k = ValueTracker(0)        num = always_redraw(            lambda: DecimalNumber().set_value(k.get_value())        )        self.play(FadeIn(num))        self.play(k.animate.set_value(10),run_time = 5,rate_func = smooth)        self.wait()\nNumberPlaneæ³¨æ„ï¼šget_graph() â€”&gt; plot()è‡ªå‹•æ’ç‰ˆï¼šalt + shift + f\nfrom manim import *import mathclass Test(Scene):    def construct(self):        plane = (            NumberPlane(x_range=[-20, 20, 5], x_length=8,                        y_range=[-4, 20, 5], y_length=8)            .to_edge(DOWN)            .add_coordinates()        )        l = plane.get_axis_labels(x_label=&#x27;x&#x27;, y_label=&#x27;f(x)&#x27;)        par = plane.plot(lambda x: (0.5*x) ** 2,                         x_range=[-10, 10], color=GREEN)        func_l = MathTex(&quot;f(x) = &#123;x&#125;^2&quot;).next_to(par, RIGHT).set_color(GREEN)        area = plane.get_riemann_rectangles(            graph=par, x_range=[-5, 5], dx=1, stroke_width=0.1, stroke_color=WHITE)        self.play(DrawBorderThenFill(plane), run_time=2)        self.play(Create(VGroup(par, l, func_l)), run_time=2)        self.wait()        self.play(Create(area))        self.wait()\nValueTrackers to Graphing Scenesfrom manim import *class Test(Scene):    def construct(self):        k = ValueTracker(-4)        ax = Axes(x_range=[-4, 4, 1], y_range=[-2, 16, 2],                  x_length=5, y_length=5).to_edge(DOWN).add_coordinates()        func = ax.plot(lambda x: x ** 2, x_range=[-4, 4], color=BLUE)        slope = always_redraw(            lambda: ax.get_secant_slope_group(                graph=func, dx=0.01, x=k.get_value(), secant_line_color=GREEN, secant_line_length=5)        )        pt = always_redraw(            lambda:            Dot().move_to(ax.c2p(k.get_value(), func.underlying_function(k.get_value())))        )        self.add(ax, func, slope, pt)        self.wait()        self.play(k.animate.set_value(4), run_time=10)        self.wait()\nOpen a file1. svg file:\nfrom manim import *H = &quot;/Users/peienwu/Downloads/&quot;class Test(Scene):    def construct(self):        Icon = SVGMobject(f&quot;&#123;H&#125;//test.svg&quot;)        self.play(FadeIn(Icon))        self.wait()\n2. png file:\nfrom manim import *class Test(Scene):    def construct(self):        Icon = ImageMobject(f&quot;/Users/peienwu/Downloads/minion.jpeg&quot;)        self.play(FadeIn(Icon))        self.wait()        self.play(Icon.animate.to_edge(LEFT))\nBar chartfrom pyclbr import Functionfrom manim import *class DifferentRotations(Scene):    def construct(self):        num = [1, 2, 5, 4, 3]        ver = [&quot;v1.0&quot;, &quot;v2.0&quot;, &quot;v3.0&quot;, &quot;v4.0&quot;, &quot;v5.0&quot;]        r = BarChart(            num,            max_value=max(num),            bar_names=ver,        )        self.play(Create(r), run_time=2)        self.wait()\nå½±ç‰‡æˆæœ\næ–‡ç« ï¼šBertrand Paradox\næ–‡ç« ï¼šæ©¢åœ“è»Œé“ä¸Šè¡Œæ˜Ÿåˆ°å¤ªé™½å¹³å‡è·é›¢\nå½±ç‰‡ï¼šYoutubeé »é“\n\n","categories":["ç¨‹å¼æ¨¡æ“¬"],"tags":["æ•¸å­¸","Manim"]},{"title":"å©šå§»åŒ¹é…å•é¡Œï¼ˆStable Marriage Problemï¼‰","url":"/marriage/","content":"å•é¡Œæè¿°å°æ–¼å©šå§»åŒ¹é…å•é¡Œæœ‰ä»¥ä¸‹æè¿°ï¼šå°æ–¼ä¸€å€‹ç¾¤é«”ä¾†èªªï¼Œç”·ç”Ÿå¥³ç”Ÿéƒ½è¦å°‹æ‰¾è‡ªå·±æœ€å¿ƒå„€çš„å°è±¡ã€‚è€Œä¸€å€‹ã€Œç©©å®šã€çš„ç¾¤é«”æˆ‘å€‘æŠŠä»–å®šç¾©ç‚ºåœ¨å©šå§»ä¸­çš„æ¯ä¸€å°ç”·å¥³éƒ½æ²’æœ‰æ¯”ç›®å‰çš„é…å°æ–¹å¼æ›´å¥½çš„çµ„åˆã€‚\nä¸‹åœ–ç‚ºå››ç”·ï¼ˆå°å¯«å­—æ¯ï¼‰ä»¥åŠå››å¥³ï¼ˆå¤§å¯«å­—æ¯ï¼‰å°ç•°æ€§çš„åå¥½é †åºï¼Œç¬¬ä¸€æ ¼ä»£è¡¨ç”·ç”Ÿå°å¥³ç”Ÿçš„åå¥½é †åºï¼Œç¬¬äºŒæ ¼å‰‡ä»£è¡¨å¥³ç”Ÿå°ç”·ç”Ÿçš„åå¥½é †åºã€‚|     |  A  |  B  |  C  |  D  || :â€”-: |:â€”-:|:â€”-:|:â€”-:|:â€”-:|| a   | 1,3 | 2,3 | 3,2 | 4,3 || b   | 1,4 | 4,1 | 3,3 | 2,2 || c   | 2,2 | 1,4 | 3,4 | 4,1 || d   | 4,1 | 2,2 | 3,1 | 1,4 |\næˆ‘å€‘ç™¼ç¾åˆ°åªæœ‰$(a,C),(b,D),(c,A),(d,B)$æ˜¯å”¯ä¸€ä¸€çµ„ç©©å®šçš„é…å°ï¼Œå°æ–¼å…¶ä»–çš„é…å°å¿…å¯æ‰¾åˆ°ä¸€å°ç”·å¥³å–œæ­¡å½¼æ­¤çš„ç¨‹åº¦å‹éå°åŸæœ¬çš„ä¼´ä¾¶ã€‚\nGale-Shapley Algorithmï¼ˆç”·æ–¹æ±‚å©šæ³•ï¼‰æ¼”ç®—æ³•æ­¥é©Ÿå¦‚ä¸‹ï¼š\næ‰€æœ‰ç”·ç”Ÿå„è‡ªå‘ä»–å€‘æœ€å–œæ­¡çš„å¥³ç”Ÿæ±‚å©š;æ¯ç•¶ï¼ˆæœ‰å¥³ç”Ÿè¢«å…©å€‹ä»¥ä¸Šçš„ç”·ç”Ÿæ±‚å©šï¼‰&#123;    é€™å€‹å¥³ç”Ÿæš«æ™‚ä¿ç•™æ‰€æœ‰æ±‚å©šè€…ä¸­å¥¹æœ€å–œæ­¡çš„ä¸€å€‹ï¼Œè€Œæ‹’çµ•å…¶ä»–äººï¼›     è¢«æ‹’çµ•çš„ç”·ç”Ÿé€€è€Œæ±‚å…¶æ¬¡ï¼Œå‘ä¸æ›¾æ‹’çµ•éä»–çš„äººç•¶ä¸­æœ€å–œæ­¡çš„å¥³ç”Ÿæ±‚å©šï¼›&#125;\næ•¸å­¸è­‰æ˜å°è§€å¯Ÿå¦‚æœæ˜¯ç”·ç”Ÿä¸æ–·å‘å¥³ç”Ÿæ±‚å©šï¼Œå‰‡æœ‰ä»¥ä¸‹çš„è§€å¯Ÿï¼š\n\nä¸€å€‹å¥³ç”Ÿä¸€æ—¦è¨‚å©šï¼Œå¥¹å°è¨‚å©šå°è±¡çš„å–œå¥½ç¨‹åº¦æœƒä¸æ–·å¢åŠ ã€‚\nä¸€å€‹ç”·ç”Ÿä¸€æ—¦è¨‚å©šï¼Œä»–å°è¨‚å©šå°è±¡çš„å–œå¥½ç¨‹åº¦æœƒä¸æ–·ä¸‹é™ã€‚\n\nå¼•ç†\nGale-Shapley Algorithm çš„çµæœå¿…å®šæ˜¯å®Œç¾é…å°ã€‚\n\n            æ³¨æ„åˆ°æ¯ä¸€å€‹å¥³ç”Ÿæœ€å¤šåªæœƒæ‹’çµ•$n-1$å€‹ç”·ç”Ÿï¼ˆå¿…å®šç•™ä¸‹ä¸€å€‹ï¼‰ï¼Œé€™æ™‚å€™æ¯å€‹å¥³ç”Ÿéƒ½ä¸€å®šæœƒè¢«æ±‚å©šéï¼Œå¦å‰‡ï¼Œå› ç‚ºæ¯ä¸€å€‹å¥³ç”Ÿåªæœƒæš«æ™‚æ¥å—ä¸€å€‹æ±‚å©šè€…ï¼Œä¸€å®šé‚„æœ‰ä¸€å€‹æœªè¢«æ¥å—çš„ç”·ç”Ÿé‚„å¯ä»¥å‘æŸä¸€ä½å¥³ç”Ÿæ±‚å©šã€‚\n          \n\nGale-Shapley Algorithm çš„çµæœå¿…å®šæ˜¯ç©©å®šçš„ã€‚\n\n            å‡è¨­é€™å€‹åŒ¹é…è£¡å‡ºç¾ä¸ç©©å®šé…å°ï¼Œä¸å¤±ä¸€èˆ¬æ€§å‡è¨­æ˜¯$(a,B)$ï¼Œå…¶ä¸­ $a$ å–œæ­¡ $B$ å‹éæ–¼ä»–çš„é…å¶ $A$ï¼Œè€Œ $B$ å–œæ­¡ $a$ å¤šéä»–çš„é…å¶ $b$ã€‚ç”±æ–¼ $a$ æ¯”è¼ƒå–œæ­¡ $B$ï¼Œä»–å¿…å®šæ›¾ç¶“å‘ $B$ æ±‚å©šéï¼Œä½†æœ€å¾Œæ²’æœ‰å’Œ $B$ é…å°ï¼Œè¡¨ç¤º $a$ è¢«æ‹’çµ•è€Œç•¶æ™‚ $B$ èº«æ—æ˜¯æœ‰ä¸€å€‹æ±‚å©šè€…æ˜¯ $B$ æ¯”è¼ƒå–œæ­¡çš„ï¼Œå› æ­¤é€™å€‹æ±‚å©šè€…åœ¨ $B$ çš„æ’è¡Œä¸­ä¹Ÿå„ªå…ˆæ–¼ $b$ ï¼ˆå„ªå…ˆæ–¼ $a$ å› è€Œå„ªå…ˆæ–¼ $b$ï¼‰ï¼Œæ ¹æ“šè§€å¯Ÿä¸€ï¼Œä¸å¯èƒ½æœ€å¾Œ $B$ è·Ÿ $b$ é…å°åœ¨ä¸€èµ·ï¼ˆå¥³ç”Ÿå°è¨‚å©šå°è±¡å–œå¥½ç¨‹åº¦åªæœƒä¸æ–·å¢åŠ ï¼‰ï¼ŒçŸ›ç›¾ã€‚\n          \n\n\nè­‰æ˜æ ¹æ“šå¼•ç†1,2ï¼Œæˆ‘å€‘çŸ¥é“ Gale-Shapley Algorithm è¼¸å‡ºçš„åŒ¹é…å¿…å®šæ˜¯å®Œç¾é…å°ä¸”ä¸å­˜åœ¨ä¸ç©©å®šé…å°ã€‚æ ¹æ“šå®šç¾©ï¼Œå¾—è­‰ã€‚\nè¤‡é›œåº¦åˆ†æè­‰æ˜ç®—æ³•çš„è¤‡é›œåº¦ç‚ºï¼š$O(n^2)$ã€‚\n\nç¸½å…±ä¸æœƒè¶…é $n^2$ å€‹æ±‚å©šè¦æ±‚ï¼šæ¯å€‹ç”·ç”Ÿåªæœƒå°ä¸€å€‹å¥³ç”Ÿæ±‚å©šæœ€å¤šä¸€æ¬¡ï¼Œç¸½å…±æœ‰ $n$ å€‹å¥³ç”Ÿï¼Œå› æ­¤æœ€å¤šæœ‰ $n^2$ å€‹æ±‚å©šè¦æ±‚ã€‚\nå°æ–¼æ¯ä¸€å€‹æ±‚å©šè¦æ±‚ä»¥ $O(1)$ è™•ç†ï¼šå¯ä»¥è—‰ç”±ä¸€å€‹äºŒç¶­é™£åˆ— $O(1)$ æ¯”è¼ƒå¥³ç”Ÿå°ç”·ç”Ÿçš„å–œå¥½ç¨‹åº¦ï¼ŒåŒæ™‚ç¶­è­·ä¸€å€‹ä½‡åˆ—ä½¿æˆ‘å€‘èƒ½ $O(1)$ å–å¾—ç”·ç”Ÿè¦ä¸‹ä¸€å€‹è¦é…å°çš„å¥³ç”Ÿã€‚\n\nå¾—è­‰ Gale-Shapley Algorithm çš„è¤‡é›œåº¦æ˜¯ $O(n^2)$ã€‚\nå¯¦ä½œé¡Œç›®é€£çµ\né€™é¡Œæ˜¯å¥³ç”Ÿæ±‚å©šæ³•ã€‚\næ¯”è¼ƒé›£è™•ç†çš„éƒ¨åˆ†æ˜¯è¼¸å…¥ï¼Œå…¶ä»–å°±ç…§è‘—è™›æ“¬ç¢¼åŸ·è¡Œç®—æ³•ã€‚åœ¨ä»¥ä¸‹ç¨‹å¼ç¢¼ä¸­ï¼Œæˆ‘å€‘ä½¿ç”¨cur_queæ”¾å…¥å°šæœªæˆåŠŸé…å°çš„å¥³ç”Ÿï¼Œæ¯ä¸€å€‹å¥³ç”Ÿä¸‹ä¸€å€‹è¦é…å°çš„ç”·ç”Ÿå‰‡å„²å­˜åœ¨queä¸­ï¼Œä¸¦åˆ©ç”¨Manè¨˜éŒ„ç”·ç”Ÿç›®å‰é…å°åˆ°çš„å¥³ç”Ÿã€‚\nåŸ·è¡Œå®Œæ¼”ç®—æ³•ä¹‹å¾Œï¼Œåˆ©ç”¨åå‡½æ•¸æ‰¾å‡ºManå¥³ç”Ÿé…å°åˆ°çš„ç”·ç”Ÿä¸¦è¼¸å‡ºã€‚\n#include &lt;bits/stdc++.h&gt;#define int long long#define pii pair&lt;int,int&gt;#define ff first#define ss second#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;const int N = 1005;int t,n;pii P[N][N];vector&lt;int&gt; gale_shapley(queue&lt;int&gt; *q)&#123;    queue&lt;int&gt; cur_que;    vector&lt;int&gt; Man;Man.resize(n+1,0);    for(int i = 1;i &lt;= n;i++)cur_que.push(i);    while(!cur_que.empty())&#123;        int woman = cur_que.front(),man = q[woman].front();        q[woman].pop();        if(!Man[man])&#123;            Man[man] = woman;            cur_que.pop();        &#125;        else if(P[woman][man].ss &lt; P[Man[man]][man].ss)&#123;            cur_que.push(Man[man]);            Man[man] = woman;            cur_que.pop();        &#125;    &#125;    return Man;&#125;signed main()&#123;    IOS;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        queue&lt;int&gt; q[N];        for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)&#123;            int temp;cin&gt;&gt;temp;            P[i][temp].ff = j;            q[i].push(temp);        &#125;        for(int i=1;i&lt;=n;i++)for(int j=1;j&lt;=n;j++)&#123;            int temp;cin&gt;&gt;temp;            P[temp][i].ss = j;        &#125;        int ans[N];        vector&lt;int&gt; Man = gale_shapley(q);        for(int i = 1;i &lt;= n;i++)ans[Man[i]] = i;        for(int i = 1;i &lt;= n;i++)cout&lt;&lt;ans[i]&lt;&lt;endl;        if(t)cout&lt;&lt;endl;    &#125;&#125;\nå»¶ä¼¸å•é¡Œ\nè­‰æ˜ç”·æ–¹æ±‚å©šæ³•æœƒçµ¦å‡ºç”·æ€§çš„æœ€ä½³åŒ¹é…ã€‚\nå¦‚ä½•æœ‰æ•ˆç‡çš„æ‰¾å‡ºæ‰€æœ‰å¯èƒ½çš„ç©©å®šåŒ¹é…ï¼Ÿ\næ‰¿ä¸Šï¼Œæ ¹æ“šWikiæ‰€è¿°ï¼Œè©¦è­‰æ˜$n$ç”·$n$å¥³ç©©å®šåŒ¹é…æ•¸çš„å¹³å‡æœƒæ¼¸é€²æ–¼$e^{-1}n\\ln n$ã€‚\nè­‰æ˜æ‰¾å‡ºç©©å®šåŒ¹é…æ•¸çš„å•é¡Œæ˜¯ä¸€å€‹#P-completeçš„å•é¡Œã€‚\n\nä¸‹åœ–æ˜¯ç”·å¥³å°æ•¸$n$è·Ÿç©©å®šåŒ¹é…æ•¸$S$çš„é—œä¿‚åœ–ï¼Œå…¶å¢é•·çš„é€Ÿåº¦èˆ‡$n\\ln n$åŒç´šï¼š\nåƒè€ƒè³‡æ–™Wiki:Galeâ€“Shapley Algorithm\næ¼”ç®—æ³•ç­†è¨˜:Matching\nMichael Dzierzawa, Marie-JosÃ© OmÃ©ro, Statistics of stable marriages, Physica A 287 (1â€“2) (2000) 321â€“333\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","åŒ¹é…"]},{"title":"Geometry in Leetcode & CSES","url":"/geo3/","content":"CSES Geometry\nPoint Location Test\nLine Segment Intersection\nPolygon Area\nPoint in Polygon\nPolygon Lattice Points\nMinimum Euclidean Distance\nConvex Hull\n\n\nPoint Location TestCODE\nçµ¦ä½ ä¸‰å€‹é» $P_1,P_2,P_3$ ï¼Œåˆ¤æ–·å‡ºå‘é‡ $(P_1,P_2)$ ä¹‹æ–¼ $P_3$ çš„æ–¹å‘ç‚ºä½•ï¼Ÿé—œä¿‚å…±æœ‰ç›¸äº¤ã€ä½æ–¼å·¦å´ä»¥åŠä½æ–¼å³å´ã€‚\nLine Segment IntersectionCODE\nçµ¦ä½ å…©æ¢ç·šæ®µï¼Œåˆ¤æ–·ä»–å€‘æ˜¯å¦ç›¸äº¤ã€‚ç·šæ®µç›¸äº¤è£¸é¡Œã€‚\nPolygon AreaCODE\nçµ¦ä½ Nå€‹é»ï¼Œè¨ˆç®—å‡ºæ­¤å¤šé‚Šå½¢åœæˆçš„é¢ç©ç‚ºä½•ã€‚å¸¶å…¥è¡Œåˆ—å¼å…¬å¼å¯è§£ã€‚\nPoint in PolygonCODE\nçµ¦ä½ Nå€‹é»æ§‹æˆçš„ä¸€å€‹ç°¡å–®å¤šé‚Šå½¢ï¼Œåˆ¤æ–·ä¸€å€‹é»æ˜¯å¦åœ¨å¤šé‚Šå½¢å…§éƒ¨ã€‚\nåƒè€ƒè³‡æ–™ï¼šgreekforgreek\n\nå‡¸å¤šé‚Šå½¢çš„æƒ…æ³ï¼Œæˆ‘å€‘å¯ä»¥åˆ©ç”¨å…§è§’å’Œæ˜¯360åº¦è½‰ä¸€åœˆçš„çš„æ–¹æ³•ï¼Œåˆ¤æ–·ä¸€é»æ˜¯å¦åœ¨å¤šé‚Šå½¢å…§éƒ¨ã€‚ä½†æœ¬é¡Œæ˜¯ç°¡å–®å¤šé‚Šå½¢ï¼Œå› æ­¤ç”¨é€™ç¨®æ–¹æ³•æ˜¯ä¸å¯è¡Œçš„ã€‚\n\né€™å¼µåœ–æ˜¯ä½œæ³•ï¼Œæˆ‘å€‘åšå‡ºä¸€å€‹ç”±xé»å‡ºç™¼å‘xè»¸æ­£å‘çš„å°„ç·šï¼Œè¨ˆç®—é€™ä¸€æ¢å°„ç·šè·Ÿå¤šé‚Šå½¢å…±æœ‰å¹¾å€‹äº¤é»ã€‚å¦‚æœæ˜¯å¥‡æ•¸ï¼Œè¡¨ç¤ºåœ¨å…§éƒ¨ï¼›åä¹‹å‰‡æ˜¯åœ¨å¤–éƒ¨ã€‚äº¤åœ¨å¤šé‚Šå½¢ä¸Šçš„é»è¦ç‰¹åˆ¥æ³¨æ„ï¼Œå› ç‚ºä»–å¯èƒ½æœƒè¢«çµ±è¨ˆåˆ°å…©æ¬¡ï¼Œå› æ­¤æˆ‘å€‘ç‰¹åˆ¥è™•ç†ç•¶é»ç›¸äº¤ä¸€é»æ™‚ï¼Œåªè¨ˆç®—é‚£æ¢é‚Šçš„å…©ç«¯é»ä¸­ï¼Œyåº§æ¨™æ¯”è¼ƒå¤§çš„é‚£ä¸€é»æ˜¯å¦ç›¸äº¤çš„æƒ…æ³ã€‚\næœ€å¾Œï¼Œæˆ‘å€‘ç™¼ç¾é‡ä¸Šå¦‚åœ–ä¸­gé»çš„ç‹€æ³ç›´æ¥å°±è¢«è™•ç†å¥½äº†ï¼ä»–æœƒè¢«ç®—åˆ°é›¶æ¬¡ï¼Œå› ç‚ºåœ¨çœ‹å…©æ¢é‚ŠåŠ ä¸Šå»ä¹‹å¾Œï¼Œåˆå› ç‚ºé ‚é»æ˜¯yåº§æ¨™æ¯”è¼ƒå¤§çš„ï¼Œæœƒè¢«å‰ªæ‰å…©æ¬¡ã€‚\nPolygon Lattice PointsCODE\nçµ¦å®šé ‚é»åº§æ¨™å‡æ˜¯æ•´é»ï¼ˆæˆ–æ­£æ–¹å½¢æ ¼å­é»ï¼‰çš„ç°¡å–®å¤šé‚Šå½¢ï¼Œçš®å…‹å®šç†èªªæ˜äº†å…¶é¢ç© $A$ å’Œå…§éƒ¨æ ¼é»æ•¸ç›® $i$ã€é‚Šä¸Šæ ¼é»æ•¸ç›® $b$ çš„é—œä¿‚ï¼š\nA = i + \\frac{b}{2} - 1PROOF\nMinimum Euclidean DistanceCODE\næœ€è¿‘é»å°å•é¡Œã€‚ä¸éï¼Œæ—¢ç„¶æ˜¯è¨ˆç®—å¹¾ä½•ï¼Œæˆ‘å€‘å°±ç”¨æƒæç·šåšæœ€è¿‘é»å°ã€‚æƒæç·šæœ‰å…©å€‹åšæ³•ï¼ˆå¯ä»¥åƒè€ƒé‚£å€‹é€£çµï¼‰ï¼Œè‡³æ–¼æ­é…setè¼”åŠ©æ­¥é©Ÿå°±æ˜¯ï¼š\n\nå°‡é»è¼¸å…¥ä¸¦ä¸”æ’åºï¼ŒXåº§æ¨™ç‚ºä¸»ï¼ŒYåº§æ¨™ç‚ºè¼”ã€‚\nä½¿ç”¨setï¼Œä¸¦ä»¥Yåº§æ¨™ç‚ºæ’åºåŸºæº–ï¼ˆpairçš„é¦–é …ï¼‰ï¼Œä»¥å„²å­˜ç¬¬ $i$ é»çš„å·¦æ–¹ã€æ°´å¹³è·é›¢å°æ–¼ç­‰æ–¼dçš„é»ã€‚\nå³æƒæç·šä¾åºçª®èˆ‰å„é»ä½œç‚ºå³ç«¯é»ã€‚ã€€(1) Eraseèˆ‡å³ç«¯é»æ°´å¹³è·é›¢å¤§æ–¼dçš„é»å€‘ï¼ˆå·¦æƒæç·šå³ç§»ï¼‰ã€€(2) ç”¨äºŒåˆ†æœæ‰¾å‡ºèˆ‡ç¬¬ $i$ é»å‚ç›´è·é›¢å°æ–¼dçš„é»ï¼Œä¸¦å˜—è©¦æ›´æ–°ã€€(3) å°‡ç¬¬ $i$ é»åŠ å…¥setä¸­ã€‚\n\n\nConvex HullCODE\nå‡¸åŒ…è£¸é¡Œã€‚\nLeetcodeï¼šGeographyLeetcode ç¸½å…±æœ‰27é¡Œçš„tagæ˜¯è¨ˆç®—å¹¾ä½•çš„ï¼Œé¡Œå–®åœ¨é€™è£¡ã€‚æœ‰ä¸‰é¡Œè¢«é–èµ·ä¾†ä¸èƒ½çœ‹ï¼Œæ‰€ä»¥ç¸½å…±æœ‰24é¡Œã€‚\n149 Max Points on a Lineé¡Œç›®é€£çµ\nclass Solution &#123;public:        int gcd(int a,int b)&#123;        if(a &gt; b)swap(a,b);        if(a == 0)return b;        return gcd(b % a, a);    &#125;        int maxPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            map&lt;pair&lt;int,int&gt;,int&gt; mp;            int same = 0,hori = 0;            for(int j = i+1;j &lt; n;j++)&#123;                int dx = points[i][0] - points[j][0];                int dy = points[i][1] - points[j][1];                if(dx == 0 &amp;&amp; dy == 0)&#123;same++;continue;&#125;                if(dx == 0 &amp;&amp; dy != 0)&#123;hori++;continue;&#125;                int g = gcd(abs(dx),abs(dy));                if(dy &lt; 0 || (dy == 0 &amp;&amp; dx &lt; 0))&#123;dx = -dx;dy = -dy;&#125;                mp[&#123;dx/g,dy/g&#125;]++;            &#125;            int sum = hori + same + 1;            for(auto it : mp)sum = max(sum,it.second + 1);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\n223 Rectangle Areaé¡Œç›®é€£çµ\nclass Solution &#123;public:    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) &#123;        int x = max(min(ax2,bx2) - max(ax1,bx1),0);        int y = max(min(ay2,by2) - max(ay1,by1),0);        int ans = (ax2 - ax1)*(ay2 - ay1)+(bx2 - bx1)*(by2 - by1)-x * y;        return ans;    &#125;&#125;;\n335 Self Crossingé¡Œç›®é€£çµ\nclass Solution &#123;public:    bool isSelfCrossing(vector&lt;int&gt;&amp; d) &#123;        int n = d.size();        if(n &lt;= 3)return false;        for(int i = 3;i &lt; n;i++)&#123;            //ç¬¬å››æ¢ã€ç¬¬äº”æ¢ã€ç¬¬å…­æ¢äº¤ç¬¬ä¸€æ¢            if(d[i] &gt;= d[i-2] &amp;&amp; d[i-1] &lt;= d[i-3])return true;            if(i &gt;= 4 &amp;&amp; d[i-1] == d[i-3] &amp;&amp; d[i] + d[i-4] &gt;= d[i-2])return true;            if(i &gt;= 5 &amp;&amp; d[i-2] &gt;= d[i-4] &amp;&amp; d[i] &gt;= d[i-2] - d[i-4]              &amp;&amp; d[i-1] &gt;= d[i-3]-d[i-5] &amp;&amp; d[i-1] &lt;= d[i-3])return true;                    &#125;        return false;    &#125;&#125;;\n587 Erect the Fenceé¡Œç›®é€£çµ\n#define pii pair&lt;int,int&gt;#define ff first#define ss secondclass Solution &#123;public:        bool check(pii a,pii b,pii o)&#123;        pii aa = &#123;a.ff - o.ff,a.ss - o.ss&#125;;        pii bb = &#123;b.ff - o.ff,b.ss - o.ss&#125;;        int cross = aa.ff * bb.ss - aa.ss * bb.ff;        return cross &gt; 0;    &#125;        vector&lt;vector&lt;int&gt;&gt; outerTrees(vector&lt;vector&lt;int&gt;&gt;&amp; point) &#123;        vector&lt;pii&gt; h;        int n = point.size();        vector&lt;pii&gt; p(n);        for(int i = 0;i &lt; n;i++)p[i] = &#123;point[i][0],point[i][1]&#125;;        sort(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; 1 &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        int down = h.size();        h.pop_back();        reverse(p.begin(),p.end());        for(auto i : p)&#123;            while(h.size() &gt; down &amp;&amp; check(i,h[h.size()-1],h[h.size()-2]))                h.pop_back();            h.push_back(i);        &#125;        set&lt;pii&gt; s;for(auto i : h)s.insert(i);        n = s.size();        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n);        for(int i=0;i&lt;n;i++)ans[i].resize(2);        int id = 0;        for(auto i : s)&#123;ans[id][0] = i.ff;ans[id][1] = i.ss;id++;&#125;        return ans;    &#125;&#125;;\n593 Valid Squareé¡Œç›®é€£çµ\nclass Solution &#123;public:        int dis(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2)&#123;        int x = p1[0] - p2[0],y = p1[1] - p2[1];        return x * x + y * y;    &#125;        bool validSquare(vector&lt;int&gt;&amp; p1, vector&lt;int&gt;&amp; p2, vector&lt;int&gt;&amp; p3, vector&lt;int&gt;&amp; p4) &#123;        map&lt;int,int&gt;mp;     //é•·åº¦ã€å€‹æ•¸        mp[dis(p1,p2)]++;        mp[dis(p1,p3)]++;        mp[dis(p1,p4)]++;        mp[dis(p2,p3)]++;        mp[dis(p2,p4)]++;        mp[dis(p3,p4)]++;        return mp.size() == 2 &amp;&amp; mp.begin()-&gt;second == 4;    &#125;&#125;;\n812    Largest Triangle Areaé¡Œç›®é€£çµclass Solution &#123;public:        int cross(int x1,int y1,int x2,int y2)&#123;        return x1 * y2 - x2 * y1;    &#125;        double area(int a,int b,int c,int d,int e,int f)&#123;        double sum = 0;        sum += cross(a,b,c,d);        sum += cross(c,d,e,f);        sum += cross(e,f,a,b);        return abs(sum / 2.0);    &#125;        double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size();        double ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i + 1;j &lt; n;j++)&#123;                for(int p = j + 1;p &lt; n;p++)&#123;                    ans = max(ans,area(points[i][0],points[i][1]                                      ,points[j][0],points[j][1]                                      ,points[p][0],points[p][1]));                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n836 Rectangle Overlapé¡Œç›®é€£çµ\nclass Solution &#123;public:    bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123;        //æœ€å°çš„å³ç«¯é» - æœ€å¤§çš„å·¦ç«¯é»        int x = min(rec1[2],rec2[2]) - max(rec1[0],rec2[0]);        //æœ€å°çš„ä¸Šç«¯é» - æœ€å¤§çš„ä¸‹ç«¯é»        int y = min(rec1[3],rec2[3]) - max(rec1[1],rec2[1]);        return x &gt; 0 &amp;&amp; y &gt; 0;    &#125;&#125;;\n858 Mirror Reflectioné¡Œç›®é€£çµ\nclass Solution &#123;public:    int gcd(int a,int b)&#123;        if(a == 0)return b;        return gcd(b % a,a);    &#125;        int mirrorReflection(int p, int q) &#123;        int len = p * q / gcd(q,p);        int a = (len / p) % 2,b = (len / q) % 2;        if(a == 0 &amp;&amp; b == 1)return 0;        else if(a == 1 &amp;&amp; b == 1)return 1;        else return 2;            &#125;&#125;;\n478 Generate Random Point in a Circleé¡Œç›®é€£çµ\nç›´æ¥RandomåŠå¾‘æœƒå‡ºäº‹ï¼ˆå¯èƒ½ä¸å¤ äº‚ï¼Œæˆ–æ˜¯åŠå¾‘å¤ªå°ï¼‰ï¼Œå¦‚æœrandomé¢ç©ä¹‹å¾Œç®—åŠå¾‘æ‰OKã€‚\nclass Solution &#123;public:    double R,X,Y;    Solution(double radius, double x_center, double y_center) &#123;        R = radius;X = x_center;Y = y_center;        srand(time(NULL));    &#125;        vector&lt;double&gt; randPoint() &#123;        double Area = rand() * R * R * M_PI / (RAND_MAX + 1.0);        double r = sqrt(Area / M_PI);        double theta = 2.0 * M_PI * rand() / (RAND_MAX + 1.0);        vector&lt;double&gt; ans;        ans.push_back(X + r * cos(theta));        ans.push_back(Y + r * sin(theta));        return ans;    &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution* obj = new Solution(radius, x_center, y_center); * vector&lt;double&gt; param_1 = obj-&gt;randPoint(); */\n883 Projection Area of 3D Shapesé¡Œç›®é€£çµ\nä¸‰ç¨®ä¸åŒçš„æŠ•å½±å°æ‡‰åˆ°ä¸‰ç¨®ä¸åŒçš„è§’åº¦çœ‹åœ–å½¢ã€‚x-yçš„é¢ç©å³ç‚ºç”±ä¸Šè€Œä¸‹çœ‹æœ‰æ–¹æ ¼çš„å€‹æ•¸ã€‚x-zæ˜¯å¾å‰æ–¹çœ‹ï¼Œå› æ­¤å°æ‡‰åˆ°çš„æ˜¯æ¯ä¸€è¡Œçš„æœ€å¤§æ–¹å¡Šå€‹æ•¸ã€‚\nclass Solution &#123;public:    int projectionArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int n = grid.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            int maxR = 0,maxC = 0;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans++;        //ç”±ä¸Šå¾€ä¸‹çœ‹                maxR = max(maxR,grid[i][j]);    //ç”±å´é‚Šçœ‹                maxC = max(maxC,grid[j][i]);    //ç”±å‰é¢çœ‹            &#125;            ans += maxR + maxC;        &#125;        return ans;    &#125;&#125;;\n892 Surface Area of 3D Shapesé¡Œç›®é€£çµ\nclass Solution &#123;public:    int surfaceArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123;        int ans = 0,n = grid.size();        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                if(grid[i][j] &gt; 0)ans += 4 * grid[i][j] + 2;                if(i &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i+1][j])*2;                &#125;                if(j &lt; n - 1)&#123;                    ans -= min(grid[i][j],grid[i][j+1])*2;                &#125;            &#125;        &#125;        return ans;    &#125;&#125;;\n939 Minimum Area Rectangleé¡Œç›®é€£çµclass Solution &#123;public:    int minAreaRect(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        vector&lt;vector&lt;int&gt;&gt;p = points;        int n = points.size();        set&lt;pair&lt;int,int&gt;&gt;s;        for(int i=0;i&lt;n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        int ans = INT_MAX;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(s.find(&#123;p[i][0],p[j][1]&#125;)!=s.end()                    &amp;&amp; s.find(&#123;p[j][0],p[i][1]&#125;)!=s.end())&#123;                    if(p[i][0] == p[j][0] || p[i][1] == p[j][1])continue;                    ans = min(ans,abs(p[i][0]-p[j][0])*abs(p[i][1]-p[j][1]));                &#125;            &#125;        &#125;        if(ans == INT_MAX)return 0;        else return ans;    &#125;&#125;;\n963 Minimum Area Rectangle IIé¡Œç›®é€£çµ\nclass Solution &#123;public:    double minAreaFreeRect(vector&lt;vector&lt;int&gt;&gt;&amp; p)&#123;        set&lt;pair&lt;int,int&gt;&gt; s;        int n = p.size();        for(int i = 0;i &lt; n;i++)s.insert(&#123;p[i][0],p[i][1]&#125;);        double ans = 1e9;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                int x1 = p[j][0] - p[i][0];                int y1 = p[j][1] - p[i][1];                for(int k = j+1;k &lt; n;k++)&#123;                    int x2 = p[k][0] - p[i][0];                    int y2 = p[k][1] - p[i][1];                    if(x1 * x2 + y1 * y2 != 0)continue;                    int nx = p[k][0] + x1,ny = p[k][1] + y1;                    if(s.find(&#123;nx,ny&#125;) != s.end())&#123;                        ans = min(ans,sqrt(x1*x1+y1*y1) * sqrt(x2*x2+y2*y2));                    &#125;                &#125;            &#125;        &#125;        if(ans == 1e9)return 0;        return ans;    &#125;&#125;;\n973 K Closest Points to Originé¡Œç›®é€£çµ\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123;        int n = points.size();        multimap&lt;int,int&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            int x = points[i][0];            int y = points[i][1];            mp.insert(&#123;x * x + y * y,i&#125;);        &#125;        auto it = mp.begin();        vector&lt;vector&lt;int&gt;&gt; ans;        for(int i=0;i&lt;k;i++)&#123;            int id = it-&gt;second;            ans.push_back(points[id]);            it++;        &#125;        return ans;    &#125;&#125;;\n1030 Matrix Cells in Distance Orderé¡Œç›®é€£çµ\nclass Solution &#123;public:    vector&lt;vector&lt;int&gt;&gt; allCellsDistOrder(int rows, int cols, int rCenter, int cCenter) &#123;        int n = rows,m = cols;        multimap&lt;int,pair&lt;int,int&gt;&gt; mp;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; m;j++)&#123;                int dis = abs(i - rCenter) + abs(j - cCenter);                mp.insert(&#123;dis,&#123;i,j&#125;&#125;);            &#125;        &#125;        vector&lt;vector&lt;int&gt;&gt; ans;ans.resize(n*m);        for(int i=0;i&lt;n*m;i++)ans[i].resize(2,0);        int id = 0;        for(auto it : mp)&#123;            ans[id][0] = (it.second.first);            ans[id][1] = (it.second.second);            id++;        &#125;        return ans;    &#125;&#125;;\n1037 Valid Boomerangé¡Œç›®é€£çµ\nclass Solution &#123;public:    bool isBoomerang(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int x1 = points[1][0]-points[0][0],y1 = points[1][1]-points[0][1];        int x2 = points[2][0]-points[1][0],y2 = points[2][1]-points[1][1];        int cross = x1 * y2 - x2 * y1;        if(cross == 0)return false;        return true;    &#125;&#125;;\n1232 Check If It Is a Straight Lineé¡Œç›®é€£çµ\nclass Solution &#123;public:    bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123;        vector&lt;vector&lt;int&gt;&gt; p = coordinates;        int n = p.size();        for(int i = 0;i &lt; n-2;i++)&#123;            int x1 = p[i+1][0] - p[i][0],y1 = p[i+1][1] - p[i][1];            int x2 = p[i+2][0] - p[i+1][0],y2 = p[i+2][1] - p[i+1][1];            if(x1 * y2 != x2 * y1)return false;        &#125;        return true;    &#125;&#125;;\n1266 Minimum Time Visiting All Pointsé¡Œç›®é€£çµ\nclass Solution &#123;public:    int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123;        int n = points.size(),ans = 0;        vector&lt;vector&lt;int&gt;&gt; p = points;        for(int i = 0;i &lt; n-1;i++)&#123;            ans += max(abs(p[i+1][0] - p[i][0]),abs(p[i+1][1] - p[i][1]));        &#125;        return ans;    &#125;&#125;;\n1401 Circle and Rectangle Overlappingé¡Œç›®é€£çµ\nclass Solution &#123;public:    bool checkOverlap(int radius, int x_center, int y_center, int x1, int y1, int x2, int y2) &#123;        int x = clamp(x_center,x1,x2) - x_center;        int y = clamp(y_center,y1,y2) - y_center;        return x*x + y*y &lt;= radius * radius;    &#125;&#125;;\n1453 Maximum Number of Darts Inside of a Circular Dartboardé¡Œç›®é€£çµ\n#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y second#define exp 1e-6class Solution &#123;public:        double dis(pdd a,pdd b)&#123;        ld x = a.x - b.x,y = a.y - b.y;        return sqrt(x * x + y * y);    &#125;        pair&lt;pdd,pdd&gt; get_center(pdd a,pdd b,ld R)&#123;        pdd mid = &#123;(a.x + b.x) / 2,(a.y + b.y) / 2&#125;;        ld theta = atan2(a.y - b.y, b.x - a.x);        ld tmp = dis(a,b) / 2, d = sqrt(R * R - tmp * tmp);                pair&lt;pdd,pdd&gt; ans;        ans.x = &#123;mid.x - d * sin(theta),mid.y - d * cos(theta)&#125;;        ans.y = &#123;mid.x + d * sin(theta),mid.y + d * cos(theta)&#125;;        return ans;    &#125;        int numPoints(vector&lt;vector&lt;int&gt;&gt;&amp; point, int R) &#123;        int n = point.size(),ans = 1;        pdd p[n];for(int i=0;i&lt;n;i++)&#123;p[i] = &#123;point[i][0],point[i][1]&#125;;&#125;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = i+1;j &lt; n;j++)&#123;                if(dis(p[i],p[j]) - 2.0 * R &gt;= exp)continue;                pair&lt;pdd,pdd&gt; cur = get_center(p[i],p[j],R);                int cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.x) - R&lt;= exp)cnt ++;                ans = max(ans, cnt);cnt = 0;                for(int k = 0;k &lt; n;k++)                    if(dis(p[k], cur.y) - R &lt;= exp)cnt ++;                ans = max(ans, cnt);            &#125;        &#125;        return ans;    &#125;&#125;;\n1515 Best Position for a Service Centreé¡Œç›®é€£çµ\né€™ä¸€é¡Œæ˜¯æ¨¡æ“¬é€€ç«ï¼Œéå¸¸é…·ï¼Œä¹‹å‰æ²’æœ‰å¯«éçš„æ±è¥¿ã€‚\n#define eps 1e-6#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 100;        ld dx[4] = &#123;1.0,0.0,-1.0,0.0&#125;,dy[4] = &#123;0.0,1.0,0.0,-1.0&#125;;        bool flag = 0;        while(test_size &gt; eps)&#123;            flag = 0;            for(int i = 0;i &lt; 4;i++)&#123;                pdd newp = cur;                newp.x += dx[i] * test_size;                newp.y += dy[i] * test_size;                ld new_dis = dis_all(newp);                if(new_dis &lt; mid_dis)&#123;                    mid_dis = new_dis;                    cur = newp;                    flag = 1;                    break;                &#125;            &#125;            if(flag == 0)test_size /= 2.0;        &#125;        return mid_dis;    &#125;&#125;;\næ›å¦å¤–ä¸€ç¨®è¿­ä»£æ–¹å¼\n#define eps 1e-8#define ld long double#define pdd pair&lt;ld,ld&gt;#define x first#define y secondclass Solution &#123;public:    pdd p[105];int n;        ld dis_all(pdd mid)&#123;        ld sum;        for(int i = 0;i &lt; n;i++)&#123;            ld x = p[i].x - mid.x,y = p[i].y - mid.y;            sum += sqrt(x * x + y * y);        &#125;        return sum;    &#125;        double getMinDistSum(vector&lt;vector&lt;int&gt;&gt;&amp; pos) &#123;        srand(time(NULL));        n = pos.size();        for(int i = 0;i &lt; n;i++)p[i] = &#123;pos[i][0],pos[i][1]&#125;;        pdd cur = p[0];ld mid_dis = dis_all(p[0]);        ld test_size = 150.0;        while(test_size &gt; eps)&#123;            pdd newp = cur;            int temp = rand();            newp.x += cos(temp) * test_size;            newp.y += sin(temp) * test_size;            ld new_dis = dis_all(newp);            if(new_dis &lt; mid_dis)&#123;                mid_dis = new_dis;                cur = newp;            &#125;            else test_size *= 0.99;        &#125;        return mid_dis;    &#125;&#125;;\n1610 Maximum Number of Visible Pointsé¡Œç›®é€£çµ\n#define ld long doubleconst int N = 1e5+5;class Solution &#123;public:    int visiblePoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, int angle, vector&lt;int&gt;&amp; loc) &#123;        vector&lt;ld&gt; ang;        int overlap = 0,n = points.size(),ans = 0;        for(auto p : points)&#123;            if(p[0] == loc[0] &amp;&amp; p[1] == loc[1])overlap++;            else ang.push_back(atan2l(p[1]-loc[1],p[0]-loc[0]) * 180 / (ld)M_PI);        &#125;        int sz = ang.size();        for(int i = 0;i &lt; sz;i++)ang.push_back(ang[i] + 360);        sort(ang.begin(),ang.end());        sz = ang.size();        for(int i = 0,it2 = 0;i &lt; sz;i++)&#123;            while(it2 &lt; sz &amp;&amp; ang[it2] - ang[i] &lt;= angle)it2++;            ans = max(ans,it2 - i);        &#125;        return ans + overlap;    &#125;&#125;;\n1828 Queries on Number of Points Inside a Circleé¡Œç›®é€£çµ\nclass Solution &#123;public:    vector&lt;int&gt; countPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points, vector&lt;vector&lt;int&gt;&gt;&amp; queries) &#123;        int n = queries.size(),m = points.size();        vector&lt;int&gt; ans;ans.resize(n);        for(int i = 0;i &lt; n;i++)&#123;            int rx = queries[i][0],ry = queries[i][1],sum = 0;            for(int j = 0;j &lt; m;j++)&#123;                int x = points[j][0] - rx,y = points[j][1] - ry;                if(x * x + y * y &lt;= queries[i][2] * queries[i][2])sum++;            &#125;            ans[i] = sum;        &#125;        return ans;    &#125;&#125;;\n2101. Detonate the Maximum Bombsé¡Œç›®é€£çµ\næŠŠåœ–å½¢è€ƒæ…®æˆä¸€å¼µåœ–ï¼Œç¬¦åˆæ¢ä»¶çš„å°±å¢åŠ ä¸€æ¢æœ‰å‘é‚Šï¼Œæ¥è‘—å°æ¯ä¸€å€‹é»åšä¸€æ¬¡DFSå³å¯ã€‚æ™‚é–“ $O(n^2)$ã€‚\n#define pii pair&lt;int,int&gt;#define ld long doubleclass Solution &#123;public:        vector&lt;int&gt; E[105];    ld dis(pii a,pii b)&#123;        int x = a.first - b.first,y = a.second - b.second;        return sqrt((long long)x * x + (long long)y * y);    &#125;    int sum = 1;    bool vis[105];    void dfs(int now)&#123;        vis[now] = 1;        for(auto i : E[now])&#123;            if(vis[i])continue;            sum++;vis[i] = 1;            dfs(i);        &#125;    &#125;        int maximumDetonation(vector&lt;vector&lt;int&gt;&gt;&amp; bomb) &#123;        int n = bomb.size(),ans = 0;        for(int i = 0;i &lt; n;i++)&#123;            for(int j = 0;j &lt; n;j++)&#123;                pii a = &#123;bomb[i][0],bomb[i][1]&#125;,b = &#123;bomb[j][0],bomb[j][1]&#125;;                int r1 = bomb[i][2],r2 = bomb[j][2];                ld d = dis(a,b);                if(r1 &gt;= d)E[i].push_back(j);                if(r2 &gt;= d)E[j].push_back(i);            &#125;        &#125;        for(int i = 0;i &lt; n;i++)&#123;            fill(vis,vis+105,0);            sum = 1;            dfs(i);            ans = max(ans,sum);        &#125;        return ans;    &#125;&#125;;\nå»¶ä¼¸å•é¡Œ\nçµ¦å®šå¹³é¢ä¸ŠNå€‹é»ï¼Œå•ä¸€æ¢ç›´ç·šæœ€å¤šèƒ½ç©¿è¶Šå¹¾å€‹é»\nç·šæ®µç›¸äº¤åº§æ¨™\nçµ¦ä½ ä¸€å€‹ç·šæ®µåŠä¸€å€‹åœ“ï¼Œåˆ¤æ–·åœ“è·Ÿç·šæ®µçš„æœ€çŸ­è·é›¢\nçµ¦ä½ ä¸€å€‹ä¸‰è§’å½¢ï¼ˆå…¶ä¸­ä¸€é ‚é»ç‚ºåœ“å¿ƒï¼‰å’Œåœ“å½¢ï¼Œæ±‚å‡ºå…©è€…çš„äº¤é›†é¢ç©\nå…©åœ“äº¤é»\nåœ“è·Ÿå¤šé‚Šå½¢äº¤é›†é¢ç©\næœ€å°åŒ…è¦†åœ“\nåŠå¹³é¢äº¤\nBentleyâ€“Ottmann Algorithm\nVoronoi Diagram\nDelaunay Triangulation\n\n","categories":["C++é€²éšä¸»é¡Œ","è¨ˆç®—å¹¾ä½•"],"tags":["è¨ˆç®—å¹¾ä½•"]},{"title":"ä¸‰é–€å•é¡Œï¼ˆMonty Hall Problemï¼‰","url":"/monty-hall/","content":"ä¸‰é–€å•é¡Œï¼Œæˆ–è’™æéœçˆ¾å•é¡Œæ˜¯ä¸€å€‹é•åç›´è¦ºçš„æ¢ä»¶æ©Ÿç‡å•é¡Œï¼Œæœ¬æ–‡å°‡å¾ä¸åŒè§’åº¦åˆ‡å…¥ï¼Œæ¢è¨ä¸åŒé¸æ“‡çš„æ©Ÿç‡å¤§å°ã€‚\nå•é¡Œæ•˜è¿°è³‡æ–™ä¾†æºå½±ç‰‡ç¶²å€åœ¨ 2008 å¹´ä¸Šæ˜ çš„ç¾åœ‹é›»å½±ã€Šæ±ºå‹21é»ã€‹ä¸­ï¼ŒåŠ‡ä¸­ä¸»è§’ç­ (Ben Campbell)åœ¨éç·šæ€§ä»£æ•¸çš„èª²å ‚ä¸Šèˆ‡æˆèª²æ•™æˆç±³å¥‡(Mickey Rosa) æœ‰ä¸€æ®µç²¾å½©çš„å°è©±ï¼š\n\nç±³å¥‡ï¼šã€Œå‡è¨­ä½ æ­£åƒåŠ ä¸€å€‹éŠæˆ²ç¯€ç›®ï¼Œä½ æœ‰æ©Ÿæœƒå¾ä¸‰æ‰‡ä¸åŒçš„é–€è£¡é¸ä¸€æ‰‡ï¼Œå…¶ä¸­ä¸€æ‰‡é–€å¾Œé¢æœ‰ä¸€è¼›æ–°è»Šï¼Œå¦å¤–å…©æ‰‡é–€å¾Œé¢å„æœ‰ä¸€é ­å±±ç¾Šï¼Ÿä½ è¦é¸æ“‡å“ªä¸€æ‰‡é–€ï¼Ÿã€\nç­ï¼š  ã€Œä¸€è™Ÿé–€ã€‚ã€\nç±³å¥‡ï¼šã€Œå¥½ï¼é€™æ™‚ç¯€ç›®ä¸»æŒäººï¼Œé †ä¾¿ä¸€æï¼Œä»–çŸ¥é“é–€å¾Œçš„ç§˜å¯†ï¼Œä»–å»æ‰“é–‹å¦ä¸€æ‰‡é–€ï¼Œæ¯”æ–¹èªªä»–é–‹äº†ä¸‰è™Ÿé–€ï¼Œå¾Œé¢æ˜¯ä¸€é ­å±±ç¾Šã€‚é€™æ™‚ç¯€ç›®ä¸»æŒäººèªªï¼šã€Œç­ï¼Œä½ æƒ³è¦å …æŒé¸æ“‡ä¸€è™Ÿé–€ï¼Œé‚„æ˜¯æ›æˆäºŒè™Ÿé–€ï¼Ÿã€ç¾åœ¨å•é¡Œæ˜¯â€“æ”¹è®Šé¸æ“‡(æ›å¦ä¸€æ‰‡é–€)æ˜¯å¦å°ä½ æœ‰åˆ©?ã€\nç­ï¼š  ã€Œæ˜¯çš„ã€\nç±³å¥‡ï¼šã€Œè¨˜ä½ï¼ä¸»æŒäººçŸ¥é“é‚£è¼›è»Šåœ¨å“ªè£¡ï¼Œä½ æ€éº¼çŸ¥é“ä»–ä¸æ˜¯åœ¨è€ä½ ï¼Ÿâ€¦â€¦ã€\nç­ï¼š  ã€Œæˆ‘ä¸¦ä¸ä»‹æ„ï¼Œå› ç‚ºæˆ‘çš„ç­”æ¡ˆæ˜¯åŸºæ–¼çµ±è¨ˆå­¸ï¼Œâ€¦â€¦ï¼Œç•¶ä¸€é–‹å§‹ä»–è®“æˆ‘é¸ä¸€æ‰‡é–€æ™‚ï¼Œæˆ‘æœ‰ 33.3% çš„æ©Ÿç‡æ˜¯é¸å°çš„ï¼Œä½†ç•¶ä»–é–‹å…¶ä¸­ä¸€æ‰‡é–€æ™‚ï¼Œç„¶å¾Œåˆè®“æˆ‘é¸æ™‚ï¼Œæ­¤åˆ»å¦‚æœæˆ‘é¸æ“‡æ›ä¸€æ‰‡é–€ï¼Œé¸å°çš„æ©Ÿç‡æ˜¯ 66.7%ï¼Œâ€¦â€¦ã€‚ã€\n\næ›å¥è©±èªªï¼Œå‡è¨­ä½ æ­£åœ¨åƒåŠ ä¸€å€‹æ¸¸æˆ²ç¯€ç›®ï¼Œä½ è¢«è¦æ±‚åœ¨ä¸‰æ‰‡é–€ä¸­é¸æ“‡ä¸€æ‰‡ï¼šå…¶ä¸­ä¸€æ‰‡å¾Œé¢æœ‰ä¸€è¼›è»Šï¼›å…¶é¤˜å…©æ‰‡å¾Œé¢å‰‡æ˜¯å±±ç¾Šã€‚ä½ é¸æ“‡äº†ä¸€é“é–€ï¼Œå‡è¨­æ˜¯ä¸€è™Ÿé–€ï¼Œç„¶å¾ŒçŸ¥é“é–€å¾Œé¢æœ‰ä»€éº¼çš„ä¸»æŒäººï¼Œé–‹å•Ÿäº†å¦ä¸€æ‰‡å¾Œé¢æœ‰å±±ç¾Šçš„é–€ï¼Œå‡è¨­æ˜¯ä¸‰è™Ÿé–€ã€‚ä»–ç„¶å¾Œå•ä½ ï¼šã€Œä½ æƒ³é¸æ“‡äºŒè™Ÿé–€å—ï¼Ÿã€è½‰æ›ä½ çš„é¸æ“‡å°ä½ ä¾†èªªæ˜¯ä¸€ç¨®å„ªå‹¢å—ï¼Ÿ\n\nç­”æ¡ˆï¼šæ›é–€è´å¾—çå“çš„æ©Ÿç‡ç‚º$\\frac{2}{3}$ï¼Œä¸æ›é–€ç‚º$\\frac{1}{3}$ï¼Œå› æ­¤æ‡‰è©²é¸æ“‡æ›é–€ï¼\né€™å€‹å•é¡Œå¯ä»¥æ“´å±•æˆNé–€å•é¡Œï¼Œä¹Ÿå°±æ˜¯ä¸»æŒäººåœ¨é–‹äº†$N-2$é“é–€ä»¥å¾Œï¼Œåˆ†ææ›é–€èˆ‡ä¸æ›é–€è´å¾—æ±½è»Šçš„æ©Ÿç‡ã€‚\næ¢ä»¶æ©Ÿç‡ï¼šè²å¼å®šç†åœ¨æ¢ä»¶æ©Ÿç‡ä¸­ï¼Œä»¥$P(A|B)$è¡¨ç¤ºåœ¨Bç™¼ç”Ÿçš„æ¢ä»¶ä¸‹Aç™¼ç”Ÿçš„æ©Ÿç‡ï¼Œå…¶å€¼ï¼š\nP(A|B)=\\frac{P(A\\cap B)}{P(B)}æˆ‘å€‘é‚„å¯ä»¥ç•«å‡ºä»¥ä¸‹æ¨¹ç‹€åœ–åšåˆ†æï¼šå‡è¨­ $A$ ç‚ºå¾—ççš„æƒ…æ³ï¼Œ$Aâ€™$ ç‚ºä¸å¾—ççš„æƒ…æ³ï¼Œ$B$ ç‚ºæ›é–€çš„æƒ…æ³ï¼Œ$Bâ€™$ ç‚ºä¸æ›é–€çš„æƒ…æ³å¦‚æœè¦å¾—çæœƒç™¼ç”Ÿä»¥ä¸‹å…©ç¨®ç‹€æ³ï¼š\n\nä¸æ›é–€å¾—çï¼š$P(A|Bâ€™)=\\frac{\\frac{1}{6}}{\\frac{1}{6}+\\frac{1}{3}}=\\frac{1}{3}\\cong 0.33$\næ›é–€å¾—çï¼š$P(A|B)=\\frac{\\frac{1}{3}}{\\frac{1}{6}+\\frac{1}{3}}=\\frac{1}{3}\\cong 0.66$\n\nå¾è²å¼å®šå¾‹å¯ä»¥å¾—åˆ°ï¼Œæ›é–€çš„æ©Ÿç‡æ¯”è¼ƒé«˜ï¼\nçª®èˆ‰æ³•ï¼ˆåˆ—è¡¨è§€å¯Ÿï¼‰æˆ‘å€‘ä¹Ÿå¯ä»¥é€éåˆ—è¡¨å¾—åˆ°ç›¸åŒçš„çµè«–ï¼Œåœ¨ä¸‹è¡¨ä¸­å‡è¨­ã€Œé¸ä¸­ã€ç‚ºåƒèˆ‡è€…ç¬¬ä¸€æ¬¡é¸ä¸­çš„é–€ï¼Œã€Œé–‹é–€ã€å‰‡æ˜¯ä¸»æŒäººæ‰“é–‹çš„æœ‰å±±ç¾Šçš„é–€ï¼Œã€Œæ›é–€ã€å‰‡æ˜¯å‰©ä¸‹çš„é‚£å€‹é–€\né€™é‚Šå¯èƒ½æœƒæœ‰ä¸€å€‹ç–‘æƒ‘ï¼ˆå¦‚æœæ²’æœ‰é‚£ä¸è¦ç†æˆ‘XDï¼‰ï¼šç•¶æˆ‘ç¬¬ä¸€æ¬¡é¸ä¸­æœ‰è»Šçš„é–€æ™‚ç‚ºä»€éº¼åªæœ‰åˆ—ä¸€æ¬¡ï¼Œä¸»æŒäººä¸æ˜¯å¯ä»¥é¸æ“‡æ‰“é–‹å…©å€‹æœ‰å±±ç¾Šçš„é–€å…¶ä¸­ä¸€å€‹ï¼Œä¸æ‡‰æ˜¯å…©ç¨®ç‹€æ³ï¼Ÿ\nåªæœ‰ä¸€ç¨®æ˜¯å› ç‚ºå¾Œé¢æœ‰è»Šçš„é–€è§€çœ¾åªæœƒé¸åˆ°ä¸€æ¬¡ï¼Œä¸åƒå±±ç¾Šè§€çœ¾å¯ä»¥é¸å…©æ¬¡ï¼Œä¸¦ä¸”ä¸»æŒäººæ‰“é–‹å“ªä¸€é“é–€å¯¦éš›æ˜¯æ²’æœ‰å½±éŸ¿ï¼Œéƒ½è¦–ç‚ºåŒä¸€ç¨®ç‹€æ³ï¼\n\n\n\n\næ–°è»Š\nå±±ç¾Š\nå±±ç¾Š\nçµæœ\n\n\n\n\né¸ä¸­\né–‹é–€\næ›é–€\nä¸æ›é–€è´\n\n\næ›é–€\né¸ä¸­\né–‹é–€\næ›é–€è´\n\n\næ›é–€\né–‹é–€\né¸ä¸­\næ›é–€è´\n\n\n\n\nå¾ä¸Šè¡¨å¯ä»¥æ¸…æ¥šçœ‹å‡ºï¼Œæ›é–€ä¹‹å¾Œè´çš„æ©Ÿæœƒæ˜¯$\\frac{2}{3}$ï¼Œä¸æ›é–€å‰‡æ˜¯$\\frac{1}{3}$ã€‚\nç›´è¦ºæƒ³æ³•éŒ¯èª¤æƒ³æ³•-é²åˆ°æ³•æœ‰äº›äººæœƒå•ï¼šç•¶æˆ‘å¾ä¸‰é“é–€é¸å®Œä¹‹å¾Œï¼Œä¸»æŒäººæ‰“é–‹äº†ä¸€æ‰‡é–€ã€‚é€™æ™‚å€™æˆ‘è«‹å¦å¤–ä¸€å€‹å ´å¤–äººä¾†çœ‹ç¾åœ¨çš„å±€é¢ï¼šå…©æ‰‡é–€é—œé–‰ï¼Œä¸€æ‰‡é–€æ‰“é–‹æ˜¯å±±ç¾Šï¼Œé‚£é€™æ™‚å€™é€™å€‹å±€å¤–äººé¸ä¸­çš„æ©Ÿæœƒä¸å°±æ˜¯$\\frac{1}{2}$ï¼Ÿ\né€™å€‹æ¨è«–å…¶å¯¦æ˜¯æ­£ç¢ºçš„ï¼Œä»¥ä¸€å€‹å±€å¤–äººçœ‹åˆ°çš„æƒ…æ³èˆ‡æ©Ÿç‡ç¢ºå¯¦æ˜¯$\\frac{1}{2}$ï¼Œä½†é€™æ¨£çš„æ€è€ƒå‰ææ˜¯éŒ¯èª¤çš„ï¼Œå› ç‚ºé€™ä½å±€å¤–äººä¸¦æ²’æœ‰åƒèˆ‡ä¸€é–‹å§‹ä¸‰é–€çš„é¸æ“‡ï¼æ¢ä»¶æ©Ÿç‡æœ‰ä¸€å€‹é‡è¦çš„æ¦‚å¿µï¼Œä¹Ÿå°±æ˜¯ä¸€å€‹äº‹ä»¶çš„æ©Ÿï¥¡æœƒéš¨è‘—æƒ…å¢ƒçš„ï¥§åŒï¼ˆæä¾›è¨Šæ¯çš„æ”¹è®Šï¼‰è€Œå¯èƒ½æœƒæœ‰æ‰€æ”¹è®Šï¼Œé€™å°±æ˜¯ä¸€å€‹å¾ˆæ˜é¡¯çš„ä¾‹å­\nå¹«åŠ©ç†è§£çš„æ€è€ƒæ–¹æ³•\n1990 å¹´ 9 æœˆ 9 æ—¥ï¼Œç‘ªéº—è“®â€§æ²ƒæ–¯â€§è–©è¬ç‰¹ (Marilyn vos Savant) åœ¨ã€Šç¹½ç´›éŠè¡Œã€‹(Parade) çš„ã€Œè«‹å•ç‘ªéº—è“®ã€å°ˆæ¬„ä¸­ï¼Œå›ç­”è®€è€…æå‡ºçš„ä¸‰é–€å•é¡Œï¼Œæ²ƒæ–¯â€§è–©è¬ç‰¹æ˜¯é‡‘æ°ä¸–ç•Œç´€éŒ„æœ€é«˜æ™ºå•† 228 çš„äººï¼Œå¥¹èªç‚ºé¸æ“‡æ›çš„å‹ç®—æ¯”è¼ƒå¤§ã€‚ç‚ºäº†èªªæœè®€è€…ï¼Œå¥¹è«‹å¤§å®¶æƒ³åƒæœ‰ 1,000,000 æ‰‡é–€ï¼Œå¥¹èªªï¼š\nä½ é¸æ“‡ 1 è™Ÿé–€ï¼Œè€Œä¸»æŒäººçŸ¥é“é–€å¾Œæœ‰ä»€éº¼ï¼Œä»–ç¸½æ˜¯é¿é–‹æœ‰ççš„é‚£æ‰‡é–€ï¼Œé™¤äº† 777,777 è™Ÿé–€å¤–ï¼ŒæŠŠåˆ¥çš„é–€éƒ½æ‰“é–‹äº†ã€‚é€™æ™‚ä½ æœƒæ¯«ä¸çŒ¶è±«åœ°æ›åˆ°å¦ä¸€æ‰‡é–€ï¼Œæ˜¯å§?ã€\n\nå¾Né“é–€ä¸­é¸æ“‡å…¶ä¸­ä¸€é“é–€ä¸­çæ©Ÿç‡$\\frac{1}{N}$ï¼Œä¸ä¸­ççš„æ©Ÿç‡ç‚º$\\frac{N-1}{N}$ï¼Œä¹Ÿå°±æ˜¯èªªæœ‰$\\frac{N-1}{N}$çš„æ©Ÿç‡æ±½è»Šåœ¨å¦å¤–$N-1$é“é–€ä¸­ã€‚é€™æ™‚å€™ä¸»æŒäººå¹«ä½ ä¸€å€‹å¤§å¿™ï¼Œä»–æ‰“é–‹äº†å…¶ä¸­æ²’æœ‰æ±½è»Šçš„$N-2$é“é–€ï¼Œä¸å°±æ˜¯å¹«åŠ©ä½ å‰”é™¤äº†ä¸å¯èƒ½é¸ä¸­çš„æƒ…æ³ï¼Œä¹Ÿå°±ä»£è¡¨æŠŠ$\\frac{N-1}{N}$çš„ä¸­çæ©Ÿç‡é›†ä¸­åœ¨å‰©ä¸‹çš„é‚£ä¸€æ‰‡é–€ä¸­ï¼\nå› æ­¤å¯ä»¥å¾—åˆ°çµè«–ï¼šåœ¨$N$é–€å•é¡Œä¸­ï¼Œå‡è¨­ä¸»æŒäººç¸½å…±æœƒæ‰“é–‹$N-2$é“é–€ï¼Œé‚£æ›é–€ä¸­ççš„æ©Ÿç‡æœƒæ˜¯$\\frac{N-1}{N}$ï¼Œä¸æ›é–€ä¸­çå‰‡æ˜¯$\\frac{1}{N}$\nç¨‹å¼å¯¦ä½œï¼šä»¥C++æ¨¡æ“¬å¦‚æœä¸Šé¢çš„æ±è¥¿éƒ½ç„¡æ³•èªªæœä½ ï¼Œé‚£å°±ä¾†å¯«ä¸€å€‹ç¨‹å¼æ¨¡æ“¬å§ï¼å¯«ç¨‹å¼æœ€é‡è¦çš„å°±æ˜¯è¦è­‰æ˜æ¨¡æ“¬æ˜¯æ­£ç¢ºçš„ï¼Œå› æ­¤æœƒå°å‡ºè‹¥å¹²çµ„çµæœçœ‹çœ‹æ˜¯å¦åˆç†ï¼é€™å€‹ç¨‹å¼æœƒäº‚æ•¸å¹«è§€çœ¾é¸ä¸€æ‰‡é–€ï¼ˆéš¨æ©Ÿé¸ï¼‰ï¼Œèˆ‡ä¸­ççš„é–€ï¼ˆä¹Ÿæ˜¯éš¨æ©Ÿé¸ï¼‰ï¼Œæ¥è‘—ä¸»æŒäººæ‰“é–‹é–€å¾Œæœƒå‰©ä¸‹è§€çœ¾é¸çš„èˆ‡ä¸€å€‹é‚„æ²’æœ‰è¢«é–‹çš„é–€\nä¸»æŒäººæ‰“é–‹N-2é“é–€ï¼ˆå‰©2é“é–€åšé¸æ“‡ï¼‰æˆ‘å€‘å–$N=3$ åšä¾‹å­ï¼ˆç•¶ç„¶ä¹Ÿå¯ä»¥éš¨æ„è¼¸å…¥ï¼‰ï¼Œç¬¬ä¸€å€‹3è¡¨ç¤ºé–€çš„æ•¸é‡ï¼Œæ¥ä¸‹ä¾†çš„100000è¡¨ç¤ºæ¨¡æ“¬æ¬¡æ•¸\nå°å‡ºå‰äº”æ¬¡çš„æ¨¡æ“¬æƒ…æ³ä½œè§€å¯Ÿï¼Œé€™å€‹ç¨‹å¼åœ¨å°å‡ºæœªä¸­çæ™‚ï¼Œæ›é–€ä¸­ççš„äº‹ä»¶åŠ ä¸€ï¼›åä¹‹ï¼Œå°å‡ºä¸­çæ™‚ï¼Œä¸æ›é–€ä¸­ççš„äº‹ä»¶åŠ ä¸€ï¼Œæ¨¡æ“¬çµæœç¬¦åˆé æœŸï¼\nå¦‚æœå…±æœ‰10é“é–€ï¼Œä¸€æ¨£ç¬¦åˆé æœŸï¼Œæ›é–€ä¸­çæ©Ÿç‡è½åœ¨$\\frac{9}{10}$å·¦å³\nä¸»æŒäººæ‰“é–‹Ké“é–€ï¼ˆå‰©N-Ké“é–€åšé¸æ“‡ï¼‰å¦‚æœçµ¦å€‹è®ŠåŒ–é¡Œï¼Œä¸»æŒäººæƒ³èªªä¸è¦å°è§€çœ¾é‚£éº¼å¥½ï¼Œåœ¨æœªè¢«è§€çœ¾é¸ä¸­çš„$N-1$ é“é–€ä¸­é–‹å•ŸKé“å¾Œé¢æœ‰ç¾Šçš„é–€ã€‚æˆ‘å€‘çŸ¥é“æœƒæœ‰$\\frac{N-1}{N}$çš„æ©Ÿç‡æœƒåœ¨ä¸æ˜¯è§€çœ¾é¸çš„å¦å¤–$N-1$é“é–€ä¸­ï¼Œä½†åœ¨é€™$N-1$é“é–€ä¸­å› ç‚ºæ‰“é–‹äº†$K$é“é–€ï¼Œå‰©ä¸‹$N-1-K$é“é–€å¯ä»¥é¸æ“‡ï¼Œå› æ­¤å¯ä»¥åˆ—å‡ºä»¥ä¸‹å¼å­ï¼š\n\\frac{N-1}{N}\\times \\frac{1}{N-K-1}=\\frac{N-1}{N^2-NK-1}é€™å°±æ˜¯æ›é–€ä¸­ççš„æ©Ÿç‡ï¼\næˆ‘å€‘å¯ä»¥å°‡æ›é–€ä¸­ççš„æ©Ÿç‡æ‰£æ‰ä¸æ›é–€ä¸­ççš„æ©Ÿç‡ï¼š\n\\begin{split}\\frac{1}{N}\\cdot \\frac{N-1}{N-K-1}-\\frac{1}{N} &=\\frac{1}{N}(\\frac{N-1}{N-K-1}-1) \\\\&= \\frac{1}{N}\\cdot\\frac{K}{N-K-1}\\end{split}å·²çŸ¥$N-K\\geq2$ ä¸”$K\\geq0$ï¼Œå› æ­¤ç„¡è«–é–‹å¤šå°‘é–€ï¼ˆç”šè‡³ä¸é–‹ï¼‰ï¼Œæ›é–€çš„ä¸­çæ©Ÿç‡æ°¸ä¸å°æ–¼ä¸æ›é–€çš„æ©Ÿç‡ï¼\nä»¥ä¸Šç‚ºè¨­å®š9å€‹é–€ï¼Œä¸»æŒäººæ‰“é–‹5é“é–€ï¼ŒåŸ·è¡Œä¸€ç™¾è¬æ¬¡çš„çµæœã€‚æ ¹æ“šä¸Šé¢çš„å…¬å¼ï¼Œæˆ‘å€‘é æœŸæœƒæœ‰$\\frac{8}{27}\\cong 0.2963$çš„æ©Ÿç‡æ›äº†æœƒä¸­çï¼Œç¬¦åˆæ¨¡æ“¬çš„çµæœ\næœ‰aè¼›è»Šï¼Œä¸»æŒäººé–‹Ké“é–€é€™å°±æ¯”è¼ƒç°¡å–®äº†ï¼ŒåŸæœ¬åªæœ‰1è¼›è»Šï¼Œè®Šæˆaè¼›è»Šè‡ªç„¶ä¸­ççš„æ©Ÿç‡å°±æœƒè®Šaå€ï¼Œå¥—ç”¨ä¸Šé¢çš„å…¬å¼ï¼Œæ›é–€ä¸­çæ©Ÿç‡ï¼š\n\\frac{a\\cdot(N-1)}{N^2-NK-1}ç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;using namespace std;int selected_door,selected[1000000],make_change=0,keep=0,N,M,open;int main()&#123;    cin&gt;&gt;N&gt;&gt;open&gt;&gt;M; //è¼¸å…¥é–€çš„æ•¸é‡Nï¼Œä¸»æŒäººé–‹é–€æ•¸openï¼Œæ¨¡æ“¬æ¬¡æ•¸M    srand((unsigned)time(NULL));    for(int i=0;i&lt;M;i++)&#123;            //åŸ·è¡ŒMæ¬¡        selected_door = rand()%N;    //é¸æ“‡ä¸€å€‹é–€æ”¾æ±½è»Š        for(int j=0;j&lt;N;j++)&#123;          if(j==selected_door)selected[j]=1;          else selected[j]=0;        &#125;        int audience_selected = rand()%N; //è§€çœ¾é¸æ“‡ä¸€å€‹é–€        for(int j=0,ind=0;j&lt;open;ind++)&#123; //å°‡Kæ‰‡é–€æ‰“é–‹          if(ind!=audience_selected &amp;&amp; ind!=selected_door)&#123;              selected[ind]=2;              j++;          &#125;        &#125;        int change_door = 0; //è¦æ›åˆ°çš„é–€        vector&lt;int&gt;vec; //å¯ä»¥æ›çš„é¸æ“‡        vec.clear();        for(int j=0;j&lt;N;j++)&#123;          if(j!=audience_selected &amp;&amp; selected[j]!=2)&#123;              vec.push_back(j);          &#125;        &#125;        int vec_size = vec.size();        change_door = vec[(rand()%vec_size)];        if(change_door == selected_door)make_change++; //ç´€éŒ„æ›è€Œè´çš„æ¬¡æ•¸        else if(audience_selected == selected_door)keep++; //ç´€éŒ„ä¸æ›è€Œè´çš„æ¬¡æ•¸        if(i&lt;4)&#123;          cout&lt;&lt;&quot;ç¬¬&quot;&lt;&lt;i+1&lt;&lt;&quot;æ¬¡æ¨¡æ“¬&quot;&lt;&lt;endl;          cout&lt;&lt;&quot;è§€çœ¾é¸æ“‡ï¼š&quot;&lt;&lt;audience_selected+1&lt;&lt;&quot; è™Ÿé–€&quot;&lt;&lt;endl;          cout&lt;&lt;&quot;ä¸­ççš„é–€ç‚ºï¼š&quot;&lt;&lt;selected_door+1&lt;&lt;&quot; è™Ÿé–€&quot;&lt;&lt;endl;          cout&lt;&lt;&quot;æ²’æœ‰è¢«ä¸»æŒäººæ‰“é–‹çš„é–€ï¼š&quot;;          for(int j=0;j&lt;vec_size;j++)cout&lt;&lt;vec[j]+1&lt;&lt;&quot;è™Ÿé–€,&quot;;          cout&lt;&lt;endl&lt;&lt;&quot;è§€çœ¾é¸æ“‡è¦æ›çš„é–€ç‚ºï¼š&quot;&lt;&lt;change_door+1&lt;&lt;&quot; è™Ÿé–€&quot;&lt;&lt;endl;          if(audience_selected == selected_door)cout&lt;&lt;&quot;ä¸æ›é–€ä¸­ç&quot;&lt;&lt;endl;          else if(change_door == selected_door)cout&lt;&lt;&quot;æ›é–€ä¸­ç&quot;&lt;&lt;endl;          else cout&lt;&lt;&quot;æ›é–€ä¸æ›é–€çš†ä¸æœƒä¸­ç&quot;&lt;&lt;endl;          cout&lt;&lt;endl;        &#125;    &#125;    cout&lt;&lt;fixed&lt;&lt;setprecision(5);    //å°å‡ºæ©Ÿç‡    cout&lt;&lt;&quot;ä¸æ›é–€è´çš„æ©Ÿç‡ï¼š&quot;&lt;&lt;(double)keep/M&lt;&lt;endl;    cout&lt;&lt;&quot;æ›äº†é–€è´çš„æ©Ÿç‡ï¼š&quot;&lt;&lt;(double)make_change/M&lt;&lt;endl;&#125;\nè­¦å¯ŸæŠ“é…’é¬¼å•é¡Œé€™å€‹å•é¡Œå¯ä»¥ç”¨ä¾†æ¯”è¼ƒä¸€ä¸‹ä¸‰é–€å•é¡Œï¼š\n\næŸé…’é¬¼æœ‰90%çš„æ—¥å­éƒ½æœƒå‡ºå»å–é…’ï¼Œå–é…’åªéš¨æ©Ÿå»å›ºå®šçš„ä¸‰å®¶é…’å§ã€‚ä»Šå¤©è­¦å¯Ÿæ‰¾äº†å…¶ä¸­å…©å®¶é…’å§éƒ½æ²’æœ‰æ‰¾åˆ°é…’é¬¼ã€‚å•ï¼šé…’é¬¼åœ¨ç¬¬ä¸‰å®¶é…’å§çš„æ©Ÿç‡ï¼Ÿ\n\næˆ‘å€‘å‡è¨­äº‹ä»¶$A_1$ç‚ºé…’é¬¼å–é…’çš„æ©Ÿç‡ã€$A_2$ç‚ºé…’é¬¼åœ¨å®¶çš„æ©Ÿç‡ï¼Œ$B_1$ç‚ºé…’é¬¼åœ¨å‰å…©å€‹é…’å§è¢«æŠ“çš„æ©Ÿç‡ã€$B_2$ç‚ºé…’é¬¼æ²’æœ‰åœ¨å‰å…©å€‹é…’å§è¢«æŠ“çš„æ©Ÿç‡\næˆ‘å€‘è¦æ‰¾çš„æ˜¯é…’é¬¼æ²’æœ‰åœ¨å‰å…©å€‹é…’å§è¢«æŠ“çš„æ¢ä»¶ä¸‹å–é…’çš„æ©Ÿç‡ï¼Œå¯ä»¥å¥—ç”¨è²æ°å®šç†ï¼š\n\\begin{split}P(A_1|B_2)&=\\frac{P(A_1\\cap B_2)}{P(B_2)}\\\\&=\\frac{P(A_1)\\cdot P(B_2|A_1)}{P(A_1)\\cdot P(B_2|A_1)+{P(A_2)\\cdot P(B_2|A_2)}}\\\\&=\\frac{\\frac{9}{10}\\times\\frac{1}{3}}{\\frac{9}{10}\\cdot\\frac{1}{3}+\\frac{1}{10}\\times 1} \\\\&=\\frac{3}{4}=0.75\\end{split}æ­£è§£æ˜¯75%ï¼Œä¹Ÿå¯ä»¥é¡¯è€Œæ˜“è¦‹çš„ç”¨$\\frac{30\\%}{30\\%+10\\%}=75\\%$å¾—åˆ°ç­”æ¡ˆ\né€™é¡Œæƒ³è¦è¨è«–çš„æ˜¯ï¼Œåœ¨ä¸‰é–€å•é¡Œä¸­ï¼Œä¸»æŒäººæ˜¯çŸ¥é“å“ªä¸€äº›é–€æ˜¯æ²’æœ‰æ±½è»Šçš„ï¼Œæ‰€ä»¥æ•…æ„æ‰“é–‹ï¼›ä½†æ˜¯åœ¨é€™å€‹å•é¡Œä¸­ï¼Œè­¦å¯Ÿæ˜¯ä¸çŸ¥é“å“ªä¸€å€‹é…’å§æœ‰é…’é¬¼ï¼Œå…©é¡Œæœ¬èº«çš„å‰æå°±ä¸åŒï¼Œä¸èƒ½æ‹¿ä¾†äº’ç›¸è§£é‡‹\nçµè«–åœ¨åˆ†æå®Œä¸‰é–€å•é¡Œã€ç¨‹å¼å¯¦éš›æ¨¡æ“¬å’Œæ¯”è¼ƒå…¶ä»–é¡Œç›®ä¹‹å¾Œï¼Œå¾—åˆ°ä¸€å€‹çµè«–ï¼šä¸‰é–€å•é¡Œä¸­ä¸»æŒäººä¸¦ä¸æ˜¯äº‚é¸ï¼Œè€Œæ˜¯æŠŠæ²’æœ‰è»Šçš„é‚£äº›é–€æ‰“é–‹ï¼Œé€™è·Ÿå¹³å¸¸ç›´è¦ºçš„æ©Ÿç‡æƒ³æ³•æ˜¯ä¸åŒçš„ï¼\né›–ç„¶å°å¤§å¤šæ•¸äººçš„ç›´è¦ºåæ‡‰è€Œè¨€ï¼Œé¸æ“‡æ›é–€èˆ‡ä¸æ›é–€ä¼¼ä¹ä¸­ççš„æ©Ÿç‡æ˜¯ç›¸åŒçš„ï¼Œä½†ç¶“éä¸Šè¿°ä¸€é€£ä¸²åˆ©ç”¨è²æ°å®šç†çš„è¨è«–èˆ‡æ­¸ç´å¾Œï¼Œè­‰å¯¦äº†åè€Œæ›é–€æ‰æ˜¯æœ€æ˜æ™ºçš„é¸æ“‡ã€‚ã€Œäººçš„èªçŸ¥æœ‰å…©ç¨®ï¼Œä¸€æ˜¯å…ˆé©—çš„å¤å…¸æ©Ÿç‡ï¼Œä¸€æ˜¯ç¶“é©—çš„æ©Ÿç‡ï¼Œå‰è€…æœƒå¹²æ“¾å¾Œè€…ï¼›é´¿å­åªæœ‰å¾Œè€…ï¼Œåœ¨è’™æéœçˆ¾å•é¡Œä¸Šï¼Œé«˜äººä¸€ç±Œã€‚äººå…¶å¯¦æ˜¯è°æ˜åè¢«è°æ˜èª¤ã€‚ã€(æ›¾å¿—æœ—ï¼Œ2012)\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","2021æš‘æœŸç­†è¨˜"]},{"title":"æœ€è¿‘é»å°ï¼šè©³è§£4ç¨®ä¸åŒè¤‡é›œåº¦ä¹‹ç®—æ³•","url":"/pair/","content":"\né¡Œç›®æ•˜è¿°çµ¦å®šäºŒç¶­å¹³é¢ä¸Š $n$ å€‹é»ï¼Œæ¯ä¸€é»éƒ½æœ‰åº§æ¨™ $(x_i,y_i)$ ï¼Œæ±‚å‡ºæœ€è¿‘çš„é»å°ä¹‹æ­å¹¾é‡Œå¾·è·é›¢ç‚ºå¤šå°‘ï¼Ÿ$dis(p_i,p_j) = \\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$\n\nå¹³é¢æœ€è¿‘é»å°æœ‰å¥½å¤šç¨®å¯¦ä½œæ–¹å¼ï¼Œå¾æœ€å·®çš„æš´åŠ›æšèˆ‰ã€ç¨å¾®å„ªåŒ–çš„æƒæç·šæ¼”ç®—æ³•ã€åˆ°åˆ†æ²»èˆ‡éš¨æ©Ÿï¼Œæœ‰4ç¨®ä¸åŒçš„æ™‚é–“è¤‡é›œåº¦ã€‚åˆ©ç”¨TIOJ 1500é€™ä¸€é¡Œæœ€è¿‘é»å°çš„è£¸é¡Œï¼Œä¾†å¯¦æ¸¬å„ç¨®ä¸åŒè¤‡é›œåº¦ä¸‹æ‰€éœ€è¦çš„åŸ·è¡Œæ™‚é–“ã€‚\næš´åŠ›æšèˆ‰æ™‚é–“è¤‡é›œåº¦ï¼š$O(N^2)$Submissionæ™‚é–“ï¼šTLE,10440\n\næš´åŠ›$O(n^2)$å°‡æ‰€æœ‰é»é€²è¡Œæšèˆ‰ï¼Œå› ç‚ºå€¼åŸŸæ˜¯ $nâ‰¤50000$ ï¼Œå¹³æ–¹æšèˆ‰æœƒæœ‰TLEçš„å•é¡Œã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\næƒæç·šç®—æ³•æ™‚é–“è¤‡é›œåº¦ï¼šWorst Case $O(N^2)$Submissionæ™‚é–“ï¼šAC,1668\né€™ä¸€ç¨®ä½œæ³•æ˜¯æ”¹å–„éå¾Œçš„æš´åŠ›æšèˆ‰ï¼Œåˆ©ç”¨è¨ˆç®—å¹¾ä½•ä¸­æƒæç·šçš„æ¦‚å¿µï¼Œå…ˆå°‡æ‰€æœ‰é»ä¾ç…§xåº§æ¨™é€²è¡Œæ’åºï¼ˆyåº§æ¨™éš¨æ„ï¼‰ã€‚æ¥è‘—æƒ³åƒä¸€æ¢å¾å·¦å¾€å³æƒçš„æƒæç·šï¼Œå°æ–¼æ¯ä¸€æ¢æƒæç·šçœ‹å³é‚Šçš„é»ï¼Œå¦‚æœç•¶å‰æœ€è¿‘é»å°è·é›¢ç‚º $d$ï¼Œå› æ­¤åªè¦é‡ä¸Šxåº§æ¨™å·®è·å¤§æ–¼ $d$ çš„é»æ™‚ï¼Œå³å¯ç¹¼çºŒä¸‹ä¸€è¼ªçš„æšèˆ‰ã€‚\nåŠ ä¸Šæ’åºçš„é—œä¿‚ï¼Œå…¶æ™‚é–“è¤‡é›œåº¦è‡³å°‘ç‚º $O(n\\log n)$ï¼Œä½†é€™ç¨®æƒæç·šçš„æ–¹å¼ç„¡æ³•æœ‰æ•ˆéæ¿¾æ‰€æœ‰é»éƒ½åœ¨ç›¸åŒçš„xåº§æ¨™ä¸Šçš„æƒ…æ³ï¼Œå› æ­¤æœ€å·®çš„æ™‚é–“è¤‡é›œåº¦æœƒé€€åŒ–æˆ $O(n^2)$ ï¼Œä¸éè½èªªå¹³å‡çš„ç‹€æ³ä¸‹æ˜¯å¾ˆå¿«çš„ï¼\n\nä¸Šåœ–ç‚ºæƒæç·šåŸ·è¡Œæœ€è¿‘é»å°çš„ä¸€å€‹ç¤ºæ„åœ–ï¼Œé»‘ç·šç‚ºæƒæç·šï¼Œ$d$ ç‚ºæƒæç·šå·¦é‚Šæ‰€æœ‰é»çš„æœ€è¿‘é»å°è·é›¢ï¼Œæˆ‘å€‘åªè¦æ¯ä¸€è¼ªæšèˆ‰é€™å€‹é»èˆ‡å³é‚Šxåº§æ¨™å·®åœ¨ $d$ ä»¥å…§çš„æ‰€æœ‰é»ï¼Œå³å¯é€²è¡Œä¸‹ä¸€è¼ªçš„æ›´æ–°ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 50005#define all(x) x.begin(),x.end()#define INF 5e18#define eps 1e-9#define x first#define y secondusing namespace std;int n;pii p[N];ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    Orz;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);        while(cin&gt;&gt;n)&#123;        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p,p+n);        ld d = INF;        rep(i,0,n-1)&#123;            rep(j,i+1,n-1)&#123;                if(p[j].x &gt; p[i].x + d)break;                d = min(d, dis(p[i],p[j]));            &#125;        &#125;        cout&lt;&lt;d&lt;&lt;endl;    &#125;&#125;\næƒæç·šç®—æ³•ï¼ˆå„ªåŒ–å¾Œï¼‰æ™‚é–“è¤‡é›œåº¦ï¼š$O(N\\log N)$Submissionæ™‚é–“ï¼šAC,148\nåŸæœ¬ä»¥ç‚ºä¸Šé¢çš„æƒæç·šå°±æ˜¯ä»–çš„æ¥µé™äº†ï¼Œæ²’æƒ³åˆ°ä¸Šé¢çš„worst caseé‚„å¯ä»¥é€ésetå„ªåŒ–æˆ $O(n\\log n)$ï¼ç°¡å–®ä¾†èªªï¼Œæ–¹æ³•ä¸€æ¨£æ˜¯æƒ³åƒä¸€æ¢æƒæç·šç”±å·¦è€Œå³ï¼Œä¸€æ¨£ç…§ä¸Šé¢çš„æƒ³æ³•ï¼ŒæŠŠxåº§æ¨™å·®å¤§æ–¼dçš„é»æ’é™¤ï¼Œä¹‹å¾Œåˆ©ç”¨setäºŒåˆ†æœæ‰¾å‡ºyåº§æ¨™åœ¨ç¯„åœå…§çš„é»é€²è¡Œæšèˆ‰æ›´æ–°ç­”æ¡ˆã€‚\n\nå°‡é»è¼¸å…¥ä¸¦ä¸”æ’åºï¼ŒXåº§æ¨™ç‚ºä¸»ï¼ŒYåº§æ¨™ç‚ºè¼”ã€‚\nä½¿ç”¨setï¼Œä¸¦ä»¥Yåº§æ¨™ç‚ºæ’åºåŸºæº–ï¼ˆpairçš„é¦–é …ï¼‰ï¼Œä»¥å„²å­˜ç¬¬ $i$ é»çš„å·¦æ–¹ã€æ°´å¹³è·é›¢å°æ–¼ç­‰æ–¼dçš„é»ã€‚\nå³æƒæç·šä¾åºçª®èˆ‰å„é»ä½œç‚ºå³ç«¯é»ã€‚ã€€(1) Eraseèˆ‡å³ç«¯é»æ°´å¹³è·é›¢å¤§æ–¼dçš„é»å€‘ï¼ˆå·¦æƒæç·šå³ç§»ï¼‰ã€€(2) ç”¨äºŒåˆ†æœæ‰¾å‡ºèˆ‡ç¬¬ $i$ é»å‚ç›´è·é›¢å°æ–¼dçš„é»ï¼Œä¸¦å˜—è©¦æ›´æ–°ã€€(3) å°‡ç¬¬ $i$ é»åŠ å…¥setä¸­ã€‚\n\n\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define ld long double#define N 200005#define x first#define y second#define pii pair&lt;int,int&gt;#define IOS ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;vector&lt;pii&gt; p;set&lt;pii&gt; s;ld dis(pii a, pii b)&#123;    ld x = a.x-b.x, y = a.y-b.y;    return sqrt(x*x + y*y);&#125;signed main()&#123;    IOS;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    while(cin&gt;&gt;n)&#123;        p.assign(n,&#123;0,0&#125;);        for(int i = 0;i &lt; n;i++)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        s.clear();        s.insert(&#123;p[0].y,p[0].x&#125;);        int l = 0;ld ans = 5e18;        for(int i = 1;i &lt; n;i++)&#123;            int d = ceil(ans);            while(l &lt; i &amp;&amp; p[l].x &lt; p[i].x - d)&#123;                s.erase(&#123;p[l].y,p[l].x&#125;);                l++;            &#125;            auto it_l = s.lower_bound(&#123;p[i].y - d,0&#125;);            auto it_r = s.upper_bound(&#123;p[i].y + d,0&#125;);            for(auto it = it_l;it != it_r;it++)&#123;                ans = min(ans,dis(&#123;it-&gt;y,it-&gt;x&#125;,p[i]));            &#125;            s.insert(&#123;p[i].y,p[i].x&#125;);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nåˆ†æ²»ç®—æ³•æ™‚é–“è¤‡é›œåº¦ï¼š$O(N\\log N)$Submissionæ™‚é–“ï¼šAC,196\n\nåˆ†æ²»åšæœ€è¿‘é»å°çš„åŸºæœ¬æƒ³æ³•ï¼Œå…ˆå°‡æ‰€æœ‰é»ä¾ç…§xåº§æ¨™æ’åºï¼Œåˆ©ç”¨éè¿´å¾—åˆ°åˆ†å‰²é»å·¦å³å…©é‚Šæ‰€æœ‰é»çš„æœ€çŸ­è·é›¢ï¼ˆå…©é»ä¸¦ä¸æœƒè·¨éä¸­é–“åˆ†éš”ç·šï¼‰ï¼Œæšèˆ‰æ‰€æœ‰æœƒæ©«è·¨å…©å´ä¸”æœ‰å¯èƒ½æ›´æ–°æœ€çŸ­è·é›¢çš„é»å°ã€‚\n\nå¾å…©åŠé‚Šçš„éè¿´å¾—åˆ°ç›®å‰çš„æœ€è¿‘é»å°è·é›¢ $d = min(d_l,d_r)$ ï¼Œå°‡åˆ†éš”ç·šé™„è¿‘xåº§æ¨™å·®è·å°æ–¼$d$çš„é»é€šé€šéƒ½æšèˆ‰ä¸€éã€‚å¯èƒ½æœƒæœ‰ä¸€å€‹ç–‘å•ï¼Œæˆ‘å€‘æ˜¯ä¸æ˜¯å¯ä»¥ç¸®å°æšèˆ‰çš„ç¯„åœï¼Œå¦å‰‡é»çš„æ•¸é‡å¯èƒ½æœƒå¤ªå¤šå°è‡´è¤‡é›œåº¦çˆ†ç‚¸ï¼Ÿé™¤äº†xåº§æ¨™å¯ä»¥åšé»çš„ç¯©é¸ä¹‹å¤–ï¼Œåœ¨æšèˆ‰çš„éç¨‹ä¸­ï¼Œæˆ‘å€‘æœƒåˆ©ç”¨å°‡æ‰€æœ‰é»å°yåº§æ¨™æ’åºï¼Œå°‡yåº§æ¨™ç›´ç·šè·é›¢å¤§æ–¼ $d$ çš„æƒ…æ³å‰”é™¤ï¼Œæ‰€å‰©ä¸‹çœŸçš„éœ€è¦æšèˆ‰é»ä¹Ÿåªæœƒå‰©ä¸‹å¸¸æ•¸å€‹ï¼Œå› æ­¤å¯ä»¥æ”¾å¿ƒæšèˆ‰ã€‚\nè¤‡é›œåº¦åˆ†æï¼š è…¦æµ·ä¸­æƒ³åƒéè¿´æ¨¹çš„é•·ç›¸ï¼Œæœƒç™¼ç¾æ¯ä¸€å±¤éƒ½éœ€è¦éƒ½éœ€è¦å°yåº§æ¨™é€²è¡Œæ’åºï¼Œæ™‚é–“ç‚º$O(n\\log n)$ ï¼Œæ¯ä¸€æ¬¡éƒ½å°‡nçš„å€¼é™¤ä»¥2ï¼Œå› æ­¤å…±æœ‰$O(\\log n)$ å±¤ï¼Œç¸½å…±çš„æ™‚é–“è¤‡é›œåº¦ç‚º $O(n\\log^2n)$ã€‚ï¼ˆä¸éå¯¦éš›ä¸Šæ‡‰è©²æœƒæ¯”é€™å€‹å¿«ï¼Œå› ç‚ºä¸¦ä¸æ˜¯è¦å°æ‰€æœ‰é»éƒ½é€²è¡Œæ’åºï¼‰ã€‚\nT(n) = 2T(\\frac{n}{2})+O(n\\log n) = O(n\\log^2n)å¦‚æœè¦åšå¾—æ›´å¿«ï¼Œå¯ä»¥åœ¨yåº§æ¨™æ’åºçš„åœ°æ–¹ç¨å¾®å‹•å‹•æ‰‹è…³ã€‚æ—¢ç„¶æ¯ä¸€å±¤éƒ½è¦å°yåº§æ¨™é€²è¡Œæ’åºï¼Œæ’åºå¥½çš„æ±è¥¿å†æ’åºä¸€æ¬¡å…¶å¯¦æ²’æœ‰ä»€éº¼æ„ç¾©ï¼Œå› æ­¤å°±å¯ä»¥ç”¨ï¼‰åˆä½µæ’åºï¼ˆmerge sortï¼‰çš„æ–¹å¼ï¼Œå°‡æ‰€æœ‰å·²ç¶“æ’åºå¥½çš„å…©å€‹å·¦å³åºåˆ—é€²è¡Œ$O(n)$çš„åˆä½µï¼ˆå¯ä»¥ç”¨std::merge()å®Œæˆï¼‰ï¼Œå¦‚æ­¤ä¸€ä¾†ï¼Œå°±ä¸é ˆè¦æ¯ä¸€å±¤èŠ±åˆ° $O(n\\log n)$ çš„ã„•ËŠé–“é€²è¡Œæ’åºï¼Œä½¿ç¸½è¤‡é›œåº¦é™ä½ç‚º $O(n\\log n)$ï¼\nT(n) = 2T(\\frac{n}{2})+O(n) = O(n\\log n)ç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 50002#define INF1 100000000#define INF 5e18#define FOR(i,n) for(int i=0;i&lt;n;i++)#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y second#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;#define pdd pair&lt;double,double&gt;using namespace std;int n;vector&lt;pii&gt; p,temp;void init()&#123;    cout&lt;&lt;fixed&lt;&lt;setprecision(6);    temp.clear();    p.assign(n,&#123;0,0&#125;);&#125;bool cmp(pii a,pii b)&#123;    return a.y &lt; b.y;&#125;double dis(pii a,pii b)&#123;    double x1 = a.x-b.x,y1 = a.y-b.y;    return sqrt(x1 * x1 + y1 * y1);&#125;//å€é–“[l,r]double solve(int l,int r)&#123;    if(l == r)return INF;    int mid = (l+r)/2,mid_pos = p[mid].x;;    double ans = min(solve(l,mid),solve(mid+1,r));        temp.assign((r-l+1),&#123;0,0&#125;);    merge(        p.begin() + l, p.begin() + mid + 1,        p.begin() + mid + 1, p.begin() + r + 1,        temp.begin(), cmp    );    rep(i, l, r)p[i] = temp[i-l];    temp.clear();    rep(i, l, r)&#123;        if(abs(p[i].x - mid_pos) &lt;= ans)&#123;            temp.push_back(p[i]);        &#125;    &#125;    int len = temp.size();    rep(i, 0, len-1)&#123;        rep(j, i+1, len-1)&#123;            ans = min(ans, dis(temp[i],temp[j]));            if(abs(temp[i].y-temp[j].y) &gt; ans)                break;        &#125;    &#125;    return ans;&#125;signed main()&#123;    Orz;    while(cin&gt;&gt;n)&#123;        init();        rep(i,0,n-1)cin&gt;&gt;p[i].x&gt;&gt;p[i].y;        sort(p.begin(),p.end());        double ans = solve(0,n-1);        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\néš¨æ©Ÿç®—æ³•æ™‚é–“è¤‡é›œåº¦ï¼šæœŸæœ› $O(N)$Submissionæ™‚é–“ï¼šAC,488\n\nç”¨éš¨æ©Ÿç®—æ³•åšæœ€è¿‘é»å°çš„æœŸæœ›è¤‡é›œåº¦æ˜¯ $O(n)$ ï¼Œä¹Ÿå°±æ˜¯èªªå¦‚æœä¸€é–‹å§‹é€²è¡Œçš„Random_shuffleæœ‰åšå¥½çš„è©±ï¼ŒæœŸæœ›å¯ä»¥åœ¨ç·šæ€§æ™‚é–“è§£æ±ºé€™å€‹å•é¡Œã€‚åŸºæœ¬çš„æƒ³æ³•å¦‚ä¸‹ï¼š\n\nå°‡æœ€è¿‘é»å°è·é›¢è¨­ç‚ºdï¼Œåˆå§‹ç‚ºç¬¬ä¸€ã€äºŒå€‹é»ä¹‹é–“çš„è·é›¢\nå°‡æ¯ä¸€å€‹é»çš„åº§æ¨™å¡å…¥ä»¥ $\\frac{d}{2}$ ç‚ºé‚Šé•·çš„ç¶²æ ¼ä¸­\nå°‡é»åŠ å…¥ç¶²æ ¼ä¸­ï¼ŒæŸ¥çœ‹è¦åŠ å…¥çš„ç¶²æ ¼æ˜¯å¦å·²ç¶“æœ‰é»åœ¨å…¶ä¸­\nä¸€å€‹ç¶²æ ¼ä¸å¯å®¹ç´å…©å€‹é»ï¼Œå¦å‰‡å¿…é ˆæ›´æ–°æœ€è¿‘é»å°çš„è·é›¢\nåœ¨æ›´æ–°æœ€è¿‘é»å°è·é›¢ä¹‹å¾Œï¼Œå°‡å‰é¢çš„é»çš„ç¶²æ ¼åº§æ¨™ä»¥æ–°çš„$d$é€²è¡Œæ›´æ–°\n\né€™å€‹ç®—æ³•ç”¨åˆ°éš¨æ©Ÿçš„å› å­ï¼Œå› æ­¤å¦‚æœåœ¨ä¸€é–‹å§‹æœ‰å°‡æ‰€æœ‰é»é€²è¡Œå‡å‹»çš„æ‰“æ•£çš„è©±ï¼Œå¯ä»¥åšåˆ°æœŸæœ›è¤‡é›œåº¦ $O(n)$ã€‚\nè¤‡é›œåº¦åˆ†æï¼šè€ƒæ…®åŠ å…¥ç¬¬i+1å€‹é»æ™‚å‡ºç¾æ–°çš„æœ€è¿‘é»å°ï¼Œç™¼ç”Ÿçš„æ©Ÿç‡ç‚ºï¼šåœ¨$C_2^{i+1}$å€‹é…å°ä¸­è·Ÿi+1å€‹é»ç”¢ç”Ÿæœ€è¿‘é»å°å…±æœ‰iç¨®å¯èƒ½å› æ­¤æ©Ÿç‡ç‚º$\\frac{2}{i+1}$ã€‚\nç•¶æ©Ÿç‡ç™¼ç”Ÿçš„æ™‚å€™ï¼Œå¿…é ˆå°‡æ‰€æœ‰çš„é»éƒ½åˆªæ‰é‡æ–°ä¾†ä¸€éï¼ˆrè®Šå°ï¼Œé‡æ–°æ¨å…¥i+1å€‹é»ï¼‰ï¼Œéœ€è¦ä»˜å‡º$O(i+1)$çš„æ™‚é–“ï¼Œç›¸ä¹˜èµ·ä¾†åŠ å…¥æ¯ä¸€å€‹é»æœŸæœ›çš„è¤‡é›œåº¦ç‚º$O(1)$ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦ç‚º$O(n)$ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long int#define ld long double#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define INF 1000000000LL#define swift 1000000000using namespace std;int n;ld r,d,ans;int dx[25] = &#123;-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2&#125;;int dy[25] = &#123;-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2&#125;;unordered_map&lt;int, int&gt; m;void solve();inline void init();void solve();bool insert(int,int,int);inline double dis(int,int);inline int Grid(int);struct node&#123;    int x,y,ind;&#125;point[N];//å‡½å¼å¯¦ä½œinline void init()&#123;    m.clear();    cout&lt;&lt;fixed&lt;&lt;setprecision(6);&#125;inline int Grid(int ind)&#123; //inputç¶²æ ¼åº§æ¨™    int x = point[ind].x/r;    int y = point[ind].y/r;    return x*INF+y;&#125;inline ld dis(node a,node b)&#123;    ld x = a.x-b.x,y = a.y-b.y;    return sqrt(x*x+y*y);&#125;void solve()&#123;    m.insert(make_pair(Grid(0),0));m.insert(make_pair(Grid(1),1));    for(int ind = 2;ind &lt; n;ind++)&#123;        int x = point[ind].x/r,y = point[ind].y/r,better=0;        for(int i=0;i&lt;25;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            auto it = m.find(nx*INF+ny);            if(it!=m.end())&#123;                double distance = dis(point[it-&gt;second],point[ind]);                if(distance&lt;d)&#123;                    better = 1;                    ans = dis(point[it-&gt;second],point[ind]);                    d = distance;                    r = d/2;                &#125;            &#125;        &#125;        if(better)&#123;            m.clear();            for(int i=0;i&lt;=ind;i++)m.insert(make_pair(Grid(i),i));        &#125;        else&#123;            m.insert(make_pair(Grid(ind), ind));        &#125;    &#125;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        init();        for(int i=0;i&lt;n;i++)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            x+=swift;y+=swift;            point[i].x = x;point[i].y = y;        &#125;        random_shuffle(point, point+n);        int smalln = sqrt(n);        ans = dis(point[0],point[1]);        d = dis(point[0], point[1]);        for(int i=0;i&lt;=smalln;i++)&#123;            for(int j=i+1;j&lt;=smalln;j++)&#123;                d = min(d,dis(point[i], point[j]));                ans = min(ans,dis(point[i],point[j]));            &#125;        &#125;        r = d/2;        solve();        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nç›¸é—œé¡Œç›®\nNEOJ æœ€è¿‘é»å°\nTIOJ æœ€é é»å°\n\n","categories":["C++é€²éšä¸»é¡Œ","æœ€è¿‘é»å°"],"tags":["åˆ†æ²»æ³•","æš‘å‡ç­†è¨˜"]},{"title":"æœ€çŸ­è·¯å¾‘ï¼ˆShortest Path Problemï¼‰","url":"/path1/","content":"ä»Šå¹´æ˜¯2021ï¼Œè³‡èŠ½çš„äºŒéšä¸»é¡Œè·Ÿ2020ä¸Šçš„æœ‰å¾ˆå¤šçš„å·®åˆ¥ï¼Œå› æ­¤æœƒåˆ©ç”¨æš‘å‡æŠŠ2020çš„æ±è¥¿ä¹Ÿè£œä¸€è£œï¼\nèª²ç¨‹å…§å®¹è·¯å¾‘èˆ‡æ¬Šé‡\n$G=(V,E)$\nå°‹æ‰¾æœ€çŸ­è·¯å¾‘æ¬Šé‡å’Œæœ€å°\nç„¡å¸¶æ¬Šï¼šBFSç›´æ¥åš(or DFS)\næœ‰å¸¶æ¬Šæœ€çŸ­è·¯å¾‘\n\n\nFloyd-Warshallï¼šå…¨é»å°æœ€çŸ­è·¯å¾‘(All Pairs)\nä¸æ”¯æ´è² ç’°\n\næƒ³æ³•ï¼šDPè½‰ç§»ï¼ˆä¸‰å€‹è¿´åœˆä¸­é»ã€èµ·é»ã€çµ‚é»ä¾åºé¬†å¼›ï¼‰\n\n$d[i][j] = mid(d[i][j],d[i][k]+d[I][k]+d[k][j])$\nå¦‚æœæ”¹å¯«æˆå®šç¾© $dp[k][i][j]$ ç‚ºé» $i$ èµ°åˆ°é» $j$ ï¼Œåªèƒ½ç¶“éå‰kå€‹é»çš„æœ€çŸ­è·¯\nå‰‡è½‰ç§»ï¼š$d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])$\nå› æ­¤ä¸­é–“é»kå¿…é ˆåœ¨æœ€å¤–å±¤ï¼ˆä¸éæœ‰è«–æ–‡æŒ‡å‡ºé †åºé¡›å€’ä¸€æ¨£å¯ä»¥å¾—åˆ°æ­£ç¢ºè§£ï¼‰\nå„ªé»ï¼šå¯¦ä½œå®¹æ˜“ï¼Œç¼ºé»ï¼šæ™‚é–“ $O(v^3)$ ã€ç„¡æ³•è™•ç†è² ç’°ï¼ˆå¯è™•ç†è² é‚Šï¼‰\n\nDijkstraâ€™sï¼šå–®é»æºæœ€çŸ­è·¯å¾‘\nå„ªé»ï¼šæ™‚é–“ $O(E+V^2)$ã€ç„¡æ³•è™•ç†è² é‚Š\n\næƒ³æ³•ï¼šGreedyï¼ˆå’ŒDPï¼‰\n\nç¶­è­·ï¼š1. æœªæ‹œè¨ªçš„ç¯€é»é›†åˆ$U$ 2. $d[i]$ ç›®å‰èµ·é»åˆ° $i$ æœ€çŸ­è·¯ 3. ç›®å‰è€ƒæ…®ç¯€é» $p$\né‡è¤‡ä»¥ä¸‹å‹•ä½œç›´åˆ°uç‚ºç©ºï¼š\nå°æ–¼æ‰€æœ‰èˆ‡ $p$ é€£æ¥çš„ç¯€é» $q$ï¼Œ$d[q] = min(d[q],d[p]+weight[p][q])$\nç•¶ $p$ ç›¸é„°ç¯€é»éƒ½èµ°éï¼šåœ¨ $u$ ä¸­ç§»é™¤ $p$\nå°‡ $p$ æ›´æ–°æˆUä¸­é›¢èµ·é»è·é›¢æœ€çŸ­çš„é» $min(d[j])$\n\n\nå¯ä»¥è®Šæˆ $O((E+V)logV)$-&gt;é‚Šè¼ƒç‚ºç¨€ç–çš„åœ–æ™‚æœ‰åˆ©ï¼ˆä½¿ç”¨priority_queueï¼‰\nä¸èƒ½è™•ç†è² é‚Šï¼Œå› ç‚º $d[i]$ è¼ƒå°çš„è™•ç†å®Œä¹‹å¾Œå°±ä¸æœƒå†æ›´å‹•äº†ï¼ŒåŠ å…¥è² é‚Šå¯èƒ½æ›´å°\næ‹¿è·é›¢æœ€å°çš„é» $k$ å»æ›´æ–°å…¶ä»–é»ï¼Œä¸èƒ½ä¿è­‰æ›´æ–°å¾Œå…¶ä»–é»ä¸€å®šæ˜¯æœ€çŸ­è·¯\nä¸Šä¸€æ­¥èµ°å®Œ $k$ é€£æ¥æ‰€æœ‰é‚Šå¾Œï¼Œå¾é›†åˆ $U$ ä¸­ç§»é™¤ï¼Œå› ç‚ºæ²’æœ‰è² é‚Šï¼Œ $k$ å¿…å®šæ˜¯æœ€çŸ­è·¯\n\nBellman-Fordï¼šå–®é»æºæœ€çŸ­è·¯å¾‘\nå¯ä»¥è™•ç†è² ç’°\n\næ™‚é–“ï¼š$O(VE)$\n\næƒ³æ³•ï¼šRelaxé¬†å¼›\nä¸€æ¢é‚Š $\\delta(u,v)$ æ»¿è¶³ $dis[v] = min(dis[v],dis[u]+weight[u][v])$\nå°æ¯ä¸€æ¢é‚Šé€²è¡Œé¬†å¼›ï¼Œå› ç‚ºé¬†å¼›æ²’æœ‰æŒ‰ç…§æœ€çŸ­è·¯é †åºï¼Œå› æ­¤è¦åšV-1æ¬¡\næ­¤ç‚ºæš´åŠ›ä½œæ³•\nåŸ·è¡ŒV-1æ¬¡çš„worst caseï¼š\nå‰›å¥½è·Ÿæœ€çŸ­è·¯å¾‘çš„é †åºç›¸å\næ¯æ¬¡ Relax å¾Œåªèƒ½å„ªåŒ–å–®ä¸€å­è·¯å¾‘\nå…±æœ‰Vå€‹é ‚é»ï¼Œéœ€è¦æœ‰V-1 æ¢å­è·¯å¾‘ï¼Œæ¯ä¸€æ¬¡ä¸€æ¢\næª¢æŸ¥è² ç’°ï¼šåšå®Œä¹‹å¾Œå»æœ‰æ»¿è¶³$d[v] &gt; d[u]+w(u,v)$ ï¼Œè¡¨ç¤ºæœ‰è² ç’°\n\n\n\nå„ªåŒ–ï¼šSPFA(Shortest Path Faster Algorithm)\næ¯æ¬¡åªrelaxæ›´æ–°éçš„é»\n\nä½¿ç”¨queueå„ªåŒ–ï¼Œæœ‰é»åƒBFSéç¨‹\n\n1.æŠŠèµ·é» Push åˆ° Queue\n2.å¾ Queue è£¡ Pop å‡ºä¸€ç­†è³‡æ–™\n3.è©²ç­†è³‡æ–™çš„æ‰€æœ‰é‚Šé€²è¡Œ Relax\n4.æœ‰æ›´æ–°åˆ°çš„é ‚é»å† Push åˆ° Queue\n5.é‡è¤‡æ­¥é©Ÿ 2 ~ 4ï¼Œç›´åˆ° Queue ç‚ºç©º\n\n\næ™‚é–“ï¼š$O(VE)$ -&gt;worst caseï¼ŒæœŸæœ› $O(KE)$ ï¼ŒKå¤§æ¦‚æ˜¯2å§ï¼ˆåæ­£æŒºå¿«çš„ï¼‰\n\nDAG Shortest Pathé¦–å…ˆå°æ‰€æœ‰é»é€²è¡Œæ‹“å¢£æ’åºï¼ŒèŠ±ä¸Šæ™‚é–“ $O(V+E)$ï¼Œæ¥è‘—å°æ¯ä¸€æ¢é‚Šé€²è¡Œé¬†å¼›ï¼Œæ™‚é–“$O(E)$ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(V+E)$ã€‚é€™å€‹æ™‚é–“è¤‡é›œåº¦æ˜¯å¾ˆå¿«çš„ï¼Œä½†ç›¸å°çš„é™åˆ¶ä¹Ÿéå¸¸å¤šï¼Œé™¤äº†ä¸èƒ½æœ‰è² é‚Šèˆ‡è² ç’°ä¹‹å¤–ï¼Œæ›´ä¸èƒ½æœ‰æ­£ç’°åœ¨å…¶ä¸­ï¼Œå¦å‰‡ä¸èƒ½é€²è¡Œæ‹“å¢£æ’åºï¼ˆåœ¨ä¹‹å‰ç­†è¨˜é€²éšåœ–è«–ï¼ˆä¸€ï¼‰ï¼‰æœ‰æåˆ°ï¼Œä¹Ÿå°±æ˜¯é€™ä¸€ä¸­åœ–å¿…é ˆæ˜¯DAG(Directed Acyclic Graph)ï¼\nä¸€å€‹æœ‰è¶£çš„æ‡‰ç”¨ï¼šPERT\næœ€çŸ­è·¯å¾‘æ¨¹\nç´€éŒ„predecessor(æ¨¹çˆ¶ç¯€é»å”¯ä¸€)\n\nèµ·é»åˆ°æ¯å€‹é»çš„æœ€çŸ­è·¯å¾‘éƒ½å”¯ä¸€çš„è©±ï¼Œé‚£æŠŠé€™äº›è·¯å¾‘ç–Šèµ·ä¾†æœƒè®Šæˆä¸€æ£µæ¨¹\n\næ¨¹ï¼šæ¯ä¸€é»éƒ½æœ‰å”¯ä¸€ä¾†æºï¼ˆæœ€çŸ­è·¯ï¼‰\n\næœ€çŸ­è·¯å¾‘æ¯”è¼ƒæœ€çŸ­è·¯å¾‘å•é¡Œå…±æœ‰ä»¥ä¸‹æ±‚è§£æ–¹å¼ï¼ˆç•¶ç„¶é‚„æœ‰ä¸€å †ï¼‰ï¼Œæ•´ç†æ¯”è¼ƒåœ–ï¼š\nè² ç’°ä¸Šè¡¨ä¸­çš„å¯ä»¥è™•ç†è² ç’°çš„SPFAå’ŒBellman-Fordæ˜¯ä»¥ä»€éº¼æ¨£çš„æ–¹å¼è™•ç†ï¼Ÿï¼ˆé‡åˆ°è² ç’°æ¬Šé‡æ‡‰è©²æ˜¯$-\\infty$ï¼‰ä¸Šæ–¹æ‰€è¬‚è² ç’°æ˜¯æŒ‡ä¸‹åœ–é€™ç¨®æƒ…æ³ï¼ˆç•¶å‡ºç™¼é»ç‚ºsï¼Œçµ‚é»ç‚ºtæ±‚æœ€çŸ­è·¯å¾‘çš„å•é¡Œï¼‰ï¼Œå› ç‚ºæ²’æœ‰ç¶“éè² ç’°ï¼Œå› æ­¤ $\\delta(s,t)$ å¯ä»¥è¢«SPFAå’ŒBellman-Fordæ±‚å‡ºæ­£ç¢ºçš„æœ€çŸ­è·¯å¾‘ç‚º1ã€‚æˆ‘å€‘å¯ä»¥åˆ©ç”¨å¾çµ‚é»å›æœ”æœ€çŸ­è·¯å¾‘ï¼ˆåˆ©ç”¨predecessorç´€éŒ„ï¼‰çœ‹æ˜¯å¦æœ‰é‡è¤‡ç¶“éçš„é»ï¼Œå¦‚æœæœ‰å‰‡è¡¨ç¤ºé€”ä¸­æœ‰ç¶“éè² ç’°ï¼\n\nè‡³æ–¼å…¶ä»–çš„ç®—æ³•ï¼Œéƒ½æœƒæ±‚å‡ºä¸æ­£ç¢ºçš„æ•¸å€¼ï¼\n\n            Floyd warshallé€™å€‹æ¼”ç®—æ³•æ˜¯è™•ç†å…¨é»å°çš„æœ€çŸ­è·¯å¾‘ï¼Œå¦‚æœæœ‰è² ç’°ï¼Œé‚£ä¸€å®šæœ‰ä»»å…©é»çš„æœ€çŸ­è·é›¢æ˜¯éŒ¯èª¤çš„ã€‚ä¸éæˆ‘å€‘ä¸€æ¨£å¯ä»¥åˆ©ç”¨Floyd-Warshallæ¼”ç®—æ³•åˆ¤æ–·åœ–ä¸­æ˜¯å¦æœ‰è² ç’°ï¼Œåªè¦æª¢æŸ¥æ¯ä¸€å€‹é»èµ°åˆ°è‡ªå·±çš„è·é›¢æ˜¯å¦ç‚ºè²  ï¼Œå³$dis[i][i]","categories":["C++é€²éšä¸»é¡Œ","æœ€çŸ­è·¯å¾‘"],"tags":["2021æš‘æœŸç­†è¨˜","2020è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 391 å¯é­šæœé‹è¼¸å•é¡Œ","url":"/path2-1/","content":"å¯é­šæœé‹è¼¸å•é¡Œ\né¡Œç›®é€£çµDijkstraâ€™s AlgorithmSPFAé€™ä¸€é¡Œçš„ä¾†æºæ˜¯NPSC2013çš„é¡Œç›®ï¼Œé¡Œç›®å¤§æ„å¦‚ä¸‹ï¼š\n\næœ‰nå€‹åŸå¸‚må€‹é‹è¼¸æ–¹æ¡ˆï¼Œæ¯å€‹æ–¹æ¡ˆ $P_i$ æœƒå¾ä¸€å€‹å›ºå®šçš„èµ·å§‹åŸå¸‚ $A_i$ é‹é€æ±è¥¿åˆ°å¦ä¸€å€‹å›ºå®šçš„çµ‚é»åŸå¸‚ $B_i$ï¼Œæ¯é‹è¼¸ä¸€ä»¶ç‰©å“ï¼Œå°±å¿…é ˆä»˜ $C_i$ åƒ¹éŒ¢ã€‚è‹¥ç”¨æ–¹æ¡ˆ $P_i$ é‹è¼¸äº†è¶…é $D_i$ ä»¶ç‰©å“ï¼Œå¤šå‡ºä¾†çš„éƒ¨ä»½æ¯ä»¶ç‰©å“æ”¶ $C_iâ€™$ å…ƒã€‚å…±è¦é‹è¼¸ $f$ ç‰©å“ã€‚æ±‚èµ·é» $s$ åˆ°çµ‚é» $e$ çš„æœ€çŸ­è·¯å¾‘ã€‚\n\nç•¶é‹è¼¸ç¸½é‡è¶…é $D_i$ ä»¶ç‰©å“ï¼Œè¡¨ç¤ºå¯ä»¥ä½¿ç”¨æ›´å°çš„é‚Šæ¬Šé‡å»è¨ˆç®—æ¥ä¸‹ä¾†çš„è²»ç”¨ã€‚é€™æ™‚å€™æˆ‘å€‘å¯ä»¥äº†è§£åˆ°ä¸€å€‹æ€§è³ªï¼Œå¦‚æœæˆ‘æŠŠå…¨éƒ¨çš„ç‰©å“å…¨éƒ¨é›†ä¸­åœ¨ä¸€æ¢è·¯å¾‘é‹é€ï¼Œå› ç‚ºé€çš„è¶Šå¤šï¼Œç›¸å°çš„åœ¨è²»ç”¨ä¸Šå°±å¯èƒ½ç”¢ç”Ÿå„ªæƒ ï¼Œæ¯”åˆ†æ•£å¤šæ¢è·¯å¾‘çš„é‹é€èŠ±è²»ä¾†çš„å°ã€‚å› ç‚ºç¸½å…±è¦é‹é€ $f$ ä»¶ç‰©å“ï¼Œå› æ­¤æœƒå°‡é‚Šçš„æ¬Šé‡è¨­å®šç‚ºç•¶ $f$ ä»¶ç‰©å“éƒ½ç¶“éé€™ä¸€æ¢é‚Šæ™‚ï¼Œæ‰€è¦èŠ±è²»çš„åƒ¹æ ¼ã€‚\næœ‰äº†é‚Šä»¥åŠåƒ¹æ ¼ä¹‹å¾Œï¼Œä¾¿å¯é–‹å§‹é€²è¡Œæœ€çŸ­è·¯å¾‘çš„æ¼”ç®—æ³•ã€‚å› ç‚ºé¡Œç›®ç¯„åœ $Nâ‰¤100$ ï¼Œå› æ­¤ç”¨Dijkstraâ€™s æˆ–æ˜¯ SPFA éƒ½å¯ä»¥åšï¼ˆBellman-Fordå°±å…ˆä¸è¦XDï¼‰ã€‚\nDijkstraâ€™s Algorithmé€™ç¯‡æœ‰ä¸€ç¯‡è«–æ–‡æ˜¯Dijkstraåœ¨é‡å°æœ€çŸ­è·¯å¾‘å¯«çš„è«–æ–‡ï¼ˆä¹Ÿå°±æ˜¯ä»¥ä»–åå­—å‘½åçš„æ¼”ç®—æ³•è«–æ–‡ï¼‰ï¼Œé€™ç¯‡åªæœ‰ä¸‰é è€¶ï¼ä»¥ä¸‹æ˜¯ã€Œæ¼”ç®—æ³•å°è«–ã€é€™æœ¬æ›¸ä¸­æ¼”ç®—æ³•çš„è™›æ“¬ç¢¼ï¼š\nDIJKSTRA(G, w, s)  1  INITIALIZE-SINGLE-SOURCE(G, s)  2    S &lt;- Ã˜  3    Q &lt;- V[G]  4    while Q â‰  Ã˜  5        do u &lt;- EXTRACT-MIN(Q)  6            S &lt;- S âˆª &#123;u&#125;  7            for each vertex v âˆˆ Adj[u]  8                do RELAX(u,v,w)\nå…¶ä¸­é›†åˆ $S$ åœ¨ç¨‹å¼ç¢¼ä¸­ä»£è¡¨çš„æ˜¯visitï¼Œè€Œé›†åˆ $Q$ å› ç‚ºè¦æ“ä½œå–å‡ºæœ€å°å…ƒç´ çš„å‹•ä½œï¼Œå› æ­¤æœƒç”¨priority_queueå¯¦ç¾ï¼Œä»¥heapä¾†é€²è¡Œ $O(\\log n)$ çš„æ’å…¥ä»¥åŠå–å‡ºã€‚\né€™è£¡é¢ä½¿ç”¨$visit$åˆ¤æ–·æ˜¯å¦åœ¨é›†åˆ $S$ ä¸­ï¼Œä½†æˆ‘å€‘å¯ä»¥ç™¼ç¾ï¼Œå¦‚æœåœ¨priority_queueä¸­æœ‰å…©å€‹é»çš„å­˜åœ¨ï¼Œç¬¬ä¸€å€‹é»è™•ç†å®Œè¢«åŠ å…¥é›†åˆ $S$ ä¸­ä¹‹å¾Œï¼Œç¬¬äºŒæ¬¡å†æ¬¡è¢«æ‹¿å‡ºä¾†é€²è¡Œè™•ç†æ™‚å°±ä¸æœƒæœ‰ä»»ä½•ç›¸é„°çš„é»å†ä¸€æ¬¡è¢«è™•ç†ï¼Œé€™æ˜¯å› ç‚ºç¬¬ä¸€æ¬¡èˆ‡ç¬¬äºŒæ¬¡æ›´æ–°æ‰€ä½¿ç”¨çš„ $dis[cur]$ æ˜¯ä¸€æ¨£çš„ã€‚å› æ­¤ï¼Œç•¶ä¸€å€‹é»å·²ç¶“åœ¨visitä¸­ï¼ˆä¹Ÿå°±æ˜¯åœ¨é›†åˆ $s$ ä¸­ï¼‰ï¼Œæˆ‘å€‘å¯ä»¥ç›´æ¥æ›ä¸‹ä¸€å€‹é»å»åŸ·è¡Œï¼ˆä¸éå¦‚æœå¿˜äº†visitä¹Ÿæ˜¯æ²’å·®å•¦ï¼‰ã€‚\n\n            è¤‡é›œåº¦åˆ†æä»¥ä¸‹åˆ†æä¸€ä¸‹æ¼”ç®—æ³•æ™‚é–“è¤‡é›œåº¦ï¼Œç¸½å…±æœ‰å…©å€‹æ™‚é–“è¤‡é›œåº¦ï¼Œå–æ±ºæ–¼ä½¿ç”¨ä½•ç¨®è³‡æ–™çµæ§‹ä¾†å¯¦ä½œã€‚1. æ™‚é–“è¤‡é›œåº¦ $O(V^2+E)$é¦–å…ˆæ˜¯æ¯ä¸€å€‹é»åŸ·è¡Œ $V$ æ¬¡å°æ¯ä¸€å€‹ç›¸é„°çš„é»é€²è¡Œæ›´æ–°ï¼Œæ¯ä¸€è¼ªåŸ·è¡Œ $O(V)$ å°‹æ‰¾ç›®å‰è·é›¢ $dis$ æœ€å°çš„é»ã€‚ç¸½å…±æœ‰ $E$ æ¢é‚Šéœ€è¦æ›´æ–°ï¼Œå› æ­¤æœ€å¾Œè¦æŠŠ $E$ å†åŠ ä¸Šå»ã€‚é€™æ¨£ç¸½è¤‡é›œåº¦å°±æœƒ $V\\times O(V)+O(E) = O(V^2+E)$ã€‚æ­¤å¯¦ä½œæ–¹å¼ä¸€èˆ¬åœ¨ç¨ å¯†çš„åœ–ä¸­æœƒæœ‰æ¯”è¼ƒå¥½çš„è¡¨ç¾ã€‚2. æ™‚é–“è¤‡é›œåº¦ $O((V+E)\\log V)$é€™ä¸€é¡Œåœ¨ $O(n)$ çˆ†æœå°‹æ‰¾æ”¹ç”¨heapå»å„ªåŒ–ï¼Œå› æ­¤è¤‡é›œåº¦å°±æœƒæ˜¯ä¸€æ¨£åŸ·è¡ŒV è¼ªåˆ©ç”¨ $O(logV)$ æ‰¾åˆ°è·é›¢ $dis$ æœ€å°çš„é»ï¼ŒåŒæ™‚å°‡æ›´æ–°å¾Œçš„é»æ”¾é€²heapä¸­ï¼Œæˆ‘å€‘çŸ¥é“æ”¾å…¥heapçš„è¤‡é›œåº¦ä¹Ÿæ˜¯ $O(\\log n)$ï¼Œå› æ­¤è¤‡é›œåº¦å°±æœƒè®Šæˆ $O(V\\log V)+O(E\\log V) = O((V+E)\\log V)$ã€‚æ­¤å¯¦ä½œæ–¹å¼ä¸€èˆ¬åœ¨ç¨€ç–çš„åœ–ä¸­æœƒæœ‰æ¯”è¼ƒå¥½çš„è¡¨ç¾ï¼Œå¾ $V$ èˆ‡ $E$ çš„å¤§å°ä¼°è¨ˆå¯ä»¥å¤§è‡´ç™¼ç¾ã€‚\n          \nä»¥ä¸‹æ˜¯ç¨‹å¼æ³•çš„å¯¦ä½œï¼Œæœ€éœ€è¦æ³¨æ„çš„åœ°æ–¹æ˜¯pairçš„firstè·Ÿsecondå„²å­˜çš„æ±è¥¿ã€‚åœ¨å­˜åœ–æ™‚æœƒä½¿ç”¨ï¼ˆé»,æ¬Šé‡ï¼‰æ­é…vectorï¼›è€Œåœ¨priority_queueä¸­ï¼Œå› ç‚ºè¦å°æ¬Šé‡é€²è¡Œæ¯”è¼ƒï¼Œå› æ­¤æœƒç”¨ï¼ˆæ¬Šé‡,é»ï¼‰ï¼Œéœ€è¦ç‰¹åˆ¥æ³¨æ„åˆ¥ææ··äº†!\n\n            Priority_Queueå¯¦ä½œç´°ç¯€é è¨­çš„priority_queueæœƒpopå‡ºç›®å‰heapä¸­æœ€å¤§çš„å…ƒç´ ï¼ˆé è¨­æ˜¯less&lt;&gt;å‡½æ•¸ï¼‰ï¼Œå¦‚æœè¦å¯¦ä½œä¸€å€‹min heap çš„è©±è¦ä½¿ç”¨greater&lt;&gt;å‡½æ•¸ï¼ŒåŒæ™‚ç¬¬äºŒå€‹å‚³é€²å‡½æ•¸çš„åƒæ•¸è¦ç”¨ä¸€å€‹vectorï¼priority_queue &lt;Type, vector&lt;Type&gt;, ComparisonType &gt; min_heap;priority_queue &lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;   \n          \n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //å­˜åœ–    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //åŸå¸‚æ•¸nã€æ–¹æ¡ˆæ•¸mã€sèµ·ã€eçµ‚ã€fç®±æ•¸    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //ä¸€æ¢ç”±aé€£åˆ°bçš„é‚Šï¼Œæ¬Šé‡cï¼Œæµé‡è¶…édï¼Œå‰‡æ”¹æ¬Šé‡c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //Dijkstra    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;    //(è·é›¢,é»)    pq.push(&#123;0,s&#125;);    dis[s] = 0;        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;                        if(dis[cur]+weight&lt;dis[next])&#123;                dis[next] = dis[cur]+weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;        visit[cur] = 1;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\nShortest Path Faster Algorithm(SPFA)é€™æ˜¯ä¸€å€‹ä½¿ç”¨queueæœ€ä½³åŒ–çš„Bellman-Fordæ¼”ç®—æ³•ï¼ŒåŸºæœ¬çš„ä½¿ç”¨æ–¹å¼è·ŸBFSå¹¾ä¹ç›¸åŒï¼Œåœ¨Bellman-Fordå°é‚Šé€²è¡Œæ›´æœ‰æ•ˆç‡çš„é¬†å¼›(relaxation)ã€‚ä»¥ä¸‹ä¸€æ¨£æ˜¯ã€Œæ¼”ç®—æ³•å°è«–ã€ä¸­Bellman-Fordçš„è™›æ“¬ç¢¼ï¼š\nBELLMAN-FORD(G,w,s)  1    INITIALIZE-SINGLE-SOURCE(G,s)  2    for i &lt;- 1 to |V[G]|-1  3        do for each edge (u,v)âˆˆ E[G]  4            do RELAX(u,v,w)  5    for each edge (u,v)âˆˆ E[G]  6        do if d[v] &gt; d[u]+w(u,v)  7            then return FALSE  8    return TRUE\nä»¥ä¸‹æ˜¯SPFAçš„è™›æ“¬ç¢¼ï¼Œå¦‚æœç¯€é»æœ‰è¢«å¯¦éš›é¬†å¼›éï¼Œä¸”ç¯€é»ä¸åœ¨queueä¸­ï¼ˆåŒæ¨£å…ƒç´ åœ¨queueä¸­å‡ºç¾å…©æ¬¡æ²’æœ‰æ„ç¾©ï¼Œå› ç‚ºåªè¦ç¢ºä¿æœ‰åœ¨queueä¸­ç­‰æœƒæœƒè¢«æ›´æ–°åˆ°å°±å¥½ï¼Œåˆ°å®ƒçš„æœ€çŸ­è·é›¢ä¸æœƒè¢«æ”¹è®Šï¼‰ï¼Œä¾¿å°‡æ­¤ç¯€é»æ¨å…¥queueä¸­ã€‚è£¡é¢å­˜çš„æ˜¯å¸¶é€²è¡Œé¬†å¼›çš„ç¯€é»å€‘ï¼Œä¹Ÿå°±æ˜¯è¢«å‰›å‰›æ›´æ–°éçš„ç¯€é»ã€‚æˆ‘å€‘å¯ä»¥åˆ©ç”¨$visit[ ]$ä¾† $O(1)$ åˆ¤æ–·ç¯€é»æ˜¯å¦æœ‰åœ¨queueä¸­ï¼\næœ‰é€²è¡Œåˆ¤æ–·æ˜¯å¦åœ¨queueä¸­çš„ï¼ˆæ¯”è¼ƒçœç©ºé–“ä¸€é»ï¼‰ï¼šæ²’æœ‰é€²è¡Œåˆ¤æ–·çš„ï¼Œæœ‰è¢«æ›´æ–°éå°±å¡é€²å»ï¼š\nShortest-Path-Faster-Algorithm(G, s)  1    for each vertex v â‰  s in V(G)  2        d(v) := âˆ  3    d(s) := 0  4    offer s into Q  5    while Q is not empty  6        u := poll Q  7        for each edge (u, v) in E(G)  8            if d(u) + w(u, v) &lt; d(v) then  9                d(v) := d(u) + w(u, v) 10                if v is not in Q then 11                    offer v into Q\nSPFAæœ‰ä¸€å€‹å•é¡Œï¼Œä»–å¯ä»¥è¢«å‡ºé¡Œç›®çš„äººè¨­è¨ˆæ¸¬è³‡å»å¡é€™ç¨®ç®—æ³•ï¼Œä½¿æ™‚é–“è¤‡é›œåº¦è®Šæˆç³Ÿç³•çš„$O(V^2)$ï¼Œå› æ­¤ä¸€èˆ¬ä¾†èªªæœƒå¯¦ä½œDijkstraè€ŒéSPFAï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //å­˜åœ–    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //åŸå¸‚æ•¸nã€æ–¹æ¡ˆæ•¸mã€sèµ·ã€eçµ‚ã€fç®±æ•¸    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //ä¸€æ¢ç”±aé€£åˆ°bçš„é‚Šï¼Œæ¬Šé‡cï¼Œæµé‡è¶…édï¼Œå‰‡æ”¹æ¬Šé‡c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //SPFA        queue&lt;int&gt; que;    que.push(s);    dis[s] = 0;    visit[s] = 1;        while(!que.empty())&#123;        int cur = que.front();        que.pop();        visit[cur] = 0;                //popå‡ºä¾†å°‡ç‹€æ…‹æ”¹æˆä¸åœ¨queueä¸­        for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur]+weight)&#123;                dis[next] = dis[cur]+weight;                if(!visit[next])que.push(next);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]NEOJ 393 ç™¾æ…•é”ä¸‰è§’æ´²","url":"/path2-2/","content":"ç™¾æ…•é”ä¸‰è§’æ´²\né¡Œç›®é€£çµ\n\né¡Œç›®å¤§æ„ï¼šçµ¦å®šä¸€å¼µé•·nå¯¬mçš„çŸ©å½¢åœ–ï¼Œç”±â€#â€å’Œâ€.â€çµ„æˆï¼Œçµ¦å®šèµ·é»$(x_1,y_1)$ä»¥åŠçµ‚é»$(x_2,y_2)$ï¼Œå¿…é ˆæœ€å°åŒ–ç¶“éâ€.â€çš„æ¬¡æ•¸ï¼Œæ±‚æœ€å°‘éœ€å¹¾éå¹¾æ¬¡ã€‚\n\nç•¶ä¸‹çœ‹åˆ°é€™ä¸€å€‹é¡Œç›®çš„æƒ³æ³•ï¼Œå°±æ˜¯è·Ÿè™•ç†ä¸€èˆ¬çš„åœ–è«–é¡Œç›®ä¸€æ¨£ï¼Œå°‡é‚Šç”¨vectorå„²å­˜èµ·ä¾†ï¼Œå°‡ç¶“éâ€.â€çš„æ¬Šé‡è¨­ç‚ºå¾ˆå¤§çš„ä¸€å€‹æ•¸å­—ï¼Œé€™æ¨£ç”¨Dijkstraåšä¸€æ¬¡æœ€çŸ­è·¯å¾‘å°±å¯ä»¥æ‰¾å‡ºç¶“éâ€.â€æœ€å°åŒ–çš„æ¬¡æ•¸äº†ï¼\nä»¥ä¸‹æ˜¯MLEçš„Submissionåƒäº†é–‹å¿ƒçš„MLEï¼Œå¦‚æœç•¶æˆä¸€èˆ¬çš„åœ–åœ¨è™•ç†ï¼Œä¸ç®¡æ˜¯åœ¨ $dis$ é–‹long longçš„è™•è£¡ï¼Œæˆ–æ˜¯é–‹äº†ä¸€å€‹vectoré™£åˆ—å„²å­˜é‚Šï¼Œéƒ½éå¸¸çš„æ¶ˆè€—ç©ºé–“ã€‚å› æ­¤ï¼Œæˆ‘è©¢å•äº†ä¸€ä¸‹é›»ç¥é€™ä¸€é¡Œçš„æƒ³æ³•ï¼Œä»–èªªæˆ‘çš„æƒ³æ³•ç”¨Dijkstraæ˜¯æ­£ç¢ºçš„ï¼Œä¸éåœ¨è¨­å®šé‚Šæ¬Šçš„éƒ¨åˆ†å¯ä»¥ç›´æ¥ç”¨0è·Ÿ1ä»£æ›¿ï¼Œè€Œä¸”å¯ä»¥ç”¨queueå»è¼”åŠ©å¯¦ä½œBFSï¼ˆè¦èªªå®ƒä¹Ÿå¯ä»¥æ˜¯Dijkstraçš„å¦ä¸€ç¨®æ¯”è¼ƒç°¡å–®çš„ç‰ˆæœ¬ï¼‰ã€‚\n\né€™é¡Œä¹Ÿå°±æ˜¯æ‰€è¬‚0-1 BFS (Shortest Path in a Binary Weight Graph)ï¼Œæˆ–æ˜¯é€™è£¡0-1 BFSï¼Œæƒ³æ³•å¯ä»¥èªªæ˜¯Dijkstraè·ŸBFSçš„ç¶œåˆï¼ˆå…¶å¯¦å®ƒè·ŸSPFAä¹Ÿå¾ˆç›¸ä¼¼ï¼‰ã€‚ä»¥ä¸‹æ˜¯å¯¦ä½œæ­¥é©Ÿï¼š\n\nå»ºç«‹é›™å‘çš„ä½‡åˆ—(deque)ï¼Œç­‰ç­‰è¦å­˜æ”¾è¢«relaxéçš„é»ï¼Œåˆå§‹æ”¾å…¥èµ·é»\næ¯ä¸€æ¬¡å¾dequeå‰æ–¹popå‡ºä¸€é»ï¼Œå°é‚£ä¸€é»ç›¸é„°çš„æ‰€æœ‰é»é€²è¡Œé¬†å¼›\nå¦‚æœè¢«é¬†å¼›æ™‚çš„é‚Šæ¬Šé‡ç‚º0ï¼Œå°‡é»push dequeueçš„å‰æ–¹\nå¦å‰‡ç•¶é¬†å¼›æ™‚çš„é‚Šæ¬Šé‡ç‚º1ï¼Œå°‡é»push dequeueçš„å¾Œæ–¹\né‡è¤‡åŸ·è¡Œ2-4æ­¥é©Ÿç›´åˆ°dequeç‚ºç©º\n\nç•¶æˆ‘å€‘ä¸€ç›´åˆ©ç”¨dequeæœ€å‰ç«¯çš„å…ƒç´ é€²è¡Œé¬†å¼›ï¼Œå› ç‚ºæˆ‘å€‘å°‡é‚Šæ¬Šç‚º0çš„å…ƒç´ æ”¾å…¥æœ€å‰ç«¯ï¼Œç”¨è·é›¢æœ€å°çš„é‚£äº›é»é€²è¡Œé¬†å¼›ï¼Œæ¯ä¸€å€‹é»æœ€å¤šæœƒè¢«é¬†å¼›ä¸€æ¬¡ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦ç‚º$O(V+E)$ï¼Œæ¯”èµ·ç”¨Dijktraç›´æ¥åš$O((V+E)\\log V)$å¿«äº†è¨±å¤šï¼ˆæ­¤æ¼”ç®—æ³•ä¹‹æ‰€ä»¥æ­£ç¢ºæ˜¯å› ç‚ºå…¶ä¸­ä¸€é‚Šçš„æ¬Šé‡æ˜¯0ï¼Œä¸ç®¡0æ¥åˆ°èª°ä»–çš„æ¬Šé‡ä¹Ÿéƒ½æ˜¯0ï¼Œæœ‰é»åƒã€Œå¾æœ€å°å±¤é€æ¼¸æ“´å±•ã€çš„æ¦‚å¿µï¼‰ï¼\n\n            å°å•é¡Œï¼ˆå‡ºè™•é€™è£¡ï¼‰Can we apply the same trick if our edge weights can only be 0 and x (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and x+1 (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and y (x,y &gt;= 0) ?è§£ç­”YES,NO,NO\n          \né€™é¡Œä¹‹æ‰€ä»¥å¯è¡Œæ˜¯å› ç‚ºæœ‰ä¸€é‚Šçš„æ¬Šé‡æ˜¯0ï¼Œç•¶é»çš†ä»¥æ¬Šé‡ç‚º0ä¸²å†ä¸€èµ·æ™‚ï¼Œä»–æœƒæ˜¯æœ€çŸ­çš„ï¼Œä½¿ç”¨æœ€çŸ­å»æ›´æ–°æ¥ä¸‹ä¾†çš„é»ï¼Œå› æ­¤ç¬¬ä¸€é¡Œæ˜¯æ­£ç¢ºçš„ï¼ä½†ç¬¬äºŒé¡Œèˆ‡ç¬¬ä¸‰é¡Œæ˜¯éŒ¯èª¤çš„ï¼Œè€ƒæ…®ä»¥ä¸‹é»èˆ‡é‚Šçš„æƒ…æ³ï¼š\n\nç•¶æˆ‘ä¾ç…§01BFSçš„æ–¹æ³•ä¸æ–·å»ç”¨xæ›´æ–°å…¶ä»–çš„é»ï¼Œæ›´æ–°å®Œä¹‹å¾Œæœƒç™¼ç¾é»1åˆ°é»3çš„æœ€çŸ­è·¯å¾‘æ‡‰è©²æ˜¯x+1ï¼Œåˆ°æ™‚å€™åˆè¦å†é‡æ–°Relaxä¸€æ¬¡ï¼Œè¤‡é›œåº¦æœƒçˆ†ç‚¸å–”ï¼ˆæ¯”SPFAå¯èƒ½é‚„æ…˜ï¼Œå› ç‚ºç•¶é»ä¸‰åˆ©ç”¨å…©å€‹xæ›´æ–°å®Œä¹‹å¾Œï¼Œç”¨å®ƒä¾†åšè·Ÿ3æ‰€æœ‰ç›¸é„°çš„é»ï¼Œåšå®Œå»ç™¼ç¾$(1,3)$æœ‰æ›´çŸ­çš„è·é›¢ï¼Œåˆå¿…é ˆé‡æ–°å…¨éƒ¨æ›´æ–°ä¸€æ¬¡ï¼ï¼‰ç¸½çµä¾†èªªï¼Œä»–åªæ˜¯ç”¨æ–¼åªæœ‰å…©ç¨®é‚Šçš„æƒ…æ³ï¼Œä¸”å…¶ä¸­ä¸€é‚Šå¿…é ˆç‚º0ã€‚\n\n\n            æ¯”è¼ƒä¸€ä¸‹è¨˜æ†¶é«”ç”¨é‡æœ€ä¸»è¦é‚„æ˜¯æ™‚é–“è¤‡é›œåº¦çš„æ¯”è¼ƒï¼Œä¸éæ—¢ç„¶ç©ºé–“å·²ç¶“çˆ†äº†ï¼Œæ™‚é–“ä¹Ÿæ²’æ³•æ¯”äº†QQMLE#define N 2005#define N2 4000005int n,m,q,predecessor[N2],dis[N2];bool visit[N2],maze[N2];vector&lt;pii&gt;edge[N2];AC#define N 2003int n,m,dis[N][N];bool visit[N][N],maze[N][N];\n          \nä»¥ä¸‹æ˜¯ä½¿ç”¨dequeå¯¦ä½œ01BFSçš„AC codeï¼š\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 2003#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N],maze[N][N];void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    memset(visit,0,sizeof(visit));    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    deque&lt;pii&gt;deq;    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    memset(dis,0x3f3f3f3f,sizeof(dis));    dis[s1][s2] = 0;    deq.push_back(&#123;s1,s2&#125;);    while(!deq.empty())&#123;        int x = deq.front().first,y = deq.front().second;        deq.pop_front();        for(int i=0;i&lt;4;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;                        if(dis[nx][ny] &gt; dis[x][y]+maze[nx][ny])&#123;                dis[nx][ny] = dis[x][y]+maze[nx][ny];                if(maze[nx][ny]==0)deq.push_front(&#123;nx,ny&#125;);                else deq.push_back(&#123;nx,ny&#125;);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e1][e2]&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]NEOJ 431 æ±Ÿç¥èˆ‡ä»–çš„å°ç«è»Š","url":"/path2-3/","content":"æ±Ÿç¥èˆ‡ä»–çš„å°ç«è»Š\né¡Œç›®é€£çµ\n\né¡Œç›®å¤§æ„å·²çŸ¥æœ‰Nå€‹é»ä»¥åŠMæ¢é‚Šï¼Œç¸½å…±æœ‰Qç­†è©¢å•ï¼Œæ¯ç­†è©¢å•æœ‰$\\delta(a,b)$ï¼Œè¡¨ç¤ºæ–°å¢ä¸€æ¢ç”± $a$ æŒ‡å‘ $b$ çš„é‚Šï¼ˆå…¶æ¬Šé‡ç‚º1ï¼‰ï¼Œå°æ¯ä¸€ç­†è©¢å•è¼¸å‡ºå¾é» $1$ åˆ°é» $N$ çš„æœ€çŸ­è·é›¢ã€‚\n\n\næˆ‘å€‘çŸ¥é“å¦‚æœæœ‰ç”¨æ–°åŠ é€²ä¾†çš„é‚Š $\\delta(a,b)$ï¼Œå‰‡è·¯å¾‘å¯ä»¥è¢«æ‹†è§£æˆ $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$ã€‚å…¶ä¸­ï¼Œæˆ‘å€‘å¯ä»¥ç”¨Dijkstra ä¸€æ¬¡å°‹æ‰¾1åˆ°ä»»ä½•é»çš„æœ€çŸ­è·é›¢ï¼Œé‚£è¦å¦‚ä½•è™•ç†è·¯å¾‘ $\\delta(b,n)$ å‘¢ï¼Ÿé€™å°±æ˜¯å–®ä¸€ç›®çš„æœ€çŸ­è·é›¢å•é¡Œï¼Œæˆ‘å€‘å¯ä»¥å°‡æ‰€æœ‰çš„é‚Šé€†åºï¼Œå°‡çµ‚é»åšä¸€æ¬¡Dijkstraå°‹æ‰¾æœ€çŸ­è·¯ï¼Œé€™æ™‚å€™æˆ‘å€‘å°±å¯ä»¥ç”¨ $O(1)$ çš„æ™‚é–“å›ç­”æ¯ä¸€ç­†è©¢å•ï¼Œç¸½æ™‚é–“è¤‡é›œåº¦ï¼šé è™•ç†$O((V+E)\\log V)$ï¼Œè©¢å• $O(Q)$ã€‚\n\n            æ¸¬è³‡å°å•é¡Œæœ‰ä¸€ç­†æ¸¬è³‡å¦‚ä¸‹ï¼Œè—ç·šæ˜¯çµ¦å®šçš„è·¯å¾‘èˆ‡æ¬Šé‡ï¼Œç´…è‰²æ˜¯æ–°åŠ å…¥çš„é‚Šï¼Œå¦‚æœæŒ‰ç…§ä¸Šé¢ $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$ æˆ‘å€‘å¯ä»¥è¨ˆç®—å‡ºå¾èµ·é»åˆ°çµ‚é»çš„æœ€çŸ­è·é›¢ç‚ºï¼š$2+1+4 = 7$ï¼Œå¾ˆæ˜é¡¯å…©é»ä¹‹é–“çš„æœ€çŸ­è·é›¢æ˜¯ $5$ ï¼Œä½†å› ç‚ºåŸæœ¬ä½œæ³•æœƒç¶“éä¸€æ¢$\\delta (B,C)$ çš„é‡é‚Šï¼Œé€ æˆç®—å‡ºä¾†çš„è·é›¢æ˜¯æ¯”è¼ƒå¤§çš„ï¼é€™æ™‚å€™æˆ‘å€‘åªè¦å°æœ€çŸ­è·¯å¾‘é•·åº¦å–minå³å¯ï¼Œä¹Ÿå°±æ˜¯èªªåœ¨é€™ç¨®æƒ…æ³åŠ å…¥é€™ä¸€æ¢é‚Šä¸¦ä¸æœƒå½±éŸ¿æœ€çŸ­è·¯å¾‘çš„é•·åº¦ï¼æ¸¬è³‡ï¼ˆ1,2,3åˆ†åˆ¥å°æ‡‰A,B,Cï¼‰ï¼š6 5 11 2 12 3 13 4 14 5 15 6 13 2\n          \næ¥ä¸‹ä¾†æ˜¯ç¨‹å¼ç¢¼ï¼Œä¹‹å¾Œå¦‚æœé‡åˆ°æœ€çŸ­è·¯å¾‘çš„é¡Œç›®ï¼Œä¸€èˆ¬ä¾†èªªæœƒé¿å…ä½¿ç”¨SPFAï¼ˆé™¤éæœ‰è² é‚Šï¼‰ï¼Œç‚ºäº†è¦é¿å…æœ€ç³Ÿçš„æ™‚é–“è¤‡é›œåº¦ï¼Œå› æ­¤æœƒä½¿ç”¨Dijkstraä¾†è™•ç†æœ€çŸ­è·¯å¾‘å•é¡Œï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,q;bool visit[N];vector&lt;pii&gt; edge[2][N];//edge[0]-&gt;normal,edge[1]-&gt;oppositevector&lt;int&gt; Dijkstra(int start,int end,bool is_nor)&#123;    memset(visit,0,sizeof(visit));    vector&lt;int&gt; dis(n+2,1e16);        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;        dis[start] = 0;    pq.push(&#123;0,start&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                visit[cur] = 1;        for(auto i : edge[is_nor][cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur] + weight)&#123;                dis[next] = dis[cur] + weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    return dis;&#125;void solve()&#123;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=0;i&lt;m;i++)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[0][a].push_back(&#123;b,w&#125;);        edge[1][b].push_back(&#123;a,w&#125;);    &#125;        vector&lt;int&gt; normal,opposite;    normal = Dijkstra(1,n,0);    opposite = Dijkstra(n,1,1);        while(q--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        cout&lt;&lt;min(normal[a]+opposite[b]+1,normal[n])&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]TIOJ 1641 è²¨ç‰©é‹é€è¨ˆåŠƒ","url":"/path2-4/","content":"è²¨ç‰©é‹é€è¨ˆåŠƒ\né¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°çµ¦å®šNå€‹é»Mæ¢é‚Šï¼Œç¬¬iæ¢é‚Šæœ‰æ–¹é‚Šç‡$C_i$ï¼Œå‡è¨­ç›®å‰é‹é€è²¨ç‰©é‡é‡pç¶“éæ­¤é‚Šï¼Œä»£è¡¨ç¶“éé‚Šiæœƒéœ€è¦å¤šå¢åŠ  $p\\times C_i$ çš„é‡é‡ã€‚çµ¦å®šèµ·é»ã€çµ‚é»ï¼Œæ±‚åˆ°é”çµ‚é»æ™‚æœ€å°‘çš„è²¨ç‰©é‡é‡ç‚ºå¤šå°‘ã€‚\n\næ›ç¨®èªªæ³•ï¼Œé¡Œç›®è¦æ±‚çš„æ˜¯æ¯ç¶“éä¸€æ¢é‚Šï¼Œå°±è¦ä¹˜ä¸ŠæŸä¸€å€‹æ•¸ï¼Œè¦æ±‚åˆ°çµ‚é»æœ€å°çš„é‡é‡ã€‚ä¸‹åœ–æ˜¯é¡Œç›®ç¯„ä¾‹æ¸¬è³‡ï¼š\n$\\delta(1,2)\\to\\delta(2,3)$ï¼Œæ‰€ä»˜å‡ºçš„ä»£åƒ¹æ˜¯$(1\\times (1+1))\\times (2+1)=6$ã€‚å¦‚æœæ˜¯$\\delta(1,3)$ çš„è©±ç›´æ¥$1\\times (4+1)=5$ï¼Œå¯ä»¥è§€å¯Ÿåˆ°ï¼Œé‡åˆ°é‚Šå°±éœ€è¦å°‡åŸæœ¬çš„æ•¸å­—ä¹˜ä¸Š$C_i+1$ã€‚\næˆ‘å€‘å¯ä»¥é€éå°‡é‚Šæ¬Šå– $\\log$ ä¹‹å¾Œï¼Œå°±å¯ä»¥åˆ©ç”¨Dijkstraé€²è¡Œæœ€çŸ­è·¯å¾‘çš„è¨ˆç®—ï¼Œå› ç‚ºå– $\\log$ å¾Œçš„åŠ æ¸›é‹ç®—ç­‰åŒæ–¼åŸæœ¬çš„ä¹˜æ³•é‹ç®—ï¼Œåªè¦æœ€å¾ŒæŠŠç®—å‡ºä¾†çš„ç­”æ¡ˆæ¬¡æ–¹å³å¯ï¼\né€™ä¸€é¡Œçš„è¼¸å‡ºè¦æ±‚ç§‘å­¸è¨˜è™Ÿï¼ˆç‚ºäº†è¦é¿å…æµ®é»æ•¸èª¤å·®ï¼‰ï¼Œä»¥ä¸‹ç¨‹å¼ç¢¼ä¾†é”æˆï¼ˆè¦æ±‚å°æ•¸é»å¾Œå…©ä½ï¼ŒåŒæ™‚æ¬¡æ–¹éƒ¨åˆ†è¦æ±‚æ•´æ•¸3ä½ï¼‰ï¼š\nprintf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);\nç¨‹å¼ç¢¼çš„éƒ¨åˆ†ï¼Œé€é$edge$å­˜å®Œæ‰€æœ‰çš„å–å®Œ $\\log$ ä¹‹å¾Œçš„é‚Šï¼Œé€²è¡ŒDijkstraï¼Œè¼¸å‡ºæœ€çŸ­è·¯å¾‘ï¼ˆä»¥ç§‘å­¸è¨˜è™Ÿè¡¨ç¤ºï¼‰å³å¯ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s,t;double dis[N];bool visit[N];vector&lt;pid&gt; edge[N];void solve()&#123;    memset(visit,0,sizeof(visit));        scanf(&quot;%lld %lld %lld %lld&quot;,&amp;n,&amp;m,&amp;s,&amp;t);    for(int i=0;i&lt;m;i++)&#123;        int a,b;double c;scanf(&quot;%lld %lld %lf&quot;,&amp;a,&amp;b,&amp;c);        edge[a].push_back(&#123;b,(double)log10(c+1)&#125;);    &#125;    fill(dis,dis+n+2,1e16);        priority_queue&lt;pdi,vector&lt;pdi&gt;,greater&lt;pdi&gt;&gt; pq;    dis[s] = 0.0;    pq.push(&#123;0,s&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;        visit[cur] = 1;                for(auto i:edge[cur])&#123;            int next = i.first;            double w = i.second;            if(dis[next] &gt; dis[cur]+w)&#123;                dis[next] = dis[cur]+w;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    double ans = dis[t];    int x = floor(ans);    ans-=x;        printf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);&#125;signed main()&#123;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]TIOJ 1096 E.æ¼¢ç±³é “çš„éº»ç…©","url":"/path2-5/","content":"E.æ¼¢ç±³é “çš„éº»ç…©\né¡Œç›®é€£çµ\nä»–é¡Œç›®æ™‚ä¸æ™‚æåˆ°æ¼¢ç±³é “ï¼Œæ˜¯å¤šæ„›æ¼¢ç±³é “XDDï¼ˆé€™ä¸€é¡Œè·Ÿæ¼¢ç±³é “æ ¹æœ¬æ²’é—œä¿‚ï¼‰\n\né¡Œç›®å¤§æ„åœ¨ä¸€å¼µn(nâ‰¤100)å€‹é»çš„åœ–ä¸­ï¼Œå°‹æ‰¾è·¯å¾‘é•·åº¦æœ€çŸ­çš„ç’°\n\né‚£å°±ç”¨Floyd-Warshallæ‰¾æœ€å°çš„ç’°å°±å¥½ï¼\n\n            Floyd-Warshallé€™å°±æ˜¯dpçš„ä½œæ³•ï¼Œç”¨ $O(N^3)$ çš„æ™‚é–“é€²è¡Œè½‰ç§»ï¼Œå°±èƒ½å¾—åˆ°å…¨é»å°çš„æœ€çŸ­è·¯å¾‘ã€‚é€™é‚Šæœ‰ä¸€å€‹é‡è¦çš„è½‰ç§»é †åºï¼Œä¹Ÿå°±æ˜¯ä¸­é»-èµ·é»-çµ‚é»é€²è¡Œè½‰ç§»ï¼Œå¦‚æœæŠŠdpå±•é–‹å°±æœƒç™¼ç¾ä¸­é»å¿…é ˆåœ¨æœ€å¤–å±¤é€²è¡Œè½‰ç§»ï¼šå®šç¾© $dp[k][i][j]$ ç‚ºé» $i$ èµ°åˆ°é» $j$ ï¼Œåªèƒ½ç¶“éå‰kå€‹é»çš„æœ€çŸ­è·¯å¾‘ï¼Œå‰‡è½‰ç§»å¼è®Šæˆï¼šd[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])æ¯ä¸€å€‹k+1éƒ½æ˜¯ç”±kè½‰ç§»è€Œä¾†ï¼Œä»°è³´kçš„é»çš„é…å°ï¼Œå› æ­¤å¿…é ˆæœ€å…ˆè½‰ç§»ä¸­é»kçš„éƒ¨åˆ†ï¼ï¼ˆä¸éé †åºé¡›å€’ä¹Ÿä¸æœƒæ€æ¨£å•¦ï¼Œä¸Šé¢ã€Œèª²ç¨‹å…§å®¹ã€çš„åœ°æ–¹æœ‰å¯«åˆ°ï¼‰\n          \nåŒæ¨£é€™ä¸€ä»½codeä¹Ÿå¯ä»¥åˆ¤æ–·æœ‰æ²’æœ‰è² ç’°ï¼Œåªè¦anså°æ–¼0çš„è©±ä»£è¡¨æœ‰è² ç’°ï¼ˆæœ‰çš„è©±è·é›¢æ˜¯ä¸èƒ½ç”¨çš„å–”ï¼Œå› ç‚ºFloyd-Warshallä¸èƒ½è™•ç†è² ç’°ï¼Œä½†è² é‚Šæ˜¯å¯ä»¥è™•ç†çš„ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 101#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,dp[N][N];void solve()&#123;    memset(dp,0x3f3f3f3f,sizeof(dp));    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            int temp;cin&gt;&gt;temp;            if(temp!=0)dp[i][j] = temp;        &#125;    &#125;    for(int k=0;k&lt;n;k++)&#123;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)&#123;        ans = min(ans,dp[i][i]);    &#125;    if(ans == INT_MAX)cout&lt;&lt;-1&lt;&lt;endl;    else cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        solve();    &#125;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]TIOJ 1028 æ—…éŠè¦åŠƒå•é¡Œ","url":"/path2-6/","content":"æ—…éŠè¦åŠƒå•é¡Œ\né¡Œç›®é€£çµSubmissioné€™ä¸€é¡Œ $nâ‰¤13$ å¤§æ¦‚å°±æ˜¯ä½å…ƒdpä¾†å®Œæˆï¼ˆç‹€æ…‹å£“ç¸®ï¼‰ï¼Œå®šç¾© $dp[i][j]$ ç‚ºç¾åœ¨åœ¨é»iä¸Šï¼Œæ‹œè¨ªéé»é›†jçš„æœ€çŸ­è·é›¢ï¼ˆjä¸­ä¸åŒ…å«é»iï¼‰ã€‚é€™è£¡ä½¿ç”¨åˆ°äº†åŒå±¤è½‰ç§»çš„æŠ€å·§ï¼Œä¹Ÿå°±æ˜¯åˆ©ç”¨jä¸­çš„é»ï¼Œå°ç›¸åŒç‹€æ…‹ä¸‹ä¸åœ¨iä¸­çš„é»é€²è¡Œæ›´æ–°ã€‚\né»é›†jä¸­åœ¨ç‹€æ…‹iä¸‹ç‚ºèµ·é»ï¼Œç”¨Dijkstraå°ä¸åœ¨iä¸­çš„å…¶ä»–é»é€²è¡Œæ›´æ–°ï¼Œæœ€å¾Œçš„ç­”æ¡ˆå³ç‚º$dp[s][S-(1&lt;&lt;s)]$ã€‚\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m;vector&lt;pii&gt; edge[N];int dis[N],dp[N][1&lt;&lt;N],pre[N][1&lt;&lt;N];bool visit[N];//å®šç¾©dp[i][j]ç‚ºç¾åœ¨åœ¨é»iï¼Œæ‹œè¨ªéé»é›†åˆjï¼ˆiä¸åœ¨é»é›†jä¸­ï¼‰signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    rep(i,1,m)&#123;                                 //è®€å…¥mæ¢é‚Š        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    int S = 0,start = -1;cin&gt;&gt;m;                //Sç‚ºå¾…æ‹œè¨ªçš„æ‰€æœ‰é»é›†åˆ    rep(i,1,m)&#123;        int temp;cin&gt;&gt;temp;        S = S|(1&lt;&lt;temp);        if(start == -1)start = temp;    &#125;        rep(i,0,n)rep(j,0,(1&lt;&lt;n))dp[i][j] = INF;    rep(i,0,n)dp[i][0] = 0;        for(int i=1;i&lt;(1&lt;&lt;n);i++)&#123;        if(i == (S &amp; i))&#123;                       //åœ¨é›†åˆiä¸­çš„é»åœ¨Sä¸€å®šè¦æœ‰            priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;            fill(dis,dis+n,INF);                //å°‡disåˆå§‹ç‚ºç„¡é™å¤§ï¼ŒåšDijkstra            memset(visit,0,sizeof(visit));            for(int j=0;j&lt;n;j++)&#123;                if(i&amp;(1&lt;&lt;j))&#123;                   //å¾æœ‰åœ¨iä¸­çš„é»å‘ä¸åœ¨çš„é»åšDijkstra                    dis[j] = dp[j][i^(1&lt;&lt;j)];   //ç›®å‰åœ¨jï¼Œç¶“éæ‹œè¨ªäº†é»é›†iï¼ˆä¸åŒ…å«é»jï¼‰                    pq.push(&#123;dis[j],j&#125;);        //åˆ©ç”¨åœ¨iä¸­çš„é»å°å…¶ä»–é»é€²è¡Œæ›´æ–°                &#125;            &#125;            while(!pq.empty())&#123;                int cur = pq.top().second;                pq.pop();                visit[cur] = 1;                for(auto k : edge[cur])&#123;                    int v = k.first,w = k.second;                    if(i&amp;(1&lt;&lt;v))continue;                    if(dis[v] &gt; dis[cur]+w)&#123;                        dis[v] = dis[cur] + w;                        pre[v][i] = cur;        //ç´€éŒ„é»våœ¨ç‹€æ…‹iä¸‹ç”±curè½‰ç§»                        pq.push(&#123;dis[v],v&#125;);                    &#125;                    else if(dis[v] == dis[cur]+w &amp;&amp; pre[v][i] &gt; cur)&#123;                        pre[v][i] = cur;                    &#125;                &#125;            &#125;            for(int j=0;j&lt;n;j++)&#123;               //å°æ–¼ä¸åœ¨é»é›†iä¸­çš„é»é€²è¡Œæ›´æ–°                if(i &amp; (1 &lt;&lt; j))continue;                dp[j][i] = dis[j];              //åŒå±¤ç‹€æ…‹è½‰ç§»ï¼Œæ›´æ–°dp[j][i]            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;Minimum travel distance: &quot;&lt;&lt;dp[start][S^(start)]&lt;&lt;endl;    cout&lt;&lt;&quot;Travel route:&quot;;    int cur = start;S = S^(1&lt;&lt;start);    while(true)&#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;cur;        if(!S)break;        cur = pre[cur][S];        if(S&amp;(1&lt;&lt;cur))S = (S^(1&lt;&lt;cur));         //ç¶“éçš„é»ä¸ä¸€å®šæ˜¯æŒ‡å®šçš„è§€å…‰é»    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]Codeforces 543B: Destroying Roads","url":"/path2-7/","content":"Codeforces 543B: Destroying Roads\né¡Œç›®é€£çµSubmission\n\né¡Œç›®å¤§æ„çµ¦å®šNå€‹é»Mæ¢ç„¡å‘é‚Šï¼Œæ¯ä¸€é‚Šæ¬Šé‡éƒ½æ˜¯1ï¼Œä»¥åŠå…©ç­†è³‡æ–™ï¼Œç”±ä¸‰å€‹æ•¸$(x,y,w)$ æ§‹æˆï¼Œä»£è¡¨èµ·é»ç‚ºxã€çµ‚é»ç‚ºxã€è¦åœ¨wè·é›¢å…§å¾èµ·é»èµ°åˆ°çµ‚é»ã€‚è©¦å•æœ€å¤šå¯ä»¥æ‹”æ‰å¹¾æ¢é‚ŠåŒæ™‚æ»¿è¶³ä»¥ä¸Šå…©å€‹è³‡æ–™æ‰€æè¿°çš„ç‰¹æ€§ï¼Ÿ\n\né€™ä¸€é¡Œè »æœ‰è¶£çš„ï¼Œé¦–å…ˆä»–çš„é‚Šæ¬Šé‡éƒ½æ˜¯1ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥ç›´æ¥ç”¨BFSå°‹æ‰¾æœ€çŸ­è·¯å¾‘ï¼Œä¸¦ä¸”é»ç¬¬ä¸€æ¬¡æ‹œè¨ªåˆ°æ™‚çš„å°±æ˜¯è©²é»çš„æœ€çŸ­è·é›¢ï¼ˆBFSä¸€å±¤ä¸€å±¤æ“´å±•ï¼‰ã€‚\n\n            ç¬¬ä¸€å€‹æƒ³æ³•ï¼šéŒ¯èª¤æƒ³æ³•æˆ‘å…ˆå°‡å…©å€‹èµ·é»èˆ‡çµ‚é»çš„æœ€çŸ­è·¯å¾‘éƒ½æ‰¾å‡ºä¾†ï¼ŒæŠŠå°‡éçš„é‚Šéƒ½æ¨™ä¸Šä¸èƒ½ç§»é™¤ï¼Œå°‡å…¶ä»–çš„é‚Šå…¨éƒ¨æ‹”æ‰ã€‚å•é¡Œé»ï¼šå›ºç„¶æ‰¾åˆ°çš„æ˜¯æœ€çŸ­è·¯å¾‘ï¼Œä½†ä¸ä»£è¡¨å¯ä»¥æœ€å¤§åŒ–æ‹”é™¤é‚Šçš„æ•¸é‡ã€‚å› ç‚ºé¡Œç›®è¦æ±‚å…©é»åªè¦ç¬¦åˆæœ€çŸ­è·é›¢ $w$ å³å¯ï¼Œå› æ­¤æ¯ä¸€å€‹é…å°å…¶å¯¦ä¸ç”¨ç¬¦åˆæ˜¯æœ€çŸ­è·¯å¾‘çš„æƒ…æ³ï¼ˆå¦‚ä¸‹åœ–ï¼‰ï¼ç›®æ¨™æ˜¯åœ¨é¡Œç›®è¦æ±‚çš„é™åº¦å…§æœ€å¤§åŒ–é‡è¤‡çš„é‚Šï¼Œä½¿èƒ½å¤ è¢«æ‹”é™¤çš„é‚Šæœ€å¤§åŒ–ï¼ä¸Šåœ–ç´…è‰²ç·šæ®µæ˜¯$\\delta(1,7)$çš„æœ€çŸ­è·¯å¾‘ã€è¤è‰²æ˜¯ç·šæ®µ$\\delta(3,6)$çš„æœ€çŸ­è·¯å¾‘ã€é»‘è‰²ç·šæ®µæ˜¯çš†ä»¥æœ€çŸ­è·¯å¾‘ä¹‹ä¸‹å¯ä»¥è¢«æ‹”é™¤çš„é‚Šã€‚ä½†æ˜¯å¦‚æœå°‡è·¯å¾‘$\\delta(3,6)$æ›æˆæ˜¯$(3,2)\\to(2,4)\\to(4,5)\\to(5,6)$ï¼Œè¢«æ‹”é™¤çš„é‚Šå¯ä»¥å¢éç‚ºä¸‰æ¢ã€‚\n          \né€™ä¸€é¡Œæœ€é‡è¦çš„é—œéµå°±æ˜¯ä»¥$O(V^2)$æšèˆ‰æ‰€æœ‰é»å°ï¼ˆè·é›¢é•·åº¦å¯ä»¥ç›´æ¥æ›ç®—æˆé‚Šçš„æ•¸é‡ï¼‰ï¼Œå¯ä»¥å…ˆç”¨$O(V(V+E)$çš„æ™‚é–“å°æ¯ä¸€å€‹é»ç”¨é€²è¡ŒBFSï¼Œå¦‚æ­¤ä¸€ä¾†ç¸½è¤‡é›œåº¦å³ç‚º$O(V^2+VE)$ï¼Œæ‰€å¹¸é¡Œç›®çµ¦å®šç¸½å…±çš„é‚Šæ•¸ä¸æœƒè¶…é3000æ¢ï¼Œå› æ­¤æ˜¯å¯ä»¥åœ¨æ™‚é–“é™åˆ¶å…§å®Œæˆæšèˆ‰ã€‚\n\n            æšèˆ‰è·¯å¾‘ $\\delta(i,j)$ ç‚ºå…±åŒé‚Šçš„æ™‚å€™ï¼Œå¿…é ˆè€ƒæ…®èµ·é»èˆ‡çµ‚é»çš„æ–¹å‘ï¼ŒåŒæ™‚è€ƒæ…®å¾ $i\\to j$ ä»¥åŠå¾ $j\\to i$ å…©å€‹æ–¹å‘ã€‚ä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œç•¶æšèˆ‰éƒ½ä½¿ç”¨ç›¸åŒçš„èµ·é»ä»¥åŠçµ‚é»ï¼Œæœƒè®“ä¸‹åœ–çš„ $(3,4)$ è¢«é‡è¤‡è¨ˆç®—ï¼\n          \nä»¥ä¸‹æ˜¯ACç¨‹å¼ç¢¼ï¼š\n#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 3005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s1,e1,w1,s2,e2,w2,dis[N][N];bool visit[N];vector&lt;int&gt; edge[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    cin&gt;&gt;s1&gt;&gt;e1&gt;&gt;w1&gt;&gt;s2&gt;&gt;e2&gt;&gt;w2;    memset(dis,0x3f3f3f3f,sizeof(dis));        for(int i=1;i&lt;=n;i++)&#123;        memset(visit,0,sizeof(visit));        queue&lt;int&gt;que;        que.push(i);        visit[i] = 1;        dis[i][i] = 0;        while(!que.empty())&#123;            int cur = que.front();            que.pop();            for(auto j:edge[cur])&#123;                if(visit[j])continue;                dis[i][j] = dis[i][cur]+1;                visit[j] = 1;                que.push(j);            &#125;        &#125;    &#125;    if(dis[s1][e1]&gt;w1||dis[s2][e2]&gt;w2)&#123;        cout&lt;&lt;-1&lt;&lt;endl;        return 0;    &#125;    int ans = dis[s1][e1]+dis[s2][e2];    //O(n^2)æšèˆ‰æ‰€æœ‰å…±åŒé‚Š    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[s2][i]+dis[i][j]+dis[j][e2]&lt;=w2)                ans = min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[s2][i]+dis[j][e2]);            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[e2][i]+dis[i][j]+dis[j][s2]&lt;=w2)                ans=min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[e2][i]+dis[j][s2]);                    &#125;    &#125;    cout&lt;&lt;m-ans&lt;&lt;endl;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]TIOJ 2180 å‹‡è€…å†’éšª(Adventure)","url":"/path2-8/","content":"TIOJ 2180 å‹‡è€…å†’éšª (Adventure)\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦å®šä¸€å€‹åœ°åœ–å…± $R\\times C$ è¡Œï¼Œæ¥è‘—æœƒæœ‰ $M$ è¡Œæ¯ä¸€è¡Œéƒ½æœ‰ä¸€å€‹åº§æ¨™å’Œç­‰ç´šï¼Œä»£è¡¨ç¶“éé€™å€‹åº§æ¨™éœ€è¦å¤šå°‘ç­‰ç´šæ‰èƒ½é€šéã€‚å•å¾ç‰¹å®šèµ·é»åˆ°çµ‚é»æ‰€éœ€è¦çš„æœ€ä½çš„ç­‰ç´šç‚ºå¤šå°‘ã€‚\n\né€™é¡Œè »ç‰¹åˆ¥çš„ï¼Œä»–ç”¨åˆ°äº†Dijkstraä¸­æ¯ä¸€æ¬¡éƒ½æ‰¾æœ€å°çš„å»æ›´æ–°ï¼ŒåŒæ™‚å› ç‚ºè¦æ±‚çš„æ˜¯è·¯å¾‘ä¸Šæœ€å¤§çš„ç­‰ç´šç‚ºä½•ï¼Œå› æ­¤ä¹Ÿç”¨åˆ°äº†é¡ä¼¼BFSçš„æ‰‹æ³•å»æ“´å±•æ¯ä¸€å€‹åº§æ¨™ã€‚\nå› ç‚ºé¡Œç›®ä¿è­‰è‡³å°‘æœƒæœ‰ä¸€æ¢è·¯å¾‘é€šå¾€èµ·é»èˆ‡çµ‚é»ï¼ŒåŒæ™‚æˆ‘å€‘æ¯ä¸€æ¬¡å¾queueæ‹¿å‡ºä¾†çš„éƒ½æ˜¯ç›®å‰ç­‰ç´šæœ€ä½çš„é»ï¼Œå› æ­¤å¦‚æœç¢°åˆ°çµ‚é»å°±å¯ä»¥ç¢ºå®šé€™ä¸€æ¢è·¯ç·šä¸€å®šæ˜¯éœ€è¦ç­‰ç´šæœ€å°çš„ä¸€æ¢è·¯å¾‘ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int s1,s2,e1,e2;int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;void Dijkstra()&#123;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return;            &#125;            if(mp[nx][ny] == -1)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,-1,sizeof(mp));    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    Dijkstra();&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"[é¡Œè§£]æœ€å°èŠ±è²»çš„èˆªç©ºä¹‹æ—…","url":"/path2-9/","content":"æœ€å°èŠ±è²»çš„èˆªç©ºä¹‹æ—…\n\né¡Œç›®æ•˜è¿°ï¼šçµ¦å®šå¾ˆå¤šç¨®é€£æ¥åŸå¸‚é–“çš„è¯ç¥¨ï¼Œè¦æ±‚å¾èµ·å§‹ç«™æ­ä¹˜ï¼Œå¯ä»¥åœ¨ä¸­é€”ä»»æ„ç«™ä¸‹è»Šï¼Œä½†ä¸‹è»Šä»¥å¾Œå°±ä¸èƒ½å†æ¬¡ä¸Šè»Šã€‚è¼¸å…¥çš„ç¬¬ä¸€è¡Œç‚ºä¸€å€‹æ­£æ•´æ•¸ n (1 â‰¤ n â‰¤ 20)ï¼Œå³è¯ç¥¨çš„ç¨®é¡æ•¸ã€‚ä»¥ä¸‹ n è¡Œæ¯èˆªç‚ºä¸€å€‹è¯ç¥¨çš„è³‡è¨Šï¼Œå…¶ä¸­ç¬¬ä¸€å€‹æ•´æ•¸ç‚ºè¯ç¥¨çš„åƒ¹æ ¼ï¼Œç„¶å¾Œæ˜¯è¯ç¥¨ä¸ŠåŸå¸‚çš„æ•¸ç›®ã€‚\næ¥ä¸‹ä¾†ç‚ºä¸€å€‹è¡Œç¨‹å–®çš„è³‡è¨Šï¼Œå…¶ä¸­ç¬¬ä¸€å€‹æ­£æ•´æ•¸ç‚ºè¡Œç¨‹å–®ä¸Šçš„åŸå¸‚æ•¸ç›®kï¼ˆåŒ…æ‹¬èµ·å§‹åŸå¸‚ï¼Œ2 â‰¤ k â‰¤ 10ï¼‰ï¼Œä»¥åŠé€™äº›åŸå¸‚çš„ç·¨è™Ÿï¼ˆæŒ‰é †åºåˆ—å‡ºï¼‰ã€‚\nè¼¸å‡ºæœ€å°èŠ±è²»å’Œå°æ‡‰çš„æ–¹æ¡ˆçš„å…¶ä¸­ä¸€çµ„è§£ã€‚\n\né€™ä¸€é¡Œæ˜¯APCS Classçš„å…¶ä¸­ä¸€é¡Œï¼Œé›£åº¦é —é«˜ï¼Œå› ç‚ºä»–è¦æ‰¾æœ€çŸ­çš„è·¯å¾‘ï¼ŒåŒæ™‚å¢åŠ äº†å¯ä»¥åœ¨ä»»æ„ç«™ä¸‹è»Šçš„æ¢ä»¶ã€‚é¦–å…ˆæˆ‘å€‘è¦ç¶­è­·æ¯ä¸€å€‹è¯ç¥¨çš„è³‡è¨Šï¼Œå®ƒçš„åƒ¹å€¼ã€èµ·é»ã€ç·¨è™Ÿä»¥åŠç¶“éçš„åŸå¸‚ã€‚æ¥è‘—ï¼Œæˆ‘å€‘è€ƒæ…®æ‰€æœ‰å¾èµ·é»å‡ºç™¼çš„è¯ç¥¨ï¼Œå°‡æ¯ä¸€ç¨®è¯ç¥¨ä¸Šçš„æ¯ä¸€å€‹ç¶“éçš„åŸå¸‚éƒ½åŠ å…¥queueä¸­ã€‚\nè·Ÿä¸Šä¸€é¡Œä¸€æ¨£ï¼Œç•¶æˆ‘å€‘æ¯ä¸€æ¬¡éƒ½å¾costæœ€å°çš„é»ä¸‹æ‰‹ï¼Œåœ¨è½‰ç§»çš„éç¨‹ä¸­å¦‚æœå°‡æ‰€æœ‰çš„é»éƒ½èµ°è¨ªä¸€éï¼Œå‰‡ä»–çš„è·¯å¾‘å¿…å®šæ˜¯æœ€çŸ­çš„ï¼Œå› ç‚ºæ¯ä¸€æ¬¡çš„æ›´æ–°éƒ½æ˜¯å¾èŠ±è²»æœ€å°çš„è·¯å¾‘å»è½‰ç§»ã€‚\n\n            ä½¿ç”¨è‡ªå®šç¾©æ¯”è¼ƒå‡½æ•¸æ”¾å…¥Priority_queueä¸­Priority_queueä¸­çš„æ¯”è¼ƒå‡½æ•¸éœ€è¦ä½¿ç”¨åˆ°structæˆ–classåŒ…è¦†çš„æ¯”è¼ƒå‡½æ•¸ï¼Œè‹¥è¦å›å‚³costçš„æœ€å°å€¼ï¼Œå‰‡å¿…é ˆä»¥å¤§æ–¼ä¾†å¯«ï¼ˆæœ‰é»åƒé è¨­æ˜¯popå‡ºæœ€å¤§å€¼ï¼Œä½¿ç”¨çš„å»æ˜¯lessçš„æ¯”è¼ƒå‡½æ•¸ï¼‰struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;&#125;;\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,k,visit[20];struct Ticket&#123;    int id,cost;    vector&lt;int&gt; next_city;    //é™£åˆ—ticket[i]å­˜ä»¥iç‚ºèµ·é»&#125;;vector&lt;Ticket&gt; ticket[30];          //ticket[i] èµ·é»ç‚ºiçš„è¯ç¥¨struct node&#123;    int cost,cur_pos,visit_pos;    vector&lt;int&gt; used_ticket;    //cur_posç¾åœ¨æ‰€åœ¨ä½ç½®ã€visit_posåœ¨è¡Œç¨‹å–®ä¸Šä½ç½®&#125;;struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;    //è®“priority_queueå¯ä»¥popå‡ºæœ€å°çš„costçš„è·¯å¾‘&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        int cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;        vector&lt;int&gt; temp;        rep(j,1,num-1)&#123;            int k;cin&gt;&gt;k;            temp.push_back(k);        &#125;        ticket[s].push_back(&#123;i,cost,temp&#125;);    &#125;    cin&gt;&gt;k;    rep(i,1,k)cin&gt;&gt;visit[i];        for(auto i : ticket[visit[1]])&#123;         //è¡Œç¨‹ç¬¬ä¸€å€‹èµ·é»çš„è¯ç¥¨èµ·é»        int p = 1;        for(auto j : i.next_city)&#123;            if(p &lt; k &amp;&amp; j == visit[p+1])p++;            pq.push(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);//            cout&lt;&lt;&quot;ä¸€é–‹å§‹è¯ç¥¨ï¼š&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        &#125;    &#125;    while(!pq.empty())&#123;        node cur = pq.top();        pq.pop();        if(cur.visit_pos == k)&#123;            cout&lt;&lt;&quot;Cost = &quot;&lt;&lt;cur.cost&lt;&lt;&quot;, Tickets used: &quot;                &lt;&lt;cur.used_ticket[0];            for(int i=1;i&lt;cur.used_ticket.size();i++)                cout&lt;&lt;&quot;, &quot;&lt;&lt;cur.used_ticket[i];            cout&lt;&lt;endl;            break;        &#125;        for(auto i : ticket[cur.cur_pos])&#123;            vector&lt;int&gt; vec(cur.used_ticket);            vec.push_back(i.id);                //å°‡ç¾åœ¨ä½¿ç”¨çš„ç¬¬iè¯ç¥¨æ¨å…¥            int p = cur.visit_pos;            for(auto j : i.next_city)&#123;                if(p &lt; k &amp;&amp; j == visit[p+1])p++;                pq.push(&#123;cur.cost+i.cost,j,p,vec&#125;);            &#125;        &#125;    &#125;&#125;\n","categories":["æœ€çŸ­è·¯å¾‘é¡Œè§£"],"tags":["é¡Œè§£","æœ€çŸ­è·¯å¾‘"]},{"title":"æœ€çŸ­è·¯å¾‘ä¾‹é¡Œï¼ˆShortest Path Problemï¼‰","url":"/path2/","content":"é¡Œç›®ç›®éŒ„\nå¯é­šæœé‹è¼¸å•é¡Œ\nç™¾æ…•é”ä¸‰è§’æ´²\næ±Ÿç¥èˆ‡ä»–çš„å°ç«è»Š\nè²¨ç‰©é‹é€è¨ˆåŠƒ\nE.æ¼¢ç±³é “çš„éº»ç…©\næ—…éŠè¦åŠƒå•é¡Œ\nCodeforces 543B: Destroying Roads\n\n\nå¯é­šæœé‹è¼¸å•é¡Œé¡Œç›®é€£çµDijkstraâ€™s AlgorithmSPFAé€™ä¸€é¡Œçš„ä¾†æºæ˜¯NPSC2013çš„é¡Œç›®ï¼Œé¡Œç›®å¤§æ„å¦‚ä¸‹ï¼š\n\næœ‰nå€‹åŸå¸‚må€‹é‹è¼¸æ–¹æ¡ˆï¼Œæ¯å€‹æ–¹æ¡ˆ $P_i$ æœƒå¾ä¸€å€‹å›ºå®šçš„èµ·å§‹åŸå¸‚ $A_i$ é‹é€æ±è¥¿åˆ°å¦ä¸€å€‹å›ºå®šçš„çµ‚é»åŸå¸‚ $B_i$ï¼Œæ¯é‹è¼¸ä¸€ä»¶ç‰©å“ï¼Œå°±å¿…é ˆä»˜ $C_i$ åƒ¹éŒ¢ã€‚è‹¥ç”¨æ–¹æ¡ˆ $P_i$ é‹è¼¸äº†è¶…é $D_i$ ä»¶ç‰©å“ï¼Œå¤šå‡ºä¾†çš„éƒ¨ä»½æ¯ä»¶ç‰©å“æ”¶ $C_iâ€™$ å…ƒã€‚å…±è¦é‹è¼¸ $f$ ç‰©å“ã€‚æ±‚èµ·é» $s$ åˆ°çµ‚é» $e$ çš„æœ€çŸ­è·¯å¾‘ã€‚\n\nç•¶é‹è¼¸ç¸½é‡è¶…é $D_i$ ä»¶ç‰©å“ï¼Œè¡¨ç¤ºå¯ä»¥ä½¿ç”¨æ›´å°çš„é‚Šæ¬Šé‡å»è¨ˆç®—æ¥ä¸‹ä¾†çš„è²»ç”¨ã€‚é€™æ™‚å€™æˆ‘å€‘å¯ä»¥äº†è§£åˆ°ä¸€å€‹æ€§è³ªï¼Œå¦‚æœæˆ‘æŠŠå…¨éƒ¨çš„ç‰©å“å…¨éƒ¨é›†ä¸­åœ¨ä¸€æ¢è·¯å¾‘é‹é€ï¼Œå› ç‚ºé€çš„è¶Šå¤šï¼Œç›¸å°çš„åœ¨è²»ç”¨ä¸Šå°±å¯èƒ½ç”¢ç”Ÿå„ªæƒ ï¼Œæ¯”åˆ†æ•£å¤šæ¢è·¯å¾‘çš„é‹é€èŠ±è²»ä¾†çš„å°ã€‚å› ç‚ºç¸½å…±è¦é‹é€ $f$ ä»¶ç‰©å“ï¼Œå› æ­¤æœƒå°‡é‚Šçš„æ¬Šé‡è¨­å®šç‚ºç•¶ $f$ ä»¶ç‰©å“éƒ½ç¶“éé€™ä¸€æ¢é‚Šæ™‚ï¼Œæ‰€è¦èŠ±è²»çš„åƒ¹æ ¼ã€‚\næœ‰äº†é‚Šä»¥åŠåƒ¹æ ¼ä¹‹å¾Œï¼Œä¾¿å¯é–‹å§‹é€²è¡Œæœ€çŸ­è·¯å¾‘çš„æ¼”ç®—æ³•ã€‚å› ç‚ºé¡Œç›®ç¯„åœ $Nâ‰¤100$ ï¼Œå› æ­¤ç”¨Dijkstraâ€™s æˆ–æ˜¯ SPFA éƒ½å¯ä»¥åšï¼ˆBellman-Fordå°±å…ˆä¸è¦XDï¼‰ã€‚\nDijkstraâ€™s Algorithmé€™ç¯‡æœ‰ä¸€ç¯‡è«–æ–‡æ˜¯Dijkstraåœ¨é‡å°æœ€çŸ­è·¯å¾‘å¯«çš„è«–æ–‡ï¼ˆä¹Ÿå°±æ˜¯ä»¥ä»–åå­—å‘½åçš„æ¼”ç®—æ³•è«–æ–‡ï¼‰ï¼Œé€™ç¯‡åªæœ‰ä¸‰é è€¶ï¼ä»¥ä¸‹æ˜¯ã€Œæ¼”ç®—æ³•å°è«–ã€é€™æœ¬æ›¸ä¸­æ¼”ç®—æ³•çš„è™›æ“¬ç¢¼ï¼š\nDIJKSTRA(G, w, s)  1  INITIALIZE-SINGLE-SOURCE(G, s)  2    S &lt;- Ã˜  3    Q &lt;- V[G]  4    while Q â‰  Ã˜  5        do u &lt;- EXTRACT-MIN(Q)  6            S &lt;- S âˆª &#123;u&#125;  7            for each vertex v âˆˆ Adj[u]  8                do RELAX(u,v,w)\nå…¶ä¸­é›†åˆ $S$ åœ¨ç¨‹å¼ç¢¼ä¸­ä»£è¡¨çš„æ˜¯visitï¼Œè€Œé›†åˆ $Q$ å› ç‚ºè¦æ“ä½œå–å‡ºæœ€å°å…ƒç´ çš„å‹•ä½œï¼Œå› æ­¤æœƒç”¨priority_queueå¯¦ç¾ï¼Œä»¥heapä¾†é€²è¡Œ $O(\\log n)$ çš„æ’å…¥ä»¥åŠå–å‡ºã€‚\né€™è£¡é¢ä½¿ç”¨$visit$åˆ¤æ–·æ˜¯å¦åœ¨é›†åˆ $S$ ä¸­ï¼Œä½†æˆ‘å€‘å¯ä»¥ç™¼ç¾ï¼Œå¦‚æœåœ¨priority_queueä¸­æœ‰å…©å€‹é»çš„å­˜åœ¨ï¼Œç¬¬ä¸€å€‹é»è™•ç†å®Œè¢«åŠ å…¥é›†åˆ $S$ ä¸­ä¹‹å¾Œï¼Œç¬¬äºŒæ¬¡å†æ¬¡è¢«æ‹¿å‡ºä¾†é€²è¡Œè™•ç†æ™‚å°±ä¸æœƒæœ‰ä»»ä½•ç›¸é„°çš„é»å†ä¸€æ¬¡è¢«è™•ç†ï¼Œé€™æ˜¯å› ç‚ºç¬¬ä¸€æ¬¡èˆ‡ç¬¬äºŒæ¬¡æ›´æ–°æ‰€ä½¿ç”¨çš„ $dis[cur]$ æ˜¯ä¸€æ¨£çš„ã€‚å› æ­¤ï¼Œç•¶ä¸€å€‹é»å·²ç¶“åœ¨visitä¸­ï¼ˆä¹Ÿå°±æ˜¯åœ¨é›†åˆ $s$ ä¸­ï¼‰ï¼Œæˆ‘å€‘å¯ä»¥ç›´æ¥æ›ä¸‹ä¸€å€‹é»å»åŸ·è¡Œï¼ˆä¸éå¦‚æœå¿˜äº†visitä¹Ÿæ˜¯æ²’å·®å•¦ï¼‰ã€‚\n\n            è¤‡é›œåº¦åˆ†æä»¥ä¸‹åˆ†æä¸€ä¸‹æ¼”ç®—æ³•æ™‚é–“è¤‡é›œåº¦ï¼Œç¸½å…±æœ‰å…©å€‹æ™‚é–“è¤‡é›œåº¦ï¼Œå–æ±ºæ–¼ä½¿ç”¨ä½•ç¨®è³‡æ–™çµæ§‹ä¾†å¯¦ä½œã€‚1. æ™‚é–“è¤‡é›œåº¦ $O(V^2+E)$é¦–å…ˆæ˜¯æ¯ä¸€å€‹é»åŸ·è¡Œ $V$ æ¬¡å°æ¯ä¸€å€‹ç›¸é„°çš„é»é€²è¡Œæ›´æ–°ï¼Œæ¯ä¸€è¼ªåŸ·è¡Œ $O(V)$ å°‹æ‰¾ç›®å‰è·é›¢ $dis$ æœ€å°çš„é»ã€‚ç¸½å…±æœ‰ $E$ æ¢é‚Šéœ€è¦æ›´æ–°ï¼Œå› æ­¤æœ€å¾Œè¦æŠŠ $E$ å†åŠ ä¸Šå»ã€‚é€™æ¨£ç¸½è¤‡é›œåº¦å°±æœƒ $V\\times O(V)+O(E) = O(V^2+E)$ã€‚æ­¤å¯¦ä½œæ–¹å¼ä¸€èˆ¬åœ¨ç¨ å¯†çš„åœ–ä¸­æœƒæœ‰æ¯”è¼ƒå¥½çš„è¡¨ç¾ã€‚2. æ™‚é–“è¤‡é›œåº¦ $O((V+E)\\log V)$é€™ä¸€é¡Œåœ¨ $O(n)$ çˆ†æœå°‹æ‰¾æ”¹ç”¨heapå»å„ªåŒ–ï¼Œå› æ­¤è¤‡é›œåº¦å°±æœƒæ˜¯ä¸€æ¨£åŸ·è¡ŒV è¼ªåˆ©ç”¨ $O(logV)$ æ‰¾åˆ°è·é›¢ $dis$ æœ€å°çš„é»ï¼ŒåŒæ™‚å°‡æ›´æ–°å¾Œçš„é»æ”¾é€²heapä¸­ï¼Œæˆ‘å€‘çŸ¥é“æ”¾å…¥heapçš„è¤‡é›œåº¦ä¹Ÿæ˜¯ $O(\\log n)$ï¼Œå› æ­¤è¤‡é›œåº¦å°±æœƒè®Šæˆ $O(V\\log V)+O(E\\log V) = O((V+E)\\log V)$ã€‚æ­¤å¯¦ä½œæ–¹å¼ä¸€èˆ¬åœ¨ç¨€ç–çš„åœ–ä¸­æœƒæœ‰æ¯”è¼ƒå¥½çš„è¡¨ç¾ï¼Œå¾ $V$ èˆ‡ $E$ çš„å¤§å°ä¼°è¨ˆå¯ä»¥å¤§è‡´ç™¼ç¾ã€‚\n          \nä»¥ä¸‹æ˜¯ç¨‹å¼æ³•çš„å¯¦ä½œï¼Œæœ€éœ€è¦æ³¨æ„çš„åœ°æ–¹æ˜¯pairçš„firstè·Ÿsecondå„²å­˜çš„æ±è¥¿ã€‚åœ¨å­˜åœ–æ™‚æœƒä½¿ç”¨ï¼ˆé»,æ¬Šé‡ï¼‰æ­é…vectorï¼›è€Œåœ¨priority_queueä¸­ï¼Œå› ç‚ºè¦å°æ¬Šé‡é€²è¡Œæ¯”è¼ƒï¼Œå› æ­¤æœƒç”¨ï¼ˆæ¬Šé‡,é»ï¼‰ï¼Œéœ€è¦ç‰¹åˆ¥æ³¨æ„åˆ¥ææ··äº†!\n\n            Priority_Queueå¯¦ä½œç´°ç¯€é è¨­çš„priority_queueæœƒpopå‡ºç›®å‰heapä¸­æœ€å¤§çš„å…ƒç´ ï¼ˆé è¨­æ˜¯less&lt;&gt;å‡½æ•¸ï¼‰ï¼Œå¦‚æœè¦å¯¦ä½œä¸€å€‹min heap çš„è©±è¦ä½¿ç”¨greater&lt;&gt;å‡½æ•¸ï¼ŒåŒæ™‚ç¬¬äºŒå€‹å‚³é€²å‡½æ•¸çš„åƒæ•¸è¦ç”¨ä¸€å€‹vectorï¼priority_queue &lt;Type, vector&lt;Type&gt;, ComparisonType &gt; min_heap;priority_queue &lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;   \n          \n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //å­˜åœ–    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //åŸå¸‚æ•¸nã€æ–¹æ¡ˆæ•¸mã€sèµ·ã€eçµ‚ã€fç®±æ•¸    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //ä¸€æ¢ç”±aé€£åˆ°bçš„é‚Šï¼Œæ¬Šé‡cï¼Œæµé‡è¶…édï¼Œå‰‡æ”¹æ¬Šé‡c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //Dijkstra    priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;    //(è·é›¢,é»)    pq.push(&#123;0,s&#125;);    dis[s] = 0;        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;                        if(dis[cur]+weight&lt;dis[next])&#123;                dis[next] = dis[cur]+weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;        visit[cur] = 1;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\nShortest Path Faster Algorithm(SPFA)é€™æ˜¯ä¸€å€‹ä½¿ç”¨queueæœ€ä½³åŒ–çš„Bellman-Fordæ¼”ç®—æ³•ï¼ŒåŸºæœ¬çš„ä½¿ç”¨æ–¹å¼è·ŸBFSå¹¾ä¹ç›¸åŒï¼Œåœ¨Bellman-Fordå°é‚Šé€²è¡Œæ›´æœ‰æ•ˆç‡çš„é¬†å¼›(relaxation)ã€‚ä»¥ä¸‹ä¸€æ¨£æ˜¯ã€Œæ¼”ç®—æ³•å°è«–ã€ä¸­Bellman-Fordçš„è™›æ“¬ç¢¼ï¼š\nBELLMAN-FORD(G,w,s)  1    INITIALIZE-SINGLE-SOURCE(G,s)  2    for i &lt;- 1 to |V[G]|-1  3        do for each edge (u,v)âˆˆ E[G]  4            do RELAX(u,v,w)  5    for each edge (u,v)âˆˆ E[G]  6        do if d[v] &gt; d[u]+w(u,v)  7            then return FALSE  8    return TRUE\nä»¥ä¸‹æ˜¯SPFAçš„è™›æ“¬ç¢¼ï¼Œå¦‚æœç¯€é»æœ‰è¢«å¯¦éš›é¬†å¼›éï¼Œä¸”ç¯€é»ä¸åœ¨queueä¸­ï¼ˆåŒæ¨£å…ƒç´ åœ¨queueä¸­å‡ºç¾å…©æ¬¡æ²’æœ‰æ„ç¾©ï¼Œå› ç‚ºåªè¦ç¢ºä¿æœ‰åœ¨queueä¸­ç­‰æœƒæœƒè¢«æ›´æ–°åˆ°å°±å¥½ï¼Œåˆ°å®ƒçš„æœ€çŸ­è·é›¢ä¸æœƒè¢«æ”¹è®Šï¼‰ï¼Œä¾¿å°‡æ­¤ç¯€é»æ¨å…¥queueä¸­ã€‚è£¡é¢å­˜çš„æ˜¯å¸¶é€²è¡Œé¬†å¼›çš„ç¯€é»å€‘ï¼Œä¹Ÿå°±æ˜¯è¢«å‰›å‰›æ›´æ–°éçš„ç¯€é»ã€‚æˆ‘å€‘å¯ä»¥åˆ©ç”¨$visit[ ]$ä¾† $O(1)$ åˆ¤æ–·ç¯€é»æ˜¯å¦æœ‰åœ¨queueä¸­ï¼\næœ‰é€²è¡Œåˆ¤æ–·æ˜¯å¦åœ¨queueä¸­çš„ï¼ˆæ¯”è¼ƒçœç©ºé–“ä¸€é»ï¼‰ï¼šæ²’æœ‰é€²è¡Œåˆ¤æ–·çš„ï¼Œæœ‰è¢«æ›´æ–°éå°±å¡é€²å»ï¼š\nShortest-Path-Faster-Algorithm(G, s)  1    for each vertex v â‰  s in V(G)  2        d(v) := âˆ  3    d(s) := 0  4    offer s into Q  5    while Q is not empty  6        u := poll Q  7        for each edge (u, v) in E(G)  8            if d(u) + w(u, v) &lt; d(v) then  9                d(v) := d(u) + w(u, v) 10                if v is not in Q then 11                    offer v into Q\nSPFAæœ‰ä¸€å€‹å•é¡Œï¼Œä»–å¯ä»¥è¢«å‡ºé¡Œç›®çš„äººè¨­è¨ˆæ¸¬è³‡å»å¡é€™ç¨®ç®—æ³•ï¼Œä½¿æ™‚é–“è¤‡é›œåº¦è®Šæˆç³Ÿç³•çš„$O(V^2)$ï¼Œå› æ­¤ä¸€èˆ¬ä¾†èªªæœƒå¯¦ä½œDijkstraè€ŒéSPFAï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 105#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;void solve()&#123;    vector&lt;pii&gt; edge[N];                //å­˜åœ–    int n,m,s,e,f;cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;e&gt;&gt;f;    int dis[N];fill(dis,dis+N,1e16);    bool visit[N];                     //åŸå¸‚æ•¸nã€æ–¹æ¡ˆæ•¸mã€sèµ·ã€eçµ‚ã€fç®±æ•¸    memset(visit,0,sizeof(visit));        for(int i=0;i&lt;m;i++)&#123;        int a,b,c,d,e;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e;        //ä¸€æ¢ç”±aé€£åˆ°bçš„é‚Šï¼Œæ¬Šé‡cï¼Œæµé‡è¶…édï¼Œå‰‡æ”¹æ¬Šé‡c        int val = (f&gt;d?c*d+e*(f-d):c*f);        edge[a].push_back(&#123;b,val&#125;);    &#125;    //SPFA        queue&lt;int&gt; que;    que.push(s);    dis[s] = 0;    visit[s] = 1;        while(!que.empty())&#123;        int cur = que.front();        que.pop();        visit[cur] = 0;                //popå‡ºä¾†å°‡ç‹€æ…‹æ”¹æˆä¸åœ¨queueä¸­        for(auto i:edge[cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur]+weight)&#123;                dis[next] = dis[cur]+weight;                if(!visit[next])que.push(next);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e]&lt;&lt;endl;&#125;signed main()&#123;    ios;        int t;cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\nç™¾æ…•é”ä¸‰è§’æ´²é¡Œç›®é€£çµ\n\né¡Œç›®å¤§æ„ï¼šçµ¦å®šä¸€å¼µé•·nå¯¬mçš„çŸ©å½¢åœ–ï¼Œç”±â€#â€å’Œâ€.â€çµ„æˆï¼Œçµ¦å®šèµ·é»$(x_1,y_1)$ä»¥åŠçµ‚é»$(x_2,y_2)$ï¼Œå¿…é ˆæœ€å°åŒ–ç¶“éâ€.â€çš„æ¬¡æ•¸ï¼Œæ±‚æœ€å°‘éœ€å¹¾éå¹¾æ¬¡ã€‚\n\nç•¶ä¸‹çœ‹åˆ°é€™ä¸€å€‹é¡Œç›®çš„æƒ³æ³•ï¼Œå°±æ˜¯è·Ÿè™•ç†ä¸€èˆ¬çš„åœ–è«–é¡Œç›®ä¸€æ¨£ï¼Œå°‡é‚Šç”¨vectorå„²å­˜èµ·ä¾†ï¼Œå°‡ç¶“éâ€.â€çš„æ¬Šé‡è¨­ç‚ºå¾ˆå¤§çš„ä¸€å€‹æ•¸å­—ï¼Œé€™æ¨£ç”¨Dijkstraåšä¸€æ¬¡æœ€çŸ­è·¯å¾‘å°±å¯ä»¥æ‰¾å‡ºç¶“éâ€.â€æœ€å°åŒ–çš„æ¬¡æ•¸äº†ï¼\nä»¥ä¸‹æ˜¯MLEçš„Submissionåƒäº†é–‹å¿ƒçš„MLEï¼Œå¦‚æœç•¶æˆä¸€èˆ¬çš„åœ–åœ¨è™•ç†ï¼Œä¸ç®¡æ˜¯åœ¨ $dis$ é–‹long longçš„è™•è£¡ï¼Œæˆ–æ˜¯é–‹äº†ä¸€å€‹vectoré™£åˆ—å„²å­˜é‚Šï¼Œéƒ½éå¸¸çš„æ¶ˆè€—ç©ºé–“ã€‚å› æ­¤ï¼Œæˆ‘è©¢å•äº†ä¸€ä¸‹é›»ç¥é€™ä¸€é¡Œçš„æƒ³æ³•ï¼Œä»–èªªæˆ‘çš„æƒ³æ³•ç”¨Dijkstraæ˜¯æ­£ç¢ºçš„ï¼Œä¸éåœ¨è¨­å®šé‚Šæ¬Šçš„éƒ¨åˆ†å¯ä»¥ç›´æ¥ç”¨0è·Ÿ1ä»£æ›¿ï¼Œè€Œä¸”å¯ä»¥ç”¨queueå»è¼”åŠ©å¯¦ä½œBFSï¼ˆè¦èªªå®ƒä¹Ÿå¯ä»¥æ˜¯Dijkstraçš„å¦ä¸€ç¨®æ¯”è¼ƒç°¡å–®çš„ç‰ˆæœ¬ï¼‰ã€‚\n\né€™é¡Œä¹Ÿå°±æ˜¯æ‰€è¬‚0-1 BFS (Shortest Path in a Binary Weight Graph)ï¼Œæˆ–æ˜¯é€™è£¡0-1 BFSï¼Œæƒ³æ³•å¯ä»¥èªªæ˜¯Dijkstraè·ŸBFSçš„ç¶œåˆï¼ˆå…¶å¯¦å®ƒè·ŸSPFAä¹Ÿå¾ˆç›¸ä¼¼ï¼‰ã€‚ä»¥ä¸‹æ˜¯å¯¦ä½œæ­¥é©Ÿï¼š\n\nå»ºç«‹é›™å‘çš„ä½‡åˆ—(deque)ï¼Œç­‰ç­‰è¦å­˜æ”¾è¢«relaxéçš„é»ï¼Œåˆå§‹æ”¾å…¥èµ·é»\næ¯ä¸€æ¬¡å¾dequeå‰æ–¹popå‡ºä¸€é»ï¼Œå°é‚£ä¸€é»ç›¸é„°çš„æ‰€æœ‰é»é€²è¡Œé¬†å¼›\nå¦‚æœè¢«é¬†å¼›æ™‚çš„é‚Šæ¬Šé‡ç‚º0ï¼Œå°‡é»push dequeueçš„å‰æ–¹\nå¦å‰‡ç•¶é¬†å¼›æ™‚çš„é‚Šæ¬Šé‡ç‚º1ï¼Œå°‡é»push dequeueçš„å¾Œæ–¹\né‡è¤‡åŸ·è¡Œ2-4æ­¥é©Ÿç›´åˆ°dequeç‚ºç©º\n\nç•¶æˆ‘å€‘ä¸€ç›´åˆ©ç”¨dequeæœ€å‰ç«¯çš„å…ƒç´ é€²è¡Œé¬†å¼›ï¼Œå› ç‚ºæˆ‘å€‘å°‡é‚Šæ¬Šç‚º0çš„å…ƒç´ æ”¾å…¥æœ€å‰ç«¯ï¼Œç”¨è·é›¢æœ€å°çš„é‚£äº›é»é€²è¡Œé¬†å¼›ï¼Œæ¯ä¸€å€‹é»æœ€å¤šæœƒè¢«é¬†å¼›ä¸€æ¬¡ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦ç‚º$O(V+E)$ï¼Œæ¯”èµ·ç”¨Dijktraç›´æ¥åš$O((V+E)\\log V)$å¿«äº†è¨±å¤šï¼ˆæ­¤æ¼”ç®—æ³•ä¹‹æ‰€ä»¥æ­£ç¢ºæ˜¯å› ç‚ºå…¶ä¸­ä¸€é‚Šçš„æ¬Šé‡æ˜¯0ï¼Œä¸ç®¡0æ¥åˆ°èª°ä»–çš„æ¬Šé‡ä¹Ÿéƒ½æ˜¯0ï¼Œæœ‰é»åƒã€Œå¾æœ€å°å±¤é€æ¼¸æ“´å±•ã€çš„æ¦‚å¿µï¼‰ï¼\n\n            å°å•é¡Œï¼ˆå‡ºè™•é€™è£¡ï¼‰Can we apply the same trick if our edge weights can only be 0 and x (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and x+1 (x &gt;= 0) ?Can we apply the same trick if our edge weights are x and y (x,y &gt;= 0) ?è§£ç­”YES,NO,NO\n          \né€™é¡Œä¹‹æ‰€ä»¥å¯è¡Œæ˜¯å› ç‚ºæœ‰ä¸€é‚Šçš„æ¬Šé‡æ˜¯0ï¼Œç•¶é»çš†ä»¥æ¬Šé‡ç‚º0ä¸²å†ä¸€èµ·æ™‚ï¼Œä»–æœƒæ˜¯æœ€çŸ­çš„ï¼Œä½¿ç”¨æœ€çŸ­å»æ›´æ–°æ¥ä¸‹ä¾†çš„é»ï¼Œå› æ­¤ç¬¬ä¸€é¡Œæ˜¯æ­£ç¢ºçš„ï¼ä½†ç¬¬äºŒé¡Œèˆ‡ç¬¬ä¸‰é¡Œæ˜¯éŒ¯èª¤çš„ï¼Œè€ƒæ…®ä»¥ä¸‹é»èˆ‡é‚Šçš„æƒ…æ³ï¼š\n\nç•¶æˆ‘ä¾ç…§01BFSçš„æ–¹æ³•ä¸æ–·å»ç”¨xæ›´æ–°å…¶ä»–çš„é»ï¼Œæ›´æ–°å®Œä¹‹å¾Œæœƒç™¼ç¾é»1åˆ°é»3çš„æœ€çŸ­è·¯å¾‘æ‡‰è©²æ˜¯x+1ï¼Œåˆ°æ™‚å€™åˆè¦å†é‡æ–°Relaxä¸€æ¬¡ï¼Œè¤‡é›œåº¦æœƒçˆ†ç‚¸å–”ï¼ˆæ¯”SPFAå¯èƒ½é‚„æ…˜ï¼Œå› ç‚ºç•¶é»ä¸‰åˆ©ç”¨å…©å€‹xæ›´æ–°å®Œä¹‹å¾Œï¼Œç”¨å®ƒä¾†åšè·Ÿ3æ‰€æœ‰ç›¸é„°çš„é»ï¼Œåšå®Œå»ç™¼ç¾$(1,3)$æœ‰æ›´çŸ­çš„è·é›¢ï¼Œåˆå¿…é ˆé‡æ–°å…¨éƒ¨æ›´æ–°ä¸€æ¬¡ï¼ï¼‰ç¸½çµä¾†èªªï¼Œä»–åªæ˜¯ç”¨æ–¼åªæœ‰å…©ç¨®é‚Šçš„æƒ…æ³ï¼Œä¸”å…¶ä¸­ä¸€é‚Šå¿…é ˆç‚º0ã€‚\n\n\n            æ¯”è¼ƒä¸€ä¸‹è¨˜æ†¶é«”ç”¨é‡æœ€ä¸»è¦é‚„æ˜¯æ™‚é–“è¤‡é›œåº¦çš„æ¯”è¼ƒï¼Œä¸éæ—¢ç„¶ç©ºé–“å·²ç¶“çˆ†äº†ï¼Œæ™‚é–“ä¹Ÿæ²’æ³•æ¯”äº†QQMLE#define N 2005#define N2 4000005int n,m,q,predecessor[N2],dis[N2];bool visit[N2],maze[N2];vector&lt;pii&gt;edge[N2];AC#define N 2003int n,m,dis[N][N];bool visit[N][N],maze[N][N];\n          \nä»¥ä¸‹æ˜¯ä½¿ç”¨dequeå¯¦ä½œ01BFSçš„AC codeï¼š\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 2003#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,dis[N][N];int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N],maze[N][N];void solve()&#123;    cin&gt;&gt;n&gt;&gt;m;    memset(visit,0,sizeof(visit));    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=m;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 1;            else maze[i][j] = 0;        &#125;    &#125;    deque&lt;pii&gt;deq;    int s1,s2,e1,e2;cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    memset(dis,0x3f3f3f3f,sizeof(dis));    dis[s1][s2] = 0;    deq.push_back(&#123;s1,s2&#125;);    while(!deq.empty())&#123;        int x = deq.front().first,y = deq.front().second;        deq.pop_front();        for(int i=0;i&lt;4;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            if(nx&lt;1||nx&gt;n||ny&lt;1||ny&gt;m)continue;                        if(dis[nx][ny] &gt; dis[x][y]+maze[nx][ny])&#123;                dis[nx][ny] = dis[x][y]+maze[nx][ny];                if(maze[nx][ny]==0)deq.push_front(&#123;nx,ny&#125;);                else deq.push_back(&#123;nx,ny&#125;);            &#125;        &#125;    &#125;    cout&lt;&lt;dis[e1][e2]&lt;&lt;endl;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\næ±Ÿç¥èˆ‡ä»–çš„å°ç«è»Šé¡Œç›®é€£çµ\n\né¡Œç›®å¤§æ„å·²çŸ¥æœ‰Nå€‹é»ä»¥åŠMæ¢é‚Šï¼Œç¸½å…±æœ‰Qç­†è©¢å•ï¼Œæ¯ç­†è©¢å•æœ‰$\\delta(a,b)$ï¼Œè¡¨ç¤ºæ–°å¢ä¸€æ¢ç”± $a$ æŒ‡å‘ $b$ çš„é‚Šï¼ˆå…¶æ¬Šé‡ç‚º1ï¼‰ï¼Œå°æ¯ä¸€ç­†è©¢å•è¼¸å‡ºå¾é» $1$ åˆ°é» $N$ çš„æœ€çŸ­è·é›¢ã€‚\n\n\næˆ‘å€‘çŸ¥é“å¦‚æœæœ‰ç”¨æ–°åŠ é€²ä¾†çš„é‚Š $\\delta(a,b)$ï¼Œå‰‡è·¯å¾‘å¯ä»¥è¢«æ‹†è§£æˆ $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$ã€‚å…¶ä¸­ï¼Œæˆ‘å€‘å¯ä»¥ç”¨Dijkstra ä¸€æ¬¡å°‹æ‰¾1åˆ°ä»»ä½•é»çš„æœ€çŸ­è·é›¢ï¼Œé‚£è¦å¦‚ä½•è™•ç†è·¯å¾‘ $\\delta(b,n)$ å‘¢ï¼Ÿé€™å°±æ˜¯å–®ä¸€ç›®çš„æœ€çŸ­è·é›¢å•é¡Œï¼Œæˆ‘å€‘å¯ä»¥å°‡æ‰€æœ‰çš„é‚Šé€†åºï¼Œå°‡çµ‚é»åšä¸€æ¬¡Dijkstraå°‹æ‰¾æœ€çŸ­è·¯ï¼Œé€™æ™‚å€™æˆ‘å€‘å°±å¯ä»¥ç”¨ $O(1)$ çš„æ™‚é–“å›ç­”æ¯ä¸€ç­†è©¢å•ï¼Œç¸½æ™‚é–“è¤‡é›œåº¦ï¼šé è™•ç†$O((V+E)\\log V)$ï¼Œè©¢å• $O(Q)$ã€‚\n\n            æ¸¬è³‡å°å•é¡Œæœ‰ä¸€ç­†æ¸¬è³‡å¦‚ä¸‹ï¼Œè—ç·šæ˜¯çµ¦å®šçš„è·¯å¾‘èˆ‡æ¬Šé‡ï¼Œç´…è‰²æ˜¯æ–°åŠ å…¥çš„é‚Šï¼Œå¦‚æœæŒ‰ç…§ä¸Šé¢ $\\delta(1,a)+\\delta(a,b)+\\delta(b,n)$ æˆ‘å€‘å¯ä»¥è¨ˆç®—å‡ºå¾èµ·é»åˆ°çµ‚é»çš„æœ€çŸ­è·é›¢ç‚ºï¼š$2+1+4 = 7$ï¼Œå¾ˆæ˜é¡¯å…©é»ä¹‹é–“çš„æœ€çŸ­è·é›¢æ˜¯ $5$ ï¼Œä½†å› ç‚ºåŸæœ¬ä½œæ³•æœƒç¶“éä¸€æ¢$\\delta (B,C)$ çš„é‡é‚Šï¼Œé€ æˆç®—å‡ºä¾†çš„è·é›¢æ˜¯æ¯”è¼ƒå¤§çš„ï¼é€™æ™‚å€™æˆ‘å€‘åªè¦å°æœ€çŸ­è·¯å¾‘é•·åº¦å–minå³å¯ï¼Œä¹Ÿå°±æ˜¯èªªåœ¨é€™ç¨®æƒ…æ³åŠ å…¥é€™ä¸€æ¢é‚Šä¸¦ä¸æœƒå½±éŸ¿æœ€çŸ­è·¯å¾‘çš„é•·åº¦ï¼æ¸¬è³‡ï¼ˆ1,2,3åˆ†åˆ¥å°æ‡‰A,B,Cï¼‰ï¼š6 5 11 2 12 3 13 4 14 5 15 6 13 2\n          \næ¥ä¸‹ä¾†æ˜¯ç¨‹å¼ç¢¼ï¼Œä¹‹å¾Œå¦‚æœé‡åˆ°æœ€çŸ­è·¯å¾‘çš„é¡Œç›®ï¼Œä¸€èˆ¬ä¾†èªªæœƒé¿å…ä½¿ç”¨SPFAï¼ˆé™¤éæœ‰è² é‚Šï¼‰ï¼Œç‚ºäº†è¦é¿å…æœ€ç³Ÿçš„æ™‚é–“è¤‡é›œåº¦ï¼Œå› æ­¤æœƒä½¿ç”¨Dijkstraä¾†è™•ç†æœ€çŸ­è·¯å¾‘å•é¡Œï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m,q;bool visit[N];vector&lt;pii&gt; edge[2][N];//edge[0]-&gt;normal,edge[1]-&gt;oppositevector&lt;int&gt; Dijkstra(int start,int end,bool is_nor)&#123;    memset(visit,0,sizeof(visit));    vector&lt;int&gt; dis(n+2,1e16);        priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;        dis[start] = 0;    pq.push(&#123;0,start&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;                visit[cur] = 1;        for(auto i : edge[is_nor][cur])&#123;            int next = i.first,weight = i.second;            if(dis[next] &gt; dis[cur] + weight)&#123;                dis[next] = dis[cur] + weight;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    return dis;&#125;void solve()&#123;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;    for(int i=0;i&lt;m;i++)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[0][a].push_back(&#123;b,w&#125;);        edge[1][b].push_back(&#123;a,w&#125;);    &#125;        vector&lt;int&gt; normal,opposite;    normal = Dijkstra(1,n,0);    opposite = Dijkstra(n,1,1);        while(q--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        cout&lt;&lt;min(normal[a]+opposite[b]+1,normal[n])&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\nè²¨ç‰©é‹é€è¨ˆåŠƒé¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°çµ¦å®šNå€‹é»Mæ¢é‚Šï¼Œç¬¬iæ¢é‚Šæœ‰æ–¹é‚Šç‡$C_i$ï¼Œå‡è¨­ç›®å‰é‹é€è²¨ç‰©é‡é‡pç¶“éæ­¤é‚Šï¼Œä»£è¡¨ç¶“éé‚Šiæœƒéœ€è¦å¤šå¢åŠ  $p\\times C_i$ çš„é‡é‡ã€‚çµ¦å®šèµ·é»ã€çµ‚é»ï¼Œæ±‚åˆ°é”çµ‚é»æ™‚æœ€å°‘çš„è²¨ç‰©é‡é‡ç‚ºå¤šå°‘ã€‚\n\næ›ç¨®èªªæ³•ï¼Œé¡Œç›®è¦æ±‚çš„æ˜¯æ¯ç¶“éä¸€æ¢é‚Šï¼Œå°±è¦ä¹˜ä¸ŠæŸä¸€å€‹æ•¸ï¼Œè¦æ±‚åˆ°çµ‚é»æœ€å°çš„é‡é‡ã€‚ä¸‹åœ–æ˜¯é¡Œç›®ç¯„ä¾‹æ¸¬è³‡ï¼š\n$\\delta(1,2)\\to\\delta(2,3)$ï¼Œæ‰€ä»˜å‡ºçš„ä»£åƒ¹æ˜¯$(1\\times (1+1))\\times (2+1)=6$ã€‚å¦‚æœæ˜¯$\\delta(1,3)$ çš„è©±ç›´æ¥$1\\times (4+1)=5$ï¼Œå¯ä»¥è§€å¯Ÿåˆ°ï¼Œé‡åˆ°é‚Šå°±éœ€è¦å°‡åŸæœ¬çš„æ•¸å­—ä¹˜ä¸Š$C_i+1$ã€‚\næˆ‘å€‘å¯ä»¥é€éå°‡é‚Šæ¬Šå– $\\log$ ä¹‹å¾Œï¼Œå°±å¯ä»¥åˆ©ç”¨Dijkstraé€²è¡Œæœ€çŸ­è·¯å¾‘çš„è¨ˆç®—ï¼Œå› ç‚ºå– $\\log$ å¾Œçš„åŠ æ¸›é‹ç®—ç­‰åŒæ–¼åŸæœ¬çš„ä¹˜æ³•é‹ç®—ï¼Œåªè¦æœ€å¾ŒæŠŠç®—å‡ºä¾†çš„ç­”æ¡ˆæ¬¡æ–¹å³å¯ï¼\né€™ä¸€é¡Œçš„è¼¸å‡ºè¦æ±‚ç§‘å­¸è¨˜è™Ÿï¼ˆç‚ºäº†è¦é¿å…æµ®é»æ•¸èª¤å·®ï¼‰ï¼Œä»¥ä¸‹ç¨‹å¼ç¢¼ä¾†é”æˆï¼ˆè¦æ±‚å°æ•¸é»å¾Œå…©ä½ï¼ŒåŒæ™‚æ¬¡æ–¹éƒ¨åˆ†è¦æ±‚æ•´æ•¸3ä½ï¼‰ï¼š\nprintf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);\nç¨‹å¼ç¢¼çš„éƒ¨åˆ†ï¼Œé€é$edge$å­˜å®Œæ‰€æœ‰çš„å–å®Œ $\\log$ ä¹‹å¾Œçš„é‚Šï¼Œé€²è¡ŒDijkstraï¼Œè¼¸å‡ºæœ€çŸ­è·¯å¾‘ï¼ˆä»¥ç§‘å­¸è¨˜è™Ÿè¡¨ç¤ºï¼‰å³å¯ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define N 10005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s,t;double dis[N];bool visit[N];vector&lt;pid&gt; edge[N];void solve()&#123;    memset(visit,0,sizeof(visit));        scanf(&quot;%lld %lld %lld %lld&quot;,&amp;n,&amp;m,&amp;s,&amp;t);    for(int i=0;i&lt;m;i++)&#123;        int a,b;double c;scanf(&quot;%lld %lld %lf&quot;,&amp;a,&amp;b,&amp;c);        edge[a].push_back(&#123;b,(double)log10(c+1)&#125;);    &#125;    fill(dis,dis+n+2,1e16);        priority_queue&lt;pdi,vector&lt;pdi&gt;,greater&lt;pdi&gt;&gt; pq;    dis[s] = 0.0;    pq.push(&#123;0,s&#125;);        while(!pq.empty())&#123;        int cur = pq.top().second;        pq.pop();        if(visit[cur])continue;        visit[cur] = 1;                for(auto i:edge[cur])&#123;            int next = i.first;            double w = i.second;            if(dis[next] &gt; dis[cur]+w)&#123;                dis[next] = dis[cur]+w;                pq.push(&#123;dis[next],next&#125;);            &#125;        &#125;    &#125;    double ans = dis[t];    int x = floor(ans);    ans-=x;        printf(&quot;%.2fe+%03lld\\n&quot;,pow(10,ans),x);&#125;signed main()&#123;    int t;t = 1;    while(t--)&#123;        solve();    &#125;&#125;\nE.æ¼¢ç±³é “çš„éº»ç…©é¡Œç›®é€£çµ\nä»–é¡Œç›®æ™‚ä¸æ™‚æåˆ°æ¼¢ç±³é “ï¼Œæ˜¯å¤šæ„›æ¼¢ç±³é “XDDï¼ˆé€™ä¸€é¡Œè·Ÿæ¼¢ç±³é “æ ¹æœ¬æ²’é—œä¿‚ï¼‰\n\né¡Œç›®å¤§æ„åœ¨ä¸€å¼µn(nâ‰¤100)å€‹é»çš„åœ–ä¸­ï¼Œå°‹æ‰¾è·¯å¾‘é•·åº¦æœ€çŸ­çš„ç’°\n\né‚£å°±ç”¨Floyd-Warshallæ‰¾æœ€å°çš„ç’°å°±å¥½ï¼\n\n            Floyd-Warshallé€™å°±æ˜¯dpçš„ä½œæ³•ï¼Œç”¨ $O(N^3)$ çš„æ™‚é–“é€²è¡Œè½‰ç§»ï¼Œå°±èƒ½å¾—åˆ°å…¨é»å°çš„æœ€çŸ­è·¯å¾‘ã€‚é€™é‚Šæœ‰ä¸€å€‹é‡è¦çš„è½‰ç§»é †åºï¼Œä¹Ÿå°±æ˜¯ä¸­é»-èµ·é»-çµ‚é»é€²è¡Œè½‰ç§»ï¼Œå¦‚æœæŠŠdpå±•é–‹å°±æœƒç™¼ç¾ä¸­é»å¿…é ˆåœ¨æœ€å¤–å±¤é€²è¡Œè½‰ç§»ï¼šå®šç¾© $dp[k][i][j]$ ç‚ºé» $i$ èµ°åˆ°é» $j$ ï¼Œåªèƒ½ç¶“éå‰kå€‹é»çš„æœ€çŸ­è·¯å¾‘ï¼Œå‰‡è½‰ç§»å¼è®Šæˆï¼šd[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])æ¯ä¸€å€‹k+1éƒ½æ˜¯ç”±kè½‰ç§»è€Œä¾†ï¼Œä»°è³´kçš„é»çš„é…å°ï¼Œå› æ­¤å¿…é ˆæœ€å…ˆè½‰ç§»ä¸­é»kçš„éƒ¨åˆ†ï¼ï¼ˆä¸éé †åºé¡›å€’ä¹Ÿä¸æœƒæ€æ¨£å•¦ï¼Œä¸Šé¢ã€Œèª²ç¨‹å…§å®¹ã€çš„åœ°æ–¹æœ‰å¯«åˆ°ï¼‰\n          \nåŒæ¨£é€™ä¸€ä»½codeä¹Ÿå¯ä»¥åˆ¤æ–·æœ‰æ²’æœ‰è² ç’°ï¼Œåªè¦anså°æ–¼0çš„è©±ä»£è¡¨æœ‰è² ç’°ï¼ˆæœ‰çš„è©±è·é›¢æ˜¯ä¸èƒ½ç”¨çš„å–”ï¼Œå› ç‚ºFloyd-Warshallä¸èƒ½è™•ç†è² ç’°ï¼Œä½†è² é‚Šæ˜¯å¯ä»¥è™•ç†çš„ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 101#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,dp[N][N];void solve()&#123;    memset(dp,0x3f3f3f3f,sizeof(dp));    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;n;j++)&#123;            int temp;cin&gt;&gt;temp;            if(temp!=0)dp[i][j] = temp;        &#125;    &#125;    for(int k=0;k&lt;n;k++)&#123;        for(int i=0;i&lt;n;i++)&#123;            for(int j=0;j&lt;n;j++)&#123;                dp[i][j] = min(dp[i][j],dp[i][k]+dp[k][j]);            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)&#123;        ans = min(ans,dp[i][i]);    &#125;    if(ans == INT_MAX)cout&lt;&lt;-1&lt;&lt;endl;    else cout&lt;&lt;ans&lt;&lt;endl;&#125;signed main()&#123;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        solve();    &#125;&#125;\næ—…éŠè¦åŠƒå•é¡Œé¡Œç›®é€£çµSubmissioné€™ä¸€é¡Œ $nâ‰¤13$ å¤§æ¦‚å°±æ˜¯ä½å…ƒdpä¾†å®Œæˆï¼ˆç‹€æ…‹å£“ç¸®ï¼‰ï¼Œå®šç¾© $dp[i][j]$ ç‚ºç¾åœ¨åœ¨é»iä¸Šï¼Œæ‹œè¨ªéé»é›†jçš„æœ€çŸ­è·é›¢ï¼ˆjä¸­ä¸åŒ…å«é»iï¼‰ã€‚é€™è£¡ä½¿ç”¨åˆ°äº†åŒå±¤è½‰ç§»çš„æŠ€å·§ï¼Œä¹Ÿå°±æ˜¯åˆ©ç”¨jä¸­çš„é»ï¼Œå°ç›¸åŒç‹€æ…‹ä¸‹ä¸åœ¨iä¸­çš„é»é€²è¡Œæ›´æ–°ã€‚\né»é›†jä¸­åœ¨ç‹€æ…‹iä¸‹ç‚ºèµ·é»ï¼Œç”¨Dijkstraå°ä¸åœ¨iä¸­çš„å…¶ä»–é»é€²è¡Œæ›´æ–°ï¼Œæœ€å¾Œçš„ç­”æ¡ˆå³ç‚º$dp[s][S-(1&lt;&lt;s)]$ã€‚\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 14#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;using namespace std;int n,m;vector&lt;pii&gt; edge[N];int dis[N],dp[N][1&lt;&lt;N],pre[N][1&lt;&lt;N];bool visit[N];//å®šç¾©dp[i][j]ç‚ºç¾åœ¨åœ¨é»iï¼Œæ‹œè¨ªéé»é›†åˆjï¼ˆiä¸åœ¨é»é›†jä¸­ï¼‰signed main()&#123;    cin&gt;&gt;n&gt;&gt;m;    rep(i,1,m)&#123;                                 //è®€å…¥mæ¢é‚Š        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    int S = 0,start = -1;cin&gt;&gt;m;                //Sç‚ºå¾…æ‹œè¨ªçš„æ‰€æœ‰é»é›†åˆ    rep(i,1,m)&#123;        int temp;cin&gt;&gt;temp;        S = S|(1&lt;&lt;temp);        if(start == -1)start = temp;    &#125;        rep(i,0,n)rep(j,0,(1&lt;&lt;n))dp[i][j] = INF;    rep(i,0,n)dp[i][0] = 0;        for(int i=1;i&lt;(1&lt;&lt;n);i++)&#123;        if(i == (S &amp; i))&#123;                       //åœ¨é›†åˆiä¸­çš„é»åœ¨Sä¸€å®šè¦æœ‰            priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt; pq;            fill(dis,dis+n,INF);                //å°‡disåˆå§‹ç‚ºç„¡é™å¤§ï¼ŒåšDijkstra            memset(visit,0,sizeof(visit));            for(int j=0;j&lt;n;j++)&#123;                if(i&amp;(1&lt;&lt;j))&#123;                   //å¾æœ‰åœ¨iä¸­çš„é»å‘ä¸åœ¨çš„é»åšDijkstra                    dis[j] = dp[j][i^(1&lt;&lt;j)];   //ç›®å‰åœ¨jï¼Œç¶“éæ‹œè¨ªäº†é»é›†iï¼ˆä¸åŒ…å«é»jï¼‰                    pq.push(&#123;dis[j],j&#125;);        //åˆ©ç”¨åœ¨iä¸­çš„é»å°å…¶ä»–é»é€²è¡Œæ›´æ–°                &#125;            &#125;            while(!pq.empty())&#123;                int cur = pq.top().second;                pq.pop();                visit[cur] = 1;                for(auto k : edge[cur])&#123;                    int v = k.first,w = k.second;                    if(i&amp;(1&lt;&lt;v))continue;                    if(dis[v] &gt; dis[cur]+w)&#123;                        dis[v] = dis[cur] + w;                        pre[v][i] = cur;        //ç´€éŒ„é»våœ¨ç‹€æ…‹iä¸‹ç”±curè½‰ç§»                        pq.push(&#123;dis[v],v&#125;);                    &#125;                    else if(dis[v] == dis[cur]+w &amp;&amp; pre[v][i] &gt; cur)&#123;                        pre[v][i] = cur;                    &#125;                &#125;            &#125;            for(int j=0;j&lt;n;j++)&#123;               //å°æ–¼ä¸åœ¨é»é›†iä¸­çš„é»é€²è¡Œæ›´æ–°                if(i &amp; (1 &lt;&lt; j))continue;                dp[j][i] = dis[j];              //åŒå±¤ç‹€æ…‹è½‰ç§»ï¼Œæ›´æ–°dp[j][i]            &#125;        &#125;    &#125;    cout&lt;&lt;&quot;Minimum travel distance: &quot;&lt;&lt;dp[start][S^(start)]&lt;&lt;endl;    cout&lt;&lt;&quot;Travel route:&quot;;    int cur = start;S = S^(1&lt;&lt;start);    while(true)&#123;        cout&lt;&lt;&quot; &quot;&lt;&lt;cur;        if(!S)break;        cur = pre[cur][S];        if(S&amp;(1&lt;&lt;cur))S = (S^(1&lt;&lt;cur));         //ç¶“éçš„é»ä¸ä¸€å®šæ˜¯æŒ‡å®šçš„è§€å…‰é»    &#125;    cout&lt;&lt;endl;&#125;\nCodeforces 543B: Destroying Roadsé¡Œç›®é€£çµSubmission\n\né¡Œç›®å¤§æ„çµ¦å®šNå€‹é»Mæ¢ç„¡å‘é‚Šï¼Œæ¯ä¸€é‚Šæ¬Šé‡éƒ½æ˜¯1ï¼Œä»¥åŠå…©ç­†è³‡æ–™ï¼Œç”±ä¸‰å€‹æ•¸$(x,y,w)$ æ§‹æˆï¼Œä»£è¡¨èµ·é»ç‚ºxã€çµ‚é»ç‚ºxã€è¦åœ¨wè·é›¢å…§å¾èµ·é»èµ°åˆ°çµ‚é»ã€‚è©¦å•æœ€å¤šå¯ä»¥æ‹”æ‰å¹¾æ¢é‚ŠåŒæ™‚æ»¿è¶³ä»¥ä¸Šå…©å€‹è³‡æ–™æ‰€æè¿°çš„ç‰¹æ€§ï¼Ÿ\n\né€™ä¸€é¡Œè »æœ‰è¶£çš„ï¼Œé¦–å…ˆä»–çš„é‚Šæ¬Šé‡éƒ½æ˜¯1ï¼Œå› æ­¤æˆ‘å€‘å¯ä»¥ç›´æ¥ç”¨BFSå°‹æ‰¾æœ€çŸ­è·¯å¾‘ï¼Œä¸¦ä¸”é»ç¬¬ä¸€æ¬¡æ‹œè¨ªåˆ°æ™‚çš„å°±æ˜¯è©²é»çš„æœ€çŸ­è·é›¢ï¼ˆBFSä¸€å±¤ä¸€å±¤æ“´å±•ï¼‰ã€‚\n\n            ç¬¬ä¸€å€‹æƒ³æ³•ï¼šéŒ¯èª¤æƒ³æ³•æˆ‘å…ˆå°‡å…©å€‹èµ·é»èˆ‡çµ‚é»çš„æœ€çŸ­è·¯å¾‘éƒ½æ‰¾å‡ºä¾†ï¼ŒæŠŠå°‡éçš„é‚Šéƒ½æ¨™ä¸Šä¸èƒ½ç§»é™¤ï¼Œå°‡å…¶ä»–çš„é‚Šå…¨éƒ¨æ‹”æ‰ã€‚å•é¡Œé»ï¼šå›ºç„¶æ‰¾åˆ°çš„æ˜¯æœ€çŸ­è·¯å¾‘ï¼Œä½†ä¸ä»£è¡¨å¯ä»¥æœ€å¤§åŒ–æ‹”é™¤é‚Šçš„æ•¸é‡ã€‚å› ç‚ºé¡Œç›®è¦æ±‚å…©é»åªè¦ç¬¦åˆæœ€çŸ­è·é›¢ $w$ å³å¯ï¼Œå› æ­¤æ¯ä¸€å€‹é…å°å…¶å¯¦ä¸ç”¨ç¬¦åˆæ˜¯æœ€çŸ­è·¯å¾‘çš„æƒ…æ³ï¼ˆå¦‚ä¸‹åœ–ï¼‰ï¼ç›®æ¨™æ˜¯åœ¨é¡Œç›®è¦æ±‚çš„é™åº¦å…§æœ€å¤§åŒ–é‡è¤‡çš„é‚Šï¼Œä½¿èƒ½å¤ è¢«æ‹”é™¤çš„é‚Šæœ€å¤§åŒ–ï¼ä¸Šåœ–ç´…è‰²ç·šæ®µæ˜¯$\\delta(1,7)$çš„æœ€çŸ­è·¯å¾‘ã€è¤è‰²æ˜¯ç·šæ®µ$\\delta(3,6)$çš„æœ€çŸ­è·¯å¾‘ã€é»‘è‰²ç·šæ®µæ˜¯çš†ä»¥æœ€çŸ­è·¯å¾‘ä¹‹ä¸‹å¯ä»¥è¢«æ‹”é™¤çš„é‚Šã€‚ä½†æ˜¯å¦‚æœå°‡è·¯å¾‘$\\delta(3,6)$æ›æˆæ˜¯$(3,2)\\to(2,4)\\to(4,5)\\to(5,6)$ï¼Œè¢«æ‹”é™¤çš„é‚Šå¯ä»¥å¢éç‚ºä¸‰æ¢ã€‚\n          \né€™ä¸€é¡Œæœ€é‡è¦çš„é—œéµå°±æ˜¯ä»¥$O(V^2)$æšèˆ‰æ‰€æœ‰é»å°ï¼ˆè·é›¢é•·åº¦å¯ä»¥ç›´æ¥æ›ç®—æˆé‚Šçš„æ•¸é‡ï¼‰ï¼Œå¯ä»¥å…ˆç”¨$O(V(V+E)$çš„æ™‚é–“å°æ¯ä¸€å€‹é»ç”¨é€²è¡ŒBFSï¼Œå¦‚æ­¤ä¸€ä¾†ç¸½è¤‡é›œåº¦å³ç‚º$O(V^2+VE)$ï¼Œæ‰€å¹¸é¡Œç›®çµ¦å®šç¸½å…±çš„é‚Šæ•¸ä¸æœƒè¶…é3000æ¢ï¼Œå› æ­¤æ˜¯å¯ä»¥åœ¨æ™‚é–“é™åˆ¶å…§å®Œæˆæšèˆ‰ã€‚\n\n            æšèˆ‰è·¯å¾‘ $\\delta(i,j)$ ç‚ºå…±åŒé‚Šçš„æ™‚å€™ï¼Œå¿…é ˆè€ƒæ…®èµ·é»èˆ‡çµ‚é»çš„æ–¹å‘ï¼ŒåŒæ™‚è€ƒæ…®å¾ $i\\to j$ ä»¥åŠå¾ $j\\to i$ å…©å€‹æ–¹å‘ã€‚ä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œç•¶æšèˆ‰éƒ½ä½¿ç”¨ç›¸åŒçš„èµ·é»ä»¥åŠçµ‚é»ï¼Œæœƒè®“ä¸‹åœ–çš„ $(3,4)$ è¢«é‡è¤‡è¨ˆç®—ï¼\n          \nä»¥ä¸‹æ˜¯ACç¨‹å¼ç¢¼ï¼š\n#include &lt;bits/stdc++.h&gt;#define ll long long#define Orz ios::sync_with_stdio(0),cin.tie(0)#define N 3005#define FOR(i,n) for(int i=0;i&lt;n;i++)#define pii pair&lt;int,int&gt;#define pid pair&lt;int,double&gt;#define pdi pair&lt;double,int&gt;using namespace std;int n,m,s1,e1,w1,s2,e2,w2,dis[N][N];bool visit[N];vector&lt;int&gt; edge[N];int main()&#123;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        edge[a].push_back(b);        edge[b].push_back(a);    &#125;    cin&gt;&gt;s1&gt;&gt;e1&gt;&gt;w1&gt;&gt;s2&gt;&gt;e2&gt;&gt;w2;    memset(dis,0x3f3f3f3f,sizeof(dis));        for(int i=1;i&lt;=n;i++)&#123;        memset(visit,0,sizeof(visit));        queue&lt;int&gt;que;        que.push(i);        visit[i] = 1;        dis[i][i] = 0;        while(!que.empty())&#123;            int cur = que.front();            que.pop();            for(auto j:edge[cur])&#123;                if(visit[j])continue;                dis[i][j] = dis[i][cur]+1;                visit[j] = 1;                que.push(j);            &#125;        &#125;    &#125;    if(dis[s1][e1]&gt;w1||dis[s2][e2]&gt;w2)&#123;        cout&lt;&lt;-1&lt;&lt;endl;        return 0;    &#125;    int ans = dis[s1][e1]+dis[s2][e2];    //O(n^2)æšèˆ‰æ‰€æœ‰å…±åŒé‚Š    for(int i=1;i&lt;=n;i++)&#123;        for(int j=1;j&lt;=n;j++)&#123;            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[s2][i]+dis[i][j]+dis[j][e2]&lt;=w2)                ans = min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[s2][i]+dis[j][e2]);            if(dis[s1][i]+dis[i][j]+dis[j][e1]&lt;=w1&amp;&amp;dis[e2][i]+dis[i][j]+dis[j][s2]&lt;=w2)                ans=min(ans,dis[s1][i]+dis[i][j]+dis[j][e1]+dis[e2][i]+dis[j][s2]);                    &#125;    &#125;    cout&lt;&lt;m-ans&lt;&lt;endl;&#125;\nTIOJ 2180 å‹‡è€…å†’éšª (Adventure)é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦å®šä¸€å€‹åœ°åœ–å…± $R\\times C$ è¡Œï¼Œæ¥è‘—æœƒæœ‰ $M$ è¡Œæ¯ä¸€è¡Œéƒ½æœ‰ä¸€å€‹åº§æ¨™å’Œç­‰ç´šï¼Œä»£è¡¨ç¶“éé€™å€‹åº§æ¨™éœ€è¦å¤šå°‘ç­‰ç´šæ‰èƒ½é€šéã€‚å•å¾ç‰¹å®šèµ·é»åˆ°çµ‚é»æ‰€éœ€è¦çš„æœ€ä½çš„ç­‰ç´šç‚ºå¤šå°‘ã€‚\n\né€™é¡Œè »ç‰¹åˆ¥çš„ï¼Œä»–ç”¨åˆ°äº†Dijkstraä¸­æ¯ä¸€æ¬¡éƒ½æ‰¾æœ€å°çš„å»æ›´æ–°ï¼ŒåŒæ™‚å› ç‚ºè¦æ±‚çš„æ˜¯è·¯å¾‘ä¸Šæœ€å¤§çš„ç­‰ç´šç‚ºä½•ï¼Œå› æ­¤ä¹Ÿç”¨åˆ°äº†é¡ä¼¼BFSçš„æ‰‹æ³•å»æ“´å±•æ¯ä¸€å€‹åº§æ¨™ã€‚\nå› ç‚ºé¡Œç›®ä¿è­‰è‡³å°‘æœƒæœ‰ä¸€æ¢è·¯å¾‘é€šå¾€èµ·é»èˆ‡çµ‚é»ï¼ŒåŒæ™‚æˆ‘å€‘æ¯ä¸€æ¬¡å¾queueæ‹¿å‡ºä¾†çš„éƒ½æ˜¯ç›®å‰ç­‰ç´šæœ€ä½çš„é»ï¼Œå› æ­¤å¦‚æœç¢°åˆ°çµ‚é»å°±å¯ä»¥ç¢ºå®šé€™ä¸€æ¢è·¯ç·šä¸€å®šæ˜¯éœ€è¦ç­‰ç´šæœ€å°çš„ä¸€æ¢è·¯å¾‘ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 1005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,row,col,mp[N][N],dis[N][N];int s1,s2,e1,e2;int dx[4] = &#123;0,-1,0,1&#125;,dy[4] = &#123;1,0,-1,0&#125;;bool visit[N][N];typedef pair&lt;int ,pair&lt;int,int&gt;&gt; pp;void Dijkstra()&#123;    //Dijkstra    priority_queue&lt;pp,vector&lt;pp&gt;,greater&lt;pp&gt;&gt; pq;    dis[s1][s2] = 0;    pq.push(&#123;0,&#123;s1,s2&#125;&#125;);        while(!pq.empty())&#123;        int rr = pq.top().y.x,cc = pq.top().y.y;//        cout&lt;&lt;rr&lt;&lt;&quot; &quot;&lt;&lt;cc&lt;&lt;&quot;  &quot;&lt;&lt;dis[rr][cc]&lt;&lt;endl;        pq.pop();        for(int i=0;i&lt;4;i++)&#123;            int nx = rr+dx[i],ny = cc+dy[i];            if(nx&lt;0||ny&lt;0||nx&gt;=row||ny&gt;=col)continue;            if(nx == e1 &amp;&amp; ny == e2)&#123;                cout&lt;&lt;dis[rr][cc]&lt;&lt;endl;                return;            &#125;            if(mp[nx][ny] == -1)continue;            if(visit[nx][ny])continue;            dis[nx][ny] = max(dis[rr][cc],mp[nx][ny]);            pq.push(&#123;dis[nx][ny],&#123;nx,ny&#125;&#125;);            visit[nx][ny] = 1;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;row&gt;&gt;col;    memset(dis,0,sizeof(dis));    memset(visit,0,sizeof(visit));    memset(mp,-1,sizeof(mp));    cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;e1&gt;&gt;e2;    cin&gt;&gt;n;    while(n--)&#123;        int a,b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;        mp[a][b] = c;    &#125;    Dijkstra();&#125;\næœ€å°èŠ±è²»çš„èˆªç©ºä¹‹æ—…\né¡Œç›®æ•˜è¿°ï¼šçµ¦å®šå¾ˆå¤šç¨®é€£æ¥åŸå¸‚é–“çš„è¯ç¥¨ï¼Œè¦æ±‚å¾èµ·å§‹ç«™æ­ä¹˜ï¼Œå¯ä»¥åœ¨ä¸­é€”ä»»æ„ç«™ä¸‹è»Šï¼Œä½†ä¸‹è»Šä»¥å¾Œå°±ä¸èƒ½å†æ¬¡ä¸Šè»Šã€‚è¼¸å…¥çš„ç¬¬ä¸€è¡Œç‚ºä¸€å€‹æ­£æ•´æ•¸ n (1 â‰¤ n â‰¤ 20)ï¼Œå³è¯ç¥¨çš„ç¨®é¡æ•¸ã€‚ä»¥ä¸‹ n è¡Œæ¯èˆªç‚ºä¸€å€‹è¯ç¥¨çš„è³‡è¨Šï¼Œå…¶ä¸­ç¬¬ä¸€å€‹æ•´æ•¸ç‚ºè¯ç¥¨çš„åƒ¹æ ¼ï¼Œç„¶å¾Œæ˜¯è¯ç¥¨ä¸ŠåŸå¸‚çš„æ•¸ç›®ã€‚\næ¥ä¸‹ä¾†ç‚ºä¸€å€‹è¡Œç¨‹å–®çš„è³‡è¨Šï¼Œå…¶ä¸­ç¬¬ä¸€å€‹æ­£æ•´æ•¸ç‚ºè¡Œç¨‹å–®ä¸Šçš„åŸå¸‚æ•¸ç›®kï¼ˆåŒ…æ‹¬èµ·å§‹åŸå¸‚ï¼Œ2 â‰¤ k â‰¤ 10ï¼‰ï¼Œä»¥åŠé€™äº›åŸå¸‚çš„ç·¨è™Ÿï¼ˆæŒ‰é †åºåˆ—å‡ºï¼‰ã€‚\nè¼¸å‡ºæœ€å°èŠ±è²»å’Œå°æ‡‰çš„æ–¹æ¡ˆçš„å…¶ä¸­ä¸€çµ„è§£ã€‚\n\né€™ä¸€é¡Œæ˜¯APCS Classçš„å…¶ä¸­ä¸€é¡Œï¼Œé›£åº¦é —é«˜ï¼Œå› ç‚ºä»–è¦æ‰¾æœ€çŸ­çš„è·¯å¾‘ï¼ŒåŒæ™‚å¢åŠ äº†å¯ä»¥åœ¨ä»»æ„ç«™ä¸‹è»Šçš„æ¢ä»¶ã€‚é¦–å…ˆæˆ‘å€‘è¦ç¶­è­·æ¯ä¸€å€‹è¯ç¥¨çš„è³‡è¨Šï¼Œå®ƒçš„åƒ¹å€¼ã€èµ·é»ã€ç·¨è™Ÿä»¥åŠç¶“éçš„åŸå¸‚ã€‚æ¥è‘—ï¼Œæˆ‘å€‘è€ƒæ…®æ‰€æœ‰å¾èµ·é»å‡ºç™¼çš„è¯ç¥¨ï¼Œå°‡æ¯ä¸€ç¨®è¯ç¥¨ä¸Šçš„æ¯ä¸€å€‹ç¶“éçš„åŸå¸‚éƒ½åŠ å…¥queueä¸­ã€‚\nè·Ÿä¸Šä¸€é¡Œä¸€æ¨£ï¼Œç•¶æˆ‘å€‘æ¯ä¸€æ¬¡éƒ½å¾costæœ€å°çš„é»ä¸‹æ‰‹ï¼Œåœ¨è½‰ç§»çš„éç¨‹ä¸­å¦‚æœå°‡æ‰€æœ‰çš„é»éƒ½èµ°è¨ªä¸€éï¼Œå‰‡ä»–çš„è·¯å¾‘å¿…å®šæ˜¯æœ€çŸ­çš„ï¼Œå› ç‚ºæ¯ä¸€æ¬¡çš„æ›´æ–°éƒ½æ˜¯å¾èŠ±è²»æœ€å°çš„è·¯å¾‘å»è½‰ç§»ã€‚\n\n            ä½¿ç”¨è‡ªå®šç¾©æ¯”è¼ƒå‡½æ•¸æ”¾å…¥Priority_queueä¸­Priority_queueä¸­çš„æ¯”è¼ƒå‡½æ•¸éœ€è¦ä½¿ç”¨åˆ°structæˆ–classåŒ…è¦†çš„æ¯”è¼ƒå‡½æ•¸ï¼Œè‹¥è¦å›å‚³costçš„æœ€å°å€¼ï¼Œå‰‡å¿…é ˆä»¥å¤§æ–¼ä¾†å¯«ï¼ˆæœ‰é»åƒé è¨­æ˜¯popå‡ºæœ€å¤§å€¼ï¼Œä½¿ç”¨çš„å»æ˜¯lessçš„æ¯”è¼ƒå‡½æ•¸ï¼‰struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;&#125;;\n          \nä»¥ä¸‹æ˜¯AC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define ll long long#define int long long#define double long double#define N 105#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define rrep(i,l,r) for(int i=l;i&lt;r;i++)#define pii pair&lt;int,int&gt;#define pif pair&lt;int,float&gt;#define x first#define y secondusing namespace std;int n,k,visit[20];struct Ticket&#123;    int id,cost;    vector&lt;int&gt; next_city;    //é™£åˆ—ticket[i]å­˜ä»¥iç‚ºèµ·é»&#125;;vector&lt;Ticket&gt; ticket[30];          //ticket[i] èµ·é»ç‚ºiçš„è¯ç¥¨struct node&#123;    int cost,cur_pos,visit_pos;    vector&lt;int&gt; used_ticket;    //cur_posç¾åœ¨æ‰€åœ¨ä½ç½®ã€visit_posåœ¨è¡Œç¨‹å–®ä¸Šä½ç½®&#125;;struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.cost &gt; b.cost;    &#125;    //è®“priority_queueå¯ä»¥popå‡ºæœ€å°çš„costçš„è·¯å¾‘&#125;;priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;signed main()&#123;    Orz;    cin&gt;&gt;n;    rep(i,1,n)&#123;        int cost,num,s;cin&gt;&gt;cost&gt;&gt;num&gt;&gt;s;        vector&lt;int&gt; temp;        rep(j,1,num-1)&#123;            int k;cin&gt;&gt;k;            temp.push_back(k);        &#125;        ticket[s].push_back(&#123;i,cost,temp&#125;);    &#125;    cin&gt;&gt;k;    rep(i,1,k)cin&gt;&gt;visit[i];        for(auto i : ticket[visit[1]])&#123;         //è¡Œç¨‹ç¬¬ä¸€å€‹èµ·é»çš„è¯ç¥¨èµ·é»        int p = 1;        for(auto j : i.next_city)&#123;            if(p &lt; k &amp;&amp; j == visit[p+1])p++;            pq.push(&#123;i.cost,j,p,&#123;i.id&#125;&#125;);//            cout&lt;&lt;&quot;ä¸€é–‹å§‹è¯ç¥¨ï¼š&quot;&lt;&lt;i.id&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;        &#125;    &#125;    while(!pq.empty())&#123;        node cur = pq.top();        pq.pop();        if(cur.visit_pos == k)&#123;            cout&lt;&lt;&quot;Cost = &quot;&lt;&lt;cur.cost&lt;&lt;&quot;, Tickets used: &quot;                &lt;&lt;cur.used_ticket[0];            for(int i=1;i&lt;cur.used_ticket.size();i++)                cout&lt;&lt;&quot;, &quot;&lt;&lt;cur.used_ticket[i];            cout&lt;&lt;endl;            break;        &#125;        for(auto i : ticket[cur.cur_pos])&#123;            vector&lt;int&gt; vec(cur.used_ticket);            vec.push_back(i.id);                //å°‡ç¾åœ¨ä½¿ç”¨çš„ç¬¬iè¯ç¥¨æ¨å…¥            int p = cur.visit_pos;            for(auto j : i.next_city)&#123;                if(p &lt; k &amp;&amp; j == visit[p+1])p++;                pq.push(&#123;cur.cost+i.cost,j,p,vec&#125;);            &#125;        &#125;    &#125;&#125;\n","categories":["C++é€²éšä¸»é¡Œ","æœ€çŸ­è·¯å¾‘"],"tags":["2021æš‘æœŸç­†è¨˜","2020è³‡è¨Šä¹‹èŠ½"]},{"title":"ä¹å®®æ ¼åŒ¡åˆ—æ©Ÿç‡è¨è«–","url":"/quarantine/","content":"æœ€è¿‘æ¨å‡ºäº†æ–°çš„éš”é›¢æ”¿ç­–ï¼Œç­ä¸Šåªè¦æœ‰äººç¢ºè¨ºï¼Œä»–ä½ç½®é™„è¿‘çš„ä¹å®®æ ¼å…§çš„äººéƒ½å¿…é ˆè¢«åŒ¡åˆ—ã€‚é›–ç„¶é€™å€‹éš”é›¢æ–¹å¼æœ¬ä¾†å°±æ€ªæ€ªçš„ï¼Œä¸éæˆ‘å€‘é‚„æ˜¯å¯ä»¥é‡å°è¢«éš”é›¢çš„æ©Ÿç‡åšä¸€äº›å°å°çš„è¨ˆç®—ï¼\nç‚ºäº†è¨ˆç®—æ–¹ä¾¿ï¼Œéƒ½æ˜¯é™åˆ¶åœ¨æ­£æ–¹å½¢çš„åº§ä½æ’åˆ—ä¸‹ï¼Œå°9äººã€16äººã€25äººæˆ–36äººçš„æƒ…æ³åšè¨è«–ï¼Œä¸”æ¯ä¸€å€‹äººç¢ºè¨ºæ©Ÿæœƒæ˜¯ç›¸åŒçš„ã€‚é€™ç¯‡æ–‡ç« ç¸½å…±åˆ†ç‚ºä¸‰å€‹éƒ¨åˆ†ï¼Œé¦–å…ˆæ˜¯åœ¨å›ºå®šç¢ºè¨ºäººæ•¸ä¸‹ï¼Œè¨è«–ä¸åŒä½ç½®çš„éš”é›¢æ©Ÿç‡ã€‚æ¥è‘—æ˜¯è¨è«–ç¢ºè¨ºäººæ•¸èˆ‡å…¨ç­éƒ½è¢«éš”é›¢çš„æ©Ÿç‡é—œä¿‚ã€‚æœ€å¾Œï¼Œè¦è¨è«–çš„æ˜¯è®“å…¨ç­åœèª²æ‰€éœ€æœ€å°‘äººæ•¸çš„æœŸæœ›å€¼ã€‚\n\nä¸€ã€ä¸åŒåº§ä½çš„éš”é›¢æ©Ÿç‡å•é¡Œæè¿°ï¼šæŸç­æœ‰36å€‹åŒå­¸ï¼Œåº§ä½æ˜¯6x6çš„æ–¹æ ¼æ’åˆ—ï¼Œè©¦å•ç•¶ç­ä¸Šæœ‰4å€‹åŒå­¸ç¢ºè¨ºï¼Œä¸éœ€è¦è¢«éš”é›¢çš„æ©Ÿç‡æœ‰å¤šå°‘ï¼Ÿ\nå•é¡Œè§€å¯Ÿèˆ‡æ¨å°ä¸€é–‹å§‹çœ‹åˆ°é¡Œç›®å¯èƒ½æœƒé‡åˆ°ä¸€å€‹å¤§å•é¡Œï¼Œåœ¨ä¸åŒåº§ä½çš„ç¢ºè¨ºè€…è¢«éš”é›¢çš„äººæ•¸ä¹Ÿå°±ä¸åŒã€‚ä»¥ä¸‹åœ–ç‚ºä¾‹ï¼Œååœ¨è§’è½åªéœ€è¦åŒ¡åˆ—ä¸‰å€‹äººï¼Œè€Œååœ¨é é‚Šä»¥åŠä¸­é–“çš„äººè‹¥ç¢ºè¨ºå‰‡éœ€è¦åŒ¡åˆ—äº”äººä»¥åŠå…«äººï¼Œæ›å¥è©±èªªï¼Œåšé é‚Šæˆ–è§’è½çš„äººæ¯”èµ·ä¸­é–“çš„äººè¶Šä¸å®¹æ˜“è¢«åŒ¡åˆ—éš”é›¢ã€‚æ¥ä¸‹ä¾†é‡å°ä¸åŒä½ç½®åˆ†åˆ¥é€²è¡Œè¨è«–ã€‚\n\nåº§ä½åœ¨è§’è½æƒ…æ³æˆ‘å€‘å°‡ååœ¨è§’è½è€Œä¸è¢«åŒ¡åˆ—çš„æ©Ÿç‡è¨­ç‚º$P_c$ã€‚æ­¤äººè¢«åŒ¡åˆ—çš„æƒ…æ³å¯ä»¥åˆ†ç‚ºä¸‰ç¨®ï¼Œä¹Ÿå°±æ˜¯ä»–å‘¨åœä¸‰å€‹ä½ç½®åˆ†åˆ¥æœ‰ä¸€ã€äºŒæˆ–ä¸‰äººç¢ºè¨ºï¼Œé‡å°é€™ä¸‰ç¨®æƒ…å½¢æˆ‘å€‘å¯ä»¥åˆ—å‡ºä»¥ä¸‹ç®—å¼ï¼š\nP_c = 1 - \\frac{C^3_1C^{32}_3+C^3_2C^{32}_2+C^3_3C^{32}_1}{C^{35}_4}\\approx 0.6868å¾ä»–éš”å£çš„3å€‹ä½ç½®å–ä¸€åˆ°ä¸‰å€‹ä½ç½®ä½œç‚ºç¢ºè¨ºè€…ï¼Œå‰©ä¸‹çš„ç¢ºè¨ºè€…å¾ $36-4=32$ å€‹ä½ç½®ä»»é¸å…¶ä¸­å¹¾å€‹ã€‚\nåº§ä½é é‚Šã€ä¸­é–“æƒ…æ³é€™å…©ç¨®æƒ…æ³çš„æ©Ÿç‡$P_e,P_m$ä¹Ÿå¯ä»¥ç”¨ä¸€æ¨£çš„æ–¹å¼ç®—å‡ºä¾†ï¼Œä½†å…¶å¯¦æœ‰é»éº»ç…©å› ç‚ºæœ‰å››ç¨®æƒ…æ³è¦åˆ—å‡ºä¾†ã€‚å¶ç„¶ç™¼ç¾ï¼Œå…¶å¯¦ç”¨åé¢ä½œæ³•é‚„è »éº»ç…©çš„ï¼Œç”¨æ­£é¢åšå…¶å¯¦å¿«å¾ˆå¤šï¼åªè¦é™„è¿‘çš„ä½ç½®æ•¸é‡æ‰£æ‰ï¼Œè®“å‰©ä¸‹çš„ä½ç½®å®‰æ’ç¢ºè¨ºè€…ï¼Œå–ä¸€æ¬¡Cå°±å®Œæˆäº†ï¼\nP_e = \\frac{C^{30}_4}{C^{35}_4} \\approx 0.5234ä¸­é–“$P_m$çš„æƒ…æ³ï¼š\nP_m = \\frac{C^{27}_4}{C^{35}_4} \\approx 0.3352æœ‰äº†$P_c,P_e,P_m$ä¹‹å¾Œï¼Œå°æ–¼åŸé¡Œéš¨æ©Ÿä½ç½®ä¸‹çš„æ©Ÿç‡ï¼Œç”±æ–¼æ¯ä¸€å€‹ä½ç½®å‡ºç¾çš„æ©Ÿç‡ç›¸ç­‰ï¼Œä¾¿å¯é€éå„å€‹ä½ç½®çš„æ•¸é‡é€²è¡ŒåŠ æ¬Šå¹³å‡ï¼Œå¾—åˆ°éš¨æ©Ÿæƒ…æ³ä¸‹çš„æ©Ÿç‡ã€‚\n\\begin{align}P &= \\frac{1}{36}(4P_c+16P_e+16P_m)\\\\\n&\\approx 0.4579\\end{align}ç¨‹å¼æ©Ÿç‡è¨ˆç®—ç¨‹å¼ç¢¼é€£çµæ¨¡æ“¬çµæœé€£çµ\nä¸€é–‹å§‹åœ¨é‚„æ²’æœ‰æƒ³å‡ºå•é¡Œçš„è§£ä¹‹å‰ï¼Œæƒ³èªªå…ˆç”¨ç¨‹å¼æš´åŠ›é©—è­‰çœ‹çœ‹æ©Ÿç‡ç‚ºä½•ã€‚ç¸½å…±çš„çµ„æ•¸æ˜¯ $C^{36}_4 = 58905$ ç¨®æƒ…æ³ï¼Œé€éæšèˆ‰æ¯ä¸€ç¨®æƒ…æ³å¥åº·çš„äººæ•¸ï¼Œç®—å‡ºåœ¨ä¸€å€‹äººæ²’æœ‰ç¢ºè¨ºæƒ…æ³ä¸‹ä¸è¢«åŒ¡åˆ—éš”é›¢çš„æ©Ÿç‡ã€‚\n\néš¨æ©Ÿåä¸è¢«åŒ¡æ©Ÿç‡ï¼š0.457898 ,æ¬¡æ•¸ï¼š58905\n\nçœ‹åˆ°é€™å€‹çµæœå¯ä»¥å¤§æ¦‚æ¨çŸ¥ï¼Œç•¶ç­ä¸Šæœ‰å››å€‹äººç¢ºè¨ºï¼Œå‰‡ç­ä¸Šçš„äººå…¶å¯¦æœ‰è¶…éä¸€åŠçš„æ©Ÿæœƒè¦è¢«éš”é›¢ã€‚é€™å°±è®“æˆ‘é€²ä¸€æ­¥æ€è€ƒåˆ°ï¼Œç­ä¸Šåº§ä½æœ‰äº›è·Ÿå‘¨åœæ¥è§¸åˆ°çš„äººè¼ƒå¤šã€æœ‰äº›è¼ƒå°‘ï¼Œé‚£é€™äº›æ˜¯å¦æœƒå½±éŸ¿åˆ°è¢«åŒ¡åˆ—çš„æ©Ÿç‡ï¼Ÿç”±æ–¼æ¯ä¸€å€‹äººç¢ºè¨ºçš„æ©Ÿæœƒæ˜¯ä¸€æ¨£çš„ï¼Œå› æ­¤å°±æŠŠæƒ…æ³åˆ†ç‚ºä¸‰ç¨®ï¼Œåˆ†åˆ¥æ˜¯è§’è½ã€é é‚Šä»¥åŠä¸­é–“ï¼Œè€Œç›¸åŒæƒ…æ³ä¸‹æ¥è§¸çš„äººæ•¸æ˜¯ä¸€æ¨£å¤šçš„ï¼Œéš¨ä¾¿å–ä¸€å€‹ä½ç½®é€²è¡Œè§€å¯Ÿå³å¯ã€‚\nç”±æ–¼è¦æ’é™¤è‡ªå·±ç¢ºè¨ºçš„æƒ…æ³ï¼Œç¸½å…±çš„çµ„åˆæ•¸æœƒæ˜¯ $C^{35}_4 = 52360$ï¼Œä¸è¢«åŒ¡åˆ—çš„æ©Ÿç‡å¦‚ä¸‹ï¼š\n\nåè§’è½ä¸è¢«åŒ¡æ©Ÿç‡ï¼š0.686784 ,æ¬¡æ•¸ï¼š52360åé é‚Šä¸è¢«åŒ¡æ©Ÿç‡ï¼š0.523396 ,æ¬¡æ•¸ï¼š52360åä¸­é–“ä¸è¢«åŒ¡æ©Ÿç‡ï¼š0.335180 ,æ¬¡æ•¸ï¼š52360\n\n\nå¦‚ä¸Šåœ–ï¼Œåˆ†åˆ¥æŒ‘ä½ç½®æ˜¯(1,1),(2,3),(2,4)çš„äººé€²è¡Œè§€å¯Ÿï¼Œä¸ç”¨åŒ¡åˆ—æ©Ÿç‡å‰‡æ˜¯ä»¥å¥åº·äººæ•¸ï¼ˆä¸Šåœ–Hï¼‰é™¤ä¸Šéç¢ºè¨ºäººæ•¸ï¼ˆä¸Šåœ–H+Qï¼‰ã€‚\näºŒã€ç¢ºè¨ºäººæ•¸èˆ‡å…¨ç­éš”é›¢æ©Ÿç‡3x3æ’åˆ—æƒ…æ³4x4æ’åˆ—æƒ…æ³ç¨‹å¼ç¢¼é€£çµ\nè½‰æ›ä¸€ä¸‹å•é¡Œçš„é¢å‘ï¼Œæˆ‘å€‘æŠŠç¢ºè¨ºè€…çš„æ•¸é‡ç•¶ä½œå…¶ä¸­ä¸€å€‹è®Šå› ï¼Œè©¦è‘—è¨è«–ç¢ºè¨ºäººæ•¸èˆ‡å…¨ç­éš”é›¢çš„æ©Ÿç‡é—œä¿‚ã€‚å°æ–¼ä¸€å€‹æœ‰$n$äººçš„ç­ç´šï¼Œç¸½å…±çš„æ’åˆ—æ•¸ç‚º$2^n$ï¼Œæˆ‘å€‘å°‡å…¨ç­éƒ½æœƒè¢«éš”é›¢çš„æƒ…æ³æŒ‘å‡ºä¾†ï¼Œçµ±è¨ˆå…¶æ•¸é‡ã€‚\n3x3æ’åˆ—æƒ…æ³ä¸‹åœ–æ©«åæ¨™ç‚ºç¢ºè¨ºäººæ•¸ï¼Œç¸±åº§æ¨™ç‚ºå°æ‡‰çš„çµ„æ•¸ï¼Œç°è‰²å‰‡æ˜¯è©²ç¢ºè¨ºäººæ•¸çš„çµ„åˆæ•¸ã€‚å¯ä»¥ç™¼ç¾åˆ°ï¼Œç•¶äººæ•¸å¢åŠ ï¼Œå…¶å…¨ç­éš”é›¢çš„çµ„æ•¸å‘ˆç¾å…ˆå¢å¾Œæ¸›çš„è¶¨å‹¢ï¼Œè€Œå°æ‡‰åˆ°çš„å…¨ç­è¢«éš”é›¢çš„æ©Ÿç‡ï¼ˆç´…èˆ‡ç°é•·åº¦æ¯”ï¼‰éš¨ç¢ºè¨ºäººæ•¸æ¼¸å¢ã€‚æŠ˜ç·šåœ–çš„éƒ¨åˆ†å‰‡ä»£è¡¨åœ¨ç›¸åŒç¢ºè¨ºäººæ•¸ä¸‹å…¨ç­è¢«éš”é›¢çµ„æ•¸ä½”çµ„åˆæ•¸çš„æ¯”ä¾‹ã€‚\n\næœŸæœ›å€¼ï¼šåœ¨å…¨ç­è¢«åŒ¡åˆ—çš„æƒ…æ³ä¸‹ï¼Œæ­¤æƒ…æ³çš„ç¢ºè¨ºäººæ•¸çš„æœŸæœ›å€¼ç‚ºï¼š4.88249äºº\n4x4æ’åˆ—æƒ…æ³\n\næœŸæœ›å€¼ï¼šåœ¨å…¨ç­è¢«åŒ¡åˆ—çš„æƒ…æ³ä¸‹ï¼Œæ­¤æƒ…æ³çš„ç¢ºè¨ºäººæ•¸çš„æœŸæœ›å€¼ç‚ºï¼š8.5333äºº\n5x5æ’åˆ—æƒ…æ³\næœŸæœ›å€¼ï¼šåœ¨å…¨ç­è¢«åŒ¡åˆ—çš„æƒ…æ³ä¸‹ï¼Œæ­¤æƒ…æ³çš„ç¢ºè¨ºäººæ•¸çš„æœŸæœ›å€¼ç‚ºï¼š13.1412äºº\nç¨‹å¼å…·é«”çš„å¯¦ä½œç´°ç¯€æ˜¯å°‡æ¯ä¸€ç¨®æƒ…æ³é€²è¡Œç‹€æ…‹å£“ç¸®ï¼Œå­˜åœ¨ä¸€å€‹intè£¡é¢ï¼Œç„¶å¾Œå°æ¯ä¸€å€‹bité€²è¡Œæšèˆ‰ã€‚åœ¨äººæ•¸ç‚º$n$äººçš„æƒ…æ³ä¸‹ï¼Œè¤‡é›œåº¦ç‚º$2^n$ã€‚é€™æ¨£çš„è¤‡é›œåº¦åœ¨æšèˆ‰36äººçš„æƒ…æ³æœƒéœ€è¦10å¹¾å€‹å°æ™‚æ‰èƒ½è·‘å®Œã€‚å˜—è©¦ä½¿ç”¨dfsé€²è¡Œå‰ªæï¼Œæ¸›å°‘å¯¦éš›åˆ¤æ–·çš„æ¬¡æ•¸ï¼Œä¸éæ•ˆæœä¸ç›¡ç†æƒ³ï¼Œå¯èƒ½é‚„æ˜¯è¦é‡å°è¤‡é›œåº¦çš„éƒ¨åˆ†é€²è¡Œå„ªåŒ–æ‰è¡Œã€‚\nä¸‰ã€è®“å…¨ç­åœèª²æ‰€éœ€æœ€å°‘äººæ•¸æœŸæœ›å€¼ç¨‹å¼ç¢¼é€£çµ\nç¬¬äºŒéƒ¨åˆ†æ˜¯å°‡æ‰€æœ‰å¯èƒ½é€ æˆå…¨ç­è¢«åŒ¡åˆ—çš„æƒ…æ³éƒ½æ‰¾å‡ºä¾†ï¼Œä½†é€™ä¸¦ä¸æ˜¯ã€Œè®“å…¨ç­åœèª²æ‰€éœ€æœ€å°‘äººæ•¸çš„æœŸæœ›å€¼ã€ï¼Œå› ç‚ºå®ƒçš„å‰æè¢«é™åˆ¶åœ¨æ‰€æœ‰äººéƒ½å…¨ç­éƒ½è¢«åŒ¡åˆ—çš„å‰æä¹‹ä¸‹ï¼Œä¸”æœƒæœ‰å¾ˆå¤šæƒ…æ³æ˜¯è¦è¢«æ‰£é™¤æ‰çš„ã€‚è¦æ‰¾å‡ºæœ€å°‘äººæ•¸çš„æœŸæœ›å€¼ï¼Œæˆ‘å€‘å°‡æ¯ä¸€å€‹ä½ç½®çš„ç¢ºè¨ºç‹€æ³é€²è¡Œéè¿´ï¼Œç›´åˆ°ä¸€ç¨®çµ„åˆèƒ½ä»¥æœ€å°‘äººæ•¸çš„æƒ…æ³ä¸‹è®“å…¨ç­éš”é›¢ã€‚åˆ°äº†é‚£ç¨®æƒ…æ³ä¹‹å¾Œï¼Œæ¥ä¸‹ä¾†ä¸ç®¡æ€éº¼å®‰æ’æ¥ä¸‹ä¾†çš„ä½ç½®ï¼Œä¹Ÿä¸€å®šèƒ½è®“å…¨ç­è¢«åŒ¡åˆ—ã€‚\n\nå¦‚ä¸Šåœ–ï¼Œæˆ‘å€‘è¦çµ±è¨ˆçš„å°±æ˜¯æ¯ä¸€å€‹èƒ½è®“å…¨ç­è¢«éš”é›¢çš„ç‹€æ…‹xï¼Œæ‰€åŒ…å«çš„ç¢ºè¨ºäººæ•¸ã€‚ä»¥ä¸‹æ˜¯çµ±è¨ˆæœ€å°‘ç¢ºè¨ºäººæ•¸å°æ‡‰åˆ°è®“å…¨ç­è¢«éš”é›¢çš„çµ„æ•¸ã€‚\n3x3æ’åˆ—æƒ…æ³\næœ€å°‘äººæ•¸æœŸæœ›å€¼ï¼š3.74667äºº\n4x4æ’åˆ—æƒ…æ³\næœ€å°‘äººæ•¸æœŸæœ›å€¼ï¼š7.17143äºº\n5x5æ’åˆ—æƒ…æ³\næœ€å°‘äººæ•¸æœŸæœ›å€¼ï¼š11.8351äºº\nçµè«–ä¸Šé¢æ”¾çš„å¹¾å¼µé•·æ¢åœ–ä»¥åŠæŠ˜ç·šåœ–éƒ½æ”¾åœ¨ä¸‹æ–¹åƒè€ƒè³‡æ–™ä¸­ï¼Œæ¯ä¸€å¼µéƒ½æ˜¯é«˜ç•«è³ª(dpi=1000)ï¼é—œæ–¼ä¸Šé¢ç¬¬äºŒã€ä¸‰éƒ¨åˆ†ï¼Œå…¶å¯¦åŸæœ¬æ˜¯æƒ³è¦æ±‚ã€Œæœ€å°‘äººæ•¸æœŸæœ›å€¼ã€ï¼Œç•«å‡ºä¸¦ä¸”çµ±è¨ˆå®Œç¬¬äºŒéƒ¨åˆ†çš„å…§å®¹å¾Œï¼Œæ‰ç™¼ç¾çµæœæ¯”æƒ³åƒä¸­çš„é‚„è¦é«˜ï¼ˆè¶…éä¸€åŠçš„äººæ•¸ï¼‰ï¼Œç´°ç©¶ä¹‹å¾Œæ‰ç™¼ç¾å…©è€…ä¹‹é–“çš„å€åˆ¥ã€‚\nåœ¨ç¨‹å¼æ–¹é¢ï¼ŒåŸæœ¬çš„$2^n$çš„æšèˆ‰è¤‡é›œåº¦å¯¦åœ¨æœ‰é»é«˜ï¼Œæƒ³èªªå¯ä»¥åˆ©ç”¨éè¿´é€²è¡Œå‰ªæï¼Œä½†å¯¦æ¸¬ä¸‹ä¾†é€Ÿåº¦ä¸¦æ²’æœ‰å¿«å¤šå°‘ï¼Œå¿…é ˆè¦æƒ³è¾¦æ³•å„ªåŒ–æ‰èƒ½å°æ›´å¤šäººçš„æƒ…æ³é€²è¡Œæšèˆ‰ã€‚å¦å¤–ï¼Œå»¶ä¼¸éƒ¨åˆ†å¯ä»¥é‡å°ç¢ºè¨ºçš„é †åºé€²è¡Œè¨è«–ï¼Œä¹Ÿå°±æ˜¯è®“æ¯ä¸€å€‹äººä¾ç…§ä¸åŒçš„å…ˆå¾Œé †åºç¢ºè¨ºï¼Œä¸¦åœ¨ç¢ºè¨ºçš„ç•¶å¤©ç§»é™¤è©²è¢«åŒ¡åˆ—çš„äººï¼Œè®“å‰©ä¸‹çš„äººé€²è¡Œä¸‹ä¸€è¼ªæ¨¡æ“¬ã€‚\nåƒè€ƒè³‡æ–™åœ–ç‰‡ã€ç¨‹å¼ç¢¼æª”æ¡ˆ\næˆ‘çš„Github\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","æ©Ÿç‡","é«˜äºŒä¸‹ç­†è¨˜"]},{"title":"ä¸ƒæ©‹å•é¡Œã€æœ€çŸ­è·¯å¾‘å•é¡ŒåŠå…¶å»¶ä¼¸","url":"/path3/","content":"é€™ç¯‡æ–‡ç« çš„ä¸»é¡Œæœ‰ä»¥ä¸‹ï¼š\n\næ­æ‹‰è·¯å¾‘ã€è¿´è·¯ï¼ˆä¸ƒæ©‹å•é¡Œï¼‰\næ¼¢ç±³é “è·¯å¾‘ã€è¿´è·¯\næœ€çŸ­è·¯å¾‘æ¼”ç®—æ³•ï¼ˆDijkstra,Bellman-Ford,Floyd-Warshallï¼‰\næ—…è¡Œæ¥­å‹™å“¡å•é¡Œï¼ˆTSPï¼‰\n\n\næ­æ‹‰è·¯å¾‘ã€è¿´è·¯ï¼ˆä¸ƒæ©‹å•é¡Œï¼‰å•é¡Œç°¡ä»‹\nä¸ƒæ©‹å•é¡Œçš„æè¿°æ˜¯ï¼šè©²å¦‚ä½•åœ¨æ‰€æœ‰æ©‹éƒ½åªèƒ½èµ°ä¸€éçš„å‰æä¸‹ï¼ŒæŠŠé€™å€‹åœ°æ–¹æ‰€æœ‰çš„æ©‹éƒ½èµ°éï¼ˆæ¯æ¢é‚Šæ´½ç¶“éä¸€æ¬¡ï¼‰ï¼Ÿ\nç”±æ•¸å­¸æ­¸ç´æ³•å¾—è­‰ï¼Œæˆ‘å€‘åªè¦çµ±è¨ˆæ¯å€‹é»çš„åº¦æ•¸ä¸¦è¨˜éŒ„å¥‡é»çš„å€‹æ•¸ï¼Œåªè¦å¤§æ–¼äºŒå‰‡ä¸å­˜åœ¨æ­æ‹‰è·¯å¾‘ã€‚\nå¯¦ä½œç¨‹åº1. åˆ¤æ–·å¥‡é»å€‹æ•¸ï¼Œè‹¥å¥‡é»å€‹æ•¸kï¼š\n\nk &gt; 2ï¼Œé‚£éº¼ç„¡è§£\nk = 2ï¼Œå‰‡é¸æ“‡å…¶ä¸­ä¸€å€‹å¥‡é»ä½œç‚ºèµ·é»\nk = 0ï¼Œå‰‡é¸æ“‡ä»»æ„ä¸€å€‹é»ä½œç‚ºèµ·é»\n\n2. DFS åŸ·è¡Œä¸‹åˆ—æ­¥é©Ÿè‹¥ç•¶å‰ç¯€é»é‚„æœ‰å°šæœªèµ°éçš„é‚Šï¼Œé‚£éº¼æ‹œè¨ªè©²é‚Šï¼Œä¸¦åœ¨æ‹œè¨ªå®Œå¾Œè¼¸å‡ºè©²é‚Šï¼Œå¦å‰‡é›¢é–‹ç•¶å‰çµé»\n3. è‹¥é‚„æœ‰ç¯€é»å°šæœªæ‹œè¨ªï¼Œå‰‡ç„¡è§£4. å¦å‰‡è¼¸å‡ºé †åºå³ç‚ºä¸€çµ„è§£\nç¨‹å¼ç¢¼å¯¦ä½œ#include &lt;bits/stdc++.h&gt;#define N 501using namespace std;int n,Edge[N][N],ans[1025],ind = 0;void DFS(int cur)&#123;    for(int i=1;i&lt;=500;i++)&#123;        if(Edge[cur][i])&#123;            Edge[cur][i]--;Edge[i][cur]--;            DFS(i);        &#125;    &#125;    ans[ind++] = cur;&#125;signed main()&#123;    cin&gt;&gt;n;    memset(Edge, 0, sizeof(Edge));    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        Edge[a][b]++;        Edge[b][a]++;    &#125;    int start = 1;                //é–‹å§‹çš„ç¯€é»ç·¨è™Ÿ    for(int i=1;i&lt;=500;i++)&#123;        int sum = 0;        for(int j=1;j&lt;=500;j++)&#123;            sum+=Edge[i][j];        &#125;        if(sum%2!=0)&#123;             //æ‰¾åˆ°ç¬¬ä¸€å€‹åº¦æ•¸ç‚ºå¥‡æ•¸çš„ç¯€é»            start = i;            break;        &#125;    &#125;    DFS(start);    for(int i=ind-1;i&gt;=0;i--)cout&lt;&lt;ans[i]&lt;&lt;endl;&#125;\næ—…è¡Œæ¥­å‹™å“¡å•é¡Œï¼ˆTSPï¼‰èˆ‡æ¼¢ç±³é “è·¯å¾‘å•é¡Œæè¿°\næ¼¢ç±³é “è·¯å¾‘æ˜¯é¡ä¼¼æ–¼æ­æ‹‰è·¯å¾‘ï¼Œä½†æ¯ä¸€æ¢é‚Šæ°å¥½ç¶“éä¸€æ¬¡çš„é™åˆ¶è®Šæˆé»æ°å¥½ç¶“éä¸€æ¬¡ï¼Œä½†æ­¤å•é¡Œçš„é›£åº¦æ¯”æ­æ‹‰è¿´è·¯é«˜ä¸Šå¥½å¹¾å€ï¼Œç‚ºä¸€å€‹NP-Completeçš„å•é¡Œã€‚\n\næ—…è¡Œå•†å‹™å“¡å•é¡Œå‰‡æ˜¯æè¿°å¹³é¢ä¸Šnå€‹åŸå¸‚ï¼Œæ˜¯å¦å­˜åœ¨ä¸€æ¢è·¯å¾‘å°‡æ¯ä¸€å€‹é»æ°å¥½èµ°éä¸€æ¬¡å¾Œå›åˆ°å‡ºç™¼é»ã€‚æ­¤å•é¡Œç‚ºä¸€å€‹æ¼¢ç±³é “è¿´è·¯å•é¡Œçš„ç¶“å…¸å•é¡Œã€‚\né¡Œç›®é€£çµç¬¬ä¸€æ¬¡å¯«TSP(Traveling Salesman Problem)ï¼Œé¡Œç›®æ•˜è¿°å¦‚ä¸‹ï¼š\n\nçµ¦å®šä¸€ç³»åˆ—åŸå¸‚å’Œæ¯å°åŸå¸‚ä¹‹é–“çš„è·é›¢ï¼Œæ±‚è§£å­˜å–æ¯ä¸€åº§åŸå¸‚ä¸€æ¬¡ä¸¦å›åˆ°èµ·å§‹åŸå¸‚çš„æœ€çŸ­è¿´è·¯ã€‚\n\nå¯¦ä½œç¨‹åºæˆ‘å€‘é€éä½å…ƒçš„å‹•æ…‹è¦åŠƒï¼Œå¯ä»¥å°‡åŸæœ¬$o(n!)$çš„æ™‚é–“è¤‡é›œåº¦è®Šæˆä»¥$O(n^2\\cdot 2^n)$çš„è¤‡é›œåº¦è§£æ±ºé€™å€‹å•é¡Œã€‚\né€™æ˜¯ä¸€å€‹å·²ç¶“è¢«è­‰æ˜$NP-Hard$ çš„å•é¡Œï¼Œæš´åŠ›ä½œæ³•æ˜¯è¦æª¢æŸ¥æ‰€æœ‰è·¯å¾‘çš„æƒ…æ³ï¼Œå› ç‚ºå…±æœ‰nå€‹é»ï¼Œæ¯ä¸€å€‹é»åˆé€£æ¥n-1å€‹é»ï¼Œç¹¼çºŒä¸‹å»ç¸½å…±æœƒæœ‰N!ç¨®æƒ…æ³ï¼Œå› æ­¤è¤‡é›œåº¦ç‚º$O(n!)$ã€‚ç¸½å…±çš„é»æ•¸å…±æœ‰nå€‹ï¼Œæ ¹æ“šå¤šé‚Šå½¢çš„é‚Šæ•¸å…¬å¼å¯ä»¥çŸ¥é“ä¸€å…±æœ‰$\\frac{n^2-n}{2}$æ¢é‚Šï¼Œæ¯ä¸€æ¢é‚Šéƒ½æœ‰å„è‡ªçš„è·é›¢ã€‚å¦‚æœæ”¹ç”¨DPåšï¼Œæ™‚é–“è¤‡é›œåº¦å¯ä»¥å£“åˆ°æ™‚é–“è¤‡é›œåº¦$O(n^2\\cdot2^n)$ï¼Œæ¯”$O(n!)$é‚„å„ªç§€ï¼é€™ä¸€é¡Œç”¨åˆ°çš„æ˜¯DPå„ªåŒ–ä¸­çš„ç‹€æ…‹å£“ç¸®ï¼Œå…·é«”çš„å¯¦ä½œç´°ç¯€å¦‚ä¸‹ï¼š\n\n            ä½å…ƒé‹ç®—åœ¨é€™ä¸€é¡Œéœ€è¦ç”¨åˆ°ä½å…ƒé‹ç®—ï¼Œç”¨16å€‹bitè¡¨ç¤ºæ¯ä¸€å€‹é»æœ‰æ²’æœ‰è¢«èµ°è¨ªéã€‚ç”¨é€™æ¨£çš„è¡¨ç¤ºæ–¹æ³•å¯ä»¥è®“codeæ›´ç‚ºç¯€å„‰ï¼Œä¹Ÿå°±æ˜¯ç‹€æ…‹å£“ç¸®çš„æ¦‚å¿µã€‚å·¦ç§»é‹ç®—å­(&lt;&lt;)é€™ä¸€é¡Œæœƒä¸€ç›´åè¦†è¢«ç”¨åˆ°ï¼Œ1&lt;&lt;tä»£è¡¨æŠŠ1å¾€å·¦ç§»å‹•tå–®ä½ï¼Œç”¨10é€²ä½è¡¨ç¤ºå°±æ˜¯$2^t$ã€‚æ¯å¾€å·¦ç§»å‹•ä¸€æ ¼ï¼Œæ•¸å­—å°±æœƒè®ŠæˆåŸä¾†çš„å…©å€ï¼ç‹€æ…‹å£“ç¸®å°‡åé€²ä½æ•´æ•¸sä»¥äºŒé€²ä½è¡¨ç¤ºï¼Œæœƒå¾—åˆ°ä¸€ä¸²01å­—ä¸²ï¼Œå‡è¨­s=10ï¼Œå‰‡ $s = 1010_{(2)}$ã€‚ä»¥é€™é¡Œä¾†èªªï¼Œé€™æ¨£çš„å­—ä¸²æˆ‘å€‘å¯ä»¥ç”¨ä¾†è¡¨ç¤ºç¬¬4å’Œç¬¬2å€‹é»å·²ç¶“è¢«æ‹œè¨ªï¼Œè€Œç¬¬3è·Ÿç¬¬1å€‹é»é‚„æ²’æœ‰è¢«æ‹œè¨ªã€‚\n          \nå®šç¾©å®šç¾© $dp[n][s]$ è¡¨ç¤ºç›®å‰åœ¨ç¬¬né»ä¸Šï¼Œsç‚ºèµ°éçš„é»ï¼ˆç‹€æ…‹å£“ç¸®ï¼‰çš„æœ€çŸ­è·é›¢\nè½‰ç§»å¼$dp[n][s] = min(dp[i][s-(1&lt;&lt;n)]+dis[i][n])$, for all i such that s&amp;(1&lt;&lt;i)!=0\né€™å€‹è½‰ç§»å¼å¾ˆæœ‰æ„æ€ï¼Œå› ç‚ºsä»£è¡¨äº†æ¯ä¸€å€‹é»æ˜¯å¦æœ‰è¢«èµ°éï¼Œç•¶æˆ‘è¦æ›´æ–°dp[n][s]æ™‚ï¼Œæˆ‘è¦ç¢ºä¿æ­¤æ™‚çš„ç‹€æ…‹sä¸­çš„é»nå¿…é ˆç‚º1ã€‚åŒæ™‚ï¼Œå› ç‚º1&lt;&lt;iç”¨äºŒé€²ä½è¡¨ç¤ºåªæœ‰ç¬¬iä½æœƒæ˜¯1å…¶ä»–éƒ½æ˜¯0ï¼Œåšandé‹ç®—å°±çœ‹sçš„ç¬¬iä½æ±ºå®šçµæœã€‚\nå°æ–¼æ¯ä¸€å€‹iå¿…é ˆç¢ºä¿ç¬¬ié»åœ¨ç‹€æ…‹sä¸­æœ‰è¢«é€ è¨ªï¼Œå› æ­¤æœ‰äº†å¾Œé¢çš„æ¢ä»¶ã€‚å¦å¤–è½‰ç§»å¼ä¸­çš„s-(1&lt;&lt;N)æ˜¯æŠŠç¬¬nå€‹é»å¾æœªé€ è¨ªçš„ç‹€æ…‹è½‰ç§»ã€‚\né‚Šç•Œ$dp[0][1] = 0,\\quad dp[i][j]= \\infty$\nè·é›¢çš„é è¨­ç‹€æ…‹ç‚ºç„¡é™å¤§ï¼Œç¬¬ä¸€å€‹é»çš„åˆå§‹ç‹€æ…‹æ˜¯æœ€çŸ­è·é›¢0\nå¯¦ä½œå°ç´°ç¯€è¿´åœˆé †åºåœ¨è½‰ç§»çš„éç¨‹ä¸­ï¼Œè¿´åœˆçš„ç¬¬ä¸€å±¤å¿…é ˆæ˜¯ç‹€æ…‹ï¼Œç¬¬äºŒå±¤æ‰æ˜¯åŸå¸‚ã€‚å¦‚æœé¡›å€’éä¾†çš„è©±ï¼Œæœƒå°è‡´å‰é¢çš„åŸå¸‚åœ¨ç‹€æ…‹é‚„æ²’æœ‰è¢«æ›´æ–°çš„æ™‚å€™å°±å·²ç¶“å¤±å»äº†ä¹‹å¾Œè¢«æ›´æ–°çš„æ©Ÿæœƒï¼Œå› æ­¤åŸå¸‚çš„è¿´åœˆå¿…é ˆæ”¾åœ¨ç¬¬äºŒå±¤ï¼\næ±‚ç­”æ¡ˆå› ç‚ºæˆ‘å€‘è¦æ±‚çš„æ˜¯å›åˆ°åŸé»çš„æœ€çŸ­è·é›¢ï¼Œå› æ­¤åœ¨å…¨éƒ¨è½‰ç§»å®Œæˆä¹‹å¾Œï¼Œåˆ©ç”¨ä¸€å€‹è¿´åœˆæŠŠå›å»åŸé»çš„è·¯çš„è·é›¢åŠ ä¸Šå»ï¼Œæ±‚å¾—æœ€å°å€¼ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,dis[20][20];cin&gt;&gt;n;    memset(dis,0,sizeof(dis));        for(int i=0;i&lt;n-1;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            cin&gt;&gt;dis[i][j];            dis[j][i] = dis[i][j];        &#125;    &#125;        int dp[N][66000],m = 1&lt;&lt;n;    memset(dp,0x3f3f3f3f,sizeof(dp));    dp[0][1] = 0;   //å°‡0é»åˆ°è‡ªå·±çš„è·é›¢è¨­ç‚º1        //O(n^2 2^n)    for(int i=0;i&lt;m;i++)&#123;            //iè¡¨ç¤º2^næ¯ä¸€ç¨®ç‹€æ…‹        for(int j=0;j&lt;n;j++)&#123;        //jè¡¨ç¤ºåŸå¸‚            if(!(i&amp;(1&lt;&lt;j)))continue; //jåŸå¸‚è¦æ˜¯è¢«é€ è¨ªéçš„ç‹€æ…‹            for(int k=0;k&lt;n;k++)&#123;    //å¯ä»¥åˆ°çš„æ‰€æœ‰é»ä¸­çš„ç‹€æ…‹                if(i &amp; 1&lt;&lt;k)&#123;        //ç¢ºä¿è½‰ç§»éå»çš„æœ‰è¢«é€ è¨ªé                    dp[j][i] = min(dp[j][i],dp[k][i-(1&lt;&lt;j)]+dis[j][k]);                &#125;            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)ans = min(ans,dp[i][m-1]+dis[i][0]);    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\næœ€çŸ­è·¯å¾‘æ¼”ç®—æ³•Floyd-Warshallï¼šå…¨é»å°æœ€çŸ­è·¯å¾‘(All Pairs)\nä¸æ”¯æ´è² ç’°\n\næƒ³æ³•ï¼šDPè½‰ç§»ï¼ˆä¸‰å€‹è¿´åœˆä¸­é»ã€èµ·é»ã€çµ‚é»ä¾åºé¬†å¼›ï¼‰\n\n$d[i][j] = mid(d[i][j],d[i][k]+d[I][k]+d[k][j])$\nå¦‚æœæ”¹å¯«æˆå®šç¾© $dp[k][i][j]$ ç‚ºé» $i$ èµ°åˆ°é» $j$ ï¼Œåªèƒ½ç¶“éå‰kå€‹é»çš„æœ€çŸ­è·¯\nå‰‡è½‰ç§»ï¼š$d[k+1][i][j] = min(d[k][i][j], d[k][i][k+1]+d[k][k+1][j])$\nå› æ­¤ä¸­é–“é»kå¿…é ˆåœ¨æœ€å¤–å±¤ï¼ˆä¸éæœ‰è«–æ–‡æŒ‡å‡ºé †åºé¡›å€’ä¸€æ¨£å¯ä»¥å¾—åˆ°æ­£ç¢ºè§£ï¼‰\nå„ªé»ï¼šå¯¦ä½œå®¹æ˜“ï¼Œç¼ºé»ï¼šæ™‚é–“ $O(v^3)$ ã€ç„¡æ³•è™•ç†è² ç’°ï¼ˆå¯è™•ç†è² é‚Šï¼‰\n\nDijkstraâ€™sï¼šå–®é»æºæœ€çŸ­è·¯å¾‘\nå„ªé»ï¼šæ™‚é–“ $O(E+V^2)$ã€ç„¡æ³•è™•ç†è² é‚Š\n\næƒ³æ³•ï¼šGreedyï¼ˆå’ŒDPï¼‰\n\nç¶­è­·ï¼š1. æœªæ‹œè¨ªçš„ç¯€é»é›†åˆ$U$ 2. $d[i]$ ç›®å‰èµ·é»åˆ° $i$ æœ€çŸ­è·¯ 3. ç›®å‰è€ƒæ…®ç¯€é» $p$\né‡è¤‡ä»¥ä¸‹å‹•ä½œç›´åˆ°uç‚ºç©ºï¼š\nå°æ–¼æ‰€æœ‰èˆ‡ $p$ é€£æ¥çš„ç¯€é» $q$ï¼Œ$d[q] = min(d[q],d[p]+weight[p][q])$\nç•¶ $p$ ç›¸é„°ç¯€é»éƒ½èµ°éï¼šåœ¨ $u$ ä¸­ç§»é™¤ $p$\nå°‡ $p$ æ›´æ–°æˆUä¸­é›¢èµ·é»è·é›¢æœ€çŸ­çš„é» $min(d[j])$\n\n\nå¯ä»¥è®Šæˆ $O((E+V)logV)$-&gt;é‚Šè¼ƒç‚ºç¨€ç–çš„åœ–æ™‚æœ‰åˆ©ï¼ˆä½¿ç”¨priority_queueï¼‰\nä¸èƒ½è™•ç†è² é‚Šï¼Œå› ç‚º $d[i]$ è¼ƒå°çš„è™•ç†å®Œä¹‹å¾Œå°±ä¸æœƒå†æ›´å‹•äº†ï¼ŒåŠ å…¥è² é‚Šå¯èƒ½æ›´å°\næ‹¿è·é›¢æœ€å°çš„é» $k$ å»æ›´æ–°å…¶ä»–é»ï¼Œä¸èƒ½ä¿è­‰æ›´æ–°å¾Œå…¶ä»–é»ä¸€å®šæ˜¯æœ€çŸ­è·¯\nä¸Šä¸€æ­¥èµ°å®Œ $k$ é€£æ¥æ‰€æœ‰é‚Šå¾Œï¼Œå¾é›†åˆ $U$ ä¸­ç§»é™¤ï¼Œå› ç‚ºæ²’æœ‰è² é‚Šï¼Œ $k$ å¿…å®šæ˜¯æœ€çŸ­è·¯\n\nDIJKSTRA(G, w, s)    INITIALIZE-SINGLE-SOURCE(G, s)      S &lt;- Ã˜      Q &lt;- V[G]      while Q â‰  Ã˜          do u &lt;- EXTRACT-MIN(Q)              S &lt;- S âˆª &#123;u&#125;              for each vertex v âˆˆ Adj[u]                  do RELAX(u,v,w)\nBellman-Fordï¼šå–®é»æºæœ€çŸ­è·¯å¾‘\nå¯ä»¥è™•ç†è² ç’°\n\næ™‚é–“ï¼š$O(VE)$\n\næƒ³æ³•ï¼šRelaxé¬†å¼›\nä¸€æ¢é‚Š $\\delta(u,v)$ æ»¿è¶³ $dis[v] = min(dis[v],dis[u]+weight[u][v])$\nå°æ¯ä¸€æ¢é‚Šé€²è¡Œé¬†å¼›ï¼Œå› ç‚ºé¬†å¼›æ²’æœ‰æŒ‰ç…§æœ€çŸ­è·¯é †åºï¼Œå› æ­¤è¦åšV-1æ¬¡\næ­¤ç‚ºæš´åŠ›ä½œæ³•\nåŸ·è¡ŒV-1æ¬¡çš„worst caseï¼š\nå‰›å¥½è·Ÿæœ€çŸ­è·¯å¾‘çš„é †åºç›¸å\næ¯æ¬¡ Relax å¾Œåªèƒ½å„ªåŒ–å–®ä¸€å­è·¯å¾‘\nå…±æœ‰Vå€‹é ‚é»ï¼Œéœ€è¦æœ‰V-1 æ¢å­è·¯å¾‘ï¼Œæ¯ä¸€æ¬¡ä¸€æ¢\næª¢æŸ¥è² ç’°ï¼šåšå®Œä¹‹å¾Œå»æœ‰æ»¿è¶³$d[v] &gt; d[u]+w(u,v)$ ï¼Œè¡¨ç¤ºæœ‰è² ç’°\n\n\n\nBELLMAN-FORD(G,w,s)      INITIALIZE-SINGLE-SOURCE(G,s)      for i &lt;- 1 to |V[G]|-1          do for each edge (u,v)âˆˆ E[G]              do RELAX(u,v,w)      for each edge (u,v)âˆˆ E[G]          do if d[v] &gt; d[u]+w(u,v)              then return FALSE      return TRUE\nå„ªåŒ–ï¼šSPFA(Shortest Path Faster Algorithm)\næ¯æ¬¡åªrelaxæ›´æ–°éçš„é»\n\nä½¿ç”¨queueå„ªåŒ–ï¼Œæœ‰é»åƒBFSéç¨‹\n\n1.æŠŠèµ·é» Push åˆ° Queue\n2.å¾ Queue è£¡ Pop å‡ºä¸€ç­†è³‡æ–™\n3.è©²ç­†è³‡æ–™çš„æ‰€æœ‰é‚Šé€²è¡Œ Relax\n4.æœ‰æ›´æ–°åˆ°çš„é ‚é»å† Push åˆ° Queue\n5.é‡è¤‡æ­¥é©Ÿ 2 ~ 4ï¼Œç›´åˆ° Queue ç‚ºç©º\n\n\næ™‚é–“ï¼š$O(VE)$ -&gt;worst caseï¼ŒæœŸæœ› $O(KE)$ ï¼ŒKå¤§æ¦‚æ˜¯2å§ï¼ˆåæ­£æŒºå¿«çš„ï¼‰\n\nShortest-Path-Faster-Algorithm(G, s)      for each vertex v â‰  s in V(G)          d(v) := âˆ      d(s) := 0      offer s into Q      while Q is not empty          u := poll Q          for each edge (u, v) in E(G)              if d(u) + w(u, v) &lt; d(v) then                  d(v) := d(u) + w(u, v)                 if v is not in Q then                     offer v into Q\nDAG Shortest Pathé¦–å…ˆå°æ‰€æœ‰é»é€²è¡Œæ‹“å¢£æ’åºï¼ŒèŠ±ä¸Šæ™‚é–“ $O(V+E)$ï¼Œæ¥è‘—å°æ¯ä¸€æ¢é‚Šé€²è¡Œé¬†å¼›ï¼Œæ™‚é–“$O(E)$ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦æ˜¯ $O(V+E)$ã€‚é€™å€‹æ™‚é–“è¤‡é›œåº¦æ˜¯å¾ˆå¿«çš„ï¼Œä½†ç›¸å°çš„é™åˆ¶ä¹Ÿéå¸¸å¤šï¼Œé™¤äº†ä¸èƒ½æœ‰è² é‚Šèˆ‡è² ç’°ä¹‹å¤–ï¼Œæ›´ä¸èƒ½æœ‰æ­£ç’°åœ¨å…¶ä¸­ï¼Œå¦å‰‡ä¸èƒ½é€²è¡Œæ‹“å¢£æ’åºï¼ˆåœ¨ä¹‹å‰ç­†è¨˜é€²éšåœ–è«–ï¼ˆä¸€ï¼‰æœ‰æåˆ°ï¼Œä¹Ÿå°±æ˜¯é€™ä¸€ä¸­åœ–å¿…é ˆæ˜¯DAG(Directed Acyclic Graph)ï¼\nä¸€å€‹æœ‰è¶£çš„æ‡‰ç”¨ï¼šPERT\nå»¶ä¼¸ç­†è¨˜\næœ€çŸ­è·¯å¾‘å•é¡Œ\né€²éšåœ–è«–ï¼ˆä¸€ï¼‰\næœ€çŸ­è·¯å¾‘ä¾‹é¡Œ\n\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","é›¢æ•£æ•¸å­¸","å¤šå…ƒé¸ä¿®"]},{"title":"éç·šæ€§èª¿åˆ†å…¬å¼çš„ç›¸é—œæ€§è³ª","url":"/score/","content":"\nä½œè€…ï¼šå¾ä¸Šé›²ã€peienwu\n\nä¸€ã€ç°¡ä»‹åœ¨è¨±å¤šè€ƒè©¦ä¸­ç”±æ–¼åœ¨å‡ºé¡Œæ™‚é›£åº¦ç„¡æ³•æŒæ¡ï¼Œæ•…å¸¸å‡ºç¾é›†é«”åˆ†æ•¸éä½æˆ–éé«˜çš„ç¾è±¡ã€‚ç•¶åˆ†æ•¸éä½æ™‚å¸¸æœƒä»¥æ•´é«”èª¿æ•´åˆ†æ•¸çš„æ–¹å¼ä½¿é›†é«”åˆ†æ•¸å›æ­¸åˆ°æ­£å¸¸å€¼ï¼Œæˆ–ä½¿åŠæ ¼æ¯”ä¾‹åˆä¹é æœŸã€‚å¦‚ä»Šå¸¸è¦‹çš„èª¿åˆ†æ–¹å¼æœ‰è¨±å¤šç¨®ï¼Œè€Œæ¯ä¸€ç¨®èª¿åˆ†æ–¹å¼å„æœ‰å„ªç¼ºé»ï¼Œå°æ•´é«”åˆ†æ•¸çš„å½±éŸ¿åŠ›ä¹Ÿå„ç•°ã€‚æˆ‘æƒ³å˜—è©¦å°‡å¸¸è¦‹çš„å¹¾ç¨®èª¿æ•´åˆ†æ•¸æ–¹å¼é€²è¡Œæ¯”å°ï¼Œæ¢è¨æ¯ä¸€ç¨®æ–¹å¼çš„æ„ç¾©ã€ä½¿åˆ†æ•¸çš„åˆ†ä½ˆç‹€æ³ã€å„ªç¼ºé»ã€‚\n\näºŒã€å•é¡Œèªªæ˜ä»Šæœ‰ä¸€å¼µè©¦å·å‡è¨­æ»¿åˆ†ç‚º100ï¼Œæœ€ä½åˆ†ç‚º0åˆ†ã€‚ä¸”è½åœ¨0åˆ°100ä¸­çš„æ¯å€‹åˆ†æ•¸çš†æœ‰æ©Ÿæœƒå¾—åˆ°ã€‚\næ¢è¨ä»¥ä¸‹ä¸‰ç¨®å¸¸è¦‹çš„èª¿æ•´åˆ†æ•¸çš„æ–¹å¼ï¼š\nï¼ˆä¸€ï¼‰ç·šæ€§èª¿æ•´y=ax+bæ¬²ä½¿æ»¿åˆ†ä»ç¶­æŒ$100$ï¼Œå°‡$0$åˆ†èª¿æ•´ç‚º$b$åˆ†ã€‚å°‡åˆ†æ•¸ä»¥ç·šæ€§é—œä¿‚$y=ax+b$åˆ†ä½ˆã€‚å¦‚è‹¥å¸Œæœ›ä¸è«–åŸå§‹åˆ†æ•¸ç‚ºä½•ï¼Œèª¿æ•´å¾Œçš†å¯åŠæ ¼ï¼Œæœ€ä½åˆ†$0$èª¿æ•´ç‚º$60$åˆ†ï¼Œæ»¿åˆ†ç¶­æŒ$100$åˆ†ã€‚å‰‡å…¬å¼ç‚ºï¼š$y=0.4x+60$ã€‚\n\næ±‚ç•¶ä»Šå¤©è¨­å®šä¸åŒæœ€ä½åˆ†æ•¸å€¼(b)æ™‚ï¼Œåˆ†æ•¸èª¿æ•´å¾Œä¹‹ç‹€æ³ã€‚\n\nï¼ˆäºŒï¼‰å°‡åŸå§‹åˆ†æ•¸é–‹æ ¹è™Ÿå¾Œä¹˜ä»¥10å¦ä¸€ç¨®å¸¸è¦‹çš„èª¿æ•´åˆ†æ•¸åˆ†æ•¸ç‚ºå°‡åŸå§‹åˆ†æ•¸é–‹æ ¹è™Ÿå¾Œä¹˜ä»¥$10$ã€‚\n\næ¢è¨ç‚ºä½•æœ€å¸¸è¦‹çš„èª¿æ•´åˆ†æ•¸æ–¹å¼ç‚ºé–‹æ ¹è™Ÿä¹˜ä»¥$10$ï¼Ÿ\nè‹¥é–‹ç«‹æ–¹æ ¹å¾Œä¹˜ä»¥æŸæ•¸$k_3$ï¼Œä½¿æ»¿åˆ†ä»ç‚º$100$ï¼Œæ¢è¨èª¿æ•´å¾Œåˆ†æ•¸åˆ†ä½ˆç‹€æ³ã€‚\nè‹¥é–‹$n$æ¬¡æ–¹æ ¹ä¹˜ä»¥æŸæ•¸$k_n$ï¼Œä½¿æ»¿åˆ†ä»ç‚º$100$ï¼Œæ¢è¨èª¿æ•´å¾Œåˆ†æ•¸åˆ†ä½ˆç‹€æ³ã€‚\næ±‚ç•¶é–‹$n$æ¬¡æ–¹æ ¹ä¹˜ä»¥æŸæ•¸$k_n$ï¼Œä½¿æ»¿åˆ†ä»ç‚º$100$æ™‚ï¼ŒåŸå§‹åˆ†æ•¸æ‡‰ç‚ºä½•æ‰èƒ½åŠ åˆ°æœ€å¤šåˆ†ï¼Ÿ\n\nï¼ˆä¸‰ï¼‰å°‡åŸå§‹åˆ†æ•¸å–logå¾Œä¹˜ä»¥ä¸€å¸¸æ•¸ä½¿æ»¿åˆ†ä»ç‚º100\nä»Šä»¥åº•æ•¸ç‚º$n$ï¼Œå°‡åŸå§‹åˆ†æ•¸å–$\\log_a$å¾Œä¹˜ä»¥æŸæ•¸$p$ï¼Œä½¿æ»¿åˆ†ä»ç‚º$100$åˆ†ã€‚æ¢è¨èª¿æ•´å¾Œåˆ†æ•¸åˆ†ä½ˆç‹€æ³ã€‚\n\nä¸‰ã€æ¢è¨æ–¹å¼åšä»¥ä¸‹ä¸‰å¼µåœ–ï¼Œé€²è¡Œæ¯”è¼ƒï¼š\n\nèª¿æ•´å¾Œåˆ†æ•¸ï¼šç•«å‡ºåŸå§‹åˆ†æ•¸åŠèª¿æ•´åˆ†æ•¸å¾Œä¹‹åˆ†æ•¸è®Šå‹•é—œä¿‚ã€‚(ä»£è™Ÿï¼š$A$)\nèª¿åˆ†æ¯”ç‡ï¼šèª¿æ•´å¾Œåˆ†æ•¸ç›¸è¼ƒæ–¼åŸå§‹åˆ†æ•¸æé«˜äº†å¹¾å€ï¼Œå…¬å¼ï¼èª¿æ•´å¾Œåˆ†æ•¸/åŸå§‹åˆ†æ•¸ã€‚(ä»£è™Ÿï¼š$B$)ï¼Œå› åˆ†æ¯ä¸å¯ç‚º$0$æ•…ä¸è¨ˆç®—$0$åˆ†ä¹‹èª¿åˆ†æ¯”ç‡ã€‚\nå¤šå¾—åˆ†æ•¸ï¼šèª¿æ•´å¾Œåˆ†æ•¸è¼ƒåŸå§‹åˆ†æ•¸åŠ äº†å¹¾åˆ†ï¼Œå…¬å¼ï¼èª¿æ•´å¾Œåˆ†æ•¸-åŸå§‹åˆ†æ•¸ã€‚(ä»£è™Ÿï¼š$C$)\n\nå››ã€å•é¡Œè§£æ±ºï¼ˆä¸€ï¼‰ç·šæ€§èª¿æ•´y=ax+b1. å…¬å¼ï¼š$f(x)=y=ax+b, f(0)=b,f(100)=100$2. è¨­å®šä¸åŒç‹€æ³èª¿æ•´å¾Œæœ€ä½å¯å¾—åˆ°åˆ†$(b)$ç•¶æœ€ä½åˆ†ç‚º$b=60$åˆ†ï¼Œ$a=0.4$ï¼Œå…¬å¼ï¼š$y=0.4x+60$ï¼Œä¾æ­¤é¡æ¨ã€‚\n\n\n\n\nb\nå…¬å¼\n\n\n\n\n60\ny=0.4x+60\n\n\n50\ny=0.5x+50\n\n\n40\ny=0.6x+40\n\n\n30\ny=0.7x+30\n\n\n20\ny=0.8x+20\n\n\n10\ny=0.9x+10\n\n\n\n\n3. ä»¥åŸå§‹åˆ†æ•¸1-100åˆ†ï¼Œç•«å‡ºåœ–è¡¨\n\n\nï¼ˆäºŒï¼‰å°‡åŸå§‹åˆ†æ•¸é–‹æ ¹è™Ÿå¾Œä¹˜ä»¥101. å…¬å¼ï¼š$y=f(x)=10\\sqrt{x}$2. ä»¥åŸå§‹åˆ†æ•¸ç‚º$1-100$åˆ†ï¼Œç•«å‡ºåœ–è¡¨\n\n\nå¤šå¾—åˆ°åˆ†æ•¸å‘ˆç¾ä¸€æœ‰æœ€å¤§å€¼çš„æ›²ç·šï¼Œä»£è¡¨åœ¨$1-100$ä¸­æœ‰æŸä¸€å¾—åˆ†ä¹‹äººç²ç›Šæœ€å¤§ï¼Œèƒ½åŠ åˆ°æœ€å¤šåˆ†ï¼Œæ¯”å°å¾—åˆ°ä¹‹æ•¸æ“šå¯ç™¼ç¾ç•¶åŸå§‹åˆ†æ•¸ç‚º$25$åˆ†æ™‚ï¼Œæœ€åˆ’ç®—ï¼Œå¯å¤šå¾—åˆ°æœ€å¤šåˆ†æ•¸ã€‚\n3. æ­¤æƒ…æ³å¯æ¢è¨ç•¶æ¬¡æ–¹æ ¹æ•¸æé«˜å¾Œä¹˜ä»¥æŸæ•¸ï¼Œä½¿æ»¿åˆ†ä»ç‚º$100$ç•¶æ¬¡æ–¹æ ¹ç‚ºä¸‰æ¬¡æ–¹æ ¹ï¼Œéœ€ä¹˜ä»¥æŸæ•¸$k_3$ï¼Œä½¿æ»¿åˆ†ä»ç‚ºç‚º$100$ã€‚è¨ˆç®—$k_3=\\frac{100}{100^{1/3}}=100^{2/3}\\approx 21.5443469$ã€‚å…¬å¼ï¼š$y=f(x)=x^{1/3}$ä»¥åŸå§‹åˆ†æ•¸ç‚º$1-100$ï¼Œç•«å‡ºåœ–è¡¨ã€‚\n\n\n\nå¤šå¾—åˆ°åˆ†æ•¸å‘ˆç¾ä¸€æœ‰æœ€å¤§å€¼çš„æ›²ç·šï¼Œä»£è¡¨åœ¨$1-100$ä¸­æœ‰æŸä¸€å¾—åˆ†ä¹‹äººç²ç›Šæœ€å¤§ï¼Œèƒ½åŠ åˆ°æœ€å¤šåˆ†ï¼Œæ¯”å°å¾—åˆ°ä¹‹æ•¸æ“šå¯ç™¼ç¾ç•¶åŸå§‹åˆ†æ•¸ç‚º$19$åˆ†æ™‚ï¼Œæœ€åˆ’ç®—ï¼Œå¯å¤šå¾—åˆ°æœ€å¤šåˆ†æ•¸ã€‚\n4. å°‡æ­¤æƒ…å½¢æ¨å»£åˆ°æ›´é«˜æ¬¡æ–¹æ ¹ï¼Œæ±‚å‡ºä»Šç‚ºnæ¬¡æ–¹æ ¹å¾Œï¼Œknç‚ºä½•ï¼Ÿé€šå¼ï¼š$k_n\\cdot(100^{1/n})=100,k_n=100^{\\frac{n-1}{n}}$\n\nç”±ä¸Šåœ–å¯çŸ¥kå€¼ç‚ºå°‡ç„¡çª®æ¥è¿‘$100$ã€‚\n5. ç”¨$2-8$æ¬¡æ–¹æ ¹ï¼Œç•«å‡ºä»¥åŸå§‹åˆ†æ•¸ç‚º$1-100$åˆ†çš„åœ–è¡¨ã€‚åœ–ä¸­$s$ç‚ºæ¬¡æ–¹æ ¹æ•¸\n\n\n6. æ±‚å‡ºä¸åŒæ¬¡æ–¹æ ¹ä¸­ï¼Œèƒ½å¾—åˆ°æœ€å¤šåˆ†æ•¸çš„åŸå§‹åˆ†æ•¸ç‚ºä½•ï¼Ÿåœ¨äºŒæ¬¡æ–¹æ ¹ä¸­ï¼ŒåŸå§‹åˆ†æ•¸ç‚º25ï¼Œå¯ä»¥åŠ åˆ°æœ€å¤šåˆ†ã€‚åœ¨ä¸‰æ¬¡æ–¹æ ¹ä¸­ï¼ŒåŸå§‹åˆ†æ•¸ç‚º19ï¼Œå¯ä»¥åŠ åˆ°æœ€å¤šåˆ†ã€‚è¨­ç•¶næ¬¡æ–¹æ ¹æ™‚ï¼ŒåŸå§‹åˆ†æ•¸ç‚ºxï¼Œå¯ä»¥åŠ åˆ°æœ€å¤šåˆ†ã€‚è¨ˆç®—nèˆ‡xä¹‹é—œä¿‚ï¼š\n\\begin{split}f'(x) &= \\frac{d}{dx}(k_n\\cdot x^{1/n}-x) = 0\n\\\\&\\Rightarrow \\frac{d}{dx}(100^{\\frac{n-1}{n}}\\cdot x^{1/n}-x) = 0\n\\\\&\\Rightarrow \\frac{1}{n}\\cdot 100^{\\frac{n-1}{n}} = x^{\\frac{n-1}{n}}\n\\\\&\\Rightarrow x = 100\\cdot n^{\\frac{-n}{n-1}}\n\\end{split}\nåœ–ä¸­å¯è¦‹ï¼Œæ©«è»¸ç‚ºæ¬¡åˆ†æ ¹æ•¸ï¼Œç¸±è»¸ç‚ºæœ€å¤§ç²ç›Šçš„åŸå§‹åˆ†æ•¸ã€‚ä¸‰æ¬¡æ–¹æ ¹æ™‚æº–ç¢ºçš„å€¼ä¸¦é$19$ï¼Œè€Œæ˜¯$19.245$ã€‚ä»¥$x$çš„ä¸€èˆ¬å¼è¨ˆç®—ä¸‰æ¬¡æ–¹æ ¹æ™‚æœ€å¤§ç²ç›Šçš„åŸå§‹åˆ†æ•¸ã€‚\n\\begin{split}x &= 100\\cdot n^{\\frac{-3}{3-1}}\n\\\\&\\approx 19.245\n\\end{split}7. ä¸åŒçš„æ¬¡æ–¹æ ¹èˆ‡åŠ æœ€å¤šåˆ†æ•¸çš„é—œä¿‚ç”±ä¸Šè¿°å¯çŸ¥ï¼Œç•¶å¸¶å…¥$x = 100\\cdot n^{\\frac{-n}{n-1}}$ æœƒæœ‰åŠ åˆ†çš„æœ€å¤§å€¼ã€‚æ–¼æ˜¯ï¼Œæˆ‘å€‘å¯ä»¥å°‡å…¶å¸¶å…¥ä¸Šæ–¹å…¬å¼è¨ˆç®—å‡ºä¸åŒçš„$n$èˆ‡åŠ æœ€å¤šåˆ†æ•¸çš„é—œä¿‚ã€‚\n\\begin{split}f(x) &=100^{\\frac{n-1}{n}}\\cdot x^{\\frac{1}{n}}-x,\\ x = 100\\cdot n^{\\frac{-n}{n-1}}\n\\\\&\\Rightarrow 100(n^{\\frac{-1}{n-1}}-n^{\\frac{-n}{n-1}})\n\\end{split}å¯å¾—ä¸€å€‹æ–°çš„å…¬å¼$h(x)$ï¼Œä»£è¡¨ä¸åŒçš„æ¬¡æ–¹æ ¹å°æ‡‰çš„åŠ åˆ†çš„æœ€å¤§å€¼ã€‚æ­¤å‡½æ•¸æ˜¯ä¸€å€‹å–®èª¿éå¢å‡½æ•¸ï¼Œå‡½æ•¸å€¼éš¨è‘—$n$å¢åŠ æœ‰éå¢çš„æƒ…å½¢ã€‚\nh(x) = 100(n^{\\frac{-1}{n-1}}-n^{\\frac{-n}{n-1}})\nï¼ˆä¸‰ï¼‰å°‡åŸå§‹åˆ†æ•¸å–logå¾Œä¹˜ä»¥ä¸€å¸¸æ•¸ä½¿æ»¿åˆ†ä»ç‚º100é€šå¼ï¼šè¨­åŸå§‹åˆ†æ•¸ç‚º$x$, $y=f(x)=p\\log_ax,  f(100)=100, a&gt;0$\n1. ä»¥åŸå§‹åˆ†æ•¸ç‚º1-100ï¼Œç•«å‡ºåœ–è¡¨\n\n\næˆ‘å€‘ç™¼ç¾ï¼Œä¸è«–åº•æ•¸aå€¼ç‚ºä½•ï¼Œå¾—å‡ºçµæœå‡ç›¸åŒï¼Œå› æ­¤æƒ³æ¢è¨ç‚ºä»€éº¼åº•æ•¸å°æ‰€å¾—åˆ°çš„æ›²ç·šä¸æœƒæœ‰å½±éŸ¿ï¼Œå¦‚ä¸‹ã€‚\n2. ä»¥ä¸€èˆ¬å¼æè¿°å¤šå¾—åˆ°ä¹‹åˆ†æ•¸ï¼Œæ¢è¨ç‚ºä½•ä¸è«–aå€¼ç‚ºä½•ï¼Œå¾—å‡ºçµæœå‡ç›¸åŒ\\begin{split}f(x) &= p\\log_ax-x\n\\\\&= (\\frac{100}{\\log_a100})\\log_ax-x\n\\\\&=100\\frac{\\log_ax}{\\log_a100}-x\n\\\\&=50\\log_{10}x-x\n\\end{split}ç™¼ç¾åœ¨éç¨‹ä¸­åº•æ•¸aæœƒè¢«æ›åº•å¾Œå–ä»£ï¼Œæœ€çµ‚çµæœç„¡açš„å½±éŸ¿ï¼Œæ•…ä¸è«–åº•æ•¸aå€¼ç‚ºä½•ï¼Œå¾—å‡ºä¹‹æ›²ç·šå‡ç›¸åŒã€‚\n3. ç®—å‡ºåŸå§‹åˆ†æ•¸ç‚ºä½•å¯ä»¥å¤šå¾—åˆ°åˆ†æ•¸æœ€å¤š\\begin{split}f'(x) &= \\frac{d}{dx}(50\\log_{10}x-x) = 0\n\\\\&\\Rightarrow \\frac{50}{\\ln(10)x}=1\n\\\\&\\Rightarrow x = \\frac{50}{\\ln(10)}\\approx 21.7147\n\\end{split}ç™¼ç¾ç•¶åŸå§‹åˆ†æ•¸ç´„ç‚º21.7147æ™‚ï¼Œå¯åŠ åˆ°æœ€å¤šåˆ†æ•¸ã€‚\nï¼ˆå››ï¼‰æœ€ä½åŠæ ¼åˆ†æ•¸ä¹‹éç·šæ€§èª¿åˆ†1. æ¬¡æ–¹èª¿æ•´è¨ˆç®—å…¬å¼æ ¹æ“šä»¥ä¸Šçš„å®šç¾©ï¼Œå°æ–¼åˆ†æ•¸ç‚º$x$çš„äººï¼Œèª¿æ•´å¾Œçš„åˆ†æ•¸$f(x)$æ»¿è¶³ï¼š\nf(x) = k_n\\cdot x^{\\frac{1}{n}}, \\ k_n = 100^{\\frac{n-1}{n}}ä»¥é–‹äºŒæ¬¡æ–¹æ ¹ä¾†è¨ˆç®—ï¼Œå‰‡è€ƒ36åˆ†çš„äººå¯ä»¥æ°å¥½åŠæ ¼ã€‚æˆ‘å€‘æƒ³è¦åˆ©ç”¨åŸå§‹åˆ†æ•¸è·Ÿç›®æ¨™åˆ†æ•¸ï¼Œä¾†è¨ˆç®—éœ€è¦é–‹å¹¾æ¬¡æ–¹ã€‚å‡è¨­è€ƒ$b$åˆ†çš„äººç¶“éèª¿æ•´å¾Œç‚º$a$åˆ†ï¼ˆåŠæ ¼çš„è©±$a = 60$ï¼‰ï¼Œæ‰€é–‹çš„æ¬¡æ–¹æ•¸ç‚º$n$æ¬¡ï¼Œå¸¶å…¥ä¸Šæ–¹å…¬å¼ï¼Œåˆ†é …æ•´ç†éå¾Œæœ‰ä»¥ä¸‹é—œä¿‚ï¼š\nn = g(a,b)= \\frac{2-\\log b}{2-\\log a}2. ä»¥åŸå§‹åˆ†æ•¸1-100ç•«å‡ºèª¿æ•´å¾Œåˆ†æ•¸åœ–å½¢ä¸‹åœ–ç‚º$a = 60,b = 45$ï¼Œ$n \\approx 1.563$ èª¿æ•´å‰å¾Œåˆ†æ•¸çš„åœ–å½¢ã€‚\n3. æœ€ä½åŠæ ¼åˆ†æ•¸bèˆ‡æ¬¡æ–¹æ•¸nçš„é—œä¿‚ç”±ç¬¬ä¸€é»çš„å…¬å¼ï¼Œæˆ‘å€‘å¯ä»¥è§€å¯Ÿåˆ°ï¼Œè¦å°‡è¶Šä½çš„åˆ†æ•¸èª¿æ•´åˆ°åŠæ ¼ï¼Œæ‰€é–‹çš„æ¬¡æ–¹æ•¸$n$å°±å¿…é ˆè¶Šå¤§ï¼Œå‡½æ•¸$g(a,b)$åœ–å½¢å¦‚ä¸‹åœ–ï¼Œæ©«è»¸æ˜¯åŸå§‹åˆ†æ•¸$b$ï¼Œç¸±è»¸æ˜¯åˆ†æ•¸$b$è‹¥è¦èª¿æ•´åˆ°åŠæ ¼ï¼ˆ60åˆ†ï¼‰æ‰€éœ€è¦é–‹çš„æ¬¡æ–¹æ•¸$n$ã€‚ä¸€æ¨£å¯ä»¥ç™¼ç¾åˆ°ï¼Œç•¶åŸå§‹åˆ†æ•¸ç‚º36åˆ†æ™‚ï¼Œé–‹2æ¬¡æ–¹æ ¹å°±æœƒå°æ‡‰çš„å‡½æ•¸å€¼ã€‚\n\näº”ã€çµæœè¨è«–ï¼ˆä¸€ï¼‰ ç·šæ€§èª¿åˆ†è½èµ·ä¾†å¾ˆå…¬å¹³ï¼Œæ¯å€‹äººéƒ½å¯ä»¥ä¾ç…§ä¸€å®šæ¯”ä¾‹åŠ åˆ†ï¼Œä½†åœ¨å¯¦éš›åšå‡ºåŠ åˆ†æ¯”ç‡åœ–å¾Œç™¼ç¾å¯¦éš›ä¸Š$0-20$åˆ†ä¹‹åŠ åˆ†æ¯”ç‡é è¶…éå…¶ä»–åˆ†æ•¸æ—ç¾¤ã€‚å°æ–¼ä¸­åå‰æ®µä¹‹é«˜åˆ†æ—ç¾¤æ¥µç‚ºä¸åˆ©ã€‚ä¸éï¼Œè‹¥æƒ³è¦æå‡åŠæ ¼æ¯”ç‡ï¼Œéç·šæ€§èª¿åˆ†ä¸å¤±ç‚ºä¸€å€‹ååˆ†æœ‰æ•ˆçš„æ–¹å¼ã€‚\nï¼ˆäºŒï¼‰ é–‹ç‰¹å®šæ¬¡æ–¹æ ¹æ ¹å¾Œä¹˜ä»¥ä¸€å¸¸æ•¸ä¹‹çµæœå¯çœ‹å‡ºï¼Œè‹¥é–‹$n$æ¬¡æ–¹æ ¹ï¼Œ$n$è¶Šå¤§èƒ½åŠ åˆ°æœ€å¤šåˆ†åˆ°åˆ†æ•¸$x$éš¨ä¹‹ä¸‹é™ï¼Œç¬¦åˆå…¬å¼ $x = 100\\cdot n^{\\frac{-n}{n-1}}$ã€‚\nï¼ˆä¸‰ï¼‰ åŠ æœ€å¤šåˆ†éš¨è‘—é–‹çš„æ¬¡æ–¹æ•¸nå¢åŠ è€Œéå¢ï¼Œå…¶æœ€å¤§çš„åŠ åˆ†æ•¸ç¬¦åˆå…¬å¼$h(x) = 100(n^{\\frac{-1}{n-1}}-n^{\\frac{-n}{n-1}})$\nï¼ˆå››ï¼‰ è‹¥æƒ³è¦å°‡ä¸€å€‹åˆ†æ•¸ç‚º$b\\ (b&lt;60)$çš„äººèª¿æ•´åˆ†æ•¸åˆ°åŠæ ¼ï¼Œè‹¥åˆ†æ•¸$b$è¶Šå°ï¼Œæ‰€éœ€è¦çš„æ¬¡æ–¹æ•¸å°±å¿…é ˆè¶Šå¤§ï¼Œç¬¦åˆå…¬å¼$n=\\frac{2-\\log b}{2-\\log a}$ã€‚\nï¼ˆäº”ï¼‰ ç¶“élogå¾Œä¹˜ä»¥ä¸€å¸¸æ•¸ä¹‹çµæœï¼Œç™¼ç¾ä¸è«–åº•æ•¸ç‚ºä½•ï¼Œå‡ä¸å½±éŸ¿æœ€çµ‚çµæœï¼Œå› ç‚ºåº•æ•¸å¯ç¶“ç”±æ›åº•å…¬å¼æ¶ˆé™¤ã€‚\nï¼ˆå…­ï¼‰ logçµ„ä¸­ç™¼ç¾åŸåˆ†æ•¸ç‚º1è€…ï¼Œèª¿åˆ†å¾Œæœƒè®Šæˆ0åˆ†ï¼Œç†æ‡‰ä¿®æ­£ã€‚ä½¿åŸå§‹åˆ†æ•¸ç‚º1åˆ†ä¹‹äººè‡³å°‘ä¸è¦å‘ˆç¾æ‰£åˆ†çš„æƒ…æ³ã€‚\nçœ‹äº†æ¬¡æ–¹æ ¹å’Œlogå…©çµ„çš„æ›²ç·šå¾Œè¶¨å‹¢è®ŠåŒ–æœ‰é»ç›¸è¿‘ï¼Œå¯ä»¥å°‡å…©å¼µåœ–ç–Šåˆå†ä¸€èµ·åšæ¯”è¼ƒã€‚å¯è¦‹logçµ„çš„æ›²ç·šç›¸è¼ƒæ¬¡æ–¹æ ¹çµ„ä¹‹è®ŠåŒ–è¶¨å‹¢ï¼Œå¦‚ä¸‹åœ–ï¼š\n\nå…­ã€æœªä¾†å±•æœ›ä¹‹å¾Œå¯ä»¥åšå‡ºä»¥å‡è¨­å…¨ç­åŸå§‹åˆ†æ•¸ç‚ºå¸¸æ…‹åˆ†ä½ˆï¼Œå‡è¨­åœ¨ä¸åŒçš„å¹³å‡åˆ†æ•¸ä¸‹ï¼Œæ¨¡æ“¬å‡ºå…¨ç­èª¿åˆ†å¾Œä¹‹çµæœï¼Œè¨ˆç®—åŠæ ¼æ¯”ç‡ã€‚å¯ä»¥ä½œç‚ºæœªä¾†é€²è¡Œèª¿åˆ†çš„ä¾æ“šã€‚èª¿æ•´åˆ†æ•¸è€…å¯å…ˆè¡Œè¨­å®šé€™æ¬¡è€ƒè©¦å¯èƒ½ä¹‹å¹³å‡åŠå¸Œæœ›åŠæ ¼æ¯”ç‡ç‚ºä½•å¾Œï¼Œé¸å®šä¸€ç¨®æ–¹å¼é€²è¡Œèª¿åˆ†ã€‚\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","èª¿åˆ†å…¬å¼"]},{"title":"ä¸‰ç¶­ç©ºé–“ä¸­çš„åå°„å®šå¾‹æ¨¡æ“¬","url":"/reflection/","content":"ç°¡ä»‹ä¸Šé€±è£œç¿’ç­é–‹å§‹æ•™ã€Œå¹³é¢æ–¹ç¨‹å¼ã€ï¼Œæœ‰ä¸€é¡Œç¯„ä¾‹æ„Ÿè¦ºç‰¹åˆ¥çš„é…·ï¼Œé¡Œç›®å¦‚ä¸‹ï¼š\n\nç©ºé–“åæ¨™ç³»ä¸­ï¼Œæœ‰ä¸€å¹³é¢é¡Eï¼Œä¸€é›·å°„å…‰ç·šç¶“éé»$A(1,-1,2)$å°„å‘é¡é¢Eä¸Šçš„é»$B(0,1,0)$ï¼Œåå°„åˆç¶“éé»$C(4,-3,2)$ï¼Œè©¦æ±‚å¹³é¢Eçš„æ–¹ç¨‹å¼ç‚ºä½•ï¼Ÿ\n\nè§£æ³•å¤§æ¦‚å°±æ˜¯åˆ©ç”¨è±å½¢å°è§’ç·šå¹³åˆ†çš„æ¦‚å¿µæ±‚å‡ºå¹³é¢æ–¹ç¨‹å¼ï¼ç”±é€™ä¸€é¡Œå»¶ä¼¸ï¼Œæˆ‘æƒ³çœ‹çœ‹ç•¶æ”¹è®Šå·²çŸ¥å¹³é¢çš„å„é …åƒæ•¸æ™‚ï¼Œåå°„å…‰çš„å‘é‡æœƒæœ‰æ€éº¼æ¨£çš„è®ŠåŒ–ï¼Œæ–¼æ˜¯å°±å˜—è©¦ç”¨VPythonæ¨¡æ“¬å‡ºä¾†ï¼\n\n\n\nåå°„å®šå¾‹åŠæ•¸å­¸å¹³é¢çš„æƒ…æ³å¾ˆå¥½ç†è§£ï¼Œå…¥å°„è§’ç­‰æ–¼åå°„è§’ï¼Œä½†ç•¶ä¾†åˆ°ä¸‰ç¶­æ™‚ï¼Œé™¤äº†è§’åº¦ä¸€æ¨£ä¹‹å¤–ï¼Œé€™ä¸‰å€‹å‘é‡é‚„å¿…é ˆåœ¨åŒä¸€å€‹å¹³é¢ä¸Šï¼š\n\nåŸé¡Œæˆ‘å€‘æ˜¯åˆ©ç”¨å·²çŸ¥çš„$\\overrightarrow{BA},\\overrightarrow{BC}$ï¼Œåˆ©ç”¨è±å½¢é‚Šé•·ç›¸ç­‰ä¸”å¹³åˆ†å¤¾è§’çš„æ€§è³ªï¼Œå°‡é•·åº¦èª¿æ•´æˆä¸€æ¨£ä¹‹å¾Œç›¸åŠ å³å¯æ±‚å‡ºå¹³é¢çš„æ³•å‘é‡ï¼Œé€²ä¸€æ­¥æ±‚å¾—åå°„çš„å¹³é¢ï¼š\n\nè¦åˆ©ç”¨$\\overrightarrow{BA}$ä»¥åŠå¹³é¢æ–¹ç¨‹å¼é€†æ¨åå°„å…‰å‘é‡ï¼Œåœ¨ç¢ºèªæ³•å‘é‡çš„æ–¹å‘å‘é‡ä¹‹å¾Œï¼Œå°‡å¹³é¢æ³•å‘é‡çš„é•·åº¦è¨­ç‚º$|\\vec{n}| = 2\\overline{AB}\\cos\\theta$ï¼Œç”±$\\vec n = \\overrightarrow{BA}+\\overrightarrow{BC}$å³å¯æ¨å¾—èˆ‡$\\overrightarrow{BA}$é•·åº¦ç›¸åŒçš„$\\overrightarrow{BC}$ï¼\n\nç¶œåˆä»¥ä¸Šï¼Œä»¤åå°„å¹³é¢æ–¹ç¨‹å¼ç‚º$ax+by+cz = 0$ï¼Œ$\\vec n = (a,b,c)$ï¼Œå…¥å°„è§’ç‚º$\\theta$ï¼Œå‰‡ï¼š\n\\begin{split}\\overrightarrow{BC} &= \\frac{2|\\overrightarrow{BA}|\\cos\\theta}{|\\vec n|}\\vec n - \\overrightarrow{BA}\n\\\\&=\\frac{2|\\overrightarrow{BA}|(\\vec n\\cdot\\overrightarrow{BA})}{|\\vec n|^2\\,\\overrightarrow{BA}}\\vec n - \\overrightarrow{BA}\\end{split}æ¨¡æ“¬åŠç¨‹å¼ç¢¼ä½¿ç”¨èªªæ˜æ¨¡æ“¬é€£çµä»–æœƒè¦æ±‚è¼¸å…¥ç™¼å°„æºçš„$x,y,z$åº§æ¨™ï¼Œå®Œæˆå¾Œå¯ä»¥åˆ©ç”¨éµç›¤â€™A,Sâ€™éµèª¿æ•´å¹³é¢$ax+by+cz=0$ä¸Š$a$çš„å¤§å°ï¼ˆAè®Šå¤§ã€Sè®Šå°ï¼‰ï¼Œ$b$å‰‡æ˜¯â€™B,Nâ€™éµã€$c$æ˜¯â€™C,Vâ€™éµã€‚\n\nåˆ©ç”¨ä»¥ä¸Šçš„å…¬å¼ï¼Œæˆ‘å€‘å»ºç«‹å„å€‹ç‰©ä»¶ã€åŒ…å«å„å€‹åº§æ¨™è»¸ã€åå°„å¹³é¢ä»¥åŠå…¥å°„åå°„å…‰ã€‚æ¨¡æ“¬ä¸­å…©å€‹é»ƒè‰²çš„ç®­é ­ä»£è¡¨å…¥å°„å…‰åŠåå°„å…‰çš„å‘é‡ï¼Œç°è‰²ç®­é ­å‰‡æ˜¯å¹³é¢çš„æ³•å‘é‡ã€‚\nè¨ˆç®—è¨ˆç®—å¤¾è§’ç”¨åˆ°å…§ç©ç®—å¤¾è§’çš„é¤˜å¼¦$\\cos\\theta = \\frac{\\vec a\\cdot\\vec b}{|\\vec a||\\vec b|}$ï¼Œç®—å…§ç©å‡½å¼å¦‚ä¸‹ï¼š\ndef dt(a,b):    return a.x*b.x+a.y*b.y+a.z*b.z\næ¥è‘—å°±æ˜¯è¨ˆç®—$|\\vec n|$çš„é•·åº¦szï¼Œå°$\\vec n$å–å–®ä½å‘é‡å¾Œä¹˜ä¸Šé•·åº¦ï¼Œä¸¦è¨­ç‚ºå¹³é¢çš„æ³•å‘é‡ï¼Œå°‡$\\vec n$èˆ‡å…¥å°„å…‰å‘é‡ç›¸æ¸›å¾—åˆ°åå°„å…‰å‘é‡\nsz = 2 * mag(ball.pos) * dt(plane.up,ball.pos) / (mag(plane.up)*mag(ball.pos))n = norm(plane.up) * szplane.up = vec(a,b,c)normal.axis = narr_out.axis = n - ball.pos\nå®Œæ•´ç¨‹å¼ç¢¼GlowScript 3.2 VPythonx = int(input(&quot;x = &quot;))y = int(input(&quot;y = &quot;))z = int(input(&quot;z = &quot;))a = 0b = 1c = 0scene = canvas(width=1000, height=500,center = vector(0,0,0),range = max(x,max(y,z))+10) #è¨­å®šç•«é¢def dt(a,b):    return a.x*b.x+a.y*b.y+a.z*b.zplane = box(pos=vector(0,0,0),length=20, height=0.1, width=10)arrx = arrow(pos=vector(-10,0,-5), axis=vector(20,0,0), shaftwidth=0.1, color=color.red)arry = arrow(pos=vector(-10,0,-5), axis=vector(0,20,0), shaftwidth=0.1, color=color.blue)arrz = arrow(pos=vector(-10,0,-5), axis=vector(0,0,20), shaftwidth=0.1, color=color.green)ball = sphere(pos=vector(x,y,z),radius=0.5,color = color.red)arr_in = arrow(pos=ball.pos, axis=plane.pos-ball.pos, shaftwidth=0.5, color=color.yellow)arr_out = arrow(pos=vec(0,0,0), axis=vector(0,0,0), shaftwidth=0.5, color=color.yellow)normal = arrow(pos=vec(0,0,0), shaftwidth=0.1, color=color.white)label_a = label(pos=vec(max(x,max(y,z))+10,10,0), box = 0 ,height = 20, color = color.green)label_b = label(pos=vec(max(x,max(y,z))+10,5,0), box = 0 ,height = 20, color = color.green)label_c = label(pos=vec(max(x,max(y,z))+10,0,0), box = 0 ,height = 20, color = color.green)while True:    rate(10)    label_a.text = &#x27;&#123;&#125;&#123;:.1f&#125;&#x27;.format(&#x27;a = &#x27;,a)    label_b.text = &#x27;&#123;&#125;&#123;:.1f&#125;&#x27;.format(&#x27;b = &#x27;,b)    label_c.text = &#x27;&#123;&#125;&#123;:.1f&#125;&#x27;.format(&#x27;c = &#x27;,c)        ev = scene.waitfor(&#x27;click keydown&#x27;)    if ev.key == &#x27;A&#x27;or ev.key == &#x27;a&#x27;:a += 0.1    if ev.key == &#x27;B&#x27;or ev.key == &#x27;b&#x27;:b += 0.1    if ev.key == &#x27;C&#x27;or ev.key == &#x27;c&#x27;:c += 0.1        if ev.key == &#x27;S&#x27;or ev.key == &#x27;s&#x27;:a -= 0.1    if ev.key == &#x27;N&#x27;or ev.key == &#x27;n&#x27;:b -= 0.1    if ev.key == &#x27;V&#x27;or ev.key == &#x27;v&#x27;:c -= 0.1        sz = 2 * mag(ball.pos) * dt(plane.up,ball.pos) / (mag(plane.up)*mag(ball.pos))    n = norm(plane.up) * sz        plane.up = vec(a,b,c)    normal.axis = n        arr_out.axis = n - ball.pos\nå»¶ä¼¸å…§å®¹æ—¢ç„¶æœ‰åå°„å‹¢å¿…æœ‰æŠ˜å°„å®šå¾‹çš„æ¨¡æ“¬ï¼Œç‰½æ‰¯åˆ°ä¸åŒä»‹è³ªçš„æŠ˜å°„ç‡ä»¥åŠè§’åº¦çš„è¨ˆç®—$n_1\\sin\\theta_1 = n_2\\sin\\theta_2$ï¼Œä¹‹å¾Œå¯ä»¥å˜—è©¦å¯«ä¸€å€‹æ¨¡æ“¬è©¦è©¦ï¼\n","categories":["ç¨‹å¼æ¨¡æ“¬"],"tags":["æ•¸å­¸","VPYTHON","æ¨¡æ“¬"]},{"title":"ç·šæ®µæ¨¹ï¼ˆSegment Treeï¼‰","url":"/seg1/","content":"ä»Šå¹´æ˜¯2021ï¼Œè³‡èŠ½çš„äºŒéšä¸»é¡Œè·Ÿ2020ä¸Šçš„æœ‰å¾ˆå¤šçš„å·®åˆ¥ï¼Œå› æ­¤æœƒåˆ©ç”¨æš‘å‡æŠŠ2020çš„æ±è¥¿ä¹Ÿè£œä¸€è£œï¼\nèª²ç¨‹å…§å®¹å„²å­˜ç·šæ®µæ¨¹å¾ˆå¤šäººéƒ½ç”¨é™£åˆ—ä¾†å¯¦ä½œï¼Œç©ºé–“$O(n)$ï¼Œåœ¨è™•ç†æ¨¹çš„å·¦å³ç¯€é»ä¹Ÿååˆ†çš„æ–¹ä¾¿ã€‚å¦‚æœä»¥1-baseä¾†å„²å­˜é™£åˆ—é€™æ£µç·šæ®µæ¨¹ï¼Œå·¦å³ç¯€é»å¯ä»¥ç”¨ä»¥ä¸‹çš„indexä¾†è¡¨ç¤ºã€‚ç·šæ®µæ¨¹æœ‰ä¸€å€‹å„ªé»å°±æ˜¯å®ƒå¯ä»¥ç”¨å„²å­˜å®Œæ»¿äºŒå…ƒæ¨¹çš„æ–¹å¼ä¾†å„²å­˜ï¼Œé›–ç„¶å®ƒä¸ä¸€å®šæ˜¯å®Œæ»¿ä½†æœƒæ˜¯å¹³è¡¡çš„ä¸€æ£µæ¨¹ã€‚å·¦ç¯€é»ï¼š$2n$ï¼Œå³ç¯€é»$2n+1$ã€‚\nç©ºé–“å¤§å°ä¸€èˆ¬ä¾†èªªç·šæ®µæ¨¹çš„é™£åˆ—æœƒé–‹$seg[4\\times n]$ï¼Œç”±ä»¥ä¸‹è­‰æ˜å¾—åˆ°çš„çµæœï¼š\n\n            å°æ–¼ä¸€å€‹æœ‰$2^k$çš„è‘‰ç¯€é»æ•¸çš„ä¸€æ£µæ¨¹ï¼Œç¸½å…±çš„ç¯€é»å…±æœ‰ $\\sum_{i=0}^k 2^i = 2^{k+1}-1$ å€‹ç¯€é»ã€‚è‹¥ä»Šå¤©é™£åˆ—å…±æœ‰nå€‹å…ƒç´ ï¼Œå‰‡ä»£è¡¨è‘‰ç¯€é»å…±æœ‰$2^{\\lceil \\log_2 n\\rceil}$ å€‹ï¼Œç¸½ç¯€é»æ•¸é‡å…±æœ‰$2^{\\lceil \\log_2 n\\rceil+1}-1$ å€‹ã€‚å‡è¨­$n = 2^k+p,0â‰¤pâ‰¤2^k$ï¼Œå‰‡å¸¶å…¥å‰é¢å…¬å¼ $2^{\\lceil \\log_2 n\\rceil}=2^{k+1}$ï¼Œæ ¹æ“šå‰é¢æ¨å¾—çš„ç¸½ç¯€é»æ•¸å¯ä»¥çŸ¥é“ç‚º $2^{k+2}-1$ï¼Œå…¶å€¼æ†å°æ–¼$4n$ï¼Œå› æ­¤é–‹$4n$çš„é™£åˆ—ä¸€å®šå¯ä»¥å®¹ç´æ•´å€‹ç·šæ®µæ¨¹ã€‚\n          \nç”±ä»¥ä¸Šæ¨å€’å¯ä»¥çŸ¥é“ä¸€èˆ¬éƒ½æœƒé–‹$seg[4\\times n]$ï¼Œä½†æ˜¯å¦‚æœnå‰›å¥½æ˜¯äºŒçš„å†ªæ¬¡ï¼Œå…¶å¯¦åªæœƒç”¨åˆ°$2n$çš„ç©ºé–“ï¼Œæœ‰ä¸€åŠæœƒè¢«æµªè²»æ‰ï¼Œä¸éæ²’å·®ï¼Œå› ç‚ºå¤šé–‹ç¸½æ¯”å°‘é–‹ä¾†å¾—å¥½ï¼æ‡¶æ¨™ç·šæ®µæ¨¹ç¨‹å¼ç¢¼é€£çµï¼Œæ‡¶æ¨™é€™æ±è¥¿å¯¦åœ¨æŠ˜ç£¨äººï¼Œå­¸é•·å¯«çš„ä¸€å€‹å ªç¨±ä¸ç”¨ä¸‹æ¨çš„æ‡¶æ¨™ç¨‹å¼ç¢¼ï¼Œçµæœä»–æ˜¯éŒ¯çš„ï¼ï¼ï¼å®³æˆ‘Debugè¶…ä¹…ï¼Œå¯æƒ¡é€™æ˜¯å­¸é•·çš„queryç¨‹å¼ç¢¼ï¼Œå¯ä»¥çœ‹åˆ°ä»–å›å‚³çš„æ˜¯$(r-l)\\times lazy[cur]$ï¼Œé€™æ˜¯éŒ¯èª¤çš„ï¼Œå› ç‚ºä¸ä¸€å®šå·¦å³å…©å­æ¨¹éƒ½æœƒè¢«å…¨éƒ¨åŠ ä¸Šæ‡¶æ¨™çš„å€¼ï¼ˆå¯èƒ½åªæœƒæœ‰éƒ¨åˆ†äº¤é›†ï¼‰ï¼Œä½†é€™ä»½codeå»ç›´æ¥åŠ ä¸Šå»ï¼Œæœƒå¤šç®—è€ŒWAï¼Œè¦æ³¨æ„ï¼æ›´æ”¹ç‰ˆï¼Œå°å€é–“å–è¯é›†æ‡‰è©²å°±å°äº†ï¼\nå¯¦ä½œéƒ¨åˆ†é€™å€‹ç‰ˆæœ¬æ˜¯ç”¨structå¯¦ä½œï¼Œæ¯”èµ·ç”¨é™£åˆ—å¯¦ä½œï¼Œé€™å€‹ç‰ˆæœ¬æ›´ç‚ºæ–¹ä¾¿é–±è®€ï¼Œå®¹æ˜“ç†è§£ã€‚ç‚ºäº†æ–¹ä¾¿ç´¢å¼•å€¼æŸ¥è©¢å·¦å³å­æ¨¹ï¼Œä½¿ç”¨1-baseä¾†å„²å­˜ç·šæ®µæ¨¹ï¼ŒåŒæ™‚åˆ©ç”¨ä¸€å€‹structå„²å­˜æ¯ä¸€å€‹ç¯€é»ã€‚åŒæ™‚ï¼Œæ¯ä¸€å€‹å€é–“æ¡ç”¨çš„æ˜¯å·¦é–‰å³é–‹ $[l,r)$ï¼Œå€é–“å’Œçš„å¯¦ä½œå¦‚ä¸‹ï¼š\nstruct Node&#123;            //ç·šæ®µæ¨¹æ¯ä¸€å€‹ç¯€é»    int val=0,tag=0,sz; //valåŸæœ¬çš„å€¼ã€tagæ‡¶æ¨™ã€szå€é–“å¤§å°    int rv()&#123;           //å›å‚³å¯¦éš›ç¯€é»çš„å€¼        return val+tag*sz;    &#125;&#125;seg[4*N];\nå»ºç«‹(Build)åˆ†åˆ¥éè¿´å»ºç«‹å·¦å³å­æ¨¹ï¼ŒåŒæ™‚æ›´æ–°æ¯ä¸€å€‹ç¯€é»çš„å¤§å°szã€‚å› ç‚ºæ˜¯å·¦é–‰å³é–‹ï¼Œç›´æ¥å·¦å³ç›¸æ¸›r-lå³å¯å®Œæˆæ›´æ–°ã€‚\nvoid build(int l,int r,int cur)&#123;    //å»ºç«‹ç·šæ®µæ¨¹    seg[cur].sz = r-l;              //æ›´æ–°ç¯€é»çš„å¤§å°    if(r&lt;=l)return;                 //ç©ºå€é–“å›å‚³    if(r-l==1)&#123;                     //è¨­å®šç•¶å‰ç¯€é»çš„å€¼        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //åˆ†åˆ¥éè¿´å»ºç«‹å·¦å³å­æ¨¹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = seg[2*cur].val+seg[2*cur+1].val;&#125;\nä¸‹æ¨(push)æ‡¶æ¨™çœŸæ˜¯é©šäººçš„æƒ³æ³•ï¼Œåœ¨å€é–“ä¿®æ”¹çš„æ™‚å€™ä»¥$O(logn)$åœ¨è¦ä¿®æ”¹çš„å€é–“å…ˆæ‡¶æ¨™æ¨™è¨˜èµ·ä¾†ï¼Œç­‰åˆ°è¦queryçš„æ™‚å€™æŠŠæ‡¶æ¨™æ¨ä¸‹å»ï¼Œé€™æ¨£å¯ä»¥ç¢ºä¿å€é–“ä¿®æ”¹çš„è¤‡é›œåº¦æ˜¯$O(logn)$ï¼ŒåŒæ™‚queryçš„æ™‚å€™é †ä¾¿ä¸‹æ¨ï¼Œä¸€ä¾†æ¯”è¼ƒå¥½å¯¦ä½œã€äºŒä¾†è¤‡é›œåº¦ä¹Ÿä¸æœƒæœ‰ä»€éº¼æ”¹è®Šï¼Œ å› ç‚ºä¸‹æ¨çš„è¤‡é›œåº¦æ˜¯$O(1)$ã€‚\n//æŠŠidçš„æ‡¶æ¨™åœ¨queryçš„æ™‚å€™å¾€ä¸‹æ¨void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //å·¦å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[2*id+1].tag += seg[id].tag; //å³å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[id].val = seg[id].rv();     //æ›´æ–°å¯¦éš›å€¼    seg[id].tag = 0;                //å¾€ä¸‹æ¨å®Œä¹‹å¾Œè¨­å®šç‚ºé è¨­&#125;\nå€é–“è©¢å•(query)é€™è£¡çš„é‡é»æ˜¯ä¸‹æ¨ï¼Œå¦‚æœæŠŠæ‡¶æ¨™ä¸‹æ¨ï¼Œå¯ä»¥ç¢ºä¿å€é–“ä¿®æ”¹çš„æ™‚é–“æ˜¯$O(logn)$\n//å€é–“è©¢å•int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return 0;         //ç©ºé›†åˆç›´æ¥å›å‚³    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //åŒ…å«åœ¨è¦è©¢å•çš„ç¯„åœä¸­ï¼Œå›å‚³å¯¦éš›å€¼    push(cur);                                  //å°‡æ‡¶æ¨™åœ¨éè¿´ä¸‹å»çš„éç¨‹ä¸­ä¸‹æ¨    int mid = (l+r)/2;                          //éè¿´æŸ¥è©¢å·¦å³å­æ¨¹    return query(cur*2,l,mid,ql,qr)+query(cur*2+1,mid,r,ql,qr);&#125;\nå€é»ä¿®æ”¹(modify)å¯ä»¥é€™æ¨£ç†è§£ï¼Œåœ¨å€é–“ä¿®æ”¹ä¸­ï¼Œé€ééè¿´å®Œå·¦å³å­æ¨¹æ‹‰ä¸Šä¾†çš„éç¨‹ä¸­ï¼Œæ›´æ–°æ¨¹ä¸Šè¼ƒä¸Šæ–¹çš„ç¯€é»çš„å€¼ï¼ˆç”¨æ‡¶æ¨™æ›´æ–°ï¼‰ã€‚æ­¤æ™‚ä¸‹æ–¹ç¯€é»éƒ½é‚„æ²’æœ‰è¢«æ›´æ–°ï¼Œç­‰åˆ°queryçš„æ™‚å€™æœƒå¾€ä¸‹pushé †ä¾¿æŠŠå€¼ä¹Ÿä¸€èµ·æ›´æ–°ã€‚\n//å€é–“ä¿®æ”¹void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //å°‡è¢«å®Œæ•´åŒ…å«çš„å€é–“çš„æ‡¶æ¨™åŠ ä¸Šä¿®æ”¹å€¼        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //ä¿®æ”¹å·¦å³å­æ¨¹    modify(cur*2+1,mid,r,ql,qr,val);        //éè¿´å®Œæ‹‰ä¸Šä¾†çš„éç¨‹ä¸­æŠŠä¸Šé¢çš„æ•¸å€¼æ›´æ–°æˆæœ‰æ‡¶æ¨™çš„çµæœ    seg[cur].val = seg[2*cur].rv()+seg[2*cur+1].rv();&#125;\nå–®é»ä¿®æ”¹(modify)é€™ä¸€é¡Œæ²’æœ‰è¦æ±‚å–®é»ä¿®æ”¹ï¼Œæ‰€ä»¥ä»¥ä¸‹æ˜¯RMQçš„å–®é»ä¿®æ”¹ã€‚æ¦‚å¿µè¼ƒç‚ºç°¡å–®ï¼Œç”¨$O(logn)$æ‰¾åˆ°è¦ä¿®æ”¹çš„é»ï¼Œç›´æ¥ä¿®æ”¹å³å¯ã€‚\nvoid modify(int cur,int l,int r,int ind,int val)&#123;    if(r&lt;=l)return;    if(r-l==1 &amp;&amp; l==ind)&#123;        seg[cur]=val;        return;    &#125;    int mid = (l+r)/2;    if(ind&lt;mid)modify(cur*2,l,mid,ind,val);    else modify(cur*2+1,mid,r,ind,val);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;\nå‹•æ…‹é–‹é»\næœ‰ä¸€å€‹é•·åº¦æ˜¯ $10^9$ çš„åºåˆ—ï¼Œä¸€é–‹å§‹è£¡é¢çš„å…ƒç´ éƒ½æ˜¯$0$ï¼Œæœ‰ $Q$ ç­†æ“ä½œï¼Œæ¯ä¸€å€‹æ“ä½œæ˜¯ä»¥ä¸‹å…¶ä¸­å…©ç¨®ï¼š\n\næŠŠä¹‹é–“çš„å€¼éƒ½åŠ ä¸Š$v$\nè©¢å•çš„å€é–“å’Œ\n\n\né–‹é€™éº¼å¤šé»é¡¯ç„¶æœƒMLEï¼Œæ—¢ç„¶ä½¿ç”¨é™£åˆ—å‹å„²å­˜ç·šæ®µæ¨¹æœƒçˆ†ï¼Œå› ç‚ºé€™éº¼å¤§çš„å€¼åŸŸé¡¯ç„¶æœ‰è¨±å¤šé»æ˜¯ä¸æœƒè¢«ä½¿ç”¨åˆ°çš„ï¼Œé‚£å°±æ”¹æˆä½¿ç”¨æŒ‡æ¨™å‹ä¾†é–‹é€™å€‹ç·šæ®µæ¨¹ï¼Œä»¥ä¸‹ç‚ºæ¯ä¸€å€‹ç¯€é»çš„æ¶æ§‹ï¼š\nstruct Node&#123;    Node *l;    //æŒ‡å‘å·¦å­æ¨¹    Node *r;    //æŒ‡å‘å³å­æ¨¹    int val;    //ç¶­è­·å€é–“å’Œ    &#125;;//æ³¨æ„structè£¡é¢å¯æœ‰structçš„æŒ‡æ¨™ï¼Œä½†ä¸èƒ½æœ‰å¯¦é«”\n","categories":["C++é€²éšä¸»é¡Œ","ç·šæ®µæ¨¹"],"tags":["2021æš‘å‡ç­†è¨˜","2020è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 249 æœ€å¤§é€£çºŒå’Œï¼Ÿ","url":"/seg2-2/","content":"æœ€å¤§é€£çºŒå’Œï¼Ÿ\né¡Œç›®é€£çµé€™é¡Œé¡Œçµæœæˆ‘æ˜¯WAåœ¨INFå¤ªå¤§å¯èƒ½æœƒæº¢ä½çš„å•é¡Œï¼ŒæŠŠINFèª¿æ•´æˆ $5\\times 10^{14}$ æ˜¯å·®ä¸å¤šçš„\né€™ä¸€é¡Œè¦ç¶­è­·å€é–“æœ€å¤§é€£çºŒå’Œï¼Œè·Ÿdpçš„æœ€å¤§é€£çºŒå’Œå·®äº†ã€Œå€é–“ã€å…©å­—ï¼Œæ•´å€‹å¯¦ä½œçš„æ–¹å¼è·Ÿè¤‡é›œåº¦å°±ä¸ä¸€æ¨£äº†ã€‚DPçš„ä½œæ³•å¦‚æœç›´æ¥å¥—ç”¨åœ¨é€™ä¸€é¡Œçš„è©±ï¼Œè¤‡é›œåº¦ç´„ç‚ºï¼š$O(QN)$ï¼Œçµ•å°æœƒç‚¸è£‚ï¼Œå› æ­¤åªèƒ½ç”¨ç·šæ®µæ¨¹ç¶­è­·é€™å€‹æ±è¥¿ã€‚\n\n            å€é–“æœ€å¤§é€£çºŒå’Œåœ¨åˆ†æ²»æ³•çš„å–®å…ƒæœ‰æåˆ°åˆ†æ²»æ³•æœ€é‡è¦çš„æ˜¯å‡å®šå·¦å³å…©å´ï¼ˆå°æ‡‰éä¾†å°±æ˜¯å…©å­æ¨¹ï¼‰æ˜¯ç¶­è­·å¥½çš„ï¼Œä¹Ÿå°±æ˜¯ç¬¦åˆå®šç¾©ï¼Œè¦æƒ³çš„æ˜¯è¦å¦‚ä½•è™•ç†æ©«è·¨å·¦å³å­æ¨¹çš„æƒ…æ³ã€‚è¦å¦‚ä½•çŸ¥é“æ©«è·¨ä¸­é–“çš„æœ€å¤§å€¼å‘¢ï¼Ÿé€™æ™‚å€™æˆ‘å€‘å¯ä»¥ç¶­è­·4å€‹æ•¸å€¼ï¼Œä¾†æ›´æ–°æ¯ä¸€å€‹ç·šæ®µæ¨¹ä¸Šçš„ç¯€é»çš„æ•¸å€¼ã€‚ç¸½å’Œ(sum)$cur.sum = left.sum+right.sum$æœ€å¤§å‰ç¶´å’Œ(lmax)$cur.lmax = max(left.lmax,left.sum+right.lmax)$æœ€å¤§å¾Œç¶´å’Œ(rmax)$cur.rmax = max(right.rmax,right.sum+left.rmax)$å€é–“æœ€å¤§é€£çºŒå’Œ(tmax)$cur.tmax = max(left.tmax,right.tmax,left.rmax+right.lmax)$\n          \nç¶­è­·æœ€å¤§å¾Œç¶´è·Ÿæœ€å¤§å‰ç¶´å’Œï¼ˆé¦–è·Ÿæœ«æœ‰è¢«å–åˆ°çš„æƒ…æ³ï¼‰ï¼Œå°±å¯ä»¥$O(1)$ ç¶­è­·æ¯ä¸€å€‹ç¯€é»çš„å€é–“æœ€å¤§é€£çºŒå’Œï¼Œè¤‡é›œåº¦ï¼šè©¢å•$O(logn)$ï¼Œå› æ­¤ç¸½æ™‚é–“$O(Qlogn)$å°±å¯ä»¥ACäº†!\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 100005#define INF 500000000000000using namespace std;int arr[N],n,m;struct Node&#123;    int sum;    //å€é–“ç¸½å’Œ    int lmax;   //æœ€å¤§å‰ç¶´å’Œ    int rmax;   //æœ€å¤§å¾Œç¶´å’Œ    int tmax;   //å€é–“é€£çºŒæœ€å¤§å’Œ&#125;seg[N&lt;&lt;2];//æ±‚ç•¶ä¸‹çš„å€é–“é€£çºŒæœ€å¤§å’Œvoid modify(Node &amp;cur,Node &amp;left,Node &amp;right)&#123;    cur.sum = left.sum+right.sum;    cur.lmax = max(left.lmax,left.sum+right.lmax);    cur.rmax = max(right.rmax,right.sum+left.rmax);    cur.tmax = max(max(left.tmax,right.tmax),left.rmax+right.lmax);&#125;//å»ºç«‹ç·šæ®µæ¨¹ï¼š[l,r)void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = &#123;arr[l],arr[l],arr[l],arr[l]&#125;;        return;    &#125;    int mid = (l+r)/2;    build(l,mid,2*cur);    build(mid,r,2*cur+1);    modify(seg[cur],seg[2*cur],seg[2*cur+1]);&#125;//å€é–“è©¢å•ï¼š[l,r)Node query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return &#123;-INF,-INF,-INF,-INF&#125;;    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur];    int mid = (l+r)/2;    auto left = query(2*cur,l,mid,ql,qr);    auto right = query(2*cur+1,mid,r,ql,qr);    Node temp;    modify(temp,left,right);    return temp;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int l,r;cin&gt;&gt;l&gt;&gt;r;        auto ans = query(1,1,n+1,l,r+1);        cout&lt;&lt;max(ans.tmax,(long long)0)&lt;&lt;endl;    &#125;&#125;\n","categories":["ç·šæ®µæ¨¹é¡Œè§£"],"tags":["é¡Œè§£","ç·šæ®µæ¨¹"]},{"title":"[é¡Œè§£]NEOJ 80 RMQç·´ç¿’","url":"/seg2-1/","content":"RMQç·´ç¿’\né¡Œç›®é€£çµRMQ = Range minimun queryï¼Œä¹Ÿå°±æ˜¯è©¢å•ä¸€å€‹å€é–“çš„æœ€å°å€¼ã€‚åˆ†æä¸€ä¸‹å…©ç¨®ä¸åŒä½œæ³•çš„è¤‡é›œåº¦ï¼š\n            å°æ–¼æ•¸åˆ— $a_n$ å…±né …ï¼Œkç­†è©¢å•ï¼Œæ¯ä¸€æ¬¡è©¢å•å€é–“$[l,r]$çš„æœ€å¤§ã€æœ€å°å€¼1. æš´åŠ›åšæ™‚é–“è¤‡é›œåº¦ï¼šè©¢å•$O(n)$å°æ–¼æ¯ä¸€ç­†è©¢å•éƒ½æš´åŠ›æœç´¢ï¼Œæœ€å¤šæƒénå€‹æ•¸å­—ï¼Œæ™‚é–“è¤‡é›œåº¦$O(kn)$ï¼Œå°æ–¼æ•¸å­—å¤§ä¸€é»çš„æƒ…æ³å°±æœƒTLE2. åˆ†å¡Šç®—æ³•å¯ä»¥åƒè¦‹ é€™ç¯‡æ–‡ç« 3. ç·šæ®µæ¨¹æ™‚é–“è¤‡é›œåº¦ï¼šé è™•ç† $O(n)$ã€è©¢å•$O(logn)$é¦–å…ˆæ˜¯é è™•ç†å»ºç«‹ç·šæ®µæ¨¹ï¼Œç·šæ®µæ¨¹ä¸Šç´„æœ‰$2n$å€‹ç¯€é»ï¼Œå› æ­¤ç©ºé–“è¤‡é›œåº¦æ˜¯$O(n)$ï¼Œä¹Ÿå°±è¡¨ç¤ºé è™•ç†æ˜¯$O(n)$ï¼Œä¹‹å¾Œä¾¿å¯$O(logn)$æŸ¥è©¢æ¯ä¸€ç­†è©¢å•ã€‚ä»¥ä¸‹æ˜¯å„ç¨®æ“ä½œè¤‡é›œåº¦ï¼šåˆå§‹å»ºæ§‹ï¼šæ‰€æœ‰ç¯€é»æ°æœƒå»ºæ§‹ä¸€æ¬¡ï¼Œæ¯å€‹ç¯€é» $O(1)$ï¼Œé…åˆç¯€é»æ¨¹å¯å¾—ç‚º $O(ğ‘›)$å–®é»ä¿®æ”¹ï¼šè©²é»çš„æ‰€æœ‰ç¥–å…ˆç¯€é»éƒ½æœƒè¢«ä¿®æ”¹åˆ°ï¼Œå…¶ä»–éƒ½ä¸æœƒè¢«ä¿®æ”¹åˆ°ï¼Œ$ğ‘‚(logn)$å€é–“æŸ¥è©¢ï¼šæ¯ç­†è©¢å•æœ€å¤šè©¢å•åˆ°æ·±åº¦ç‚º $O(logn)$ çš„ç¯€é»ã€‚åœ¨ä¸€æ¬¡è©¢å•ä¸­ï¼Œæ¯ä¸€å±¤ä¸æœƒæœ‰è¶…é2å€‹ç¯€é»è¢«è©¢å•ï¼Œç¸½è¤‡é›œåº¦ç‚º$ğ‘‚(logğ‘›)$4. ç¨€ç–è¡¨(Sparse Table)æ™‚é–“è¤‡é›œåº¦ï¼šé è™•ç† $O(nlogn)$ã€è©¢å•$O(1)$åƒè€ƒ é€™ç¯‡æ–‡ç« \n          \né€™ä¸€é¡Œå°±æ˜¯åŸºç¤çš„è¦æœ‰æ”¯æ´å€é–“æŸ¥è©¢ã€å–®é»ä¿®æ”¹çš„ç·šæ®µæ¨¹ï¼Œä¹Ÿæ˜¯æœ€ç°¡å–®çš„ä¸€ç¨®ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 1000000#define INF 1e9using namespace std;int seg[4 * N],arr[N],n,m;void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = arr[l];        return;    &#125;    int m = (l+r)/2;    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//å–®é»ä¿®æ”¹void modify(int cur,int l,int r,int ind,int val)&#123;    if(r&lt;=l)return;    if(r-l==1 &amp;&amp; l==ind)&#123;        seg[cur]=val;        return;    &#125;    int mid = (l+r)/2;    if(ind&lt;mid)modify(cur*2,l,mid,ind,val);    else modify(cur*2+1,mid,r,ind,val);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//å€é–“è©¢å•int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return INF;    if(ql&lt;=l &amp;&amp; qr&gt;=r)&#123;        return seg[cur];    &#125;    int mid = (l+r)/2;    return min(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;int main()&#123;    ios;    cin&gt;&gt;m&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            modify(1,1,n+1,x+1,y);        &#125;        else if(p==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x+1,y+2);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["ç·šæ®µæ¨¹é¡Œè§£"],"tags":["é¡Œè§£","ç·šæ®µæ¨¹"]},{"title":"[é¡Œè§£]ZJ d799 å€é–“æ±‚å’Œ","url":"/seg2-3/","content":"d799å€é–“æ±‚å’Œ\né¡Œç›®é€£çµé€™ä¸€é¡Œè¦æ±‚å…©å€‹æ“ä½œï¼Œå€é–“åŠ å€¼è·Ÿå€é–“æŸ¥è©¢ï¼Œé€™æ™‚å€™å°±å¿…é ˆç”¨åˆ°æ‡¶æ¨™(lazy tags) è¼”åŠ©æ±‚å’Œã€‚\n\nç¯„ä¾‹æ¸¬è³‡ï¼š101 2 3 4 5 6 7 8 9 1032 2 41 3 6 32 2 4\n\nå·¦é‚Šæ˜¯æ•´æ£µç·šæ®µæ¨¹ï¼Œå³é‚Šå‰‡æ˜¯æ‡¶æ¨™ï¼Œå¯ä»¥çœ‹åˆ°3è¦å¾€ä¸‹æ¨ï¼Œä½†å­¸é•·çš„ç¨‹å¼ç¢¼ä¸­ä¸¦æ²’æœ‰åŸ·è¡Œé€™å€‹æ­¥é©Ÿï¼Œé€™æ¨£æœƒå°è‡´queryçš„æ™‚å€™ç™¼ç”ŸéŒ¯èª¤ã€‚\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500005#define int long longusing namespace std;struct Node&#123;            //ç·šæ®µæ¨¹æ¯ä¸€å€‹ç¯€é»    int val=0,tag=0,sz; //valåŸæœ¬çš„å€¼ã€tagæ‡¶æ¨™ã€szå€é–“å¤§å°    int rv()&#123;           //å›å‚³å¯¦éš›ç¯€é»çš„å€¼        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //å»ºç«‹ç·šæ®µæ¨¹    seg[cur].sz = r-l;              //æ›´æ–°ç¯€é»çš„å¤§å°    if(r&lt;=l)return;                 //ç©ºå€é–“å›å‚³    if(r-l==1)&#123;                     //è¨­å®šç•¶å‰ç¯€é»çš„å€¼        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //åˆ†åˆ¥éè¿´å»ºç«‹å·¦å³å­æ¨¹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = seg[2*cur].val+seg[2*cur+1].val;&#125;//æŠŠidçš„æ‡¶æ¨™åœ¨queryçš„æ™‚å€™å¾€ä¸‹æ¨void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //å·¦å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[2*id+1].tag += seg[id].tag; //å³å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[id].val = seg[id].rv();     //æ›´æ–°å¯¦éš›å€¼    seg[id].tag = 0;                //å¾€ä¸‹æ¨å®Œä¹‹å¾Œè¨­å®šç‚ºé è¨­&#125;//å€é–“ä¿®æ”¹void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //å°‡è¢«å®Œæ•´åŒ…å«çš„å€é–“çš„æ‡¶æ¨™åŠ ä¸Šä¿®æ”¹å€¼        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //ä¿®æ”¹å·¦å³å­æ¨¹    modify(cur*2+1,mid,r,ql,qr,val);        //éè¿´å®Œæ‹‰ä¸Šä¾†çš„éç¨‹ä¸­æŠŠä¸Šé¢çš„æ•¸å€¼æ›´æ–°æˆæœ‰æ‡¶æ¨™    seg[cur].val = seg[2*cur].rv()+seg[2*cur+1].rv();&#125;//å€é–“è©¢å•int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return 0;         //ç©ºé›†åˆç›´æ¥å›å‚³    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //åŒ…å«åœ¨è¦è©¢å•çš„ç¯„åœä¸­ï¼Œå›å‚³å¯¦éš›å€¼    push(cur);                                  //å°‡æ‡¶æ¨™åœ¨éè¿´ä¸‹å»çš„éç¨‹ä¸­ä¸‹æ¨    int mid = (l+r)/2;                          //éè¿´æŸ¥è©¢å·¦å³å­æ¨¹    return query(cur*2,l,mid,ql,qr)+query(cur*2+1,mid,r,ql,qr);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);    cin&gt;&gt;m;        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["ç·šæ®µæ¨¹é¡Œè§£"],"tags":["é¡Œè§£","ç·šæ®µæ¨¹"]},{"title":"[é¡Œè§£]NEOJ 367 RMQË™æ”¹","url":"/seg2-4/","content":"RMQË™æ”¹\né¡Œç›®é€£çµé€™ä¸€é¡Œæ˜¯Range Maximum Queryæ­é…å€é–“åŠ å€¼ï¼Œå¦‚æœç›´æ¥å¥—ç”¨å‰é¢RMQæˆ–æ˜¯å€é–“å’Œçš„æ¨¡æ¿å°±è¼•é¬†è¨±å¤šã€‚é€™ä¸€é¡Œä¸»è¦è·Ÿå‰é¢é¡Œç›®çš„ä¸åŒåœ¨æ–¼å®ƒçš„szè¦ç¶­è­·æˆ1ï¼Œæœ‰åˆ¥æ–¼æ±‚å€é–“å’Œè¦ä¹˜ä¸Šå€é–“å¤§å°ï¼Œæ¯ä¸€å€‹å€¼ä¸éœ€è¦ä¹˜ä¸Šå€é–“å¤§å°ï¼Œå› æ­¤è¨­æˆ0ã€‚\né€™é¡Œç¬¬äºŒç­†æ¸¬è³‡æ˜é¡¯å°±æ˜¯è¦å¡æš´åŠ›è§£æ³•ã€‚\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define int long longusing namespace std;const int INF = 1e14;struct Node&#123;            //ç·šæ®µæ¨¹æ¯ä¸€å€‹ç¯€é»    int val=0,tag=0,sz=0; //valåŸæœ¬çš„å€¼ã€tagæ‡¶æ¨™ã€szå€é–“å¤§å°    int rv()&#123;           //å›å‚³å¯¦éš›ç¯€é»çš„å€¼        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //å»ºç«‹ç·šæ®µæ¨¹    seg[cur].sz = 1;                //æ›´æ–°ç¯€é»çš„å¤§å°    if(r&lt;=l)return;                 //ç©ºå€é–“å›å‚³    if(r-l==1)&#123;                     //è¨­å®šç•¶å‰ç¯€é»çš„å€¼        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //åˆ†åˆ¥éè¿´å»ºç«‹å·¦å³å­æ¨¹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = max(seg[2*cur].val,seg[2*cur+1].val);&#125;//æŠŠidçš„æ‡¶æ¨™åœ¨queryçš„æ™‚å€™å¾€ä¸‹æ¨void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //å·¦å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[2*id+1].tag += seg[id].tag; //å³å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[id].val = seg[id].rv();     //æ›´æ–°å¯¦éš›å€¼    seg[id].tag = 0;                //å¾€ä¸‹æ¨å®Œä¹‹å¾Œè¨­å®šç‚ºé è¨­&#125;//å€é–“ä¿®æ”¹void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //å°‡è¢«å®Œæ•´åŒ…å«çš„å€é–“çš„æ‡¶æ¨™åŠ ä¸Šä¿®æ”¹å€¼        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //ä¿®æ”¹å·¦å³å­æ¨¹    modify(cur*2+1,mid,r,ql,qr,val);        //éè¿´å®Œæ‹‰ä¸Šä¾†çš„éç¨‹ä¸­æŠŠä¸Šé¢çš„æ•¸å€¼æ›´æ–°æˆæœ‰æ‡¶æ¨™    seg[cur].val = max(seg[2*cur].rv(),seg[2*cur+1].rv());&#125;//å€é–“è©¢å•int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return -INF;      //ç©ºé›†åˆç›´æ¥å›å‚³    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //åŒ…å«åœ¨è¦è©¢å•çš„ç¯„åœä¸­ï¼Œå›å‚³å¯¦éš›å€¼    push(cur);                                  //å°‡æ‡¶æ¨™åœ¨éè¿´ä¸‹å»çš„éç¨‹ä¸­ä¸‹æ¨    int mid = (l+r)/2;                          //éè¿´æŸ¥è©¢å·¦å³å­æ¨¹    return max(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["ç·šæ®µæ¨¹é¡Œè§£"],"tags":["é¡Œè§£","ç·šæ®µæ¨¹"]},{"title":"[é¡Œè§£]TIOJ 1224 çŸ©å½¢è¦†è“‹é¢ç©è¨ˆç®—","url":"/seg2-5/","content":"1224 . çŸ©å½¢è¦†è“‹é¢ç©è¨ˆç®—\né¡Œç›®é€£çµSubmission2:AC\n\né¡Œæ„ï¼šçµ¦ä½ å¹³é¢ä¸Šnå€‹çŸ©å½¢ï¼Œè«‹æ±‚å‡ºå®ƒå€‘è¦†è“‹çš„ç¸½è¡¨é¢ç©ã€‚\n\né€™ä¸€é¡Œæ‰€ä½¿ç”¨çš„æŠ€å·§æ˜¯æƒæç·šä»¥åŠç·šæ®µæ¨¹ï¼Œä¸‹åœ–ä¸­çš„æ°´å¹³è—è‰²ç·šå³ç‚ºæƒæç·šï¼Œç”±y=0é–‹å§‹å¾€ä¸Šæƒæï¼Œç•¶é‡åˆ°äº†çŸ©å½¢çš„é‚Šï¼Œåˆ©ç”¨ç·šæ®µæ¨¹æŸ¥è©¢å€é–“å…§ç•¶å‰çš„çŸ©å½¢å¯¬åº¦ï¼Œä¹˜ä¸Šå…©æƒæç·šçš„é«˜åº¦å·®å³ç‚ºé¢ç©ã€‚ç•¶ç„¶ï¼Œæƒæç·šä¹Ÿå¯ä»¥ä½¿ç”¨å‚ç›´æ–¹å‘çš„ç·šæ®µç”±å·¦è€Œå³çš„æƒæï¼Œå¯¦ä½œç´°ç¯€æ˜¯ä¸€æ¨£çš„ã€‚\n\nç·šæ®µæ¨¹ç¶­è­·æ–¹æ³•ä¸€æˆ‘å€‘å¯ä»¥å®šç¾©ç·šæ®µæ¨¹$seg[cur]$ç‚ºå€é–“$[l,r]$ä¸­æœ‰è¢«çŸ©å½¢è¦†è“‹çš„å¤§å°æœ‰å¤šå¤§ï¼Œä¹Ÿå°±æ˜¯åœ–ä¸­ç•¶å‰æƒæç·šå°æ‡‰åˆ°çš„å€åŸŸçš„å¯¬åº¦ã€‚é€™æ¨£å­ç¶­è­·æœ‰ä¸€å€‹å•é¡Œï¼Œç•¶æˆ‘å€‘ç›´æ¥ç”¨$seg[cur]$å„²å­˜ç­”æ¡ˆï¼Œæˆ‘å€‘åœ¨ä¿®æ”¹çš„æ™‚å€™æ²’æœ‰è¾¦æ³•ç¢ºåˆ‡çŸ¥é“é€™æ®µå€é–“è¢«è¦†è“‹çš„æƒ…æ³ã€‚\nä¸‹åœ–ç‚ºä¸€ç¨®æ¨¡æ“¬çš„æƒ…æ³ï¼Œæ¯ä¸€å€‹å€é–“çš„æ•¸å­—ä»£è¡¨è‘—é0çš„æ•¸å­—å€‹æ•¸ï¼Œä¹Ÿå°±æ˜¯å®ƒçš„å¯¬åº¦ã€‚ä»Šå¤©æˆ‘å€‘è¦å°å€é–“$[4,6]$åŠ æ¸›å€¼ï¼Œå°‡å€é–“æ‹†æˆ$[4,4]$è·Ÿ$[5,6]$ï¼Œé€™æ™‚å€™å€é–“$[3,4]$çš„æ•¸å€¼æ˜¯1ï¼Œæˆ‘å€‘å»ä¸çŸ¥é“åˆ°åº•æ˜¯3é‚„æ˜¯4æ˜¯æœ‰è¢«è¦†è“‹åˆ°çš„ï¼Œå¿…é ˆè¦éè¿´ä¸‹å»åˆ°è‘‰ç¯€é»æ‰èƒ½å¾—åˆ°å®Œæ•´çš„è¦†è“‹æƒ…æ³ï¼Œé€™æ™‚å€™æ¯ä¸€æ¬¡åŠ æ¸›å€¼çš„è¤‡é›œå°±æœƒæå‡åˆ°$O(n)$ï¼Œå› æ­¤ä¸èƒ½ä»¥é€™ç¨®æ–¹å¼ç¶­è­·ã€‚\n\næ–¹æ³•äºŒæœ‰åˆ¥æ–¼ç¬¬ä¸€ç¨®æ–¹æ³•å°$seg[id]$é€²è¡Œç¶­è­·ï¼Œæˆ‘å€‘å¯ä»¥å¤šé–‹ä¸€å€‹å€é–“ $tag$ ä¾†ç´€éŒ„è¢«çŸ©å½¢è¦†è“‹çš„æƒ…æ³ã€‚ä¸‹åœ–æœ‰3å€‹çŸ©å½¢ï¼Œå…¶ä¸­çš„æ•¸å­—ä»£è¡¨æ¯ä¸€å¡Šå€åŸŸè¢«è¦†è“‹çš„æƒ…æ³ï¼Œé€™é‚Šä½¿ç”¨äº†$tag$ä¾†ç´€éŒ„ï¼ˆä»–æ˜¯é™„åœ¨å€é–“ä¸Šçš„ï¼Œä¸æœƒåƒåœ–ä¸­ä¸€æ¨£çš„æ–¹å¼å‘ˆç¾ï¼‰ã€‚tagçš„æ•¸å€¼ç‚ºéè² æ•´æ•¸ï¼Œç´€éŒ„ç•¶å‰å€é–“æœ‰å¤šå°‘çŸ©å½¢è¦†è“‹åœ¨ä¸Šé¢ï¼Œç”¨$tag$ä¾†è¼”åŠ©ç¶­è­·$seg[id]$å¯ä»¥åœ¨$O(logn)$çš„æ™‚é–“é€²è¡Œä¿®æ”¹èˆ‡æŸ¥è©¢ã€‚\n\nä»¥ä¸‹ç¨‹å¼ç¢¼æ˜¯æ˜¯ $tag$ çš„è½‰ç§»ï¼Œç•¶å¤§çš„å€é–“çš„tagå€¼ä¸ç‚º0ï¼Œä»£è¡¨æœ‰ä¸€å€‹çŸ©å½¢æ›¾å®Œæ•´è¦†è“‹é€™å€‹å€é–“ï¼Œé€™æ™‚å€™å¯ä»¥ç›´æ¥å›å‚³å€é–“å¤§å°ï¼Œå¦å‰‡å³å›å‚³å·¦å³ç¯€é»çš„$sed[left],seg[right]$çš„æ•¸å€¼ã€‚\né€™é‚Šå®šç¾©$seg[id]$ç‚ºï¼šã€Œè€ƒæ…® id çš„å­å­«å€‘ï¼ˆä¸å« id æœ¬èº«ï¼‰çš„æ‰€æœ‰ tag å€¼ï¼Œå‡è¨­é€™äº›å­å­«åªæœ‰è¢«tagå€¼ä½œç”¨éï¼Œå…±æœ‰å¤šå°‘é0çš„æ•¸å­—ã€ã€‚\nseg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)              +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);\nå¯¦ä½œæ–¹æ³•çŸ©å½¢ç¶­è­·é¦–å…ˆæ˜¯ç¶­è­·çŸ©å½¢çš„æ–¹æ³•ã€‚æˆ‘å€‘ä¸€å€‹çŸ©å½¢ç¸½å…±è¦ç¶­è­·å››å€‹æ±è¥¿ï¼šçŸ©å½¢å·¦ç•Œx1ã€çŸ©å½¢å³ç•Œx2ã€çŸ©å½¢ä¸Šä¸‹ç•Œçš„yåº§æ¨™ï¼ˆåˆ†ä¸Šä¸‹å…©æ¢ï¼‰ï¼Œé€™å…©æ¢é‚Šæ˜¯ä¸‹ç•Œæˆ–æ˜¯ä¸Šç•Œvalã€‚ç‚ºä»€éº¼è¦æ°´å¹³æ–¹å‘è¦åˆ†å…©æ¢è¨è«–ï¼Ÿæ˜¯å› ç‚ºä¸‹ç•Œä»£è¡¨é€²å…¥ï¼Œç•¶æƒæç·šæƒåˆ°é€™ä¸€æ¢é‚Šçš„æ™‚å€™è¡¨ç¤ºæˆ‘å€‘è¦æ–°å¢å€é–“ $[x1,x2)$ é€²å…¥ç·šæ®µæ¨¹ï¼›åä¹‹å¦‚æœæƒåˆ°äº†ä¸Šç•Œï¼Œå‰‡è¡¨ç¤ºé›¢é–‹é€™å€‹çŸ©å½¢ï¼Œåœ¨ç·šæ®µæ¨¹ä¸­æ‰£æ‰å€é–“ $[x1,x2)$ã€‚\nstruct Node&#123;    //æ¯ä¸€å€‹çŸ©é™£åˆ†æˆä¸Šä¸‹å…©æ¢é‚Š    int x1;     //çŸ©å½¢å·¦ç•Œx1    int x2;     //çŸ©å½¢å³ç•Œx2    int y;      //çŸ©å½¢yåº§æ¨™ï¼ˆåˆ†ä¸Šä¸‹å…©é‚Šï¼‰    int val;    //val = Â±1(é€²å…¥ä»£è¡¨1ã€é›¢é–‹ä»£è¡¨-1)    &#125;arr[2*N];\nä¸Šä¸‹ç•Œæˆ‘å€‘åˆ©ç”¨valç¶­è­·ï¼Œç•¶ $val=1$ æ™‚è¡¨ç¤ºæ˜¯çŸ©å½¢çš„ä¸‹ç•Œï¼› $val=-1$ å‰‡æ˜¯çŸ©å½¢ä¸Šç•Œï¼Œé€™å…©å€‹æ­é…åœ¨ä¸€èµ·å‰›å¥½å°±å¯ä»¥ç”¨ç·šæ®µæ¨¹å€é–“åŠ å€¼çš„æ–¹å¼é€²è¡Œæ“ä½œï¼ç¸½å…±æœ‰ $n$ å€‹çŸ©å½¢ï¼Œå› æ­¤æˆ‘å€‘è¦æƒæç·šç¸½å…±æƒæ $2n$ æ¢ç·šæ®µã€‚\nç·šæ®µæ¨¹ä¸€æ¨£å°å€¼åŸŸï¼ˆé€™é¡Œæ˜¯1000000ï¼‰çš„4å€é–‹äº†ç·šæ®µæ¨¹ï¼ŒåŒæ™‚ç¶­è­·ä¸€å€‹éè² æ•´æ•¸ $tag$ è¡¨ç¤ºå€é–“è¢«è¦†è“‹çš„æƒ…æ³ã€‚ç•¶æ¯ä¸€æ¬¡ä¿®æ”¹å®Œæˆä¹‹å¾Œï¼Œæˆ‘å€‘å¯ä»¥ç›´æ¥å–ç”¨æ ¹ç¯€é» $seg[1]$ çš„æ•¸å€¼è¡¨ç¤ºå¯¬åº¦ï¼ˆé0çš„å€‹æ•¸ï¼‰ï¼\n//seg[i]è¡¨ç¤ºiçš„å·¦å³å…©å­æ¨¹çš„å€é–“é0çš„å€‹æ•¸struct node&#123;    //å»ºç«‹ç·šæ®µæ¨¹    int val;    //ç¶­è­·é0å€‹æ•¸    int tag;    //ä½¿ç”¨tagç´€éŒ„å€é–“è¢«è¦†è“‹æ¬¡æ•¸&#125;seg[4*M];\næ¥ä¸‹ä¾†å°±æ˜¯åœ¨ç¨‹å¼åŸ·è¡Œçš„éç¨‹ä¸­å°‡ $2n$ æ¢é‚Šä¾ç…§yåº§æ¨™é€²è¡Œæ’åº $O(nlogn)$ï¼Œæ¥è‘—ä¾åºä½¿ç”¨æƒæç·šæ­é…ç·šæ®µæ¨¹çš„ä¿®æ”¹ï¼Œè¨ˆç®—çŸ©å½¢çš„é¢ç©ã€‚æœ€å¾Œå°±æ˜¯è¼¸å‡ºåŠ èµ·ä¾†çš„ç­”æ¡ˆã€‚\n\n            Debug å°éŒ¯èª¤Submission1:WAå¯ä»¥çœ‹åˆ°æœ‰ä¸€ç­†æ¸¬è³‡éä¸äº†ï¼Œ95åˆ†QQQå¾Œä¾†debugä¹‹å¾Œç™¼ç¾åˆ°ï¼Œå› ç‚ºæˆ‘æ˜¯å°æ¯ä¸€å€‹çŸ©å½¢å…ˆè¼¸å…¥ä¸‹ç•Œä¹‹å¾Œæ‰æ˜¯ä¸Šç•Œï¼Œç•¶æˆ‘åœ¨æ’åºçš„éç¨‹ä¸­ï¼Œä¸Šç•Œæœ‰å¯èƒ½æœ‰æ©Ÿæœƒè·‘åˆ°ä¸‹ç•Œä¹‹å‰ï¼Œé€ æˆ $tag$ è¢«æ‰£åˆ°è² çš„æƒ…æ³ï¼Œä½†åœ¨å®šç¾©ä¸­å¯ä»¥æ¸…æ¥šçŸ¥é“ $tag$ æ˜¯éè² æ•´æ•¸é€ æˆéŒ¯èª¤ã€‚å› æ­¤åªè¦æŠŠæ’åºçš„éç¨‹æ”¹æˆ stable_sort() å³å¯ï¼stable_sort(arr,arr+(n&lt;&lt;1),cmp);\n          \næœ€å¾Œçµ‚æ–¼æ˜¯ç¨‹å¼ç¢¼çš„éƒ¨åˆ†ï¼Œä»¥ä¸‹ï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define M 1000001#define lld long longusing namespace std;int n;struct Node&#123;    //æ¯ä¸€å€‹çŸ©é™£åˆ†æˆä¸Šä¸‹å…©æ¢é‚Š    int x1;     //çŸ©å½¢å·¦ç•Œx1    int x2;     //çŸ©å½¢å³ç•Œx2    int y;      //çŸ©å½¢yåº§æ¨™ï¼ˆåˆ†ä¸Šä¸‹å…©é‚Šï¼‰    int val;    //val = Â±1(é€²å…¥ä»£è¡¨1ã€é›¢é–‹ä»£è¡¨-1)    &#125;arr[2*N];//seg[i]è¡¨ç¤ºiçš„å·¦å³å…©å­æ¨¹çš„å€é–“é0çš„å€‹æ•¸struct node&#123;    //å»ºç«‹ç·šæ®µæ¨¹    int val;    //ç¶­è­·é0å€‹æ•¸    int tag;    //ä½¿ç”¨tagç´€éŒ„å€é–“è¢«è¦†è“‹æ¬¡æ•¸    &#125;seg[4*M];bool cmp(Node a, Node b)&#123;    return a.y&lt;b.y;&#125;//å°å€é–“[ql,qr)é€²è¡ŒåŠ å€¼valvoid modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[cur].tag += val;        return;    &#125;    int mid = (l+r)/2;    modify(2*cur,l,mid,ql,qr,val);    modify(2*cur+1,mid,r,ql,qr,val);        //å·¦å³ç¯€é»å¦‚æœ‰tagè¡¨ç¤ºè¢«å®Œå…¨è¦†è“‹ï¼Œç›´æ¥åŠ ä¸Šå€é–“å¤§å°ï¼Œå¦å‰‡åŠ ä¸Šseg[å·¦å³å­æ¨¹]    seg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)                  +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);&#125;int main()&#123;    ios;    memset(arr,0,sizeof(arr));    memset(seg,0,sizeof(seg));        cin&gt;&gt;n;                                   //ä¾åºè¼¸å…¥å·¦å³ä¸‹ä¸Šï¼šx1,x2,y1,y2    for(int i=0;i&lt;(n&lt;&lt;1);i+=2)&#123;        int x1,x2,y1,y2;cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;y1&gt;&gt;y2;        arr[i] = (Node)&#123;x1,x2,y1,1&#125;;          //æ’å…¥çŸ©å½¢ä¸‹é‚Šï¼Œå¸¶å…¥val = 1        arr[i+1] = (Node)&#123;x1,x2,y2,-1&#125;;       //ä¸Šé‚Šè¦val = -1    &#125;    stable_sort(arr,arr+(n&lt;&lt;1),cmp);          //ä¾ç…§yåº§æ¨™ç”±å°åˆ°å¤§æ’åº        int y0 = 0,val = 0;                       //æœ‰ä¸‹è€Œä¸Šçš„æšèˆ‰æ‰€æœ‰æ°´å¹³é‚Š    lld ans = 0LL;                            //ä¸Šä¸€æ¢yçš„åº§æ¨™ï¼Œè¨ˆç®—é«˜ï¼Œvalç‚ºçŸ©å½¢çµåˆèµ·ä¾†çš„å¯¬    for(int i=0;i&lt;(n&lt;&lt;1);i++)&#123;                //æšèˆ‰2næ¢yçš„é‚Š        ans += (lld)(arr[i].y-y0)*val;        //è¨ˆç®—é¢ç©ï¼ˆå¯¬*é«˜ï¼‰        modify(1,0,M,arr[i].x1,arr[i].x2,arr[i].val);        y0 = arr[i].y;        val = seg[1].val;                     //ä¿®æ”¹å¾Œï¼ˆä¸‹ä¸€è¼ªï¼‰çš„çŸ©é™£å¯¬åº¦    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;\n","categories":["ç·šæ®µæ¨¹é¡Œè§£"],"tags":["é¡Œè§£","ç·šæ®µæ¨¹"]},{"title":"ç·šæ®µæ¨¹ä¾‹é¡Œï¼ˆSegment Treeï¼‰","url":"/seg2/","content":"é¡Œç›®ç›®éŒ„\nNEOJ 80 RMQç·´ç¿’\nNEOJ 249 æœ€å¤§é€£çºŒå’Œï¼Ÿ\nZJ d799 å€é–“æ±‚å’Œ\nNEOJ 367 RMQË™æ”¹\nTIOJ 1224 çŸ©å½¢è¦†è“‹é¢ç©è¨ˆç®—\n\n\nRMQç·´ç¿’é¡Œç›®é€£çµRMQ = Range minimun queryï¼Œä¹Ÿå°±æ˜¯è©¢å•ä¸€å€‹å€é–“çš„æœ€å°å€¼ã€‚åˆ†æä¸€ä¸‹å…©ç¨®ä¸åŒä½œæ³•çš„è¤‡é›œåº¦ï¼š\n            å°æ–¼æ•¸åˆ— $a_n$ å…±né …ï¼Œkç­†è©¢å•ï¼Œæ¯ä¸€æ¬¡è©¢å•å€é–“$[l,r]$çš„æœ€å¤§ã€æœ€å°å€¼1. æš´åŠ›åšæ™‚é–“è¤‡é›œåº¦ï¼šè©¢å•$O(n)$å°æ–¼æ¯ä¸€ç­†è©¢å•éƒ½æš´åŠ›æœç´¢ï¼Œæœ€å¤šæƒénå€‹æ•¸å­—ï¼Œæ™‚é–“è¤‡é›œåº¦$O(kn)$ï¼Œå°æ–¼æ•¸å­—å¤§ä¸€é»çš„æƒ…æ³å°±æœƒTLE2. åˆ†å¡Šç®—æ³•å¯ä»¥åƒè¦‹ é€™ç¯‡æ–‡ç« 3. ç·šæ®µæ¨¹æ™‚é–“è¤‡é›œåº¦ï¼šé è™•ç† $O(n)$ã€è©¢å•$O(logn)$é¦–å…ˆæ˜¯é è™•ç†å»ºç«‹ç·šæ®µæ¨¹ï¼Œç·šæ®µæ¨¹ä¸Šç´„æœ‰$2n$å€‹ç¯€é»ï¼Œå› æ­¤ç©ºé–“è¤‡é›œåº¦æ˜¯$O(n)$ï¼Œä¹Ÿå°±è¡¨ç¤ºé è™•ç†æ˜¯$O(n)$ï¼Œä¹‹å¾Œä¾¿å¯$O(logn)$æŸ¥è©¢æ¯ä¸€ç­†è©¢å•ã€‚ä»¥ä¸‹æ˜¯å„ç¨®æ“ä½œè¤‡é›œåº¦ï¼šåˆå§‹å»ºæ§‹ï¼šæ‰€æœ‰ç¯€é»æ°æœƒå»ºæ§‹ä¸€æ¬¡ï¼Œæ¯å€‹ç¯€é» $O(1)$ï¼Œé…åˆç¯€é»æ¨¹å¯å¾—ç‚º $O(ğ‘›)$å–®é»ä¿®æ”¹ï¼šè©²é»çš„æ‰€æœ‰ç¥–å…ˆç¯€é»éƒ½æœƒè¢«ä¿®æ”¹åˆ°ï¼Œå…¶ä»–éƒ½ä¸æœƒè¢«ä¿®æ”¹åˆ°ï¼Œ$ğ‘‚(logn)$å€é–“æŸ¥è©¢ï¼šæ¯ç­†è©¢å•æœ€å¤šè©¢å•åˆ°æ·±åº¦ç‚º $O(logn)$ çš„ç¯€é»ã€‚åœ¨ä¸€æ¬¡è©¢å•ä¸­ï¼Œæ¯ä¸€å±¤ä¸æœƒæœ‰è¶…é2å€‹ç¯€é»è¢«è©¢å•ï¼Œç¸½è¤‡é›œåº¦ç‚º$ğ‘‚(logğ‘›)$4. ç¨€ç–è¡¨(Sparse Table)æ™‚é–“è¤‡é›œåº¦ï¼šé è™•ç† $O(nlogn)$ã€è©¢å•$O(1)$åƒè€ƒ é€™ç¯‡æ–‡ç« \n          \né€™ä¸€é¡Œå°±æ˜¯åŸºç¤çš„è¦æœ‰æ”¯æ´å€é–“æŸ¥è©¢ã€å–®é»ä¿®æ”¹çš„ç·šæ®µæ¨¹ï¼Œä¹Ÿæ˜¯æœ€ç°¡å–®çš„ä¸€ç¨®ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 1000000#define INF 1e9using namespace std;int seg[4 * N],arr[N],n,m;void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = arr[l];        return;    &#125;    int m = (l+r)/2;    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//å–®é»ä¿®æ”¹void modify(int cur,int l,int r,int ind,int val)&#123;    if(r&lt;=l)return;    if(r-l==1 &amp;&amp; l==ind)&#123;        seg[cur]=val;        return;    &#125;    int mid = (l+r)/2;    if(ind&lt;mid)modify(cur*2,l,mid,ind,val);    else modify(cur*2+1,mid,r,ind,val);    seg[cur] = min(seg[2*cur],seg[2*cur+1]);&#125;//å€é–“è©¢å•int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return INF;    if(ql&lt;=l &amp;&amp; qr&gt;=r)&#123;        return seg[cur];    &#125;    int mid = (l+r)/2;    return min(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;int main()&#123;    ios;    cin&gt;&gt;m&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            modify(1,1,n+1,x+1,y);        &#125;        else if(p==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x+1,y+2);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\næœ€å¤§é€£çºŒå’Œï¼Ÿé¡Œç›®é€£çµé€™é¡Œé¡Œçµæœæˆ‘æ˜¯WAåœ¨INFå¤ªå¤§å¯èƒ½æœƒæº¢ä½çš„å•é¡Œï¼ŒæŠŠINFèª¿æ•´æˆ $5\\times 10^{14}$ æ˜¯å·®ä¸å¤šçš„\né€™ä¸€é¡Œè¦ç¶­è­·å€é–“æœ€å¤§é€£çºŒå’Œï¼Œè·Ÿdpçš„æœ€å¤§é€£çºŒå’Œå·®äº†ã€Œå€é–“ã€å…©å­—ï¼Œæ•´å€‹å¯¦ä½œçš„æ–¹å¼è·Ÿè¤‡é›œåº¦å°±ä¸ä¸€æ¨£äº†ã€‚DPçš„ä½œæ³•å¦‚æœç›´æ¥å¥—ç”¨åœ¨é€™ä¸€é¡Œçš„è©±ï¼Œè¤‡é›œåº¦ç´„ç‚ºï¼š$O(QN)$ï¼Œçµ•å°æœƒç‚¸è£‚ï¼Œå› æ­¤åªèƒ½ç”¨ç·šæ®µæ¨¹ç¶­è­·é€™å€‹æ±è¥¿ã€‚\n\n            å€é–“æœ€å¤§é€£çºŒå’Œåœ¨åˆ†æ²»æ³•çš„å–®å…ƒæœ‰æåˆ°åˆ†æ²»æ³•æœ€é‡è¦çš„æ˜¯å‡å®šå·¦å³å…©å´ï¼ˆå°æ‡‰éä¾†å°±æ˜¯å…©å­æ¨¹ï¼‰æ˜¯ç¶­è­·å¥½çš„ï¼Œä¹Ÿå°±æ˜¯ç¬¦åˆå®šç¾©ï¼Œè¦æƒ³çš„æ˜¯è¦å¦‚ä½•è™•ç†æ©«è·¨å·¦å³å­æ¨¹çš„æƒ…æ³ã€‚è¦å¦‚ä½•çŸ¥é“æ©«è·¨ä¸­é–“çš„æœ€å¤§å€¼å‘¢ï¼Ÿé€™æ™‚å€™æˆ‘å€‘å¯ä»¥ç¶­è­·4å€‹æ•¸å€¼ï¼Œä¾†æ›´æ–°æ¯ä¸€å€‹ç·šæ®µæ¨¹ä¸Šçš„ç¯€é»çš„æ•¸å€¼ã€‚ç¸½å’Œ(sum)$cur.sum = left.sum+right.sum$æœ€å¤§å‰ç¶´å’Œ(lmax)$cur.lmax = max(left.lmax,left.sum+right.lmax)$æœ€å¤§å¾Œç¶´å’Œ(rmax)$cur.rmax = max(right.rmax,right.sum+left.rmax)$å€é–“æœ€å¤§é€£çºŒå’Œ(tmax)$cur.tmax = max(left.tmax,right.tmax,left.rmax+right.lmax)$\n          \nç¶­è­·æœ€å¤§å¾Œç¶´è·Ÿæœ€å¤§å‰ç¶´å’Œï¼ˆé¦–è·Ÿæœ«æœ‰è¢«å–åˆ°çš„æƒ…æ³ï¼‰ï¼Œå°±å¯ä»¥$O(1)$ ç¶­è­·æ¯ä¸€å€‹ç¯€é»çš„å€é–“æœ€å¤§é€£çºŒå’Œï¼Œè¤‡é›œåº¦ï¼šè©¢å•$O(logn)$ï¼Œå› æ­¤ç¸½æ™‚é–“$O(Qlogn)$å°±å¯ä»¥ACäº†!\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 100005#define INF 500000000000000using namespace std;int arr[N],n,m;struct Node&#123;    int sum;    //å€é–“ç¸½å’Œ    int lmax;   //æœ€å¤§å‰ç¶´å’Œ    int rmax;   //æœ€å¤§å¾Œç¶´å’Œ    int tmax;   //å€é–“é€£çºŒæœ€å¤§å’Œ&#125;seg[N&lt;&lt;2];//æ±‚ç•¶ä¸‹çš„å€é–“é€£çºŒæœ€å¤§å’Œvoid modify(Node &amp;cur,Node &amp;left,Node &amp;right)&#123;    cur.sum = left.sum+right.sum;    cur.lmax = max(left.lmax,left.sum+right.lmax);    cur.rmax = max(right.rmax,right.sum+left.rmax);    cur.tmax = max(max(left.tmax,right.tmax),left.rmax+right.lmax);&#125;//å»ºç«‹ç·šæ®µæ¨¹ï¼š[l,r)void build(int l,int r,int cur)&#123;    if(r&lt;=l)return;    if(r-l==1)&#123;        seg[cur] = &#123;arr[l],arr[l],arr[l],arr[l]&#125;;        return;    &#125;    int mid = (l+r)/2;    build(l,mid,2*cur);    build(mid,r,2*cur+1);    modify(seg[cur],seg[2*cur],seg[2*cur+1]);&#125;//å€é–“è©¢å•ï¼š[l,r)Node query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return &#123;-INF,-INF,-INF,-INF&#125;;    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur];    int mid = (l+r)/2;    auto left = query(2*cur,l,mid,ql,qr);    auto right = query(2*cur+1,mid,r,ql,qr);    Node temp;    modify(temp,left,right);    return temp;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int l,r;cin&gt;&gt;l&gt;&gt;r;        auto ans = query(1,1,n+1,l,r+1);        cout&lt;&lt;max(ans.tmax,(long long)0)&lt;&lt;endl;    &#125;&#125;\nd799å€é–“æ±‚å’Œé¡Œç›®é€£çµé€™ä¸€é¡Œè¦æ±‚å…©å€‹æ“ä½œï¼Œå€é–“åŠ å€¼è·Ÿå€é–“æŸ¥è©¢ï¼Œé€™æ™‚å€™å°±å¿…é ˆç”¨åˆ°æ‡¶æ¨™(lazy tags) è¼”åŠ©æ±‚å’Œã€‚\n\nç¯„ä¾‹æ¸¬è³‡ï¼š101 2 3 4 5 6 7 8 9 1032 2 41 3 6 32 2 4\n\nå·¦é‚Šæ˜¯æ•´æ£µç·šæ®µæ¨¹ï¼Œå³é‚Šå‰‡æ˜¯æ‡¶æ¨™ï¼Œå¯ä»¥çœ‹åˆ°3è¦å¾€ä¸‹æ¨ï¼Œä½†å­¸é•·çš„ç¨‹å¼ç¢¼ä¸­ä¸¦æ²’æœ‰åŸ·è¡Œé€™å€‹æ­¥é©Ÿï¼Œé€™æ¨£æœƒå°è‡´queryçš„æ™‚å€™ç™¼ç”ŸéŒ¯èª¤ã€‚\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500005#define int long longusing namespace std;struct Node&#123;            //ç·šæ®µæ¨¹æ¯ä¸€å€‹ç¯€é»    int val=0,tag=0,sz; //valåŸæœ¬çš„å€¼ã€tagæ‡¶æ¨™ã€szå€é–“å¤§å°    int rv()&#123;           //å›å‚³å¯¦éš›ç¯€é»çš„å€¼        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //å»ºç«‹ç·šæ®µæ¨¹    seg[cur].sz = r-l;              //æ›´æ–°ç¯€é»çš„å¤§å°    if(r&lt;=l)return;                 //ç©ºå€é–“å›å‚³    if(r-l==1)&#123;                     //è¨­å®šç•¶å‰ç¯€é»çš„å€¼        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //åˆ†åˆ¥éè¿´å»ºç«‹å·¦å³å­æ¨¹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = seg[2*cur].val+seg[2*cur+1].val;&#125;//æŠŠidçš„æ‡¶æ¨™åœ¨queryçš„æ™‚å€™å¾€ä¸‹æ¨void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //å·¦å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[2*id+1].tag += seg[id].tag; //å³å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[id].val = seg[id].rv();     //æ›´æ–°å¯¦éš›å€¼    seg[id].tag = 0;                //å¾€ä¸‹æ¨å®Œä¹‹å¾Œè¨­å®šç‚ºé è¨­&#125;//å€é–“ä¿®æ”¹void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //å°‡è¢«å®Œæ•´åŒ…å«çš„å€é–“çš„æ‡¶æ¨™åŠ ä¸Šä¿®æ”¹å€¼        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //ä¿®æ”¹å·¦å³å­æ¨¹    modify(cur*2+1,mid,r,ql,qr,val);        //éè¿´å®Œæ‹‰ä¸Šä¾†çš„éç¨‹ä¸­æŠŠä¸Šé¢çš„æ•¸å€¼æ›´æ–°æˆæœ‰æ‡¶æ¨™    seg[cur].val = seg[2*cur].rv()+seg[2*cur+1].rv();&#125;//å€é–“è©¢å•int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return 0;         //ç©ºé›†åˆç›´æ¥å›å‚³    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //åŒ…å«åœ¨è¦è©¢å•çš„ç¯„åœä¸­ï¼Œå›å‚³å¯¦éš›å€¼    push(cur);                                  //å°‡æ‡¶æ¨™åœ¨éè¿´ä¸‹å»çš„éç¨‹ä¸­ä¸‹æ¨    int mid = (l+r)/2;                          //éè¿´æŸ¥è©¢å·¦å³å­æ¨¹    return query(cur*2,l,mid,ql,qr)+query(cur*2+1,mid,r,ql,qr);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);    cin&gt;&gt;m;        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\nRMQË™æ”¹é¡Œç›®é€£çµé€™ä¸€é¡Œæ˜¯Range Maximum Queryæ­é…å€é–“åŠ å€¼ï¼Œå¦‚æœç›´æ¥å¥—ç”¨å‰é¢RMQæˆ–æ˜¯å€é–“å’Œçš„æ¨¡æ¿å°±è¼•é¬†è¨±å¤šã€‚é€™ä¸€é¡Œä¸»è¦è·Ÿå‰é¢é¡Œç›®çš„ä¸åŒåœ¨æ–¼å®ƒçš„szè¦ç¶­è­·æˆ1ï¼Œæœ‰åˆ¥æ–¼æ±‚å€é–“å’Œè¦ä¹˜ä¸Šå€é–“å¤§å°ï¼Œæ¯ä¸€å€‹å€¼ä¸éœ€è¦ä¹˜ä¸Šå€é–“å¤§å°ï¼Œå› æ­¤è¨­æˆ0ã€‚\né€™é¡Œç¬¬äºŒç­†æ¸¬è³‡æ˜é¡¯å°±æ˜¯è¦å¡æš´åŠ›è§£æ³•ã€‚\n#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define int long longusing namespace std;const int INF = 1e14;struct Node&#123;            //ç·šæ®µæ¨¹æ¯ä¸€å€‹ç¯€é»    int val=0,tag=0,sz=0; //valåŸæœ¬çš„å€¼ã€tagæ‡¶æ¨™ã€szå€é–“å¤§å°    int rv()&#123;           //å›å‚³å¯¦éš›ç¯€é»çš„å€¼        return val+tag*sz;    &#125;&#125;seg[4*N];int arr[N],n,m;void build(int l,int r,int cur)&#123;    //å»ºç«‹ç·šæ®µæ¨¹    seg[cur].sz = 1;                //æ›´æ–°ç¯€é»çš„å¤§å°    if(r&lt;=l)return;                 //ç©ºå€é–“å›å‚³    if(r-l==1)&#123;                     //è¨­å®šç•¶å‰ç¯€é»çš„å€¼        seg[cur].val = arr[l];        return;    &#125;    int m = (l+r)/2;                //åˆ†åˆ¥éè¿´å»ºç«‹å·¦å³å­æ¨¹    build(l,m,2*cur);    build(m,r,2*cur+1);    seg[cur].val = max(seg[2*cur].val,seg[2*cur+1].val);&#125;//æŠŠidçš„æ‡¶æ¨™åœ¨queryçš„æ™‚å€™å¾€ä¸‹æ¨void push(int id)&#123;    seg[2*id].tag += seg[id].tag;   //å·¦å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[2*id+1].tag += seg[id].tag; //å³å­æ¨¹æ‡¶æ¨™æ›´æ–°    seg[id].val = seg[id].rv();     //æ›´æ–°å¯¦éš›å€¼    seg[id].tag = 0;                //å¾€ä¸‹æ¨å®Œä¹‹å¾Œè¨­å®šç‚ºé è¨­&#125;//å€é–“ä¿®æ”¹void modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if (r&lt;=l||ql&gt;=r||qr&lt;=l)return;    if (ql&lt;=l &amp;&amp; qr&gt;=r) &#123;        seg[cur].tag += val;               //å°‡è¢«å®Œæ•´åŒ…å«çš„å€é–“çš„æ‡¶æ¨™åŠ ä¸Šä¿®æ”¹å€¼        return;    &#125;    int mid = (l+r)/2;    modify(cur*2,l,mid,ql,qr,val);          //ä¿®æ”¹å·¦å³å­æ¨¹    modify(cur*2+1,mid,r,ql,qr,val);        //éè¿´å®Œæ‹‰ä¸Šä¾†çš„éç¨‹ä¸­æŠŠä¸Šé¢çš„æ•¸å€¼æ›´æ–°æˆæœ‰æ‡¶æ¨™    seg[cur].val = max(seg[2*cur].rv(),seg[2*cur+1].rv());&#125;//å€é–“è©¢å•int query(int cur,int l,int r,int ql,int qr)&#123;    if(r&lt;=l || ql&gt;=r || qr&lt;=l)return -INF;      //ç©ºé›†åˆç›´æ¥å›å‚³    if(ql&lt;=l &amp;&amp; qr&gt;=r)return seg[cur].rv();     //åŒ…å«åœ¨è¦è©¢å•çš„ç¯„åœä¸­ï¼Œå›å‚³å¯¦éš›å€¼    push(cur);                                  //å°‡æ‡¶æ¨™åœ¨éè¿´ä¸‹å»çš„éç¨‹ä¸­ä¸‹æ¨    int mid = (l+r)/2;                          //éè¿´æŸ¥è©¢å·¦å³å­æ¨¹    return max(query(cur*2,l,mid,ql,qr),query(cur*2+1,mid,r,ql,qr));&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    build(1,n+1,1);        while(m--)&#123;        int p;cin&gt;&gt;p;        if(p==1)&#123;            int x,y,k;cin&gt;&gt;x&gt;&gt;y&gt;&gt;k;            modify(1,1,n+1,x,y+1,k);        &#125;        else if(p==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            int ans = query(1,1,n+1,x,y+1);            cout&lt;&lt;ans&lt;&lt;endl;        &#125;    &#125;&#125;\n1224 . çŸ©å½¢è¦†è“‹é¢ç©è¨ˆç®—é¡Œç›®é€£çµSubmission2:AC\n\né¡Œæ„ï¼šçµ¦ä½ å¹³é¢ä¸Šnå€‹çŸ©å½¢ï¼Œè«‹æ±‚å‡ºå®ƒå€‘è¦†è“‹çš„ç¸½è¡¨é¢ç©ã€‚\n\né€™ä¸€é¡Œæ‰€ä½¿ç”¨çš„æŠ€å·§æ˜¯æƒæç·šä»¥åŠç·šæ®µæ¨¹ï¼Œä¸‹åœ–ä¸­çš„æ°´å¹³è—è‰²ç·šå³ç‚ºæƒæç·šï¼Œç”±y=0é–‹å§‹å¾€ä¸Šæƒæï¼Œç•¶é‡åˆ°äº†çŸ©å½¢çš„é‚Šï¼Œåˆ©ç”¨ç·šæ®µæ¨¹æŸ¥è©¢å€é–“å…§ç•¶å‰çš„çŸ©å½¢å¯¬åº¦ï¼Œä¹˜ä¸Šå…©æƒæç·šçš„é«˜åº¦å·®å³ç‚ºé¢ç©ã€‚ç•¶ç„¶ï¼Œæƒæç·šä¹Ÿå¯ä»¥ä½¿ç”¨å‚ç›´æ–¹å‘çš„ç·šæ®µç”±å·¦è€Œå³çš„æƒæï¼Œå¯¦ä½œç´°ç¯€æ˜¯ä¸€æ¨£çš„ã€‚\n\nç·šæ®µæ¨¹ç¶­è­·æ–¹æ³•ä¸€æˆ‘å€‘å¯ä»¥å®šç¾©ç·šæ®µæ¨¹$seg[cur]$ç‚ºå€é–“$[l,r]$ä¸­æœ‰è¢«çŸ©å½¢è¦†è“‹çš„å¤§å°æœ‰å¤šå¤§ï¼Œä¹Ÿå°±æ˜¯åœ–ä¸­ç•¶å‰æƒæç·šå°æ‡‰åˆ°çš„å€åŸŸçš„å¯¬åº¦ã€‚é€™æ¨£å­ç¶­è­·æœ‰ä¸€å€‹å•é¡Œï¼Œç•¶æˆ‘å€‘ç›´æ¥ç”¨$seg[cur]$å„²å­˜ç­”æ¡ˆï¼Œæˆ‘å€‘åœ¨ä¿®æ”¹çš„æ™‚å€™æ²’æœ‰è¾¦æ³•ç¢ºåˆ‡çŸ¥é“é€™æ®µå€é–“è¢«è¦†è“‹çš„æƒ…æ³ã€‚\nä¸‹åœ–ç‚ºä¸€ç¨®æ¨¡æ“¬çš„æƒ…æ³ï¼Œæ¯ä¸€å€‹å€é–“çš„æ•¸å­—ä»£è¡¨è‘—é0çš„æ•¸å­—å€‹æ•¸ï¼Œä¹Ÿå°±æ˜¯å®ƒçš„å¯¬åº¦ã€‚ä»Šå¤©æˆ‘å€‘è¦å°å€é–“$[4,6]$åŠ æ¸›å€¼ï¼Œå°‡å€é–“æ‹†æˆ$[4,4]$è·Ÿ$[5,6]$ï¼Œé€™æ™‚å€™å€é–“$[3,4]$çš„æ•¸å€¼æ˜¯1ï¼Œæˆ‘å€‘å»ä¸çŸ¥é“åˆ°åº•æ˜¯3é‚„æ˜¯4æ˜¯æœ‰è¢«è¦†è“‹åˆ°çš„ï¼Œå¿…é ˆè¦éè¿´ä¸‹å»åˆ°è‘‰ç¯€é»æ‰èƒ½å¾—åˆ°å®Œæ•´çš„è¦†è“‹æƒ…æ³ï¼Œé€™æ™‚å€™æ¯ä¸€æ¬¡åŠ æ¸›å€¼çš„è¤‡é›œå°±æœƒæå‡åˆ°$O(n)$ï¼Œå› æ­¤ä¸èƒ½ä»¥é€™ç¨®æ–¹å¼ç¶­è­·ã€‚\n\næ–¹æ³•äºŒæœ‰åˆ¥æ–¼ç¬¬ä¸€ç¨®æ–¹æ³•å°$seg[id]$é€²è¡Œç¶­è­·ï¼Œæˆ‘å€‘å¯ä»¥å¤šé–‹ä¸€å€‹å€é–“ $tag$ ä¾†ç´€éŒ„è¢«çŸ©å½¢è¦†è“‹çš„æƒ…æ³ã€‚ä¸‹åœ–æœ‰3å€‹çŸ©å½¢ï¼Œå…¶ä¸­çš„æ•¸å­—ä»£è¡¨æ¯ä¸€å¡Šå€åŸŸè¢«è¦†è“‹çš„æƒ…æ³ï¼Œé€™é‚Šä½¿ç”¨äº†$tag$ä¾†ç´€éŒ„ï¼ˆä»–æ˜¯é™„åœ¨å€é–“ä¸Šçš„ï¼Œä¸æœƒåƒåœ–ä¸­ä¸€æ¨£çš„æ–¹å¼å‘ˆç¾ï¼‰ã€‚tagçš„æ•¸å€¼ç‚ºéè² æ•´æ•¸ï¼Œç´€éŒ„ç•¶å‰å€é–“æœ‰å¤šå°‘çŸ©å½¢è¦†è“‹åœ¨ä¸Šé¢ï¼Œç”¨$tag$ä¾†è¼”åŠ©ç¶­è­·$seg[id]$å¯ä»¥åœ¨$O(logn)$çš„æ™‚é–“é€²è¡Œä¿®æ”¹èˆ‡æŸ¥è©¢ã€‚\n\nä»¥ä¸‹ç¨‹å¼ç¢¼æ˜¯æ˜¯ $tag$ çš„è½‰ç§»ï¼Œç•¶å¤§çš„å€é–“çš„tagå€¼ä¸ç‚º0ï¼Œä»£è¡¨æœ‰ä¸€å€‹çŸ©å½¢æ›¾å®Œæ•´è¦†è“‹é€™å€‹å€é–“ï¼Œé€™æ™‚å€™å¯ä»¥ç›´æ¥å›å‚³å€é–“å¤§å°ï¼Œå¦å‰‡å³å›å‚³å·¦å³ç¯€é»çš„$sed[left],seg[right]$çš„æ•¸å€¼ã€‚\né€™é‚Šå®šç¾©$seg[id]$ç‚ºï¼šã€Œè€ƒæ…® id çš„å­å­«å€‘ï¼ˆä¸å« id æœ¬èº«ï¼‰çš„æ‰€æœ‰ tag å€¼ï¼Œå‡è¨­é€™äº›å­å­«åªæœ‰è¢«tagå€¼ä½œç”¨éï¼Œå…±æœ‰å¤šå°‘é0çš„æ•¸å­—ã€ã€‚\nseg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)              +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);\nå¯¦ä½œæ–¹æ³•çŸ©å½¢ç¶­è­·é¦–å…ˆæ˜¯ç¶­è­·çŸ©å½¢çš„æ–¹æ³•ã€‚æˆ‘å€‘ä¸€å€‹çŸ©å½¢ç¸½å…±è¦ç¶­è­·å››å€‹æ±è¥¿ï¼šçŸ©å½¢å·¦ç•Œx1ã€çŸ©å½¢å³ç•Œx2ã€çŸ©å½¢ä¸Šä¸‹ç•Œçš„yåº§æ¨™ï¼ˆåˆ†ä¸Šä¸‹å…©æ¢ï¼‰ï¼Œé€™å…©æ¢é‚Šæ˜¯ä¸‹ç•Œæˆ–æ˜¯ä¸Šç•Œvalã€‚ç‚ºä»€éº¼è¦æ°´å¹³æ–¹å‘è¦åˆ†å…©æ¢è¨è«–ï¼Ÿæ˜¯å› ç‚ºä¸‹ç•Œä»£è¡¨é€²å…¥ï¼Œç•¶æƒæç·šæƒåˆ°é€™ä¸€æ¢é‚Šçš„æ™‚å€™è¡¨ç¤ºæˆ‘å€‘è¦æ–°å¢å€é–“ $[x1,x2)$ é€²å…¥ç·šæ®µæ¨¹ï¼›åä¹‹å¦‚æœæƒåˆ°äº†ä¸Šç•Œï¼Œå‰‡è¡¨ç¤ºé›¢é–‹é€™å€‹çŸ©å½¢ï¼Œåœ¨ç·šæ®µæ¨¹ä¸­æ‰£æ‰å€é–“ $[x1,x2)$ã€‚\nstruct Node&#123;    //æ¯ä¸€å€‹çŸ©é™£åˆ†æˆä¸Šä¸‹å…©æ¢é‚Š    int x1;     //çŸ©å½¢å·¦ç•Œx1    int x2;     //çŸ©å½¢å³ç•Œx2    int y;      //çŸ©å½¢yåº§æ¨™ï¼ˆåˆ†ä¸Šä¸‹å…©é‚Šï¼‰    int val;    //val = Â±1(é€²å…¥ä»£è¡¨1ã€é›¢é–‹ä»£è¡¨-1)    &#125;arr[2*N];\nä¸Šä¸‹ç•Œæˆ‘å€‘åˆ©ç”¨valç¶­è­·ï¼Œç•¶ $val=1$ æ™‚è¡¨ç¤ºæ˜¯çŸ©å½¢çš„ä¸‹ç•Œï¼› $val=-1$ å‰‡æ˜¯çŸ©å½¢ä¸Šç•Œï¼Œé€™å…©å€‹æ­é…åœ¨ä¸€èµ·å‰›å¥½å°±å¯ä»¥ç”¨ç·šæ®µæ¨¹å€é–“åŠ å€¼çš„æ–¹å¼é€²è¡Œæ“ä½œï¼ç¸½å…±æœ‰ $n$ å€‹çŸ©å½¢ï¼Œå› æ­¤æˆ‘å€‘è¦æƒæç·šç¸½å…±æƒæ $2n$ æ¢ç·šæ®µã€‚\nç·šæ®µæ¨¹ä¸€æ¨£å°å€¼åŸŸï¼ˆé€™é¡Œæ˜¯1000000ï¼‰çš„4å€é–‹äº†ç·šæ®µæ¨¹ï¼ŒåŒæ™‚ç¶­è­·ä¸€å€‹éè² æ•´æ•¸ $tag$ è¡¨ç¤ºå€é–“è¢«è¦†è“‹çš„æƒ…æ³ã€‚ç•¶æ¯ä¸€æ¬¡ä¿®æ”¹å®Œæˆä¹‹å¾Œï¼Œæˆ‘å€‘å¯ä»¥ç›´æ¥å–ç”¨æ ¹ç¯€é» $seg[1]$ çš„æ•¸å€¼è¡¨ç¤ºå¯¬åº¦ï¼ˆé0çš„å€‹æ•¸ï¼‰ï¼\n//seg[i]è¡¨ç¤ºiçš„å·¦å³å…©å­æ¨¹çš„å€é–“é0çš„å€‹æ•¸struct node&#123;    //å»ºç«‹ç·šæ®µæ¨¹    int val;    //ç¶­è­·é0å€‹æ•¸    int tag;    //ä½¿ç”¨tagç´€éŒ„å€é–“è¢«è¦†è“‹æ¬¡æ•¸&#125;seg[4*M];\næ¥ä¸‹ä¾†å°±æ˜¯åœ¨ç¨‹å¼åŸ·è¡Œçš„éç¨‹ä¸­å°‡ $2n$ æ¢é‚Šä¾ç…§yåº§æ¨™é€²è¡Œæ’åº $O(nlogn)$ï¼Œæ¥è‘—ä¾åºä½¿ç”¨æƒæç·šæ­é…ç·šæ®µæ¨¹çš„ä¿®æ”¹ï¼Œè¨ˆç®—çŸ©å½¢çš„é¢ç©ã€‚æœ€å¾Œå°±æ˜¯è¼¸å‡ºåŠ èµ·ä¾†çš„ç­”æ¡ˆã€‚\n\n            Debug å°éŒ¯èª¤Submission1:WAå¯ä»¥çœ‹åˆ°æœ‰ä¸€ç­†æ¸¬è³‡éä¸äº†ï¼Œ95åˆ†QQQå¾Œä¾†debugä¹‹å¾Œç™¼ç¾åˆ°ï¼Œå› ç‚ºæˆ‘æ˜¯å°æ¯ä¸€å€‹çŸ©å½¢å…ˆè¼¸å…¥ä¸‹ç•Œä¹‹å¾Œæ‰æ˜¯ä¸Šç•Œï¼Œç•¶æˆ‘åœ¨æ’åºçš„éç¨‹ä¸­ï¼Œä¸Šç•Œæœ‰å¯èƒ½æœ‰æ©Ÿæœƒè·‘åˆ°ä¸‹ç•Œä¹‹å‰ï¼Œé€ æˆ $tag$ è¢«æ‰£åˆ°è² çš„æƒ…æ³ï¼Œä½†åœ¨å®šç¾©ä¸­å¯ä»¥æ¸…æ¥šçŸ¥é“ $tag$ æ˜¯éè² æ•´æ•¸é€ æˆéŒ¯èª¤ã€‚å› æ­¤åªè¦æŠŠæ’åºçš„éç¨‹æ”¹æˆ stable_sort() å³å¯ï¼stable_sort(arr,arr+(n&lt;&lt;1),cmp);\n          \næœ€å¾Œçµ‚æ–¼æ˜¯ç¨‹å¼ç¢¼çš„éƒ¨åˆ†ï¼Œä»¥ä¸‹ï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 100005#define M 1000001#define lld long longusing namespace std;int n;struct Node&#123;    //æ¯ä¸€å€‹çŸ©é™£åˆ†æˆä¸Šä¸‹å…©æ¢é‚Š    int x1;     //çŸ©å½¢å·¦ç•Œx1    int x2;     //çŸ©å½¢å³ç•Œx2    int y;      //çŸ©å½¢yåº§æ¨™ï¼ˆåˆ†ä¸Šä¸‹å…©é‚Šï¼‰    int val;    //val = Â±1(é€²å…¥ä»£è¡¨1ã€é›¢é–‹ä»£è¡¨-1)    &#125;arr[2*N];//seg[i]è¡¨ç¤ºiçš„å·¦å³å…©å­æ¨¹çš„å€é–“é0çš„å€‹æ•¸struct node&#123;    //å»ºç«‹ç·šæ®µæ¨¹    int val;    //ç¶­è­·é0å€‹æ•¸    int tag;    //ä½¿ç”¨tagç´€éŒ„å€é–“è¢«è¦†è“‹æ¬¡æ•¸    &#125;seg[4*M];bool cmp(Node a, Node b)&#123;    return a.y&lt;b.y;&#125;//å°å€é–“[ql,qr)é€²è¡ŒåŠ å€¼valvoid modify(int cur,int l,int r,int ql,int qr,int val)&#123;    if(r &lt;= l || ql &gt;= r || qr &lt;= l)return;    if(ql &lt;= l &amp;&amp; qr &gt;= r)&#123;        seg[cur].tag += val;        return;    &#125;    int mid = (l+r)/2;    modify(2*cur,l,mid,ql,qr,val);    modify(2*cur+1,mid,r,ql,qr,val);        //å·¦å³ç¯€é»å¦‚æœ‰tagè¡¨ç¤ºè¢«å®Œå…¨è¦†è“‹ï¼Œç›´æ¥åŠ ä¸Šå€é–“å¤§å°ï¼Œå¦å‰‡åŠ ä¸Šseg[å·¦å³å­æ¨¹]    seg[cur].val = (seg[2*cur].tag?mid-l:seg[2*cur].val)                  +(seg[2*cur+1].tag?r-mid:seg[2*cur+1].val);&#125;int main()&#123;    ios;    memset(arr,0,sizeof(arr));    memset(seg,0,sizeof(seg));        cin&gt;&gt;n;                                   //ä¾åºè¼¸å…¥å·¦å³ä¸‹ä¸Šï¼šx1,x2,y1,y2    for(int i=0;i&lt;(n&lt;&lt;1);i+=2)&#123;        int x1,x2,y1,y2;cin&gt;&gt;x1&gt;&gt;x2&gt;&gt;y1&gt;&gt;y2;        arr[i] = (Node)&#123;x1,x2,y1,1&#125;;          //æ’å…¥çŸ©å½¢ä¸‹é‚Šï¼Œå¸¶å…¥val = 1        arr[i+1] = (Node)&#123;x1,x2,y2,-1&#125;;       //ä¸Šé‚Šè¦val = -1    &#125;    stable_sort(arr,arr+(n&lt;&lt;1),cmp);          //ä¾ç…§yåº§æ¨™ç”±å°åˆ°å¤§æ’åº        int y0 = 0,val = 0;                       //æœ‰ä¸‹è€Œä¸Šçš„æšèˆ‰æ‰€æœ‰æ°´å¹³é‚Š    lld ans = 0LL;                            //ä¸Šä¸€æ¢yçš„åº§æ¨™ï¼Œè¨ˆç®—é«˜ï¼Œvalç‚ºçŸ©å½¢çµåˆèµ·ä¾†çš„å¯¬    for(int i=0;i&lt;(n&lt;&lt;1);i++)&#123;                //æšèˆ‰2næ¢yçš„é‚Š        ans += (lld)(arr[i].y-y0)*val;        //è¨ˆç®—é¢ç©ï¼ˆå¯¬*é«˜ï¼‰        modify(1,0,M,arr[i].x1,arr[i].x2,arr[i].val);        y0 = arr[i].y;        val = seg[1].val;                     //ä¿®æ”¹å¾Œï¼ˆä¸‹ä¸€è¼ªï¼‰çš„çŸ©é™£å¯¬åº¦    &#125;    cout&lt;&lt;ans&lt;&lt;&#x27;\\n&#x27;;&#125;\n","categories":["C++é€²éšä¸»é¡Œ","ç·šæ®µæ¨¹"],"tags":["2021æš‘å‡ç­†è¨˜","2020è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 19 å¤§å–„äººè€é—†æ•‘æ¿Ÿæ±å—äºå…’ç«¥","url":"/sprout1-2-1/","content":"å¤§å–„äººè€é—†æ•‘æ¿Ÿæ±å—äºå…’ç«¥\né¡Œç›®é€£çµé€™ä¸€é¡Œå¾ˆç†Ÿæ‚‰ï¼Œåœ¨å»å¹´9æœˆå‰›é–‹å­¸çš„è³‡è®€å­¸é•·æœ‰è¬›éï¼Œçµæœé‚£æ™‚å€™æ ¹æœ¬è½ä¸æ‡‚QQä½†ç¾åœ¨ä¾†çœ‹ï¼Œé€™ä¸€é¡Œå°±æ˜¯æ¨¡æ“¬stack ï¼Œå¾ˆåŸºç¤çš„é¡Œç›®å¯ä»¥ç”¨queue (ä¹Ÿå¯ä»¥ä¸ç”¨)é…ä¸Šstackï¼Œåˆ†åˆ¥æ¨¡æ“¬Station è·ŸBç«™ çš„æƒ…æ³\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        stack&lt;int&gt;s;        queue&lt;int&gt;q;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;arr[i];            q.push(arr[i]);        &#125;                for(int i=0;i&lt;n;i++)&#123;            s.push(i+1);//push é€²station            while(!s.empty()&amp;&amp;!q.empty()&amp;&amp;s.top()==q.front())&#123;                s.pop();q.pop();            &#125;        &#125;        if(s.empty()&amp;&amp;q.empty())cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 20 ä¸­åœ‹äººæ’éšŠå•é¡Œ","url":"/sprout1-2-2/","content":"ä¸­åœ‹äººæ’éšŠå•é¡Œ\né¡Œç›®é€£çµé€™ä¸€é¡Œæœ‰ä¸€å€‹æ¢ä»¶æœ‰é»é›£ç¶­è­·ï¼Œå°±æ˜¯å¦‚æœåŒä¸€åœ˜é«”çš„äººè¦æ’éšŠè€ŒéšŠä¸­å·²ç¶“æœ‰åŒä¸€åœ˜äººåœ¨è£¡é¢æ™‚ï¼Œä»–å°±è¦æ’åœ¨åœ˜è£¡é¢æœ€å¾Œä¸€å€‹ä½ç½®å› æ­¤è¦ç”¨iterator é™£åˆ—æŒ‡å‘æ¯å€‹åœ˜éšŠçš„æœ«ç«¯ä¹‹é¡çš„å¥½å¥½ç¶­è­·ç´°ç¯€å¯ä»¥æ¸›å°‘debug çš„æ™‚é–“ï¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt = 1;int main()&#123;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;&quot;Line #&quot;&lt;&lt;cnt&lt;&lt;endl;        int arr[1000005],gt[1005];//ç´€éŒ„åœ¨å“ªä¸€å€‹åœ˜é«”ç•¶ä¸­        memset(arr, 0, sizeof(arr));        memset(gt, 0, sizeof(gt));        for(int i=1;i&lt;=n;i++)&#123;            int k;cin&gt;&gt;k;            for(int j=0;j&lt;k;j++)&#123;                int temp;cin&gt;&gt;temp;                arr[temp] = i;            &#125;        &#125;        list&lt;int&gt; ls;        list&lt;int&gt;::iterator it[1005];//æŒ‡å‘ç¬¬iå€‹åœ˜é«”çš„å°¾ç«¯        while(true)&#123;            string s;int cur;            cin&gt;&gt;s;            if(s[0]==&#x27;E&#x27;)&#123;                cin&gt;&gt;cur;                int i = arr[cur];                if(i&gt;0)&#123;                    if(gt[i]==0)&#123;                        ls.push_back(cur);                        it[i] = --ls.end();                    &#125;                    else&#123;                        it[i] = ls.insert(++it[i],cur);                    &#125;                    gt[i]++;                &#125;                else ls.push_back(cur);            &#125;            else if(s[0]==&#x27;D&#x27;)&#123;                int i = ls.front();                if(arr[i]&gt;0)gt[arr[i]]--;                cout&lt;&lt;ls.front()&lt;&lt;endl;                ls.pop_front();            &#125;            else break;        &#125;        cnt++;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 21 é™¸è¡Œé³¥å¤§è³½è»Š","url":"/sprout1-2-3/","content":"é™¸è¡Œé³¥å¤§è³½è»Š\né¡Œç›®é€£çµé€™ä¸€é¡Œæˆ‘å˜—è©¦äº†å…©å€‹æ–¹æ³•ç¬¬ä¸€å€‹æ–¹æ³•ï¼šç”¨vector ç´€éŒ„åæ¬¡ï¼Œä½†å°±æ˜¯æœƒTLE ï¼ŒåŸå› ï¼šéœ€è¦O(N)æ‰¾åˆ°ç•¶å‰çš„è»Šè»Šåœ¨ç¬¬å¹¾åï¼Œå¦‚æœé­å—æ”»æ“Šï¼Œä¹Ÿè¦ç”¨O(N)ä¾†erase vectorçš„å…ƒç´ ï¼Œçµæœé•·é€™æ¨£ï¼šè¬›å¸«èªªï¼šä¸è¦ç”¨vector çš„erase ï¼Œå› ç‚ºä»–æœƒè€—è²»O(N)çš„æ™‚é–“\nç¬¬äºŒå€‹æ–¹æ³•ï¼šç”¨ä¸€å€‹struct çš„é™£åˆ—ï¼Œè£¡é¢åŒ…äº†æ¯ä¸€å°è»Šçš„è³‡è¨ŠåŒ…å«ä»–çš„åæ¬¡ï¼Œé€™æ¨£å°±å¯ä»¥ç”¨O(1)æ›´æ”¹æ¯ä¸€å°è»Šçš„åæ¬¡ï¼Œç®—æ˜¯ç¬¬ä¸€å€‹ç®—æ³•çš„å„ªåŒ–\n#include &lt;bits/stdc++.h&gt;using namespace std;int N,M;struct node&#123;    int player_id;    node *next,*prev;    node()&#123;        next = NULL;        prev = NULL;    &#125;&#125;;node *player[100005];signed main()&#123;    ios    cin&gt;&gt;N&gt;&gt;M;    for(int i=0;i&lt;=N+2;i++)&#123;        player[i] = new node();        player[i]-&gt;player_id = i;    &#125;    for(int i=1;i&lt;=N+2;i++)&#123;        player[i]-&gt;prev = player[i-1];        player[i]-&gt;next = player[i+1];    &#125;//åˆå§‹åŒ–è¨­å®š    for(int i=0;i&lt;M;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(a==0)&#123;            player[b]-&gt;prev-&gt;next = player[b]-&gt;next;            player[b]-&gt;next-&gt;prev = player[b]-&gt;prev;        &#125;//ç·¨è™Ÿbçš„è»Šè»Šè¢«æ¶ˆæ»…        else&#123;            if(!player[b]-&gt;prev-&gt;prev)continue;            int pp,p,n;            pp = player[b]-&gt;prev-&gt;prev-&gt;player_id;            p = player[b]-&gt;prev-&gt;player_id;            n = player[b]-&gt;next-&gt;player_id;                        player[pp]-&gt;next = player[b];            player[b]-&gt;prev = player[pp];            player[b]-&gt;next = player[p];            player[p]-&gt;next = player[n];            player[n]-&gt;prev = player[p];            player[p]-&gt;prev = player[b];        &#125;//äº¤æ›åæ¬¡çš„éƒ¨åˆ†ï¼Œä¸éæ‡‰è©²æœ‰æ–¹æ³•å¯ä»¥æ›´ç°¡å–®    &#125;    stack&lt;int&gt; s;    int ind = N+1;    while(player[ind]-&gt;prev!=NULL)&#123;        if(ind!=N+1)&#123;            s.push(player[ind]-&gt;player_id);        &#125;        ind = player[ind]-&gt;prev-&gt;player_id;    &#125;    while(!s.empty()&amp;&amp;s.size()!=1)&#123;        cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;;        s.pop();    &#125;    cout&lt;&lt;s.top()&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 513 è¶…å¤§è¢å¹•è¨­ç½®","url":"/sprout1-2-4/","content":"è¶…å¤§è¢å¹•è¨­ç½®\né¡Œç›®é€£çµè¬›å¸«åœ¨èª²å ‚ä¸Šæœ‰è¬›è§£é€™å€‹é¡Œç›®çš„ç®—æ³•ï¼Œå°±æ˜¯å°æ¯å€‹ã€Œå¤§æ¨“ã€ï¼ˆå‰›å‰›çœ‹æ‰çŸ¥é“ï¼‰åˆ†åˆ¥å¾€å·¦å¾€å³çœ‹ï¼ˆå–®èª¿éšŠåˆ—ï¼‰ï¼Œçœ‹åˆ°ç¬¬ä¸€å€‹å°æ–¼è‡ªå·±å°±åœæ­¢å–®èª¿éšŠåˆ—å•äº†è¬›å¸«ä¹‹å¾Œï¼Œåƒç…§ä»–çš„å¯«æ³•ï¼Œç”¨vector å„²å­˜ã€Œä½ç½®çš„indexã€è€Œä¸è¦ç”¨pair ï¼Œæ˜é¡¯å¢åŠ äº†ç¨‹å¼ç¢¼çš„æ˜“è®€æ€§ï¼\né€™æ˜¯ç”¨pair ç‰ˆæœ¬ï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    vector&lt;pair&lt;int,int&gt;&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        vec.push_back(make_pair(temp, i+1));    &#125;    int ans[n+5][2];    stack&lt;pair&lt;int, int&gt;&gt; p;    p.push(vec[0]);        for(int i=1;i&lt;n;i++)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][0] = i-p.top().second+1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][0] = n-p.top().second+1;        p.pop();    &#125;    p.push(vec[n-1]);        for(int i=n-2;i&gt;=0;i--)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][1] = p.top().second-i-1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][1] = p.top().second;        p.pop();    &#125;        int total = 0;    for(int i=0;i&lt;n;i++)&#123;        int sum =0;        sum = vec[i].first*(ans[i][0]+ans[i][1]-1);        total = max(total,sum);    &#125;    cout&lt;&lt;total&lt;&lt;endl;&#125;\nè€Œé€™å€‹æ˜¯ç”¨è¬›å¸«ç¿’æ…£çš„ä½œæ³•ï¼Œæ˜é¡¯çŸ­äº†å¾ˆå¤šï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    int arr[n+5],lft[n+5],rht[n+5];    memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    vector&lt;int&gt; stk(1,0);        for(int i=1;i&lt;=n;i++)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        lft[i] = i-stk.back();        stk.push_back(i);    &#125;    while(!stk.empty())stk.pop_back();        stk.push_back(n+1);        for(int i=n;i&gt;=1;i--)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        rht[i] = stk.back()-i-1;        stk.push_back(i);    &#125;    int ans[n+5];    for(int i=1;i&lt;=n;i++)&#123;        ans[i-1] = arr[i]*(lft[i]+rht[i]);    &#125;    cout&lt;&lt;*max_element(ans,ans+n)&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 22 æª¸æª¬æ±½æ°´å‚³èªªï¼ˆNPSCï¼‰","url":"/sprout1-2-5/","content":"æª¸æª¬æ±½æ°´å‚³èªªï¼ˆNPSCï¼‰\né¡Œç›®é€£çµé€™é¡Œæˆ‘è¦ºå¾—å¾ˆé›£ï¼ä¸€é–‹å§‹æƒ³èªªç¶­è­·ä¸€å€‹éå¢çš„å–®èª¿éšŠåˆ—ï¼Œæ²’æƒ³åˆ°ä¸€ç›´åƒWAå¥½å§ï¼Œä¸Šç¶²æ‰¾ç­”æ¡ˆçµæœæ˜¯ç™¼ç¾ï¼Œé¡Œç›®å¾ˆæ©Ÿè»Šçš„éœ€è¦è™•ç†ç›¸åŒå…ƒç´ çš„æƒ…æ³å› ç‚ºä¸€æ’ä¸€æ¨£çš„æ•¸å­—å¯ä»¥æ©«è·¨å¾ˆå¤šå€‹æ•¸å­—ï¼Œå½¢æˆæ•¸å°å¥½ä¸å®¹æ˜“è™•ç†å®Œä¹‹å¾Œä¸Šå‚³code åˆåƒWAdebug äº†å¥½ä¹…ï¼Œæ‰ç™¼ç¾æ˜¯å› ç‚ºç¬¬ä¸€å€‹é€£çºŒå‡ºç¾çš„æ•¸å­—å¥½å¥½è™•ç†å› ç‚ºç¬¬ä¸€å€‹æ•¸å­—å°±ç®—è·Ÿå¾Œé¢é€£çºŒçš„æ•¸å­—ç›¸åŒä¹Ÿä¸èƒ½å†è·Ÿå‰é¢æ§‹æˆä»»ä½•æ•¸å°ï¼ç¸½ç®—ï¼Œç¶“éå¥½ä¹…å¥½ä¹…ï¼Œçµ‚æ–¼æ‰AC ï¼ŒçœŸæ˜¯å¾—ä¾†ä¸æ˜“ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n,t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        vector&lt;int&gt; s;                int ans = 0,cnt[1000005];        memset(cnt, 0, sizeof(cnt));//ç´€éŒ„sç•¶ä¸‹è©²æ•¸å‡ºç¾æ¬¡æ•¸        while(n--)&#123;            int k,top = s.size();cin&gt;&gt;k;                        while(!s.empty() &amp;&amp; s.back()&lt;k)&#123;                cnt[top--] = 0;                s.pop_back();                ans++;            &#125;            if(s.empty())s.push_back(k);            else&#123;                if(s.back()==k &amp;&amp; top&gt;1)&#123;                    cnt[top+1]+=cnt[top]+1;                    ans+=cnt[top+1];                &#125;                s.push_back(k);ans++;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 48 äºŒå…ƒæœå°‹æ¨¹","url":"/sprout1-2-6/","content":"äºŒå…ƒæœå°‹æ¨¹\né¡Œç›®é€£çµå¾ˆç‰¹åˆ¥çš„ä¸€é¡Œï¼ŒåŸä¾†BST ç”¨ä¸­åºéæ­·å°±æ˜¯æ’åºå¥½çš„æ•¸åˆ—ï¼æœ‰äº†å‰åºè·Ÿä¸­åºä¹‹å¾Œï¼Œå°±å¯ä»¥é€ééè¿´ä¾†é‚„åŸæ•´æ£µäºŒå…ƒæ¨¹äº†ï¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int n;struct Node&#123;    Node *left;    Node *right;    int val;&#125;;Node* BinaryTree(int* preorder, int* inorder, int length)&#123;    if(length==0)return NULL;    Node *node = new Node;    node-&gt;val = *preorder;        int root_index = 0;    for(;root_index&lt;length;root_index++)&#123;        if(inorder[root_index]==*preorder)break;    &#125;    node-&gt;left = BinaryTree(preorder+1, inorder,root_index);    node-&gt;right = BinaryTree(preorder+root_index+1, inorder+root_index+1,length-root_index-1);    cout&lt;&lt;node-&gt;val&lt;&lt;endl;    return node;&#125;signed main()&#123;    int arr[2005],sorted[2005];    while(cin&gt;&gt;arr[n])&#123;        sorted[n] = arr[n];        n++;    &#125;    sort(sorted, sorted+n);    BinaryTree(arr, sorted, n);&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 293 æ¨¹é‡å¿ƒ","url":"/sprout1-2-7/","content":"æ¨¹é‡å¿ƒ\né¡Œç›®é€£çµè¶…æ„›é€™ä¸€é¡Œï¼Œç«Ÿç„¶å¯ä»¥ç”¨DFS è·‘ä¸€æ¬¡O(N)æŠŠæ‰€æœ‰çš„é»çš„è³‡è¨Šå…¨éƒ¨æ±‚å‡ºä¾†é€éç°¡å–®çš„é‹ç®—æŠŠçœ‹èµ·ä¾†å¾ˆè¤‡é›œçš„é¡Œç›®å¾ˆå„ªç¾çš„è§£å‡ºä¾†ï¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;vector&lt;int&gt; Edge[100005];bool visit[100005];struct Node&#123;    int sum;//å­ç¯€é»ç¸½æ•¸ï¼ˆæ‰£æ‰ç®—çˆ¶ç¯€é»ï¼‰    int maxn;//å­æ•¸æœ€å¤§çš„é‚£ä¸€å€‹&#125;node[100005];int dfs(int id)&#123;    visit[id] = true;    int len = Edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = Edge[id][i];        if(visit[temp]==1)continue;        int t = dfs(temp);        node[id].sum += t;        node[id].maxn = max(node[id].maxn,t);    &#125;    return node[id].sum+1;&#125;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n;cin&gt;&gt;n;        memset(visit, 0, sizeof(visit));                for(int i=0;i&lt;n;i++)&#123;//initialize            Edge[i].clear();            node[i].maxn = node[i].sum = 0;        &#125;        for(int i=0;i&lt;n-1;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            Edge[a].push_back(b);            Edge[b].push_back(a);        &#125;        dfs(0);        int ans = n,index = 0;        for(int i=0;i&lt;n;i++)&#123;            int temp = max(node[i].maxn,n-node[i].sum-1);//å­èˆ‡çˆ¶æ±‚æ…˜åº¦            if(temp&lt;ans)&#123;                index = i;                ans = temp;            &#125;        &#125;        cout&lt;&lt;index&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬ä¸€ã€äºŒé€±ï¼šåŸºç¤è³‡çµã€è¤‡é›œåº¦ã€æ¨¹","url":"/sprout1-2/","content":"ç¬¬ä¸€æ¬¡ä¸Šèª²ï¼ŒåŸæœ¬æƒ³èªªæœƒè¼•é¬†çš„åº¦éä¸€å€‹ç¦®æ‹œæ²’æƒ³åˆ°ç›´æ¥ç”¨å–®èª¿éšŠåˆ—ç•¶ä½œé–‹å ´ï¼Œè®“ç¬¬ä¸€å€‹æ˜ŸæœŸåœç¹è‘—stack èˆ‡queueçš„è³‡çµä¸–ç•Œä¸­ä½†ä¹Ÿå¾ˆæ…¶å¹¸çš„ï¼Œåœ¨ç¬¬ä¸€é€±çµ‚æ–¼å­¸æœƒç”¨å¾ˆç¯€ç°¡çš„ç¨‹å¼ç¢¼å¯«å–®èª¿éšŠåˆ—ç¬¬äºŒé€±çš„å…§å®¹å‰‡æ˜¯è¤‡é›œåº¦åˆ†æP èˆ‡NP å•é¡ŒçœŸè®“äººä¸€é ­æ˜¯å¤§ï¼Œé›–ç„¶åœ¨ç«¶ç¨‹ä¸­å°æ–¼è¼ƒè¤‡é›œçš„è¤‡é›œåº¦å•é¡Œå¾ˆå°‘æ´¾ä¸Šç”¨å ´ä¸éé‚„æ˜¯è »æœ‰è¶£çš„ï¼Œåªè¦è­‰æ˜P=NPå°±å¯ä»¥å¾ˆå¤šéŒ¢äº†ï¼\n\nä¸Šèª²å…§å®¹ç¬¬ä¸€é€±ä¸»é¡Œï¼šåŸºç¤è³‡æ–™çµæ§‹ï¼ˆqueue, stack, å–®èª¿éšŠåˆ—ï¼‰ç¬¬äºŒé€±ä¸»é¡Œï¼šè¤‡é›œåº¦åˆ†æã€æ¨¹ç‹€çµæ§‹\nä¸Šæ©Ÿä½œæ¥­æŒ‘å¹¾é¡Œæ¯”è¼ƒæœ‰è¶£çš„\nå¤§å–„äººè€é—†æ•‘æ¿Ÿæ±å—äºå…’ç«¥é¡Œç›®é€£çµé€™ä¸€é¡Œå¾ˆç†Ÿæ‚‰ï¼Œåœ¨å»å¹´9æœˆå‰›é–‹å­¸çš„è³‡è®€å­¸é•·æœ‰è¬›éï¼Œçµæœé‚£æ™‚å€™æ ¹æœ¬è½ä¸æ‡‚QQä½†ç¾åœ¨ä¾†çœ‹ï¼Œé€™ä¸€é¡Œå°±æ˜¯æ¨¡æ“¬stack ï¼Œå¾ˆåŸºç¤çš„é¡Œç›®å¯ä»¥ç”¨queue (ä¹Ÿå¯ä»¥ä¸ç”¨)é…ä¸Šstackï¼Œåˆ†åˆ¥æ¨¡æ“¬Station è·ŸBç«™ çš„æƒ…æ³\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        stack&lt;int&gt;s;        queue&lt;int&gt;q;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;arr[i];            q.push(arr[i]);        &#125;                for(int i=0;i&lt;n;i++)&#123;            s.push(i+1);//push é€²station            while(!s.empty()&amp;&amp;!q.empty()&amp;&amp;s.top()==q.front())&#123;                s.pop();q.pop();            &#125;        &#125;        if(s.empty()&amp;&amp;q.empty())cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;    &#125;&#125;\nä¸­åœ‹äººæ’éšŠå•é¡Œé¡Œç›®é€£çµé€™ä¸€é¡Œæœ‰ä¸€å€‹æ¢ä»¶æœ‰é»é›£ç¶­è­·ï¼Œå°±æ˜¯å¦‚æœåŒä¸€åœ˜é«”çš„äººè¦æ’éšŠè€ŒéšŠä¸­å·²ç¶“æœ‰åŒä¸€åœ˜äººåœ¨è£¡é¢æ™‚ï¼Œä»–å°±è¦æ’åœ¨åœ˜è£¡é¢æœ€å¾Œä¸€å€‹ä½ç½®å› æ­¤è¦ç”¨iterator é™£åˆ—æŒ‡å‘æ¯å€‹åœ˜éšŠçš„æœ«ç«¯ä¹‹é¡çš„å¥½å¥½ç¶­è­·ç´°ç¯€å¯ä»¥æ¸›å°‘debug çš„æ™‚é–“ï¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,cnt = 1;int main()&#123;    while(cin&gt;&gt;n)&#123;        cout&lt;&lt;&quot;Line #&quot;&lt;&lt;cnt&lt;&lt;endl;        int arr[1000005],gt[1005];//ç´€éŒ„åœ¨å“ªä¸€å€‹åœ˜é«”ç•¶ä¸­        memset(arr, 0, sizeof(arr));        memset(gt, 0, sizeof(gt));        for(int i=1;i&lt;=n;i++)&#123;            int k;cin&gt;&gt;k;            for(int j=0;j&lt;k;j++)&#123;                int temp;cin&gt;&gt;temp;                arr[temp] = i;            &#125;        &#125;        list&lt;int&gt; ls;        list&lt;int&gt;::iterator it[1005];//æŒ‡å‘ç¬¬iå€‹åœ˜é«”çš„å°¾ç«¯        while(true)&#123;            string s;int cur;            cin&gt;&gt;s;            if(s[0]==&#x27;E&#x27;)&#123;                cin&gt;&gt;cur;                int i = arr[cur];                if(i&gt;0)&#123;                    if(gt[i]==0)&#123;                        ls.push_back(cur);                        it[i] = --ls.end();                    &#125;                    else&#123;                        it[i] = ls.insert(++it[i],cur);                    &#125;                    gt[i]++;                &#125;                else ls.push_back(cur);            &#125;            else if(s[0]==&#x27;D&#x27;)&#123;                int i = ls.front();                if(arr[i]&gt;0)gt[arr[i]]--;                cout&lt;&lt;ls.front()&lt;&lt;endl;                ls.pop_front();            &#125;            else break;        &#125;        cnt++;    &#125;&#125;\né™¸è¡Œé³¥å¤§è³½è»Šé¡Œç›®é€£çµé€™ä¸€é¡Œæˆ‘å˜—è©¦äº†å…©å€‹æ–¹æ³•ç¬¬ä¸€å€‹æ–¹æ³•ï¼šç”¨vector ç´€éŒ„åæ¬¡ï¼Œä½†å°±æ˜¯æœƒTLE ï¼ŒåŸå› ï¼šéœ€è¦O(N)æ‰¾åˆ°ç•¶å‰çš„è»Šè»Šåœ¨ç¬¬å¹¾åï¼Œå¦‚æœé­å—æ”»æ“Šï¼Œä¹Ÿè¦ç”¨O(N)ä¾†erase vectorçš„å…ƒç´ ï¼Œçµæœé•·é€™æ¨£ï¼šè¬›å¸«èªªï¼šä¸è¦ç”¨vector çš„erase ï¼Œå› ç‚ºä»–æœƒè€—è²»O(N)çš„æ™‚é–“\nç¬¬äºŒå€‹æ–¹æ³•ï¼šç”¨ä¸€å€‹struct çš„é™£åˆ—ï¼Œè£¡é¢åŒ…äº†æ¯ä¸€å°è»Šçš„è³‡è¨ŠåŒ…å«ä»–çš„åæ¬¡ï¼Œé€™æ¨£å°±å¯ä»¥ç”¨O(1)æ›´æ”¹æ¯ä¸€å°è»Šçš„åæ¬¡ï¼Œç®—æ˜¯ç¬¬ä¸€å€‹ç®—æ³•çš„å„ªåŒ–\n#include &lt;bits/stdc++.h&gt;using namespace std;int N,M;struct node&#123;    int player_id;    node *next,*prev;    node()&#123;        next = NULL;        prev = NULL;    &#125;&#125;;node *player[100005];signed main()&#123;    ios    cin&gt;&gt;N&gt;&gt;M;    for(int i=0;i&lt;=N+2;i++)&#123;        player[i] = new node();        player[i]-&gt;player_id = i;    &#125;    for(int i=1;i&lt;=N+2;i++)&#123;        player[i]-&gt;prev = player[i-1];        player[i]-&gt;next = player[i+1];    &#125;//åˆå§‹åŒ–è¨­å®š    for(int i=0;i&lt;M;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        if(a==0)&#123;            player[b]-&gt;prev-&gt;next = player[b]-&gt;next;            player[b]-&gt;next-&gt;prev = player[b]-&gt;prev;        &#125;//ç·¨è™Ÿbçš„è»Šè»Šè¢«æ¶ˆæ»…        else&#123;            if(!player[b]-&gt;prev-&gt;prev)continue;            int pp,p,n;            pp = player[b]-&gt;prev-&gt;prev-&gt;player_id;            p = player[b]-&gt;prev-&gt;player_id;            n = player[b]-&gt;next-&gt;player_id;                        player[pp]-&gt;next = player[b];            player[b]-&gt;prev = player[pp];            player[b]-&gt;next = player[p];            player[p]-&gt;next = player[n];            player[n]-&gt;prev = player[p];            player[p]-&gt;prev = player[b];        &#125;//äº¤æ›åæ¬¡çš„éƒ¨åˆ†ï¼Œä¸éæ‡‰è©²æœ‰æ–¹æ³•å¯ä»¥æ›´ç°¡å–®    &#125;    stack&lt;int&gt; s;    int ind = N+1;    while(player[ind]-&gt;prev!=NULL)&#123;        if(ind!=N+1)&#123;            s.push(player[ind]-&gt;player_id);        &#125;        ind = player[ind]-&gt;prev-&gt;player_id;    &#125;    while(!s.empty()&amp;&amp;s.size()!=1)&#123;        cout&lt;&lt;s.top()&lt;&lt;&quot; &quot;;        s.pop();    &#125;    cout&lt;&lt;s.top()&lt;&lt;endl;&#125;\nè¶…å¤§è¢å¹•è¨­ç½®é¡Œç›®é€£çµè¬›å¸«åœ¨èª²å ‚ä¸Šæœ‰è¬›è§£é€™å€‹é¡Œç›®çš„ç®—æ³•ï¼Œå°±æ˜¯å°æ¯å€‹ã€Œå¤§æ¨“ã€ï¼ˆå‰›å‰›çœ‹æ‰çŸ¥é“ï¼‰åˆ†åˆ¥å¾€å·¦å¾€å³çœ‹ï¼ˆå–®èª¿éšŠåˆ—ï¼‰ï¼Œçœ‹åˆ°ç¬¬ä¸€å€‹å°æ–¼è‡ªå·±å°±åœæ­¢å–®èª¿éšŠåˆ—å•äº†è¬›å¸«ä¹‹å¾Œï¼Œåƒç…§ä»–çš„å¯«æ³•ï¼Œç”¨vector å„²å­˜ã€Œä½ç½®çš„indexã€è€Œä¸è¦ç”¨pair ï¼Œæ˜é¡¯å¢åŠ äº†ç¨‹å¼ç¢¼çš„æ˜“è®€æ€§ï¼\né€™æ˜¯ç”¨pair ç‰ˆæœ¬ï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    vector&lt;pair&lt;int,int&gt;&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        vec.push_back(make_pair(temp, i+1));    &#125;    int ans[n+5][2];    stack&lt;pair&lt;int, int&gt;&gt; p;    p.push(vec[0]);        for(int i=1;i&lt;n;i++)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][0] = i-p.top().second+1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][0] = n-p.top().second+1;        p.pop();    &#125;    p.push(vec[n-1]);        for(int i=n-2;i&gt;=0;i--)&#123;        if(vec[i].first &gt;= p.top().first)&#123;            p.push(vec[i]);        &#125;        else&#123;            while(!p.empty() &amp;&amp; p.top().first &gt; vec[i].first)&#123;                ans[p.top().second-1][1] = p.top().second-i-1;                p.pop();            &#125;            p.push(vec[i]);        &#125;    &#125;    while(!p.empty())&#123;        ans[p.top().second-1][1] = p.top().second;        p.pop();    &#125;        int total = 0;    for(int i=0;i&lt;n;i++)&#123;        int sum =0;        sum = vec[i].first*(ans[i][0]+ans[i][1]-1);        total = max(total,sum);    &#125;    cout&lt;&lt;total&lt;&lt;endl;&#125;\nè€Œé€™å€‹æ˜¯ç”¨è¬›å¸«ç¿’æ…£çš„ä½œæ³•ï¼Œæ˜é¡¯çŸ­äº†å¾ˆå¤šï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0);cin.tie(0);#define int long longusing namespace std;int n;signed main()&#123;    ios    cin&gt;&gt;n;    int arr[n+5],lft[n+5],rht[n+5];    memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];    vector&lt;int&gt; stk(1,0);        for(int i=1;i&lt;=n;i++)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        lft[i] = i-stk.back();        stk.push_back(i);    &#125;    while(!stk.empty())stk.pop_back();        stk.push_back(n+1);        for(int i=n;i&gt;=1;i--)&#123;        while(arr[i]&lt;=arr[stk.back()])stk.pop_back();        rht[i] = stk.back()-i-1;        stk.push_back(i);    &#125;    int ans[n+5];    for(int i=1;i&lt;=n;i++)&#123;        ans[i-1] = arr[i]*(lft[i]+rht[i]);    &#125;    cout&lt;&lt;*max_element(ans,ans+n)&lt;&lt;endl;&#125;\næª¸æª¬æ±½æ°´å‚³èªªï¼ˆNPSCï¼‰é¡Œç›®é€£çµé€™é¡Œæˆ‘è¦ºå¾—å¾ˆé›£ï¼ä¸€é–‹å§‹æƒ³èªªç¶­è­·ä¸€å€‹éå¢çš„å–®èª¿éšŠåˆ—ï¼Œæ²’æƒ³åˆ°ä¸€ç›´åƒWAå¥½å§ï¼Œä¸Šç¶²æ‰¾ç­”æ¡ˆçµæœæ˜¯ç™¼ç¾ï¼Œé¡Œç›®å¾ˆæ©Ÿè»Šçš„éœ€è¦è™•ç†ç›¸åŒå…ƒç´ çš„æƒ…æ³å› ç‚ºä¸€æ’ä¸€æ¨£çš„æ•¸å­—å¯ä»¥æ©«è·¨å¾ˆå¤šå€‹æ•¸å­—ï¼Œå½¢æˆæ•¸å°å¥½ä¸å®¹æ˜“è™•ç†å®Œä¹‹å¾Œä¸Šå‚³code åˆåƒWAdebug äº†å¥½ä¹…ï¼Œæ‰ç™¼ç¾æ˜¯å› ç‚ºç¬¬ä¸€å€‹é€£çºŒå‡ºç¾çš„æ•¸å­—å¥½å¥½è™•ç†å› ç‚ºç¬¬ä¸€å€‹æ•¸å­—å°±ç®—è·Ÿå¾Œé¢é€£çºŒçš„æ•¸å­—ç›¸åŒä¹Ÿä¸èƒ½å†è·Ÿå‰é¢æ§‹æˆä»»ä½•æ•¸å°ï¼ç¸½ç®—ï¼Œç¶“éå¥½ä¹…å¥½ä¹…ï¼Œçµ‚æ–¼æ‰AC ï¼ŒçœŸæ˜¯å¾—ä¾†ä¸æ˜“ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n,t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        vector&lt;int&gt; s;                int ans = 0,cnt[1000005];        memset(cnt, 0, sizeof(cnt));//ç´€éŒ„sç•¶ä¸‹è©²æ•¸å‡ºç¾æ¬¡æ•¸        while(n--)&#123;            int k,top = s.size();cin&gt;&gt;k;                        while(!s.empty() &amp;&amp; s.back()&lt;k)&#123;                cnt[top--] = 0;                s.pop_back();                ans++;            &#125;            if(s.empty())s.push_back(k);            else&#123;                if(s.back()==k &amp;&amp; top&gt;1)&#123;                    cnt[top+1]+=cnt[top]+1;                    ans+=cnt[top+1];                &#125;                s.push_back(k);ans++;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\näºŒå…ƒæœå°‹æ¨¹é¡Œç›®é€£çµå¾ˆç‰¹åˆ¥çš„ä¸€é¡Œï¼ŒåŸä¾†BST ç”¨ä¸­åºéæ­·å°±æ˜¯æ’åºå¥½çš„æ•¸åˆ—ï¼æœ‰äº†å‰åºè·Ÿä¸­åºä¹‹å¾Œï¼Œå°±å¯ä»¥é€ééè¿´ä¾†é‚„åŸæ•´æ£µäºŒå…ƒæ¨¹äº†ï¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int n;struct Node&#123;    Node *left;    Node *right;    int val;&#125;;Node* BinaryTree(int* preorder, int* inorder, int length)&#123;    if(length==0)return NULL;    Node *node = new Node;    node-&gt;val = *preorder;        int root_index = 0;    for(;root_index&lt;length;root_index++)&#123;        if(inorder[root_index]==*preorder)break;    &#125;    node-&gt;left = BinaryTree(preorder+1, inorder,root_index);    node-&gt;right = BinaryTree(preorder+root_index+1, inorder+root_index+1,length-root_index-1);    cout&lt;&lt;node-&gt;val&lt;&lt;endl;    return node;&#125;signed main()&#123;    int arr[2005],sorted[2005];    while(cin&gt;&gt;arr[n])&#123;        sorted[n] = arr[n];        n++;    &#125;    sort(sorted, sorted+n);    BinaryTree(arr, sorted, n);&#125;\næ¨¹é‡å¿ƒé¡Œç›®é€£çµè¶…æ„›é€™ä¸€é¡Œï¼Œç«Ÿç„¶å¯ä»¥ç”¨DFS è·‘ä¸€æ¬¡O(N)æŠŠæ‰€æœ‰çš„é»çš„è³‡è¨Šå…¨éƒ¨æ±‚å‡ºä¾†é€éç°¡å–®çš„é‹ç®—æŠŠçœ‹èµ·ä¾†å¾ˆè¤‡é›œçš„é¡Œç›®å¾ˆå„ªç¾çš„è§£å‡ºä¾†ï¼\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;vector&lt;int&gt; Edge[100005];bool visit[100005];struct Node&#123;    int sum;//å­ç¯€é»ç¸½æ•¸ï¼ˆæ‰£æ‰ç®—çˆ¶ç¯€é»ï¼‰    int maxn;//å­æ•¸æœ€å¤§çš„é‚£ä¸€å€‹&#125;node[100005];int dfs(int id)&#123;    visit[id] = true;    int len = Edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = Edge[id][i];        if(visit[temp]==1)continue;        int t = dfs(temp);        node[id].sum += t;        node[id].maxn = max(node[id].maxn,t);    &#125;    return node[id].sum+1;&#125;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n;cin&gt;&gt;n;        memset(visit, 0, sizeof(visit));                for(int i=0;i&lt;n;i++)&#123;//initialize            Edge[i].clear();            node[i].maxn = node[i].sum = 0;        &#125;        for(int i=0;i&lt;n-1;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            Edge[a].push_back(b);            Edge[b].push_back(a);        &#125;        dfs(0);        int ans = n,index = 0;        for(int i=0;i&lt;n;i++)&#123;            int temp = max(node[i].maxn,n-node[i].sum-1);//å­èˆ‡çˆ¶æ±‚æ…˜åº¦            if(temp&lt;ans)&#123;                index = i;                ans = temp;            &#125;        &#125;        cout&lt;&lt;index&lt;&lt;endl;    &#125;&#125;\næ‰‹å¯«ä½œæ¥­é€™å…©é€±æ‰‹å¯«éƒ½æ˜¯æ•¸å­¸è­‰æ˜ï¼æœ‰å¤ æ‚²æ…˜ï¼Œå› ç‚ºé¡Œç›®å¾ˆå¤šéƒ½ä¸æœƒå•Šï¼Œé‚„è¦å»å•è€å¸«ï¼Œçµæœè€å¸«ä¹Ÿæ²’æœ‰çµ¦å‡ºä¸€å€‹å¥½çš„è§£æ–¹FFæ›å€‹è§’åº¦æƒ³ï¼Œå°±ç®—è„«é›¢æ•¸å­¸è­‰æ˜ï¼Œä½œæ¥­ä¸€æ¨£ä¸æœƒç°¡å–®åˆ°å“ªè£¡å»çš„ï¼\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","æ¨¹","è³‡çµ"]},{"title":"[é¡Œè§£]TIOJ 1211 æœ€å°ç”Ÿæˆæ¨¹","url":"/sprout10-1/","content":"æœ€å°ç”Ÿæˆæ¨¹\né¡Œç›®é€£çµNEOJé¡Œç›®é€£çµTIOJå¯¦ä½œè¬›ç¾©è³‡èŠ½è¬›ç¾©\né€™ä¸€é¡Œæ‰‹åˆ»æœ€å°ç”Ÿæˆæ¨¹ï¼Œæ„Ÿè¦ºè »å¥½çš„ï¼Œéƒ½æ˜¯åˆ©ç”¨ä¸€äº›æ€§è³ªä¾†å¯¦ä½œæœ€å°ç”Ÿæˆæ¨¹\næ€§è³ªä¸€ï¼šæ¨¹æœ€å°ç”Ÿæˆåœ–ä¸€å®šæœƒæ˜¯ä¸€æ£µæ¨¹ï¼Œä¸å…·å‚™ç’°ï¼Œä¸”ä¸€å…±æœ‰n-1æ¢é‚Šå¦‚æœé€™å¼µåœ–ä¸æ˜¯æ¨¹ï¼Œå‰‡å¿…å®šæœ‰ç’°ï¼Œå³ä»£è¡¨å¯ä»¥å†æ‹”æ‰ä¸€æ¢é‚Šä½¿æ¬Šé‡å’Œæ›´å°\næ€§è³ªäºŒï¼šCycle PropertyCæ˜¯åœ–ä¸Šçš„ä¸€å€‹ç’°ï¼Œeæ˜¯Cä¸Šæ¬Šé‡æœ€å¤§ä¸€æ¢é‚Šï¼Œå‰‡eå¿…ä¸åœ¨MSTä¸€éƒ¨åˆ†ï¼ˆè­‰æ˜ï¼šåè­‰ï¼Œå‡è¨­eåœ¨MSTï¼Œå‰‡åŠ å…¥å¦ä¸€é‚Šæ¯”eæ¬Šé‡æ›´å°å½¢æˆç’°ï¼Œæ­¤æ™‚æŠŠeæ‹”æ‰å¯ä»¥å½¢æˆæ›´å°çš„æ¬Šé‡å’Œï¼Œå› æ­¤çŸ›ç›¾ï¼‰\næ€§è³ªä¸‰ï¼šCut PropertyæŠŠåœ–ä¸Šçš„é»é›†åˆ†å‰²æˆå…©åŠï¼Œå‰‡cutä¸Šé¢çš„é‚Šé›†åˆä¸­æœ€å°æ¬Šé‡çš„é‚Šeæœƒåœ¨MSTè£¡é¢ï¼ˆè­‰æ˜ï¼šåè­‰ï¼Œå‡è¨­eä¸åœ¨MSTï¼Œå‰‡åŠ å…¥eæœƒå½¢æˆé€£æ¥å…©åŠç¯€é»çš„ç’°ï¼Œæ­¤æ™‚æ‹”æ‰å¦ä¸€æ¯”eæ¬Šé‡å¤§çš„é‚Šï¼Œæœƒå½¢æˆæ›´å°æ¬Šé‡å’Œï¼Œå› æ­¤çŸ›ç›¾ï¼‰\nåˆ©ç”¨æ€§è³ªäºŒã€æ€§è³ªä¸‰ï¼Œå°±å¯ä»¥åˆ©ç”¨Kruskalæ¼”ç®—æ³•ï¼šåˆ©ç”¨åˆ°ä½µæŸ¥é›†çš„ç¶­è­·æ­é…è·¯å¾‘å£“ç¸®ï¼Œå¯ä»¥å¿«é€Ÿåˆ¤æ–·ä¸€å€‹å…ƒç´ æ˜¯å¦èˆ‡å¦ä¸€å€‹å…ƒç´ åŒå±¬ä¸€å€‹é›†åˆï¼ˆè¤‡é›œåº¦å¹¾ä¹å¯ä»¥$O(1)$ï¼Œæ›´æº–ç¢ºä¾†èªªæ˜¯$O(\\alpha)$ï¼‰ï¼ŒKruskalç¸½è¤‡é›œåº¦ç‚º $O(ElogE)$å¦å¤–é‚„æœ‰ä¸€ç¨®å¯¦ä½œæ–¹å¼Primâ€™s algorithmï¼Œç­‰ç­‰å†çœ‹\n\n            å¯¦ä½œæ­¥é©Ÿ1. åˆå§‹åŒ–è¨­å®šï¼š è¨­å®šå¥½bossä»¥åŠé›†åˆå¤§å°ç­‰åƒæ•¸2. å°æ‰€æœ‰çš„é‚Šä¾ç…§æ¬Šé‡æ’åºï¼š åˆ©ç”¨$O(m\\log m)$çš„æ™‚é–“æ’åºï¼Œå°‡é‚Šä¾ç…§æ¬Šé‡ç”±å°åˆ°å¤§åŠ å…¥MSTä¸­3. ä¾åºåŠ å…¥é‚Šï¼š ä»¥ä¸‹æœƒæœ‰å…©ç¨®æƒ…æ³ï¼Œå¯ä»¥ç”¨ä¸¦æŸ¥é›†+è·¯å¾‘å£“ç¸®ï¼ˆå„ªåŒ–ï¼‰åˆ¤æ–·æ˜¯å¦æœƒå½¢æˆç’°Case 1: å¦‚æœåŠ äº†é€™æ¢é‚Šå½¢æˆç’°ï¼ˆæŸ¥åˆ°æœ‰ä¸€æ¨£çš„bossï¼‰é‚£é€™æ¢é‚Šæœƒæ˜¯é€™å€‹ç’°ä¸Šçš„æœ€å¤§é‚Šæ ¹æ“š Cycle propertyï¼Œé€™æ¢é‚Šä¸æœƒæ˜¯MSTçš„ä¸€éƒ¨åˆ†Case 2: åŠ äº†é€™æ¢é‚Šä¸æœƒå½¢æˆç’°é‚£é€™æ¢é‚Šæ˜¯æ¢æ©‹ï¼Œé€£æ¥å·¦å³å…©æ£µæ¨¹æ ¹æ“š Cut Propertyï¼Œå› ç‚ºé€™æ¢é‚Šæ˜¯é€™å€‹ cut ä¸Šæœ€å°çš„é‚Šæ‰€ä»¥é€™æ¢é‚Šæœƒæ˜¯ MST çš„ä¸€éƒ¨åˆ†4. åˆ¤æ–·æ˜¯å¦åˆæ³•ï¼š nå€‹é»æ‰€å½¢æˆçš„æ¨¹æœƒæœ‰n-1æ¢é‚Šï¼Œæœ€å°ç”Ÿæˆæ¨¹æ˜¯ä¸€æ£µæ¨¹å°±å¿…é ˆæ»¿è¶³æ¢ä»¶ã€‚\n          \nKRUSKALâ€™S ALGORITHM\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,num[N],boss[N];struct Node&#123;    int x,y,w;&#125;edge[N];bool cmp(Node a, Node b)&#123;    return a.w &lt; b.w;&#125;int findboss(int a)&#123;                    //å°‹æ‰¾é›†åˆçš„è€å¤§ï¼ˆä»£è¡¨æ•´å€‹é›†åˆï¼‰    if(a==boss[a])return a;    return boss[a]=findboss(boss[a]);   //éè¿´æ­é…è·¯å¾‘å£“ç¸®&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].w;    &#125;    for(int i=0;i&lt;n;i++)&#123;        num[i] = 1;        boss[i] = i;    &#125;    sort(edge,edge+m,cmp);                 //ä¾ç…§æ¬Šé‡å¤§å°æ”¾å…¥MST    int result = 0,num_edge = 0;    for(int i=0;i&lt;m &amp;&amp; num_edge&lt;n;i++)&#123;    //æ¨¹å¿…é ˆæ»¿è¶³å°æ–¼n-1æ¢é‚Š        int a = findboss(edge[i].x),b = findboss(edge[i].y);        if(a!=b)&#123;                          //bossä¸åŒå¯ä»¥æ”¾å…¥MSTï¼ˆåŠ å…¥ä¸æœƒå½¢æˆç’°by Cut Propertyï¼‰            if(num[a]&gt;=num[b])&#123;            //åŸ·è¡Œå•Ÿç™¼å¼åˆä½µ                boss[b] = a;                num[a]+=num[b];            &#125;            else&#123;                boss[a] = b;                num[b]+=num[a];            &#125;            result+=edge[i].w;            num_edge++;        &#125;    &#125;    cout&lt;&lt;result&lt;&lt;endl;    //é€™é‚Šå¯ä»¥åˆ¤æ–·num_edge==n-1æœ‰æ²’æœ‰æˆç«‹ï¼Œä¸éé¡Œç›®æ˜¯è¼¸å…¥éƒ½å¯ä»¥å½¢æˆMST&#125;\nPrimâ€™s Algorithmæ˜¯ä¸€ç¨®è²ªå©ªæ¼”ç®—æ³•ï¼Œé¦–å…ˆå–ä»»ä¸€é»åŠ å…¥æœ€å°ç”Ÿæˆæ¨¹ä¸­ï¼Œæ¥è‘—å°‡é€£åˆ°çš„é‚ŠåŠ å…¥heapä¸­ï¼Œæ¯ä¸€æ¬¡å–å‡ºheapä¸­é‚Šæ¬Šé‡æœ€å°çš„é‚Šï¼Œå¦‚æœé€™ä¸€æ¢é‚Šé€£åˆ°çš„é»å°šæœªè¢«èµ°è¨ªï¼Œå‰‡åŠ å…¥é€™ä¸€æ¢é‚Šç‚ºæœ€å°ç”Ÿæˆæ•¸ã€‚æ­£ç¢ºæ€§è­‰æ˜å‰‡å¯ç”¨cut proprityè­‰æ˜æ¯æ¬¡éƒ½åŠ å…¥æ¬Šé‡æœ€å°çš„é‚Šå³ç‚ºæœ€å°ç”Ÿæˆæ•¸ã€‚\n\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 200005#define eps 1e-9#define x first#define y secondusing namespace std;int n,m;bool visit[N];struct node&#123;    int to,w;&#125;;vector&lt;node&gt; edge[N];struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.w &gt; b.w;    &#125;&#125;;signed main()&#123;    Orz;    memset(visit,0,sizeof(visit));    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,m-1)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;    visit[1] = 1;    for(auto i : edge[1])pq.push(i);    int num_edge = 0,ans = 0;    while(num_edge &lt; n-1)&#123;        node x = pq.top();pq.pop();        if(visit[x.to])continue;        visit[x.to] = 1;        num_edge += 1;        ans += x.w;        for(auto i : edge[x.to])&#123;            pq.push(i);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 169 é«˜æ£•æ«šçš„æ„å¤–æ”¶ç©«","url":"/sprout10-2/","content":"é«˜æ£•æ«šçš„æ„å¤–æ”¶ç©«\né¡Œç›®é€£çµè¬›ç¾©é€£çµ\né€™ä¸€é¡Œå°±æ˜¯æŒ‰ç…§å­—å…¸åºprintå‡ºå°¤æ‹‰è·¯å¾‘ï¼Œç‰¹åˆ¥ç”¨é„°æ¥çŸ©é™£ä¾†å­˜åœ–æ˜¯å› ç‚ºè¦æŒ‰ç…§å­—å…¸åºè¼¸å‡ºï¼Œå¦‚æœç”¨éˆçµä¸²åˆ—ä¾†å­˜é‚„è¦èŠ±æ™‚é–“æ’åºï¼Œå› æ­¤ç”¨å¤§ä¸€é»çš„ç©ºé–“ä¾†ç¯€çœæ™‚é–“\nå°¤æ‹‰è·¯å¾‘ä¹Ÿæ˜¯ä¸€ç­†ç•«å•é¡Œï¼Œæ¯ä¸€å€‹ç¯€é»ä¸€å®šæœƒæœ‰é€²æœ‰å‡ºï¼Œå› æ­¤åŸå…ˆçš„ç„¡å‘åœ–ä¸Šæ¯ä¸€é»ä¸€å®šåº¦æ•¸ç‚ºå¶æ•¸ï¼Œè‹¥æœ‰å¥‡é»å‰‡é¸æ“‡å…¶ä¸­ä¸€å€‹å¥‡é»ä½œç‚ºèµ·é»ï¼Œç•¶å¥‡é»æ•¸é‡è¶…éå…©å€‹å‰‡ä»£è¡¨ç„¡è§£ã€‚æˆ‘å€‘å°‡DFSçš„éç¨‹ä¸­é›¢é–‹ç•¶å‰ç¯€é»çš„é †åºç´€éŒ„èµ·ä¾†ï¼Œé€†åºè¼¸å‡ºå°±æ˜¯ä¸€çµ„åˆæ³•æ­æ‹‰è¿´è·¯çš„è§£äº†ï¼\n            å¯¦ä½œç¨‹åº1. åˆ¤æ–·å¥‡é»å€‹æ•¸ï¼Œè‹¥å¥‡é»å€‹æ•¸kï¼šk &gt; 2ï¼Œé‚£éº¼ç„¡è§£k = 2ï¼Œå‰‡é¸æ“‡å…¶ä¸­ä¸€å€‹å¥‡é»ä½œç‚ºèµ·é»k = 0ï¼Œå‰‡é¸æ“‡ä»»æ„ä¸€å€‹é»ä½œç‚ºèµ·é»2. DFS åŸ·è¡Œä¸‹åˆ—æ­¥é©Ÿè‹¥ç•¶å‰ç¯€é»é‚„æœ‰å°šæœªèµ°éçš„é‚Šï¼Œé‚£éº¼æ‹œè¨ªè©²é‚Šï¼Œä¸¦åœ¨æ‹œè¨ªå®Œå¾Œè¼¸å‡ºè©²é‚Šå¦å‰‡é›¢é–‹ç•¶å‰çµé»3. è‹¥é‚„æœ‰ç¯€é»å°šæœªæ‹œè¨ªï¼Œå‰‡ç„¡è§£4. å¦å‰‡è¼¸å‡ºé †åºå³ç‚ºä¸€çµ„è§£\n          \n#include &lt;bits/stdc++.h&gt;#define N 501using namespace std;int n,Edge[N][N],ans[1025],ind = 0;void DFS(int cur)&#123;    for(int i=1;i&lt;=500;i++)&#123;        if(Edge[cur][i])&#123;            Edge[cur][i]--;Edge[i][cur]--;            DFS(i);        &#125;    &#125;    ans[ind++] = cur;&#125;signed main()&#123;    cin&gt;&gt;n;    memset(Edge, 0, sizeof(Edge));    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        Edge[a][b]++;        Edge[b][a]++;    &#125;    int start = 1;                //é–‹å§‹çš„ç¯€é»ç·¨è™Ÿ    for(int i=1;i&lt;=500;i++)&#123;        int sum = 0;        for(int j=1;j&lt;=500;j++)&#123;            sum+=Edge[i][j];        &#125;        if(sum%2!=0)&#123;             //æ‰¾åˆ°ç¬¬ä¸€å€‹åº¦æ•¸ç‚ºå¥‡æ•¸çš„ç¯€é»            start = i;            break;        &#125;    &#125;    DFS(start);    for(int i=ind-1;i&gt;=0;i--)cout&lt;&lt;ans[i]&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 165 é™£ç·šæ¨é€²","url":"/sprout10-3/","content":"é™£ç·šæ¨é€²\né¡Œç›®é€£çµæ‹“å¢£æ’åºé¡Œï¼Œå…©ç¨®å¯¦ä½œæ–¹å¼ï¼Œç¬¬ä¸€æ˜¯BFSè®Šå½¢å¯¦ä½œï¼ˆqueueå¯¦ä½œï¼‰ï¼Œè¢«popå‡ºä¾†çš„é †åºå°±æ˜¯topological sortç¬¬äºŒç¨®å°±æ˜¯DFSæ­é…æ™‚é–“æˆ³è¨˜ï¼Œæœ€æ™šé›¢é–‹çš„æ”¾åœ¨æœ€å‰é¢\né€™ä¸€é¡Œæ˜¯æŠŠå…¥åº¦ç‚º0çš„ç¯€é»å…ˆpushé€²priority_queueï¼ˆæŒ‰ç…§å­—å…¸åºï¼‰ï¼Œç•¶ä¸€å€‹é»è™•ç†éä¹‹å¾Œï¼Œå…¥åº¦è®Šæˆ0çš„æ‰€æœ‰å®ƒæŒ‡å‘çš„é»åœ¨pushé€²queueè£¡é¢æ‹“å¢£æ’åºå¯ä»¥ç”¨åœ¨DAGçš„åˆ¤å®šä»¥åŠè§£æ±ºå…·æœ‰ä¾è³´é—œä¿‚çš„å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define N 100001using namespace std;int t,n,m,deg[N];//å…¥åº¦int ans[N],ind = 0;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        memset(deg,0,sizeof(deg));        memset(ans, 0, sizeof(ans));        ind = 0;        vector&lt;int&gt; edge[N];        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;m;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            deg[b]++;        &#125;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qq;//priority_queueå–ä»£queue        for(int i=0;i&lt;n;i++)if(deg[i]==0)qq.push(i);        while(!qq.empty())&#123;            int cur = qq.top();            qq.pop();            ans[ind++] = cur;            int len = edge[cur].size();            for(int i=0;i&lt;len;i++)&#123;                deg[edge[cur][i]]--;                if(deg[edge[cur][i]]==0)                    qq.push(edge[cur][i]);            &#125;        &#125;        if(ind==n)&#123;            cout&lt;&lt;ans[0];            for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];            cout&lt;&lt;endl;        &#125;        else cout&lt;&lt;&quot;QAQ&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬åé€±ï¼šé€²éšåœ–è«–ï¼ˆä¸€ï¼‰","url":"/sprout10/","content":"ä¸Šèª²å…§å®¹ä¸¦æŸ¥é›† Disjoint Setç›®æ¨™ï¼šå¿«é€Ÿåˆ¤æ–·å…©å€‹å…ƒç´ æ˜¯å¦åŒå±¬ä¸€å€‹é›†åˆåŠŸèƒ½ï¼šè©¢å•å…ƒç´ éš¸å±¬çš„é›†åˆã€åˆä½µå…©å€‹é›†åˆï¼Œåœ¨åœ–è«–ä¸­ï¼Œé›†åˆé€šå¸¸è¡¨ç¤ºé€£é€šå¿«ï¼Œä¸¦æŸ¥é›†å¯ä»¥æŸ¥è©¢ä»»å…©é»æ˜¯å¦é€£é€šã€‚åœ¨å¯¦ä½œMSTçš„æ™‚å€™ï¼Œç•¶æˆ‘å€‘è¦æª¢æŸ¥å…©å€‹é»é€£æ¥æˆçš„é‚Šæ˜¯å¦æœƒè·Ÿå…¶ä»–å·²ç¶“åŠ å…¥çš„é‚Šå½¢æˆç’°ï¼Œå°±æœƒä½¿ç”¨ä¸¦æŸ¥é›†å¹«åŠ©æˆ‘å€‘åˆ¤æ–·ï¼è¤‡é›œåº¦ï¼šéå¸¸å„ªç§€ï¼Œå¯ä»¥èªªæ˜¯O(1)#include &lt;bits/stdc++.h&gt;#define N 100001using namespace std;int n,boss[N],num[N];int find_boss(int a)&#123;        //ä½¿ç”¨è·¯å¾‘å£“ç¸®    if(a==boss[a])return a;    else return boss[a] = find_boss(boss[a]);&#125;void merge(int a,int b)&#123;    //å•Ÿç™¼å¼åˆä½µ    if(num[a]&gt;=num[b])&#123;     //è¼ƒå°çš„é›†åˆåˆä½µåˆ°è¼ƒå¤§çš„é›†åˆ        num[a] += num[b];        boss[b] = a;    &#125;    else&#123;        num[b] += num[a];        boss[a] = b;    &#125;&#125;signed main()&#123;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)&#123;        boss[i] = i;        num[i] = 1;    &#125;    while(1)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;                    //è¦æŸ¥è©¢å…©å€‹å…ƒç´         a = find_boss(a),b = find_boss(b);    //åˆ¤æ–·æ˜¯å¦åŒå±¬ä¸€å€‹é›†åˆ        if(a!=b)&#123;                             //è€å¤§ä¸åŒå±¬ä¸åŒé›†åˆ            cout&lt;&lt;&quot;ä¸åŒé›†åˆ&quot;&lt;&lt;endl;            merge(a, b);        &#125;        else cout&lt;&lt;&quot;åŒé›†åˆ&quot;&lt;&lt;endl;        for(int i=1;i&lt;=n;i++)cout&lt;&lt;boss[i]&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;&#125;\n\n            è·¯å¾‘å£“ç¸®åœ¨å›å‚³éç¨‹ä¸­é †ä¾¿åˆ©ç”¨éè¿´æŠŠæ‰€ç¶“éçš„bossæŒ‡å‘æœ€ä¸Šé¢çš„bossï¼Œç”±å·¦åœ–è®Šæˆå³åœ–ï¼Œæ•ˆç‡æ›´é«˜ï¼ˆå¯¦æ¸¬å…¶å¯¦å·®ä¸å¤šï¼Œå¯èƒ½lognå·²ç¶“å¤ å°åŠ ä¸Šéè¿´æœ¬ä¾†å°±æ¯”è¼ƒæ…¢ï¼‰ç”¨éè¿´å¯¦ç¾çš„ç‰¹æ€§å¯¦ç¾ï¼Œéè¿´æ‹‰ä¸Šä¾†çš„æ™‚å€™é †ä¾¿æ›´æ–°boss[x]ï¼šè·¯å¾‘å£“ç¸®æ­é…å•Ÿç™¼å¼åˆä½µï¼Œè¤‡é›œåº¦ï¼š$O(Î±(N))$ç­‰åŒå¸¸æ•¸\n          \nä¸Šæ©Ÿä½œæ¥­æœ€å°ç”Ÿæˆæ¨¹é¡Œç›®é€£çµNEOJé¡Œç›®é€£çµTIOJå¯¦ä½œè¬›ç¾©è³‡èŠ½è¬›ç¾©\né€™ä¸€é¡Œæ‰‹åˆ»æœ€å°ç”Ÿæˆæ¨¹ï¼Œæ„Ÿè¦ºè »å¥½çš„ï¼Œéƒ½æ˜¯åˆ©ç”¨ä¸€äº›æ€§è³ªä¾†å¯¦ä½œæœ€å°ç”Ÿæˆæ¨¹\næ€§è³ªä¸€ï¼šæ¨¹æœ€å°ç”Ÿæˆåœ–ä¸€å®šæœƒæ˜¯ä¸€æ£µæ¨¹ï¼Œä¸å…·å‚™ç’°ï¼Œä¸”ä¸€å…±æœ‰n-1æ¢é‚Šå¦‚æœé€™å¼µåœ–ä¸æ˜¯æ¨¹ï¼Œå‰‡å¿…å®šæœ‰ç’°ï¼Œå³ä»£è¡¨å¯ä»¥å†æ‹”æ‰ä¸€æ¢é‚Šä½¿æ¬Šé‡å’Œæ›´å°\næ€§è³ªäºŒï¼šCycle PropertyCæ˜¯åœ–ä¸Šçš„ä¸€å€‹ç’°ï¼Œeæ˜¯Cä¸Šæ¬Šé‡æœ€å¤§ä¸€æ¢é‚Šï¼Œå‰‡eå¿…ä¸åœ¨MSTä¸€éƒ¨åˆ†ï¼ˆè­‰æ˜ï¼šåè­‰ï¼Œå‡è¨­eåœ¨MSTï¼Œå‰‡åŠ å…¥å¦ä¸€é‚Šæ¯”eæ¬Šé‡æ›´å°å½¢æˆç’°ï¼Œæ­¤æ™‚æŠŠeæ‹”æ‰å¯ä»¥å½¢æˆæ›´å°çš„æ¬Šé‡å’Œï¼Œå› æ­¤çŸ›ç›¾ï¼‰\næ€§è³ªä¸‰ï¼šCut PropertyæŠŠåœ–ä¸Šçš„é»é›†åˆ†å‰²æˆå…©åŠï¼Œå‰‡cutä¸Šé¢çš„é‚Šé›†åˆä¸­æœ€å°æ¬Šé‡çš„é‚Šeæœƒåœ¨MSTè£¡é¢ï¼ˆè­‰æ˜ï¼šåè­‰ï¼Œå‡è¨­eä¸åœ¨MSTï¼Œå‰‡åŠ å…¥eæœƒå½¢æˆé€£æ¥å…©åŠç¯€é»çš„ç’°ï¼Œæ­¤æ™‚æ‹”æ‰å¦ä¸€æ¯”eæ¬Šé‡å¤§çš„é‚Šï¼Œæœƒå½¢æˆæ›´å°æ¬Šé‡å’Œï¼Œå› æ­¤çŸ›ç›¾ï¼‰\nåˆ©ç”¨æ€§è³ªäºŒã€æ€§è³ªä¸‰ï¼Œå°±å¯ä»¥åˆ©ç”¨Kruskalæ¼”ç®—æ³•ï¼šåˆ©ç”¨åˆ°ä½µæŸ¥é›†çš„ç¶­è­·æ­é…è·¯å¾‘å£“ç¸®ï¼Œå¯ä»¥å¿«é€Ÿåˆ¤æ–·ä¸€å€‹å…ƒç´ æ˜¯å¦èˆ‡å¦ä¸€å€‹å…ƒç´ åŒå±¬ä¸€å€‹é›†åˆï¼ˆè¤‡é›œåº¦å¹¾ä¹å¯ä»¥$O(1)$ï¼Œæ›´æº–ç¢ºä¾†èªªæ˜¯$O(\\alpha)$ï¼‰ï¼ŒKruskalç¸½è¤‡é›œåº¦ç‚º $O(ElogE)$å¦å¤–é‚„æœ‰ä¸€ç¨®å¯¦ä½œæ–¹å¼Primâ€™s algorithmï¼Œç­‰ç­‰å†çœ‹\n\n            å¯¦ä½œæ­¥é©Ÿ1. åˆå§‹åŒ–è¨­å®šï¼š è¨­å®šå¥½bossä»¥åŠé›†åˆå¤§å°ç­‰åƒæ•¸2. å°æ‰€æœ‰çš„é‚Šä¾ç…§æ¬Šé‡æ’åºï¼š åˆ©ç”¨$O(m\\log m)$çš„æ™‚é–“æ’åºï¼Œå°‡é‚Šä¾ç…§æ¬Šé‡ç”±å°åˆ°å¤§åŠ å…¥MSTä¸­3. ä¾åºåŠ å…¥é‚Šï¼š ä»¥ä¸‹æœƒæœ‰å…©ç¨®æƒ…æ³ï¼Œå¯ä»¥ç”¨ä¸¦æŸ¥é›†+è·¯å¾‘å£“ç¸®ï¼ˆå„ªåŒ–ï¼‰åˆ¤æ–·æ˜¯å¦æœƒå½¢æˆç’°Case 1: å¦‚æœåŠ äº†é€™æ¢é‚Šå½¢æˆç’°ï¼ˆæŸ¥åˆ°æœ‰ä¸€æ¨£çš„bossï¼‰é‚£é€™æ¢é‚Šæœƒæ˜¯é€™å€‹ç’°ä¸Šçš„æœ€å¤§é‚Šæ ¹æ“š Cycle propertyï¼Œé€™æ¢é‚Šä¸æœƒæ˜¯MSTçš„ä¸€éƒ¨åˆ†Case 2: åŠ äº†é€™æ¢é‚Šä¸æœƒå½¢æˆç’°é‚£é€™æ¢é‚Šæ˜¯æ¢æ©‹ï¼Œé€£æ¥å·¦å³å…©æ£µæ¨¹æ ¹æ“š Cut Propertyï¼Œå› ç‚ºé€™æ¢é‚Šæ˜¯é€™å€‹ cut ä¸Šæœ€å°çš„é‚Šæ‰€ä»¥é€™æ¢é‚Šæœƒæ˜¯ MST çš„ä¸€éƒ¨åˆ†4. åˆ¤æ–·æ˜¯å¦åˆæ³•ï¼š nå€‹é»æ‰€å½¢æˆçš„æ¨¹æœƒæœ‰n-1æ¢é‚Šï¼Œæœ€å°ç”Ÿæˆæ¨¹æ˜¯ä¸€æ£µæ¨¹å°±å¿…é ˆæ»¿è¶³æ¢ä»¶ã€‚\n          \nKRUSKALâ€™S ALGORITHM\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 200005#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,m,num[N],boss[N];struct Node&#123;    int x,y,w;&#125;edge[N];bool cmp(Node a, Node b)&#123;    return a.w &lt; b.w;&#125;int findboss(int a)&#123;                    //å°‹æ‰¾é›†åˆçš„è€å¤§ï¼ˆä»£è¡¨æ•´å€‹é›†åˆï¼‰    if(a==boss[a])return a;    return boss[a]=findboss(boss[a]);   //éè¿´æ­é…è·¯å¾‘å£“ç¸®&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].w;    &#125;    for(int i=0;i&lt;n;i++)&#123;        num[i] = 1;        boss[i] = i;    &#125;    sort(edge,edge+m,cmp);                 //ä¾ç…§æ¬Šé‡å¤§å°æ”¾å…¥MST    int result = 0,num_edge = 0;    for(int i=0;i&lt;m &amp;&amp; num_edge&lt;n;i++)&#123;    //æ¨¹å¿…é ˆæ»¿è¶³å°æ–¼n-1æ¢é‚Š        int a = findboss(edge[i].x),b = findboss(edge[i].y);        if(a!=b)&#123;                          //bossä¸åŒå¯ä»¥æ”¾å…¥MSTï¼ˆåŠ å…¥ä¸æœƒå½¢æˆç’°by Cut Propertyï¼‰            if(num[a]&gt;=num[b])&#123;            //åŸ·è¡Œå•Ÿç™¼å¼åˆä½µ                boss[b] = a;                num[a]+=num[b];            &#125;            else&#123;                boss[a] = b;                num[b]+=num[a];            &#125;            result+=edge[i].w;            num_edge++;        &#125;    &#125;    cout&lt;&lt;result&lt;&lt;endl;    //é€™é‚Šå¯ä»¥åˆ¤æ–·num_edge==n-1æœ‰æ²’æœ‰æˆç«‹ï¼Œä¸éé¡Œç›®æ˜¯è¼¸å…¥éƒ½å¯ä»¥å½¢æˆMST&#125;\nPrimâ€™s Algorithmæ˜¯ä¸€ç¨®è²ªå©ªæ¼”ç®—æ³•ï¼Œé¦–å…ˆå–ä»»ä¸€é»åŠ å…¥æœ€å°ç”Ÿæˆæ¨¹ä¸­ï¼Œæ¥è‘—å°‡é€£åˆ°çš„é‚ŠåŠ å…¥heapä¸­ï¼Œæ¯ä¸€æ¬¡å–å‡ºheapä¸­é‚Šæ¬Šé‡æœ€å°çš„é‚Šï¼Œå¦‚æœé€™ä¸€æ¢é‚Šé€£åˆ°çš„é»å°šæœªè¢«èµ°è¨ªï¼Œå‰‡åŠ å…¥é€™ä¸€æ¢é‚Šç‚ºæœ€å°ç”Ÿæˆæ•¸ã€‚æ­£ç¢ºæ€§è­‰æ˜å‰‡å¯ç”¨cut proprityè­‰æ˜æ¯æ¬¡éƒ½åŠ å…¥æ¬Šé‡æœ€å°çš„é‚Šå³ç‚ºæœ€å°ç”Ÿæˆæ•¸ã€‚\n\n#include &lt;bits/stdc++.h&gt;#define Orz ios::sync_with_stdio(0),cin.tie(0)#define rep(i,a,b) for(int i=a;i&lt;=b;i++)#define pii pair&lt;int,int&gt;#define pdd pair&lt;double,double&gt;#define int long long#define ll long long#define ld long double#define N 200005#define eps 1e-9#define x first#define y secondusing namespace std;int n,m;bool visit[N];struct node&#123;    int to,w;&#125;;vector&lt;node&gt; edge[N];struct cmp&#123;    bool operator()(node a,node b)&#123;        return a.w &gt; b.w;    &#125;&#125;;signed main()&#123;    Orz;    memset(visit,0,sizeof(visit));    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,m-1)&#123;        int a,b,w;cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;        edge[a].push_back(&#123;b,w&#125;);        edge[b].push_back(&#123;a,w&#125;);    &#125;    priority_queue&lt;node,vector&lt;node&gt;,cmp&gt; pq;    visit[1] = 1;    for(auto i : edge[1])pq.push(i);    int num_edge = 0,ans = 0;    while(num_edge &lt; n-1)&#123;        node x = pq.top();pq.pop();        if(visit[x.to])continue;        visit[x.to] = 1;        num_edge += 1;        ans += x.w;        for(auto i : edge[x.to])&#123;            pq.push(i);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\né«˜æ£•æ«šçš„æ„å¤–æ”¶ç©«é¡Œç›®é€£çµè¬›ç¾©é€£çµ\né€™ä¸€é¡Œå°±æ˜¯æŒ‰ç…§å­—å…¸åºprintå‡ºå°¤æ‹‰è·¯å¾‘ï¼Œç‰¹åˆ¥ç”¨é„°æ¥çŸ©é™£ä¾†å­˜åœ–æ˜¯å› ç‚ºè¦æŒ‰ç…§å­—å…¸åºè¼¸å‡ºï¼Œå¦‚æœç”¨éˆçµä¸²åˆ—ä¾†å­˜é‚„è¦èŠ±æ™‚é–“æ’åºï¼Œå› æ­¤ç”¨å¤§ä¸€é»çš„ç©ºé–“ä¾†ç¯€çœæ™‚é–“\nå°¤æ‹‰è·¯å¾‘ä¹Ÿæ˜¯ä¸€ç­†ç•«å•é¡Œï¼Œæ¯ä¸€å€‹ç¯€é»ä¸€å®šæœƒæœ‰é€²æœ‰å‡ºï¼Œå› æ­¤åŸå…ˆçš„ç„¡å‘åœ–ä¸Šæ¯ä¸€é»ä¸€å®šåº¦æ•¸ç‚ºå¶æ•¸ï¼Œè‹¥æœ‰å¥‡é»å‰‡é¸æ“‡å…¶ä¸­ä¸€å€‹å¥‡é»ä½œç‚ºèµ·é»ï¼Œç•¶å¥‡é»æ•¸é‡è¶…éå…©å€‹å‰‡ä»£è¡¨ç„¡è§£ã€‚æˆ‘å€‘å°‡DFSçš„éç¨‹ä¸­é›¢é–‹ç•¶å‰ç¯€é»çš„é †åºç´€éŒ„èµ·ä¾†ï¼Œé€†åºè¼¸å‡ºå°±æ˜¯ä¸€çµ„åˆæ³•æ­æ‹‰è¿´è·¯çš„è§£äº†ï¼\n            å¯¦ä½œç¨‹åº1. åˆ¤æ–·å¥‡é»å€‹æ•¸ï¼Œè‹¥å¥‡é»å€‹æ•¸kï¼šk &gt; 2ï¼Œé‚£éº¼ç„¡è§£k = 2ï¼Œå‰‡é¸æ“‡å…¶ä¸­ä¸€å€‹å¥‡é»ä½œç‚ºèµ·é»k = 0ï¼Œå‰‡é¸æ“‡ä»»æ„ä¸€å€‹é»ä½œç‚ºèµ·é»2. DFS åŸ·è¡Œä¸‹åˆ—æ­¥é©Ÿè‹¥ç•¶å‰ç¯€é»é‚„æœ‰å°šæœªèµ°éçš„é‚Šï¼Œé‚£éº¼æ‹œè¨ªè©²é‚Šï¼Œä¸¦åœ¨æ‹œè¨ªå®Œå¾Œè¼¸å‡ºè©²é‚Šå¦å‰‡é›¢é–‹ç•¶å‰çµé»3. è‹¥é‚„æœ‰ç¯€é»å°šæœªæ‹œè¨ªï¼Œå‰‡ç„¡è§£4. å¦å‰‡è¼¸å‡ºé †åºå³ç‚ºä¸€çµ„è§£\n          \n#include &lt;bits/stdc++.h&gt;#define N 501using namespace std;int n,Edge[N][N],ans[1025],ind = 0;void DFS(int cur)&#123;    for(int i=1;i&lt;=500;i++)&#123;        if(Edge[cur][i])&#123;            Edge[cur][i]--;Edge[i][cur]--;            DFS(i);        &#125;    &#125;    ans[ind++] = cur;&#125;signed main()&#123;    cin&gt;&gt;n;    memset(Edge, 0, sizeof(Edge));    for(int i=0;i&lt;n;i++)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        Edge[a][b]++;        Edge[b][a]++;    &#125;    int start = 1;                //é–‹å§‹çš„ç¯€é»ç·¨è™Ÿ    for(int i=1;i&lt;=500;i++)&#123;        int sum = 0;        for(int j=1;j&lt;=500;j++)&#123;            sum+=Edge[i][j];        &#125;        if(sum%2!=0)&#123;             //æ‰¾åˆ°ç¬¬ä¸€å€‹åº¦æ•¸ç‚ºå¥‡æ•¸çš„ç¯€é»            start = i;            break;        &#125;    &#125;    DFS(start);    for(int i=ind-1;i&gt;=0;i--)cout&lt;&lt;ans[i]&lt;&lt;endl;&#125;\né™£ç·šæ¨é€²é¡Œç›®é€£çµæ‹“å¢£æ’åºé¡Œï¼Œå…©ç¨®å¯¦ä½œæ–¹å¼ï¼Œç¬¬ä¸€æ˜¯BFSè®Šå½¢å¯¦ä½œï¼ˆqueueå¯¦ä½œï¼‰ï¼Œè¢«popå‡ºä¾†çš„é †åºå°±æ˜¯topological sortç¬¬äºŒç¨®å°±æ˜¯DFSæ­é…æ™‚é–“æˆ³è¨˜ï¼Œæœ€æ™šé›¢é–‹çš„æ”¾åœ¨æœ€å‰é¢\né€™ä¸€é¡Œæ˜¯æŠŠå…¥åº¦ç‚º0çš„ç¯€é»å…ˆpushé€²priority_queueï¼ˆæŒ‰ç…§å­—å…¸åºï¼‰ï¼Œç•¶ä¸€å€‹é»è™•ç†éä¹‹å¾Œï¼Œå…¥åº¦è®Šæˆ0çš„æ‰€æœ‰å®ƒæŒ‡å‘çš„é»åœ¨pushé€²queueè£¡é¢æ‹“å¢£æ’åºå¯ä»¥ç”¨åœ¨DAGçš„åˆ¤å®šä»¥åŠè§£æ±ºå…·æœ‰ä¾è³´é—œä¿‚çš„å•é¡Œ\n#include &lt;bits/stdc++.h&gt;#define N 100001using namespace std;int t,n,m,deg[N];//å…¥åº¦int ans[N],ind = 0;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        memset(deg,0,sizeof(deg));        memset(ans, 0, sizeof(ans));        ind = 0;        vector&lt;int&gt; edge[N];        cin&gt;&gt;n&gt;&gt;m;        for(int i=0;i&lt;m;i++)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            deg[b]++;        &#125;        priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; qq;//priority_queueå–ä»£queue        for(int i=0;i&lt;n;i++)if(deg[i]==0)qq.push(i);        while(!qq.empty())&#123;            int cur = qq.top();            qq.pop();            ans[ind++] = cur;            int len = edge[cur].size();            for(int i=0;i&lt;len;i++)&#123;                deg[edge[cur][i]]--;                if(deg[edge[cur][i]]==0)                    qq.push(edge[cur][i]);            &#125;        &#125;        if(ind==n)&#123;            cout&lt;&lt;ans[0];            for(int i=1;i&lt;n;i++)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];            cout&lt;&lt;endl;        &#125;        else cout&lt;&lt;&quot;QAQ&quot;&lt;&lt;endl;    &#125;&#125;\næ‰‹å¯«ä½œæ¥­é€™ä¸€æ¬¡çš„æ‰‹å¯«ä¹Ÿè »å›°é›£çš„ï¼Œè¨è«–BIT(fenwick tree)çš„å¯¦ä½œä»¥åŠè¤‡é›œåº¦ï¼\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","åœ–è«–"]},{"title":"[é¡Œè§£]NEOJ 183 é«˜æ£•æ«šå‚³ééˆ","url":"/sprout11-1/","content":"é«˜æ£•æ«šå‚³ééˆ\né¡Œç›®é€£çµåœ¨ä¸€å¼µåœ–ä¸­æ‰¾å‰²é»ï¼ˆå®šç¾©ï¼šæ‹”æ‰å®ƒæ•´å¼µåœ–å°±ä¸é€£é€šäº†ï¼‰ä½œæ³•ï¼šå¦‚æœç”¨æš´åŠ›ï¼Œå¯ä»¥æ¯ä¸€å€‹é»æ‹”æ‰ï¼Œåšä¸€æ¬¡DFSåˆ¤æ–·æ˜¯å¦è¯é€šï¼ˆæ•ˆç‡å¤ªå·®ï¼‰\næ•ˆç‡æ›´é«˜çš„å°±æ˜¯Trajan æ¼”ç®—æ³•æ‰¾AP(articulation point)\n\n            Tarjanâ€™s algorithm æ‰¾ APé‚Šçš„ç¨®é¡å¯ä»¥åˆ†æˆï¼šTree edge,Back edge,Forward edge,Cross edgeï¼Œå…¶ä¸­ç„¡å‘åœ–ä¸­åªæœƒæœ‰æ¨¹é‚Šè·Ÿå›é‚Šï¼ˆæŒ‰ç…§ç„¡å‘é‚ŠDFSçš„çµæœï¼ŒFoward edge éƒ½æœƒè®Šæˆå­å­«çš„back edge, cross edge æœƒè®Šæˆæ¨¹é‚Šï¼‰ç¶­è­·ä¸€å€‹lowå‡½æ•¸ï¼Œä»£è¡¨ä¸ç¶“éçˆ¶ç¯€é»èƒ½åˆ°çš„æœ€å°æ™‚é–“æˆ³è¨˜ï¼ˆé€²å…¥ï¼‰çš„ç¯€é»ï¼Œlvå‡½æ•¸ç‚ºç•¶å‰ç¯€é»çš„æ™‚é–“æˆ³è¨˜ã€‚ä¸€å€‹é»æ˜¯ä¸æ˜¯å‰²é»ï¼Œåªè¦ä»–çš„ä»»æ„å­ç¯€é»çš„lowå‡½æ•¸å¤§æ–¼ç­‰æ–¼è‡ªå·±çš„æ™‚é–“æˆ³è¨˜ç·¨è™Ÿï¼Œé‚£æŠŠé€™å€‹é»æ‹”æ‰ï¼Œä»–å°å­©å°±èµ°ä¸åˆ°ç¥–å…ˆäº†ï¼ˆå¦‚æœèµ°å¾—åˆ°ç¥–å…ˆï¼Œå°æ–¼é€™ä¸€æ£µå­æ¨¹ï¼Œæ‹”æ‰ç•¶å‰ç¯€é»å°±å¯åˆ©ç”¨æ­¤é‚Šç¹¼çºŒé€£é€šï¼‰ï¼Œæ‰€ä»¥ä»–å°±æ˜¯å‰²é»ã€‚æ›´æ–°ï¼š$low[now] = min(low[now],low[next])$åˆ†åˆ¥ç‚ºåˆ©ç”¨å­å­«æˆ–é è‡ªå·±\n          \nå¿…é ˆè¦æ³¨æ„çš„æ˜¯ï¼Œå‰²é»åˆ¤æ–·æ™‚è¦æŠŠrootçš„ç‰¹ä¾‹ç¨ç«‹åˆ¤æ–·ã€‚å…¶å¯¦rootåè€Œæ¯”è¼ƒç°¡å–®ï¼Œå¦‚æœrootæœ‰è¶…éä¸€å€‹å­æ¨¹ï¼Œä»£è¡¨æ‹”æ‰rootä»¥å¾Œæœƒåˆ†è£‚æˆä»¥æ¯å€‹å­æ¨¹ç‚ºå–®ä½çš„é€£é€šå¡Š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,low[N],lv[N],es=1,root,son_cnt = 0;bool visit[N],ans[N];vector&lt;int&gt; edge[N];//lowå‡½æ•¸ç‚ºä¸ç¶“éçˆ¶ç¯€é»èƒ½åˆ°çš„æœ€å°æ™‚é–“æˆ³è¨˜,lvç‚ºç•¶å‰é€²å…¥æ™‚é–“æˆ³è¨˜void DFS(int now,int father)&#123;    visit[now] = 1;             //å°‡æ­¤é»è¨­ç‚ºå·²æ‹œè¨ª    low[now] = lv[now] = es++;  //é€²å…¥çš„æ™‚é–“æˆ³è¨˜        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;     //æ‹œè¨ªæ¯ä¸€å€‹å­å­«        int next = edge[now][i];        if(now==root &amp;&amp; !visit[next])son_cnt++;//è¨ˆç®—rootå°å­©ï¼ˆè™•ç†ç‰¹ä¾‹ï¼‰        if(!visit[next])&#123;       //æ’é™¤èµ°åˆ°ç¥–å…ˆçš„æƒ…æ³            DFS(next, now);            if(low[next]&gt;=lv[now] &amp;&amp; now!=root)ans[now]=1;            //ç„¡æ³•é€éå°å­©åˆ°é”æ¯”è‡ªå·±æ·ºçš„ç¯€é»ï¼Œå°‡nowè¨­ç‚ºAP        &#125;        if(next!=father)low[now] = min(low[now],low[next]);        //æ’é™¤æŒ‡å‘çˆ¶è¦ªçš„æƒ…æ³ï¼Œå¦‚æœç¶“éçˆ¶è¦ªï¼Œæ‹”æ‰å°±ä¸èƒ½å¾€æ›´ä¸Šé¢å»    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(lv, 0, sizeof(lv));    memset(low, 0, sizeof(low));    memset(visit, 0, sizeof(visit));    memset(ans,0,sizeof(ans));        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(!visit[i])&#123;            root = i;            son_cnt = 0;            DFS(i, i);            if(son_cnt&gt;1)ans[root] = 1;        &#125;    &#125;    for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;i&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 179 è¬ è¨€å•é¡Œ","url":"/sprout11-2/","content":"è¬ è¨€å•é¡Œ\né¡Œç›®é€£çµè·Ÿä¸Šä¸€é¡Œï¼ˆé«˜æ£•æ«šå‚³ééˆï¼‰è »é¡ä¼¼çš„ï¼Œä¸€æ¨£æ‰¾åˆ°å‰²é»ï¼Œä¸åŒçš„æ˜¯è¦åœ¨DFSéç¨‹ä¸­åŒæ™‚ç´€éŒ„å­æ¨¹ç¯€é»çš„æ•¸é‡ã€‚å¦‚æœç¢°åˆ°å‰²é»ï¼Œç¶­è­·æ‹”æ‰å®ƒä¹‹å¾Œåˆ†è£‚å‡ºå»é‚£äº›å­æ¨¹çš„ç¯€é»å€‹æ•¸ï¼Œåˆ°æ™‚å€™é€éç¯€é»ç¸½æ•¸-æ‹”æ‰å¾Œåˆ†è£‚å€‹æ•¸å³å¯æ¨ç®—æœ‰å¹¾å€‹äººæœƒçŸ¥é“è¬ è¨€ï¼Œå–minå³å¯\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 30001using namespace std;int n,m,root,lv[N],low[N],tree_cnt[N],es = 1;bool visit[N],ans[N];vector&lt;int&gt; edge[N];int DFS(int now,int father)&#123;      //å›å‚³ç•¶å‰å­ç¯€é»å€‹æ•¸    visit[now] = 1;    lv[now] = es;    low[now] = es++;        int len = edge[now].size(),sum=1;//è¨ˆç®—ç¯€é»æ•¸    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];     //ä¸‹ä¸€å€‹ç¯€é»                if(!visit[next])&#123;            int temp = DFS(next,now);            sum += temp;            if(low[next] &gt;= lv[now] &amp;&amp; now!=root)&#123; //ä¸èƒ½æ‹”æ‰root                ans[now] = 1;           //è¨­ç‚ºAP                tree_cnt[now] += temp;  //è¢«æ‹”æ‰å¾Œå¯è¢«åˆ†å‰²æˆå¹¾å€‹é€£é€šå¡Šç¯€é»æ•¸            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;    return sum;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    cin&gt;&gt;root;        memset(ans, 0, sizeof(ans));    memset(visit, 0, sizeof(visit));    memset(tree_cnt, 0, sizeof(tree_cnt));        int sum = DFS(root,root),min_cnt = INT_MAX,min_pos = 0;        for(int i=1;i&lt;=n;i++)&#123;        int temp = sum-tree_cnt[i]; //æ‹”æ‰å¾Œå‰©ä¸‹é€£é€šå¡Šå¤§å°ï¼ˆè·Ÿrooté€£çš„ï¼‰        if(ans[i] &amp;&amp; temp &lt; min_cnt)&#123;            min_pos = i;        //æ‹”æ‰ç¬¬å¹¾å€‹            min_cnt = temp;     //æ›´æ–°æ‹”æ‰å¾Œå‰©ä¸‹é€£é€šå¡Šå¤§å°        &#125;    &#125;    if(min_cnt == INT_MAX)cout&lt;&lt;0&lt;&lt;endl;    else cout&lt;&lt;min_pos&lt;&lt;&quot; &quot;&lt;&lt;min_cnt&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 183 é«˜æ£•æ«šå‚³ééˆ","url":"/sprout11-3/","content":"é«˜æ£•æ«šå‚³ééˆ\né¡Œç›®é€£çµå‰å…©é¡Œæ‰¾å‰²é»ï¼Œé€™ä¸€é¡Œæ˜¯æ‰¾æ©‹ï¼Œè·Ÿæ‰¾å‰²é»çš„æ–¹æ³•å¹¾ä¹ä¸€æ¨£ï¼Œè€Œä¸”å°æ–¼é‚Šé‚„ä¸éœ€è¦è¨è«–rootçš„æƒ…æ³ï¼ˆrootè®Šæˆä¸æ˜¯ç‰¹ä¾‹ï¼‰ï¼Œç„¶å¾Œåˆ¤æ–·å‰²é»çš„ &gt;= è®Šæˆ &gt;ï¼ŒåŸå› å¯ä»¥é€éç•«åœ–ç†è§£ï¼ˆæŠŠé»æ‹”æ‰è·ŸæŠŠé‚Šæ‹”æ‰çš„å·®åˆ¥ï¼‰ï¼Œå°±å¯ä»¥å¯¦ä½œäº†ï¼é¡Œç›®æœ‰ä¸€å€‹ç‰¹åˆ¥çš„è¦æ±‚ï¼ŒæŒ‰ç…§çµ¦é‚Šçš„é †åºé€²è¡Œè¼¸å‡ºï¼Œé‚£å¯ä»¥æ­é…setä¾†å¿«é€ŸæŸ¥çœ‹æŸä¸€å…ƒç´ æ˜¯å¦åœ¨é›†åˆå…§$O(logN)$ï¼Œæ¥è‘—å°±æŒ‰ç…§çµ¦å®šçš„æ¢ä»¶ä¾†è¼¸å‡º\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,lv[N],low[N],timestamp = 1;bool visit[N];vector&lt;int&gt; edge[N];vector&lt;pair&lt;int, int&gt;&gt; ans;set&lt;pair&lt;int, int&gt;&gt;s;void DFS(int now,int father)&#123;    lv[now] = low[now] = timestamp++;    visit[now] = 1;        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];                if(!visit[next])&#123;            DFS(next, now);            if(low[next] &gt; lv[now])&#123;                if(next&lt;now)s.insert(make_pair(next,now));                else s.insert(make_pair(now, next));            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);        ans.push_back(make_pair(x, y));    &#125;    memset(visit, 0, sizeof(visit));        for(int i=1;i&lt;=n;i++)&#123;        if(!visit[i])&#123;            DFS(i, i);        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        pair&lt;int, int&gt; temp = ans[i];        if(s.find(temp)!=s.end())&#123;            cout&lt;&lt;temp.first&lt;&lt;&quot; &quot;&lt;&lt;temp.second&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 739 èŠ½èŠ½é€›å¤§è¡—","url":"/sprout11-4/","content":"èŠ½èŠ½é€›å¤§è¡—\né¡Œç›®é€£çµæœ‰å‘ç„¡ç’°åœ–çš„ case â†’ DAG æœ€é•·è·¯å¾‘!å°‡æ¯å€‹å¼·é€£é€šå…ƒä»¶ç¸®æˆé»å¾Œï¼Œå› ç‚ºå…§éƒ¨çš„é»å¯ä»¥ä¸€ç›´äº‚èµ°å…¨éƒ¨èµ°åˆ°ï¼Œæ‰€ä»¥åªè¦å°‡æ–°é»çš„é»æ¬Šæ›´æ–°æˆå…§éƒ¨æ‰€æœ‰é»çš„é»æ¬Šç¸½å’Œï¼Œå¾—åˆ°ä¸€å¼µæ–°çš„æœ‰å‘ç„¡ç’°åœ–ï¼Œå°±å¯ä»¥ç›´æ¥åš DAG æœ€é•·è·¯å¾‘å¾—åˆ°ç­”æ¡ˆã€‚\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500002using namespace std;int n,m,dfn[N],low[N],es = 1,stk_in[N],vertex_val[N],deg[N];//dfnç‚ºæ™‚é–“æˆ³è¨˜,lowç‚ºback, cross edgeï¼ˆç¶“éæœ€å¤šä¸€æ¬¡ï¼‰åˆ°é”æœ€å°é»dfn,stk_inæ˜¯å¦åœ¨stackå…§bool visit[N];int scc[N],scc_ind = 0,scc_val[N];//ç´€éŒ„å±¬æ–¼å“ªå€‹scc,sccç·¨è™Ÿ,sccç·¨è™Ÿçš„åƒ¹å€¼ï¼ˆæ¬Šé‡å’Œï¼‰int topological_order[N],ind = 0;struct edg&#123;    int to;    int val;&#125;;vector&lt;edg&gt; edge[N],new_edge[N];stack&lt;int&gt; s;void DFS(int now)&#123;    dfn[now] = low[now] = es++;    s.push(now);    stk_in[now] = 1;    visit[now] = 1;    int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i].to;        if(!visit[next])&#123;       //å°šæœªæ‹œè¨ªå‰‡æ‹œè¨ª            DFS(next);            low[now] = min(low[now],low[next]);        &#125;        else if(stk_in[next])&#123;  //åœ¨stkå…§ä¸”å·²æ‹œè¨ª-&gt;åŒå±¬ä¸€å€‹SCC            low[now] = min(low[now],dfn[next]);            //é€™æ¢é‚ŠæŒ‡å‘é‚„æ²’å‡ºstackçš„é»ï¼Œå¯ç‚ºcross or back edge æ›´æ–°low[now]        &#125;    &#125;    //å¦‚æœæ˜¯sccå°±pop stackè£¡é¢çš„æ±è¥¿    if(low[now] == dfn[now])&#123;        stk_in[now] = 0;        //popå‡ºstackè£¡é¢        scc[now] = ++scc_ind;   //é€²è¡ŒSCCç·¨è™Ÿ        scc_val[scc_ind] = vertex_val[now]; //æ›´æ–°é»æ¬Š        while(s.top()!=now)&#123;                //popç›´åˆ°nowè¢«æ‰¾åˆ°            scc[s.top()] = scc_ind;            stk_in[s.top()] = 0;            //popå‡ºä¾†            scc_val[scc_ind] += vertex_val[s.top()];            s.pop();        &#125;        s.pop();//å°‡stack ä¸­nowä¹Ÿpop    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(visit, 0, sizeof(visit));    memset(stk_in, 0, sizeof(stk_in));    memset(deg, 0, sizeof(deg));    for(int i=1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        vertex_val[i] = x;    &#125;    for(int i=0;i&lt;m;i++)&#123;        int x,y,val;cin&gt;&gt;x&gt;&gt;y&gt;&gt;val;//xæŒ‡å‘y        edge[x].push_back( edg&#123;y,val&#125; );    &#125;    for(int i=1;i&lt;=n;i++)        if(!visit[i])DFS(i);        //æšèˆ‰æ¯ä¸€æ¢é‚Šæ›´æ–°é‚Šæ¬Š    for(int i=1;i&lt;=n;i++)&#123;        int len = edge[i].size();        for(int j=0;j&lt;len;j++)&#123;            int to = edge[i][j].to;            if(scc[to]==scc[i])&#123;                int ind = scc[to];                scc_val[ind]+=edge[i][j].val;            &#125;            else&#123;   //ä¸åŒSCCæŒ‡å‘ä¸åŒçš„é‚Š                new_edge[scc[i]].push_back( edg&#123;scc[to],edge[i][j].val&#125;);                deg[scc[to]]++;            &#125;        &#125;    &#125;        //Topological sort    queue&lt;int&gt; q;        for(int i=1;i&lt;=scc_ind;i++)        if(deg[i]==0)q.push(i);    while(!q.empty())&#123;        int now = q.front(),len = new_edge[now].size();        topological_order[ind++] = now;        q.pop();        for(int i=0;i&lt;len;i++)&#123;            int next = new_edge[now][i].to;            if(--deg[next]==0)q.push(next);        &#125;    &#125;        //æ‹“å¢£æ’åºå®Œé€²è¡ŒDPæ‰¾æœ€é•·è·¯å¾‘    int dp[ind],ans = 0;    for(int i=1;i&lt;=scc_ind;i++)&#123;        dp[i] = scc_val[i];        ans = max(ans, scc_val[i]);    &#125;        for(int i=0;i&lt;ind;i++)&#123;        int now = topological_order[i],len = new_edge[now].size();        for(int j=0;j&lt;len;j++)&#123;            int next = new_edge[now][j].to;            dp[next] = max(dp[next],scc_val[next]+dp[now]+new_edge[now][j].val);            ans = max(ans, dp[next]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬åä¸€é€±ï¼šé€²éšåœ–è«–ï¼ˆäºŒï¼‰","url":"/sprout11/","content":"ä¸Šèª²å…§å®¹é›™é€£é€šå…ƒä»¶æ¨¹å£“å¹³ã€é»é›™é€£é€šã€é‚Šé›™é€£é€š\nSCCå¼·é€£é€šå…ƒä»¶LCAï¼ˆæœ€ä½å…±åŒç¥–å…ˆï¼‰\nä¸Šæ©Ÿä½œæ¥­é«˜æ£•æ«šå‚³ééˆé¡Œç›®é€£çµåœ¨ä¸€å¼µåœ–ä¸­æ‰¾å‰²é»ï¼ˆå®šç¾©ï¼šæ‹”æ‰å®ƒæ•´å¼µåœ–å°±ä¸é€£é€šäº†ï¼‰ä½œæ³•ï¼šå¦‚æœç”¨æš´åŠ›ï¼Œå¯ä»¥æ¯ä¸€å€‹é»æ‹”æ‰ï¼Œåšä¸€æ¬¡DFSåˆ¤æ–·æ˜¯å¦è¯é€šï¼ˆæ•ˆç‡å¤ªå·®ï¼‰\næ•ˆç‡æ›´é«˜çš„å°±æ˜¯Trajan æ¼”ç®—æ³•æ‰¾AP(articulation point)\n\n            Tarjanâ€™s algorithm æ‰¾ APé‚Šçš„ç¨®é¡å¯ä»¥åˆ†æˆï¼šTree edge,Back edge,Forward edge,Cross edgeï¼Œå…¶ä¸­ç„¡å‘åœ–ä¸­åªæœƒæœ‰æ¨¹é‚Šè·Ÿå›é‚Šï¼ˆæŒ‰ç…§ç„¡å‘é‚ŠDFSçš„çµæœï¼ŒFoward edge éƒ½æœƒè®Šæˆå­å­«çš„back edge, cross edge æœƒè®Šæˆæ¨¹é‚Šï¼‰ç¶­è­·ä¸€å€‹lowå‡½æ•¸ï¼Œä»£è¡¨ä¸ç¶“éçˆ¶ç¯€é»èƒ½åˆ°çš„æœ€å°æ™‚é–“æˆ³è¨˜ï¼ˆé€²å…¥ï¼‰çš„ç¯€é»ï¼Œlvå‡½æ•¸ç‚ºç•¶å‰ç¯€é»çš„æ™‚é–“æˆ³è¨˜ã€‚ä¸€å€‹é»æ˜¯ä¸æ˜¯å‰²é»ï¼Œåªè¦ä»–çš„ä»»æ„å­ç¯€é»çš„lowå‡½æ•¸å¤§æ–¼ç­‰æ–¼è‡ªå·±çš„æ™‚é–“æˆ³è¨˜ç·¨è™Ÿï¼Œé‚£æŠŠé€™å€‹é»æ‹”æ‰ï¼Œä»–å°å­©å°±èµ°ä¸åˆ°ç¥–å…ˆäº†ï¼ˆå¦‚æœèµ°å¾—åˆ°ç¥–å…ˆï¼Œå°æ–¼é€™ä¸€æ£µå­æ¨¹ï¼Œæ‹”æ‰ç•¶å‰ç¯€é»å°±å¯åˆ©ç”¨æ­¤é‚Šç¹¼çºŒé€£é€šï¼‰ï¼Œæ‰€ä»¥ä»–å°±æ˜¯å‰²é»ã€‚æ›´æ–°ï¼š$low[now] = min(low[now],low[next])$åˆ†åˆ¥ç‚ºåˆ©ç”¨å­å­«æˆ–é è‡ªå·±\n          \nå¿…é ˆè¦æ³¨æ„çš„æ˜¯ï¼Œå‰²é»åˆ¤æ–·æ™‚è¦æŠŠrootçš„ç‰¹ä¾‹ç¨ç«‹åˆ¤æ–·ã€‚å…¶å¯¦rootåè€Œæ¯”è¼ƒç°¡å–®ï¼Œå¦‚æœrootæœ‰è¶…éä¸€å€‹å­æ¨¹ï¼Œä»£è¡¨æ‹”æ‰rootä»¥å¾Œæœƒåˆ†è£‚æˆä»¥æ¯å€‹å­æ¨¹ç‚ºå–®ä½çš„é€£é€šå¡Š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,low[N],lv[N],es=1,root,son_cnt = 0;bool visit[N],ans[N];vector&lt;int&gt; edge[N];//lowå‡½æ•¸ç‚ºä¸ç¶“éçˆ¶ç¯€é»èƒ½åˆ°çš„æœ€å°æ™‚é–“æˆ³è¨˜,lvç‚ºç•¶å‰é€²å…¥æ™‚é–“æˆ³è¨˜void DFS(int now,int father)&#123;    visit[now] = 1;             //å°‡æ­¤é»è¨­ç‚ºå·²æ‹œè¨ª    low[now] = lv[now] = es++;  //é€²å…¥çš„æ™‚é–“æˆ³è¨˜        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;     //æ‹œè¨ªæ¯ä¸€å€‹å­å­«        int next = edge[now][i];        if(now==root &amp;&amp; !visit[next])son_cnt++;//è¨ˆç®—rootå°å­©ï¼ˆè™•ç†ç‰¹ä¾‹ï¼‰        if(!visit[next])&#123;       //æ’é™¤èµ°åˆ°ç¥–å…ˆçš„æƒ…æ³            DFS(next, now);            if(low[next]&gt;=lv[now] &amp;&amp; now!=root)ans[now]=1;            //ç„¡æ³•é€éå°å­©åˆ°é”æ¯”è‡ªå·±æ·ºçš„ç¯€é»ï¼Œå°‡nowè¨­ç‚ºAP        &#125;        if(next!=father)low[now] = min(low[now],low[next]);        //æ’é™¤æŒ‡å‘çˆ¶è¦ªçš„æƒ…æ³ï¼Œå¦‚æœç¶“éçˆ¶è¦ªï¼Œæ‹”æ‰å°±ä¸èƒ½å¾€æ›´ä¸Šé¢å»    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(lv, 0, sizeof(lv));    memset(low, 0, sizeof(low));    memset(visit, 0, sizeof(visit));    memset(ans,0,sizeof(ans));        for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    for(int i=0;i&lt;n;i++)&#123;        if(!visit[i])&#123;            root = i;            son_cnt = 0;            DFS(i, i);            if(son_cnt&gt;1)ans[root] = 1;        &#125;    &#125;    for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;i&lt;&lt;endl;&#125;\nè¬ è¨€å•é¡Œé¡Œç›®é€£çµè·Ÿä¸Šä¸€é¡Œï¼ˆé«˜æ£•æ«šå‚³ééˆï¼‰è »é¡ä¼¼çš„ï¼Œä¸€æ¨£æ‰¾åˆ°å‰²é»ï¼Œä¸åŒçš„æ˜¯è¦åœ¨DFSéç¨‹ä¸­åŒæ™‚ç´€éŒ„å­æ¨¹ç¯€é»çš„æ•¸é‡ã€‚å¦‚æœç¢°åˆ°å‰²é»ï¼Œç¶­è­·æ‹”æ‰å®ƒä¹‹å¾Œåˆ†è£‚å‡ºå»é‚£äº›å­æ¨¹çš„ç¯€é»å€‹æ•¸ï¼Œåˆ°æ™‚å€™é€éç¯€é»ç¸½æ•¸-æ‹”æ‰å¾Œåˆ†è£‚å€‹æ•¸å³å¯æ¨ç®—æœ‰å¹¾å€‹äººæœƒçŸ¥é“è¬ è¨€ï¼Œå–minå³å¯\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 30001using namespace std;int n,m,root,lv[N],low[N],tree_cnt[N],es = 1;bool visit[N],ans[N];vector&lt;int&gt; edge[N];int DFS(int now,int father)&#123;      //å›å‚³ç•¶å‰å­ç¯€é»å€‹æ•¸    visit[now] = 1;    lv[now] = es;    low[now] = es++;        int len = edge[now].size(),sum=1;//è¨ˆç®—ç¯€é»æ•¸    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];     //ä¸‹ä¸€å€‹ç¯€é»                if(!visit[next])&#123;            int temp = DFS(next,now);            sum += temp;            if(low[next] &gt;= lv[now] &amp;&amp; now!=root)&#123; //ä¸èƒ½æ‹”æ‰root                ans[now] = 1;           //è¨­ç‚ºAP                tree_cnt[now] += temp;  //è¢«æ‹”æ‰å¾Œå¯è¢«åˆ†å‰²æˆå¹¾å€‹é€£é€šå¡Šç¯€é»æ•¸            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;    return sum;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);    &#125;    cin&gt;&gt;root;        memset(ans, 0, sizeof(ans));    memset(visit, 0, sizeof(visit));    memset(tree_cnt, 0, sizeof(tree_cnt));        int sum = DFS(root,root),min_cnt = INT_MAX,min_pos = 0;        for(int i=1;i&lt;=n;i++)&#123;        int temp = sum-tree_cnt[i]; //æ‹”æ‰å¾Œå‰©ä¸‹é€£é€šå¡Šå¤§å°ï¼ˆè·Ÿrooté€£çš„ï¼‰        if(ans[i] &amp;&amp; temp &lt; min_cnt)&#123;            min_pos = i;        //æ‹”æ‰ç¬¬å¹¾å€‹            min_cnt = temp;     //æ›´æ–°æ‹”æ‰å¾Œå‰©ä¸‹é€£é€šå¡Šå¤§å°        &#125;    &#125;    if(min_cnt == INT_MAX)cout&lt;&lt;0&lt;&lt;endl;    else cout&lt;&lt;min_pos&lt;&lt;&quot; &quot;&lt;&lt;min_cnt&lt;&lt;endl;&#125;\né«˜æ£•æ«šå‚³ééˆé¡Œç›®é€£çµå‰å…©é¡Œæ‰¾å‰²é»ï¼Œé€™ä¸€é¡Œæ˜¯æ‰¾æ©‹ï¼Œè·Ÿæ‰¾å‰²é»çš„æ–¹æ³•å¹¾ä¹ä¸€æ¨£ï¼Œè€Œä¸”å°æ–¼é‚Šé‚„ä¸éœ€è¦è¨è«–rootçš„æƒ…æ³ï¼ˆrootè®Šæˆä¸æ˜¯ç‰¹ä¾‹ï¼‰ï¼Œç„¶å¾Œåˆ¤æ–·å‰²é»çš„ &gt;= è®Šæˆ &gt;ï¼ŒåŸå› å¯ä»¥é€éç•«åœ–ç†è§£ï¼ˆæŠŠé»æ‹”æ‰è·ŸæŠŠé‚Šæ‹”æ‰çš„å·®åˆ¥ï¼‰ï¼Œå°±å¯ä»¥å¯¦ä½œäº†ï¼é¡Œç›®æœ‰ä¸€å€‹ç‰¹åˆ¥çš„è¦æ±‚ï¼ŒæŒ‰ç…§çµ¦é‚Šçš„é †åºé€²è¡Œè¼¸å‡ºï¼Œé‚£å¯ä»¥æ­é…setä¾†å¿«é€ŸæŸ¥çœ‹æŸä¸€å…ƒç´ æ˜¯å¦åœ¨é›†åˆå…§$O(logN)$ï¼Œæ¥è‘—å°±æŒ‰ç…§çµ¦å®šçš„æ¢ä»¶ä¾†è¼¸å‡º\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long long#define N 1000001using namespace std;int n,m,lv[N],low[N],timestamp = 1;bool visit[N];vector&lt;int&gt; edge[N];vector&lt;pair&lt;int, int&gt;&gt; ans;set&lt;pair&lt;int, int&gt;&gt;s;void DFS(int now,int father)&#123;    lv[now] = low[now] = timestamp++;    visit[now] = 1;        int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i];                if(!visit[next])&#123;            DFS(next, now);            if(low[next] &gt; lv[now])&#123;                if(next&lt;now)s.insert(make_pair(next,now));                else s.insert(make_pair(now, next));            &#125;        &#125;        if(next!=father)low[now] = min(low[now],low[next]);    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        edge[x].push_back(y);        edge[y].push_back(x);        ans.push_back(make_pair(x, y));    &#125;    memset(visit, 0, sizeof(visit));        for(int i=1;i&lt;=n;i++)&#123;        if(!visit[i])&#123;            DFS(i, i);        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        pair&lt;int, int&gt; temp = ans[i];        if(s.find(temp)!=s.end())&#123;            cout&lt;&lt;temp.first&lt;&lt;&quot; &quot;&lt;&lt;temp.second&lt;&lt;endl;        &#125;    &#125;&#125;\nèŠ½èŠ½é€›å¤§è¡—é¡Œç›®é€£çµæœ‰å‘ç„¡ç’°åœ–çš„ case â†’ DAG æœ€é•·è·¯å¾‘!å°‡æ¯å€‹å¼·é€£é€šå…ƒä»¶ç¸®æˆé»å¾Œï¼Œå› ç‚ºå…§éƒ¨çš„é»å¯ä»¥ä¸€ç›´äº‚èµ°å…¨éƒ¨èµ°åˆ°ï¼Œæ‰€ä»¥åªè¦å°‡æ–°é»çš„é»æ¬Šæ›´æ–°æˆå…§éƒ¨æ‰€æœ‰é»çš„é»æ¬Šç¸½å’Œï¼Œå¾—åˆ°ä¸€å¼µæ–°çš„æœ‰å‘ç„¡ç’°åœ–ï¼Œå°±å¯ä»¥ç›´æ¥åš DAG æœ€é•·è·¯å¾‘å¾—åˆ°ç­”æ¡ˆã€‚\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);#define N 500002using namespace std;int n,m,dfn[N],low[N],es = 1,stk_in[N],vertex_val[N],deg[N];//dfnç‚ºæ™‚é–“æˆ³è¨˜,lowç‚ºback, cross edgeï¼ˆç¶“éæœ€å¤šä¸€æ¬¡ï¼‰åˆ°é”æœ€å°é»dfn,stk_inæ˜¯å¦åœ¨stackå…§bool visit[N];int scc[N],scc_ind = 0,scc_val[N];//ç´€éŒ„å±¬æ–¼å“ªå€‹scc,sccç·¨è™Ÿ,sccç·¨è™Ÿçš„åƒ¹å€¼ï¼ˆæ¬Šé‡å’Œï¼‰int topological_order[N],ind = 0;struct edg&#123;    int to;    int val;&#125;;vector&lt;edg&gt; edge[N],new_edge[N];stack&lt;int&gt; s;void DFS(int now)&#123;    dfn[now] = low[now] = es++;    s.push(now);    stk_in[now] = 1;    visit[now] = 1;    int len = edge[now].size();    for(int i=0;i&lt;len;i++)&#123;        int next = edge[now][i].to;        if(!visit[next])&#123;       //å°šæœªæ‹œè¨ªå‰‡æ‹œè¨ª            DFS(next);            low[now] = min(low[now],low[next]);        &#125;        else if(stk_in[next])&#123;  //åœ¨stkå…§ä¸”å·²æ‹œè¨ª-&gt;åŒå±¬ä¸€å€‹SCC            low[now] = min(low[now],dfn[next]);            //é€™æ¢é‚ŠæŒ‡å‘é‚„æ²’å‡ºstackçš„é»ï¼Œå¯ç‚ºcross or back edge æ›´æ–°low[now]        &#125;    &#125;    //å¦‚æœæ˜¯sccå°±pop stackè£¡é¢çš„æ±è¥¿    if(low[now] == dfn[now])&#123;        stk_in[now] = 0;        //popå‡ºstackè£¡é¢        scc[now] = ++scc_ind;   //é€²è¡ŒSCCç·¨è™Ÿ        scc_val[scc_ind] = vertex_val[now]; //æ›´æ–°é»æ¬Š        while(s.top()!=now)&#123;                //popç›´åˆ°nowè¢«æ‰¾åˆ°            scc[s.top()] = scc_ind;            stk_in[s.top()] = 0;            //popå‡ºä¾†            scc_val[scc_ind] += vertex_val[s.top()];            s.pop();        &#125;        s.pop();//å°‡stack ä¸­nowä¹Ÿpop    &#125;&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;m;    memset(visit, 0, sizeof(visit));    memset(stk_in, 0, sizeof(stk_in));    memset(deg, 0, sizeof(deg));    for(int i=1;i&lt;=n;i++)&#123;        int x;cin&gt;&gt;x;        vertex_val[i] = x;    &#125;    for(int i=0;i&lt;m;i++)&#123;        int x,y,val;cin&gt;&gt;x&gt;&gt;y&gt;&gt;val;//xæŒ‡å‘y        edge[x].push_back( edg&#123;y,val&#125; );    &#125;    for(int i=1;i&lt;=n;i++)        if(!visit[i])DFS(i);        //æšèˆ‰æ¯ä¸€æ¢é‚Šæ›´æ–°é‚Šæ¬Š    for(int i=1;i&lt;=n;i++)&#123;        int len = edge[i].size();        for(int j=0;j&lt;len;j++)&#123;            int to = edge[i][j].to;            if(scc[to]==scc[i])&#123;                int ind = scc[to];                scc_val[ind]+=edge[i][j].val;            &#125;            else&#123;   //ä¸åŒSCCæŒ‡å‘ä¸åŒçš„é‚Š                new_edge[scc[i]].push_back( edg&#123;scc[to],edge[i][j].val&#125;);                deg[scc[to]]++;            &#125;        &#125;    &#125;        //Topological sort    queue&lt;int&gt; q;        for(int i=1;i&lt;=scc_ind;i++)        if(deg[i]==0)q.push(i);    while(!q.empty())&#123;        int now = q.front(),len = new_edge[now].size();        topological_order[ind++] = now;        q.pop();        for(int i=0;i&lt;len;i++)&#123;            int next = new_edge[now][i].to;            if(--deg[next]==0)q.push(next);        &#125;    &#125;        //æ‹“å¢£æ’åºå®Œé€²è¡ŒDPæ‰¾æœ€é•·è·¯å¾‘    int dp[ind],ans = 0;    for(int i=1;i&lt;=scc_ind;i++)&#123;        dp[i] = scc_val[i];        ans = max(ans, scc_val[i]);    &#125;        for(int i=0;i&lt;ind;i++)&#123;        int now = topological_order[i],len = new_edge[now].size();        for(int j=0;j&lt;len;j++)&#123;            int next = new_edge[now][j].to;            dp[next] = max(dp[next],scc_val[next]+dp[now]+new_edge[now][j].val);            ans = max(ans, dp[next]);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\næ‰‹å¯«ä½œæ¥­ä»‹ç´¹é›œæ¹Šï¼Œé‡é»åœ¨æ–¼rolling hashï¼Œé€™ä¹Ÿæ˜¯ä¸‹ä¸€é€±éš¨æ©Ÿèª²ç¨‹ç•¶ä¸­æœƒç”¨åˆ°çš„é‡è¦æ¦‚å¿µã€‚\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","åœ–è«–"]},{"title":"[é¡Œè§£]NEOJ 265 æ¬¸è¿ªçš„å­—ä¸²","url":"/sprout12-1/","content":"æ¬¸è¿ªçš„å­—ä¸²\né¡Œç›®é€£çµè¼¸å…¥æœ‰å…©è¡Œï¼Œç¬¬ä¸€è¡ŒåŒ…å«ä¸€å€‹é•·åº¦ä»‹æ–¼[1,500000]çš„å­—ä¸²Sï¼Œç¬¬äºŒè¡ŒåŒ…å«ä¸€å€‹é•·åº¦ä»‹æ–¼[1,500000]çš„å­—ä¸²Tï¼Œè«‹è¼¸å‡ºä¸€ä¸²éå¢çš„æ•¸åˆ—è¡¨ç¤ºå­—ä¸²Så‡ºç¾åœ¨å­—ä¸²Tçš„å“ªäº›åœ°æ–¹ã€‚\nRolling hashï¼š\nH(s[1:n]) = \\sum_{i=0}^n S_i\\times C^{n-i}æˆ‘å€‘å¦‚æœå‡è¨­æˆ‘å€‘è¦æ‰¾çš„ç›®æ¨™å­—ä¸²Sï¼Œé•·åº¦ç‚ºmï¼Œä»–çš„é›œæ¹Šå€¼æ˜¯ï¼š\nH(S)= \\sum_{i=1}^mS_i \\times C^{m-i}å‰‡å°æ–¼é•·åº¦ç‚ºLèˆ‡r-1çš„å­—ä¸²Tï¼Œå…¶hashå€¼ç‚ºï¼š\nH(T[1:L]) = \\sum_{i=1}^LT_i\\times C^{L-i}H(T[1:r-1]) = \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i}å‰‡ç›®æ¨™å€é–“é•·åº¦ç‚ºmçš„å­—ä¸²é•·åº¦å³ç‚ºå­—ä¸²Sçš„é›œæ¹Šå€¼ï¼Œå°‡T[1:L]çš„é›œæ¹Šå€¼æ‰£æ‰$C^{m}$ä¹˜ä¸ŠT[1:r-1]çš„é›œæ¹Šå€¼ï¼Œå³ç‚ºæ‰€æ±‚ã€‚\n\\begin{split}H(S)&=H(T[r:L])\\\\ &=H(T[1:L])-H(T[1:r-1])\\\\\n&= \\sum_{i=1}^LT_i\\times C^{L-i} - C^{m}\\times \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i} \\\\\n&=\\sum_{i=1}^LT_i\\times C^{L-i}-\\sum_{i=1}^{r-1}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=r}^{L}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=1}^{m}T_{i+r-1}\\times C^{m-1}\\end{split}å°±å¯ä»¥å¾—åˆ°ç•¶å‰å€é–“çš„hashå€¼æ‰€ä»¥é€™æ•´é¡Œå°±è®Šæˆç¶­è­·å­—ä¸²Tçš„å‰ç¶´å’Œï¼Œé€éä»¥ä¸Šæ–¹å¼O(n)å¾—åˆ°æ¯ä¸€å€‹indexçš„hashå€¼ï¼Œæ¥è‘—O(1)æ¯”å°å³å¯ã€‚\n            Q:ç…§æœ€åŸºæœ¬çš„æš´åŠ›æ¯”å°å¯ä¸å¯è¡Œï¼ŸA:å¯ä»¥æ§‹é€ å‡ºéœ€è¦æ¯”å°å¾ˆå¤šæ¬¡çš„å­—ä¸²ï¼Œæœ‰å¯èƒ½æœƒè¢«å¡TLEä¹‹é¡çš„\n          ä»¥å¾Œä¸€å®šè¦è¨˜å¾—ï¼Œå¿…é ˆè¦è¡Œæœ«è¼¸å‡ºä¸€è¡Œï¼Œæˆ‘åœ¨é€™é‚ŠWAè¶…ä¹…\n#include &lt;bits/stdc++.h&gt;#define int unsigned long long int#define INF 0x3f3f3f3f#define N 500005#define mod 1000000007using namespace std;int power[N],hash_func[N],charc[30],n,m,C = 137;char target[N],a[N];vector&lt;int&gt; vec;void init()&#123;    power[0] = 1;    srand(time(NULL));    for(int i=1;i&lt;=m;i++)&#123;        power[i] = ((power[i-1]*C)+mod)%mod;    &#125;    for(int i=0;i&lt;30;i++)&#123;    //å†ç”¨randä¾†ä½¿å­—ä¸²æ›´äº‚ï¼ˆä¸ç”¨ä¹Ÿæ²’å·®ï¼‰        int temp = rand();        charc[i] = temp;    &#125;&#125;signed main()&#123;    scanf(&quot;%s\\n%s&quot;,target+1,a+1);    m = strlen(target+1);    n = strlen(a+1);    init();    hash_func[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;        hash_func[i] = ((C*hash_func[i-1]+(charc[a[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    int sum = 0;    for(int i=1;i&lt;=m;i++)&#123;        sum = ((sum*C+(charc[target[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    for(int i=0;i&lt;=n-m;i++)&#123;        if(sum == ((hash_func[i+m]-((hash_func[i]*power[m])+mod)%mod)+mod)%mod)            vec.push_back(i);    &#125;    int len = vec.size();        if(len&gt;0)printf(&quot;%llu&quot;,vec[0]);    for(int i=1;i&lt;len;i++)&#123;        printf(&quot; %llu&quot;,vec[i]);    &#125;    cout&lt;&lt;endl;    //é€™ä¸€è¡Œæ˜¯æ¯’ç˜¤&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 266 æº«åŠ›çš„æ•…äº‹","url":"/sprout12-2/","content":"æº«åŠ›çš„æ•…äº‹\né¡Œç›®é€£çµçµ¦å­—ä¸²é›†åˆAï¼Œæ¥ä¸‹ä¾†çµ¦må€‹å­—ä¸²ï¼Œå•ä½ åœ¨må€‹å­—ä¸²ä¸­iå­—ä¸²ä¸€å…±å‡ºç¾äº†å¹¾æ¬¡ã€‚ç›´è¦ºçš„æƒ³æ³•å°±æ˜¯ç›´æ¥ç”¨multisetä¾†è§£é€™ä¸€é¡Œã€‚\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int unsigned long long int#define N 105using namespace std;int n,m,power[N],C = 13331;void init()&#123;    power[0] = 1;    for(int i=1;i&lt;=N;i++)&#123;        power[i] = power[i-1]*C;    &#125;&#125;int func(string s)&#123;    int len = s.size(),sum = 0;    for(int i=1;i&lt;=len;i++)&#123;        sum+=((int)s[i-1]*power[len-i]);    &#125;    return sum;&#125;signed main()&#123;    ios;    init();    multiset&lt;int&gt; ss;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        ss.insert(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        cout&lt;&lt;ss.count(temp)&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 793 æƒ³ä¸åˆ°é¡Œç›®æ¨™é¡ŒQQ","url":"/sprout12-3/","content":"æƒ³ä¸åˆ°é¡Œç›®æ¨™é¡ŒQQ\né¡Œç›®é€£çµåœ–ä¸­çš„-2æ”¹æˆ-(k-1)ï¼Œå°æ–¼åœ–ä¸­çš„x,yéƒ½æ˜¯è¨­è¨ˆæˆå¤§æ•¸äº‚æ•¸ï¼Œè¦æ‰¿æ“”çš„é¢¨éšªå°±æ˜¯é€™äº›å¤§æ•¸ç›¸åŠ ä¹‹å¾Œä¸æ‡‰è©²è®Šæˆ0çš„å»è®Šæˆ0ï¼ˆæ©Ÿç‡è¶…å°ï¼‰é‚„æœ‰ä¸€å€‹é‡é»ï¼Œå°æ–¼æ¯ä¸€ç­†è©¢å•éƒ½è¦æ±‚å‡ºå€é–“çš„å’Œï¼Œå› æ­¤è¦ç”¨O(n)ç¶­è­·å‰ç¶´å’Œï¼ï¼ˆä¸€é–‹å§‹æ²’æƒ³åˆ°tleï¼Œä¸ééˆå…‰ä¸€é–ƒç¶­è­·å‰ç¶´å’Œå°±éäº†ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 500005#define mod 1000000007using namespace std;int n,k,m,arr[N],times[N],fuck[N],value[N],pre[N];void init()&#123;    memset(times, 0, sizeof(times));    srand(time(NULL));    pre[0] = 0;    for(int i=0;i&lt;=N;i++)&#123;        int temp = rand()%mod;        fuck[i] = temp;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        times[arr[i]]++;        if(times[arr[i]]%k==0)&#123;            value[i] = -(k-1)*fuck[arr[i]];        &#125;        else&#123;            value[i] = fuck[arr[i]];        &#125;        pre[i] = (pre[i-1]+value[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l,r,sum=0;cin&gt;&gt;l&gt;&gt;r;        sum = pre[r]-pre[l-1];        if(sum==0)cout&lt;&lt;1;        else cout&lt;&lt;0;    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 740 çŸ©é™£ä¹˜æ³•","url":"/sprout12-4/","content":"çŸ©é™£ä¹˜æ³•\né¡Œç›®é€£çµçµ¦å®šä¸‰å€‹çŸ©é™£ABCï¼Œé©—è­‰Aä¹˜ä¸ŠBæ˜¯å¦ç‚ºCã€‚ç•¶ç„¶å¯ä»¥ç”¨$O(n^3)$çš„æ™‚é–“å¯¦éš›é©—è­‰Aä¹˜ä¸ŠBçš„çµæœèˆ‡Cæ¯”å°ï¼Œä½†å…¶å¯¦æœ‰æ›´å¿«çš„æ–¹æ³•å¦‚ä¸‹ï¼Œæ§‹é€ å‡ºçŸ©é™£Rï¼Œé€™ä¸€é¡Œå¯ä»¥æ€è€ƒè¦1ä¹˜ä¸Šå¤šå°‘çš„çŸ©é™£ï¼Œé€éå…©æ¬¡O(n^2)çš„ä¹˜æ³•ï¼Œå°±å¯ä»¥æ¯”å°é€™å€‹RçŸ©é™£ä¹˜ä¸ŠCçŸ©é™£çš„çµæœé€™é¡Œè »ç°¡å–®çš„ï¼Œä¸€æ¬¡å°±éäº†\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 1505#define mod 1000000007using namespace std;int n,m,k,a[N][N],b[N][N],c[N][N],R[N],temp[N],c_new[N];void init()&#123;    memset(temp, 0, sizeof(temp));    srand(time(NULL));    for(int i=0;i&lt;N;i++)&#123;        int temp = rand()%mod;        R[i] = temp;    &#125;&#125;void input()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;b[i][j];        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;c[i][j];        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    input();    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            temp[i]+=(b[i][j]*R[j])%mod;        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            c_new[i]+=(a[i][j]*temp[j])%mod;        &#125;    &#125;    bool flag = 1;    for(int i=0;i&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;k;j++)&#123;            sum+=(c[i][j]*R[j])%mod;        &#125;        if(c_new[i]!=sum)&#123;            flag = 0;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 795 æœ€è¿‘é»å°","url":"/sprout12-5/","content":"æœ€è¿‘é»å°\né¡Œç›®é€£çµå¤§é­”ç‹é¡Œï¼Œå®³æˆ‘TLE 27æ¬¡ã€‚äºŒç¶­å¹³é¢ï¼Œçµ¦å®šnå€‹é»ï¼Œæ±‚å‡ºæœ€è¿‘çš„å…©å€‹é»çš„è·é›¢ã€‚é‡å¤§BUGå®³æˆ‘å¡ä¸‰å¤©çš„BUGåœ¨æ–¼ï¼Œé¡Œç›®è¦æ±‚è¼¸å‡ºè·é›¢çš„å¹³æ–¹ï¼Œçµæœåœ¨è¨ˆç®—éç¨‹ä¸­å°±ç›´æ¥æŠŠè·é›¢ç•¶ä½œæ˜¯å¹³æ–¹ï¼Œè‡ªç„¶æœ‰å¾ˆå¤šé»æœƒåŒæ™‚å‡ºç¾åœ¨ä¸€æ ¼ç¶²æ ¼åº§æ¨™ä¸­ï¼ˆæˆ‘å¼±ï¼Œä¸€ç›´TLEï¼‰ï¼Œé‚„ä¸€ç›´ç”¨ä»€éº¼multi_mapä¹‹é¡çš„ï¼Œç•¶ç„¶å°±æ˜¯TLEå˜ã€‚æš´åŠ›åšï¼š$O(n^2)$ï¼Œåˆ†æ²»åšï¼š$O(nlogn)$ï¼Œéš¨æ©Ÿåšï¼šæœŸæœ›$O(n)$,æœ€æ…˜$O(n^2)$é€™ä¸€é¡Œçš„æ­¥é©Ÿï¼š\n\næŠŠ N å€‹é»å¹³ç§»åˆ°ç¬¬ä¸€è±¡é™\næŠŠ N å€‹é»çš„é †åºéš¨æ©Ÿæ‰“äº‚ï¼Œd = dis(ğ‘1, ğ‘2)\nä»¥ ğ‘Ÿ = ğ‘‘/2 çš„å¤§å°å°‡äºŒç¶­å¹³é¢åˆ‡æˆç¶²æ ¼ç‹€ï¼Œä¸¦å°‡é€™äº›ç¶²æ ¼ä¹Ÿ ğ‘¥ğ‘¦ä»¥åº§æ¨™è¡¨ç¤º:é»(ğ‘¥,ğ‘¦)æœƒè½å…¥åº§æ¨™ç‚º (ğ‘Ÿ,ğ‘Ÿ)ä¸æœƒæœ‰å…©å€‹é»åœ¨åŒä¸€å€‹æ ¼å­å…§ï¼ˆå¾ˆé‡è¦çš„æ€§è³ªï¼‰\nä¸€ç›´æŠŠé»åŠ é€²ç¶²æ ¼ä¸­å¦‚æœç”¢ç”Ÿæ–°çš„æœ€è¿‘é»å°ä¸€å®šæœƒå‡ºç¾åœ¨ä»¥æŸå€‹é»ç‚ºä¸­å¿ƒçš„5Ã—5å®®æ ¼å…§\næ‰¾åˆ°æ›´è¿‘çš„æœ€è¿‘é»å°æ›´æ–° r= æ–°çš„æœ€è¿‘é»å° /2 ï¼Œå›åˆ°æ­¥é©Ÿä¸‰é‡ä¾† O(i+1)\n\n\n            æœŸæœ›è¤‡é›œåº¦ $O(n)$ è­‰æ˜è€ƒæ…®åŠ å…¥ç¬¬i+1å€‹é»æ™‚å‡ºç¾æ–°çš„æœ€è¿‘é»å°ï¼Œç™¼ç”Ÿçš„æ©Ÿç‡ç‚ºï¼šåœ¨$C_2^{i+1}$å€‹é…å°ä¸­è·Ÿi+1å€‹é»ç”¢ç”Ÿæœ€è¿‘é»å°å…±æœ‰iç¨®å¯èƒ½ï¼Œå› æ­¤æ©Ÿç‡ç‚º$\\frac{2}{i+1}$ï¼Œç•¶æ©Ÿç‡ç™¼ç”Ÿçš„æ™‚å€™ï¼Œå¿…é ˆå°‡æ‰€æœ‰çš„é»éƒ½åˆªæ‰é‡æ–°ä¾†ä¸€éï¼ˆå› ç‚ºrè®Šå°ï¼Œunordered_mapè£¡é¢çš„æ±è¥¿ä¹Ÿè¦è¢«æ¸…ç©ºï¼Œé‡æ–°æ¨å…¥i+1å€‹é»ï¼‰ï¼Œéœ€è¦ä»˜å‡º$O(i+1)$çš„æ™‚é–“ï¼Œç›¸ä¹˜èµ·ä¾†æ¯ä¸€å€‹é»æœŸæœ›çš„è¤‡é›œåº¦ç‚º$O(1)$ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦ç‚º$O(n)$ã€‚\n          \nå¯¦ä½œä¸Šå¯ä»¥ç”¨unordered_mapï¼Œå› ç‚ºä¿è­‰ä¸æœƒå‡ºç¾åŒä¸€æ ¼çš„æƒ…æ³ï¼ˆä¸€æ ¼é–“çš„æœ€é•·è·é›¢ä¹Ÿå°±ä¸è¶…édï¼Œæ‰€ä»¥ç•¶å‡ºç¾åœ¨åŒä¸€æ ¼å°±è¡¨ç¤ºè©²æ›´æ–°äº†ï¼‰\nå„ªåŒ–ï¼šå…ˆç”¨$O(n^2)$çš„ä½œæ³•ï¼Œæ‰¾åˆ°å‰é¢çš„å°‘æ•¸pairï¼ˆ$\\sqrt n$ï¼‰çš„æœ€çŸ­è·é›¢ï¼Œé€™æ¨£å¯ä»¥æ¸›å°‘è¢«é‡æ–°æ›´æ–°çš„æ©Ÿæœƒ\né€™ç¯‡æ–‡ç« æœ‰åˆ†æ²»çš„ä½œæ³•ï¼Œé›–ç„¶åˆ†æ²»çš„è¤‡é›œåº¦æ˜¯O(n\\log n)ï¼Œéš¨æ©Ÿæ˜¯$O(n)$ï¼Œä½†å› ç‚ºéš¨æ©Ÿå¸¸æ•¸æ¯”è¼ƒå¤§çš„é—œä¿‚ï¼Œæ™‚é–“æ¯”åˆ†æ²»æ…¢äº†å¿«å…©å€ï¼ä¸‹åœ–æ˜¯åˆ†æ²»çš„åŸ·è¡Œçµæœï¼š\nä»¥ä¸‹æ˜¯éš¨æ©ŸAC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define int long long int#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define INF 1000000000LL#define swift 1000000000using namespace std;int n,ans;double r,d;int dx[25] = &#123;-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2&#125;;int dy[25] = &#123;-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2&#125;;unordered_map&lt;int, int&gt; m;void solve();inline void init();void solve();bool insert(int,int,int);inline double dis(int,int);inline int Grid(int);struct node&#123;    int x,y,ind;&#125;point[N];//å‡½å¼å¯¦ä½œinline void init()&#123;    m.clear();&#125;inline int Grid(int ind)&#123; //inputç¶²æ ¼åº§æ¨™    int x = point[ind].x/r;    int y = point[ind].y/r;    return x*INF+y;&#125;inline int dist(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return (x*x+y*y);&#125;inline double dis(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return sqrt(x*x+y*y);&#125;void solve()&#123;    m.insert(make_pair(Grid(0),0));m.insert(make_pair(Grid(1),1));    for(int ind = 2;ind &lt; n;ind++)&#123;        int x = point[ind].x/r,y = point[ind].y/r,better=0;        for(int i=0;i&lt;25;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            auto it = m.find(nx*INF+ny);            if(it!=m.end())&#123;                double distance = dis(point[it-&gt;second],point[ind]);                if(distance&lt;d)&#123;                    better = 1;                    ans = dist(point[it-&gt;second],point[ind]);                    d = distance;                    r = d/2;                &#125;            &#125;        &#125;        if(better)&#123;    //å‰é¢çš„æ ¼å­ç›´æ¥ç‘±å…¥            m.clear();            for(int i=0;i&lt;=ind;i++)m.insert(make_pair(Grid(i),i));        &#125;        else&#123;            m.insert(make_pair(Grid(ind), ind));        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        x+=swift;y+=swift;        point[i].x = x;point[i].y = y;    &#125;    random_shuffle(point, point+n);    int smalln = sqrt(n);    ans = dist(point[0],point[1]);    d = dis(point[0], point[1]);    for(int i=0;i&lt;=smalln;i++)&#123;        for(int j=i+1;j&lt;=smalln;j++)&#123;            d = min(d,dis(point[i], point[j]));            ans = min(ans,dist(point[i],point[j]));        &#125;    &#125;    r = d/2;    solve();    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬åäºŒé€±ï¼šéš¨æ©Ÿç®—æ³•","url":"/sprout12/","content":"ä¸Šèª²å…§å®¹é€™ä¸€é€±è¬›éš¨æ©Ÿï¼Œä¸»è¦è¬›rolling hashï¼Œå­—ä¸²çš„hashã€éš¨æ©Ÿçš„ä¾‹é¡Œï¼Œåƒæ˜¯çŸ©é™£ä¹˜æ³•çš„é©—è­‰$O(n^2)$ã€è¨ªå•å€é–“å„å…ƒç´ å‡ºç¾æ¬¡æ•¸æ˜¯å¦ç‚ºkçš„å€æ•¸ï¼Œæœ€è¿‘é»å°çš„$O(n)$ä½œæ³•ç­‰ï¼ˆé‚„æœ‰æ±è¥¿é‚„æ²’æœ‰çœ‹XDï¼‰\n\nä¸Šæ©Ÿä½œæ¥­æ¬¸è¿ªçš„å­—ä¸²é¡Œç›®é€£çµè¼¸å…¥æœ‰å…©è¡Œï¼Œç¬¬ä¸€è¡ŒåŒ…å«ä¸€å€‹é•·åº¦ä»‹æ–¼[1,500000]çš„å­—ä¸²Sï¼Œç¬¬äºŒè¡ŒåŒ…å«ä¸€å€‹é•·åº¦ä»‹æ–¼[1,500000]çš„å­—ä¸²Tï¼Œè«‹è¼¸å‡ºä¸€ä¸²éå¢çš„æ•¸åˆ—è¡¨ç¤ºå­—ä¸²Så‡ºç¾åœ¨å­—ä¸²Tçš„å“ªäº›åœ°æ–¹ã€‚\nRolling hashï¼š\nH(s[1:n]) = \\sum_{i=0}^n S_i\\times C^{n-i}æˆ‘å€‘å¦‚æœå‡è¨­æˆ‘å€‘è¦æ‰¾çš„ç›®æ¨™å­—ä¸²Sï¼Œé•·åº¦ç‚ºmï¼Œä»–çš„é›œæ¹Šå€¼æ˜¯ï¼š\nH(S)= \\sum_{i=1}^mS_i \\times C^{m-i}å‰‡å°æ–¼é•·åº¦ç‚ºLèˆ‡r-1çš„å­—ä¸²Tï¼Œå…¶hashå€¼ç‚ºï¼š\nH(T[1:L]) = \\sum_{i=1}^LT_i\\times C^{L-i}H(T[1:r-1]) = \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i}å‰‡ç›®æ¨™å€é–“é•·åº¦ç‚ºmçš„å­—ä¸²é•·åº¦å³ç‚ºå­—ä¸²Sçš„é›œæ¹Šå€¼ï¼Œå°‡T[1:L]çš„é›œæ¹Šå€¼æ‰£æ‰$C^{m}$ä¹˜ä¸ŠT[1:r-1]çš„é›œæ¹Šå€¼ï¼Œå³ç‚ºæ‰€æ±‚ã€‚\n\\begin{split}H(S)&=H(T[r:L])\\\\ &=H(T[1:L])-H(T[1:r-1])\\\\\n&= \\sum_{i=1}^LT_i\\times C^{L-i} - C^{m}\\times \\sum_{i=1}^{r-1}T_i\\times C^{r-1-i} \\\\\n&=\\sum_{i=1}^LT_i\\times C^{L-i}-\\sum_{i=1}^{r-1}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=r}^{L}T_i\\times C^{L-i} \\\\\n&= \\sum_{i=1}^{m}T_{i+r-1}\\times C^{m-1}\\end{split}å°±å¯ä»¥å¾—åˆ°ç•¶å‰å€é–“çš„hashå€¼æ‰€ä»¥é€™æ•´é¡Œå°±è®Šæˆç¶­è­·å­—ä¸²Tçš„å‰ç¶´å’Œï¼Œé€éä»¥ä¸Šæ–¹å¼O(n)å¾—åˆ°æ¯ä¸€å€‹indexçš„hashå€¼ï¼Œæ¥è‘—O(1)æ¯”å°å³å¯ã€‚\n            Q:ç…§æœ€åŸºæœ¬çš„æš´åŠ›æ¯”å°å¯ä¸å¯è¡Œï¼ŸA:å¯ä»¥æ§‹é€ å‡ºéœ€è¦æ¯”å°å¾ˆå¤šæ¬¡çš„å­—ä¸²ï¼Œæœ‰å¯èƒ½æœƒè¢«å¡TLEä¹‹é¡çš„\n          ä»¥å¾Œä¸€å®šè¦è¨˜å¾—ï¼Œå¿…é ˆè¦è¡Œæœ«è¼¸å‡ºä¸€è¡Œï¼Œæˆ‘åœ¨é€™é‚ŠWAè¶…ä¹…\n#include &lt;bits/stdc++.h&gt;#define int unsigned long long int#define INF 0x3f3f3f3f#define N 500005#define mod 1000000007using namespace std;int power[N],hash_func[N],charc[30],n,m,C = 137;char target[N],a[N];vector&lt;int&gt; vec;void init()&#123;    power[0] = 1;    srand(time(NULL));    for(int i=1;i&lt;=m;i++)&#123;        power[i] = ((power[i-1]*C)+mod)%mod;    &#125;    for(int i=0;i&lt;30;i++)&#123;    //å†ç”¨randä¾†ä½¿å­—ä¸²æ›´äº‚ï¼ˆä¸ç”¨ä¹Ÿæ²’å·®ï¼‰        int temp = rand();        charc[i] = temp;    &#125;&#125;signed main()&#123;    scanf(&quot;%s\\n%s&quot;,target+1,a+1);    m = strlen(target+1);    n = strlen(a+1);    init();    hash_func[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;        hash_func[i] = ((C*hash_func[i-1]+(charc[a[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    int sum = 0;    for(int i=1;i&lt;=m;i++)&#123;        sum = ((sum*C+(charc[target[i]-&#x27;a&#x27;]))+mod)%mod;    &#125;    for(int i=0;i&lt;=n-m;i++)&#123;        if(sum == ((hash_func[i+m]-((hash_func[i]*power[m])+mod)%mod)+mod)%mod)            vec.push_back(i);    &#125;    int len = vec.size();        if(len&gt;0)printf(&quot;%llu&quot;,vec[0]);    for(int i=1;i&lt;len;i++)&#123;        printf(&quot; %llu&quot;,vec[i]);    &#125;    cout&lt;&lt;endl;    //é€™ä¸€è¡Œæ˜¯æ¯’ç˜¤&#125;\næº«åŠ›çš„æ•…äº‹é¡Œç›®é€£çµçµ¦å­—ä¸²é›†åˆAï¼Œæ¥ä¸‹ä¾†çµ¦må€‹å­—ä¸²ï¼Œå•ä½ åœ¨må€‹å­—ä¸²ä¸­iå­—ä¸²ä¸€å…±å‡ºç¾äº†å¹¾æ¬¡ã€‚ç›´è¦ºçš„æƒ³æ³•å°±æ˜¯ç›´æ¥ç”¨multisetä¾†è§£é€™ä¸€é¡Œã€‚\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int unsigned long long int#define N 105using namespace std;int n,m,power[N],C = 13331;void init()&#123;    power[0] = 1;    for(int i=1;i&lt;=N;i++)&#123;        power[i] = power[i-1]*C;    &#125;&#125;int func(string s)&#123;    int len = s.size(),sum = 0;    for(int i=1;i&lt;=len;i++)&#123;        sum+=((int)s[i-1]*power[len-i]);    &#125;    return sum;&#125;signed main()&#123;    ios;    init();    multiset&lt;int&gt; ss;    cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        ss.insert(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string s;cin&gt;&gt;s;        int temp = func(s);        cout&lt;&lt;ss.count(temp)&lt;&lt;endl;    &#125;&#125;\næƒ³ä¸åˆ°é¡Œç›®æ¨™é¡ŒQQé¡Œç›®é€£çµåœ–ä¸­çš„-2æ”¹æˆ-(k-1)ï¼Œå°æ–¼åœ–ä¸­çš„x,yéƒ½æ˜¯è¨­è¨ˆæˆå¤§æ•¸äº‚æ•¸ï¼Œè¦æ‰¿æ“”çš„é¢¨éšªå°±æ˜¯é€™äº›å¤§æ•¸ç›¸åŠ ä¹‹å¾Œä¸æ‡‰è©²è®Šæˆ0çš„å»è®Šæˆ0ï¼ˆæ©Ÿç‡è¶…å°ï¼‰é‚„æœ‰ä¸€å€‹é‡é»ï¼Œå°æ–¼æ¯ä¸€ç­†è©¢å•éƒ½è¦æ±‚å‡ºå€é–“çš„å’Œï¼Œå› æ­¤è¦ç”¨O(n)ç¶­è­·å‰ç¶´å’Œï¼ï¼ˆä¸€é–‹å§‹æ²’æƒ³åˆ°tleï¼Œä¸ééˆå…‰ä¸€é–ƒç¶­è­·å‰ç¶´å’Œå°±éäº†ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 500005#define mod 1000000007using namespace std;int n,k,m,arr[N],times[N],fuck[N],value[N],pre[N];void init()&#123;    memset(times, 0, sizeof(times));    srand(time(NULL));    pre[0] = 0;    for(int i=0;i&lt;=N;i++)&#123;        int temp = rand()%mod;        fuck[i] = temp;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n&gt;&gt;k&gt;&gt;m;    for(int i=1;i&lt;=n;i++)&#123;        cin&gt;&gt;arr[i];        times[arr[i]]++;        if(times[arr[i]]%k==0)&#123;            value[i] = -(k-1)*fuck[arr[i]];        &#125;        else&#123;            value[i] = fuck[arr[i]];        &#125;        pre[i] = (pre[i-1]+value[i]);    &#125;    for(int i=1;i&lt;=m;i++)&#123;        int l,r,sum=0;cin&gt;&gt;l&gt;&gt;r;        sum = pre[r]-pre[l-1];        if(sum==0)cout&lt;&lt;1;        else cout&lt;&lt;0;    &#125;    cout&lt;&lt;endl;&#125;\nçŸ©é™£ä¹˜æ³•é¡Œç›®é€£çµçµ¦å®šä¸‰å€‹çŸ©é™£ABCï¼Œé©—è­‰Aä¹˜ä¸ŠBæ˜¯å¦ç‚ºCã€‚ç•¶ç„¶å¯ä»¥ç”¨$O(n^3)$çš„æ™‚é–“å¯¦éš›é©—è­‰Aä¹˜ä¸ŠBçš„çµæœèˆ‡Cæ¯”å°ï¼Œä½†å…¶å¯¦æœ‰æ›´å¿«çš„æ–¹æ³•å¦‚ä¸‹ï¼Œæ§‹é€ å‡ºçŸ©é™£Rï¼Œé€™ä¸€é¡Œå¯ä»¥æ€è€ƒè¦1ä¹˜ä¸Šå¤šå°‘çš„çŸ©é™£ï¼Œé€éå…©æ¬¡O(n^2)çš„ä¹˜æ³•ï¼Œå°±å¯ä»¥æ¯”å°é€™å€‹RçŸ©é™£ä¹˜ä¸ŠCçŸ©é™£çš„çµæœé€™é¡Œè »ç°¡å–®çš„ï¼Œä¸€æ¬¡å°±éäº†\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long int#define N 1505#define mod 1000000007using namespace std;int n,m,k,a[N][N],b[N][N],c[N][N],R[N],temp[N],c_new[N];void init()&#123;    memset(temp, 0, sizeof(temp));    srand(time(NULL));    for(int i=0;i&lt;N;i++)&#123;        int temp = rand()%mod;        R[i] = temp;    &#125;&#125;void input()&#123;    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            cin&gt;&gt;a[i][j];        &#125;    &#125;    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;b[i][j];        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            cin&gt;&gt;c[i][j];        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    input();    for(int i=0;i&lt;m;i++)&#123;        for(int j=0;j&lt;k;j++)&#123;            temp[i]+=(b[i][j]*R[j])%mod;        &#125;    &#125;    for(int i=0;i&lt;n;i++)&#123;        for(int j=0;j&lt;m;j++)&#123;            c_new[i]+=(a[i][j]*temp[j])%mod;        &#125;    &#125;    bool flag = 1;    for(int i=0;i&lt;n;i++)&#123;        int sum = 0;        for(int j=0;j&lt;k;j++)&#123;            sum+=(c[i][j]*R[j])%mod;        &#125;        if(c_new[i]!=sum)&#123;            flag = 0;            break;        &#125;    &#125;    if(flag)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;\næœ€è¿‘é»å°é¡Œç›®é€£çµå¤§é­”ç‹é¡Œï¼Œå®³æˆ‘TLE 27æ¬¡ã€‚äºŒç¶­å¹³é¢ï¼Œçµ¦å®šnå€‹é»ï¼Œæ±‚å‡ºæœ€è¿‘çš„å…©å€‹é»çš„è·é›¢ã€‚é‡å¤§BUGå®³æˆ‘å¡ä¸‰å¤©çš„BUGåœ¨æ–¼ï¼Œé¡Œç›®è¦æ±‚è¼¸å‡ºè·é›¢çš„å¹³æ–¹ï¼Œçµæœåœ¨è¨ˆç®—éç¨‹ä¸­å°±ç›´æ¥æŠŠè·é›¢ç•¶ä½œæ˜¯å¹³æ–¹ï¼Œè‡ªç„¶æœ‰å¾ˆå¤šé»æœƒåŒæ™‚å‡ºç¾åœ¨ä¸€æ ¼ç¶²æ ¼åº§æ¨™ä¸­ï¼ˆæˆ‘å¼±ï¼Œä¸€ç›´TLEï¼‰ï¼Œé‚„ä¸€ç›´ç”¨ä»€éº¼multi_mapä¹‹é¡çš„ï¼Œç•¶ç„¶å°±æ˜¯TLEå˜ã€‚æš´åŠ›åšï¼š$O(n^2)$ï¼Œåˆ†æ²»åšï¼š$O(nlogn)$ï¼Œéš¨æ©Ÿåšï¼šæœŸæœ›$O(n)$,æœ€æ…˜$O(n^2)$é€™ä¸€é¡Œçš„æ­¥é©Ÿï¼š\n\næŠŠ N å€‹é»å¹³ç§»åˆ°ç¬¬ä¸€è±¡é™\næŠŠ N å€‹é»çš„é †åºéš¨æ©Ÿæ‰“äº‚ï¼Œd = dis(ğ‘1, ğ‘2)\nä»¥ ğ‘Ÿ = ğ‘‘/2 çš„å¤§å°å°‡äºŒç¶­å¹³é¢åˆ‡æˆç¶²æ ¼ç‹€ï¼Œä¸¦å°‡é€™äº›ç¶²æ ¼ä¹Ÿ ğ‘¥ğ‘¦ä»¥åº§æ¨™è¡¨ç¤º:é»(ğ‘¥,ğ‘¦)æœƒè½å…¥åº§æ¨™ç‚º (ğ‘Ÿ,ğ‘Ÿ)ä¸æœƒæœ‰å…©å€‹é»åœ¨åŒä¸€å€‹æ ¼å­å…§ï¼ˆå¾ˆé‡è¦çš„æ€§è³ªï¼‰\nä¸€ç›´æŠŠé»åŠ é€²ç¶²æ ¼ä¸­å¦‚æœç”¢ç”Ÿæ–°çš„æœ€è¿‘é»å°ä¸€å®šæœƒå‡ºç¾åœ¨ä»¥æŸå€‹é»ç‚ºä¸­å¿ƒçš„5Ã—5å®®æ ¼å…§\næ‰¾åˆ°æ›´è¿‘çš„æœ€è¿‘é»å°æ›´æ–° r= æ–°çš„æœ€è¿‘é»å° /2 ï¼Œå›åˆ°æ­¥é©Ÿä¸‰é‡ä¾† O(i+1)\n\n\n            æœŸæœ›è¤‡é›œåº¦ $O(n)$ è­‰æ˜è€ƒæ…®åŠ å…¥ç¬¬i+1å€‹é»æ™‚å‡ºç¾æ–°çš„æœ€è¿‘é»å°ï¼Œç™¼ç”Ÿçš„æ©Ÿç‡ç‚ºï¼šåœ¨$C_2^{i+1}$å€‹é…å°ä¸­è·Ÿi+1å€‹é»ç”¢ç”Ÿæœ€è¿‘é»å°å…±æœ‰iç¨®å¯èƒ½ï¼Œå› æ­¤æ©Ÿç‡ç‚º$\\frac{2}{i+1}$ï¼Œç•¶æ©Ÿç‡ç™¼ç”Ÿçš„æ™‚å€™ï¼Œå¿…é ˆå°‡æ‰€æœ‰çš„é»éƒ½åˆªæ‰é‡æ–°ä¾†ä¸€éï¼ˆå› ç‚ºrè®Šå°ï¼Œunordered_mapè£¡é¢çš„æ±è¥¿ä¹Ÿè¦è¢«æ¸…ç©ºï¼Œé‡æ–°æ¨å…¥i+1å€‹é»ï¼‰ï¼Œéœ€è¦ä»˜å‡º$O(i+1)$çš„æ™‚é–“ï¼Œç›¸ä¹˜èµ·ä¾†æ¯ä¸€å€‹é»æœŸæœ›çš„è¤‡é›œåº¦ç‚º$O(1)$ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦ç‚º$O(n)$ã€‚\n          \nå¯¦ä½œä¸Šå¯ä»¥ç”¨unordered_mapï¼Œå› ç‚ºä¿è­‰ä¸æœƒå‡ºç¾åŒä¸€æ ¼çš„æƒ…æ³ï¼ˆä¸€æ ¼é–“çš„æœ€é•·è·é›¢ä¹Ÿå°±ä¸è¶…édï¼Œæ‰€ä»¥ç•¶å‡ºç¾åœ¨åŒä¸€æ ¼å°±è¡¨ç¤ºè©²æ›´æ–°äº†ï¼‰\nå„ªåŒ–ï¼šå…ˆç”¨$O(n^2)$çš„ä½œæ³•ï¼Œæ‰¾åˆ°å‰é¢çš„å°‘æ•¸pairï¼ˆ$\\sqrt n$ï¼‰çš„æœ€çŸ­è·é›¢ï¼Œé€™æ¨£å¯ä»¥æ¸›å°‘è¢«é‡æ–°æ›´æ–°çš„æ©Ÿæœƒ\né€™ç¯‡æ–‡ç« æœ‰åˆ†æ²»çš„ä½œæ³•ï¼Œé›–ç„¶åˆ†æ²»çš„è¤‡é›œåº¦æ˜¯O(n\\log n)ï¼Œéš¨æ©Ÿæ˜¯$O(n)$ï¼Œä½†å› ç‚ºéš¨æ©Ÿå¸¸æ•¸æ¯”è¼ƒå¤§çš„é—œä¿‚ï¼Œæ™‚é–“æ¯”åˆ†æ²»æ…¢äº†å¿«å…©å€ï¼ä¸‹åœ–æ˜¯åˆ†æ²»çš„åŸ·è¡Œçµæœï¼š\nä»¥ä¸‹æ˜¯éš¨æ©ŸAC Codeï¼š\n#include &lt;bits/stdc++.h&gt;#define int long long int#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 200005#define INF 1000000000LL#define swift 1000000000using namespace std;int n,ans;double r,d;int dx[25] = &#123;-2,-2,-2,-2,-2,-1,-1,-1,-1,-1,0,0,0,0,0,1,1,1,1,1,2,2,2,2,2&#125;;int dy[25] = &#123;-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2,-2,-1,0,1,2&#125;;unordered_map&lt;int, int&gt; m;void solve();inline void init();void solve();bool insert(int,int,int);inline double dis(int,int);inline int Grid(int);struct node&#123;    int x,y,ind;&#125;point[N];//å‡½å¼å¯¦ä½œinline void init()&#123;    m.clear();&#125;inline int Grid(int ind)&#123; //inputç¶²æ ¼åº§æ¨™    int x = point[ind].x/r;    int y = point[ind].y/r;    return x*INF+y;&#125;inline int dist(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return (x*x+y*y);&#125;inline double dis(node a,node b)&#123;    int x = a.x-b.x,y = a.y-b.y;    return sqrt(x*x+y*y);&#125;void solve()&#123;    m.insert(make_pair(Grid(0),0));m.insert(make_pair(Grid(1),1));    for(int ind = 2;ind &lt; n;ind++)&#123;        int x = point[ind].x/r,y = point[ind].y/r,better=0;        for(int i=0;i&lt;25;i++)&#123;            int nx = x+dx[i],ny = y+dy[i];            auto it = m.find(nx*INF+ny);            if(it!=m.end())&#123;                double distance = dis(point[it-&gt;second],point[ind]);                if(distance&lt;d)&#123;                    better = 1;                    ans = dist(point[it-&gt;second],point[ind]);                    d = distance;                    r = d/2;                &#125;            &#125;        &#125;        if(better)&#123;    //å‰é¢çš„æ ¼å­ç›´æ¥ç‘±å…¥            m.clear();            for(int i=0;i&lt;=ind;i++)m.insert(make_pair(Grid(i),i));        &#125;        else&#123;            m.insert(make_pair(Grid(ind), ind));        &#125;    &#125;&#125;signed main()&#123;    ios;    init();    cin&gt;&gt;n;    for(int i=0;i&lt;n;i++)&#123;        int x,y;cin&gt;&gt;x&gt;&gt;y;        x+=swift;y+=swift;        point[i].x = x;point[i].y = y;    &#125;    random_shuffle(point, point+n);    int smalln = sqrt(n);    ans = dist(point[0],point[1]);    d = dis(point[0], point[1]);    for(int i=0;i&lt;=smalln;i++)&#123;        for(int j=i+1;j&lt;=smalln;j++)&#123;            d = min(d,dis(point[i], point[j]));            ans = min(ans,dist(point[i],point[j]));        &#125;    &#125;    r = d/2;    solve();    cout&lt;&lt;ans&lt;&lt;endl;&#125;\næ‰‹å¯«ä½œæ¥­ä¸ç”¨äº¤æ‰‹å¯«ä½œæ¥­ï¼ä¸éé‚„æ˜¯æœ‰ä¸€ä»½ã€Œæ¬£è³ç”¨ã€çš„ï¼Œè¬›Disjoint Set\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","éš¨æ©Ÿ"]},{"title":"[é¡Œè§£]NEOJ 252 Counting Triangles","url":"/sprout13-1/","content":"Counting Triangles\né¡Œç›®é€£çµæˆ‘å€‹äººèªç‚ºåšæ³•è¶…ç´šç²¾å¦™çš„ï¼æœ‰å¾ˆå¤šç¨®ä½œæ³•ï¼ŒæŒ‘ä¸€å€‹æ¯”è¼ƒå¥½å¯¦ä½œçš„ï¼š\n            å‡è¨­å¯ä»¥ $O(1)$ å›ç­” (x, y) æ˜¯å¦ç‚ºåœ–ä¸­çš„ä¸€å€‹é‚Šã€‚å°æ–¼æ¯æ¢é‚Š (u, v) ï¼Œä½ èŠ±$O(min(d_u, d_v))$å»ç®—å‡ºåŒ…å«é€™æ¢é‚Šçš„ä¸‰è§’å½¢å€‹æ•¸ç¸½è¤‡é›œåº¦ï¼š$O(M\\sqrt{M})$\n          \n\nå…¶ä¸­å°æ–¼å‡æ”¤æŸ¥è©¢ä¸€æ¢é‚Šæœ‰æ²’æœ‰åœ¨åœ–ä¸­ï¼Œç¸½é‚Šæ•¸$O(M)$ $\\div$ è©¢å•æ¯ä¸€æ¢é‚Š$O(M)$ = å‡æ”¤$O(1)$çš„è¤‡é›œåº¦ï¼Œå¯¦ä½œèµ·ä¾†éå¸¸ç°¡å–®\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100001#define M 100001using namespace std;int main()&#123;    ios;    vector&lt;int&gt; G[N],query[N];  //Gæ˜¯å­˜åœ–ã€queryæ˜¯å­˜è©¢å•    int n,m,x[M],y[M];  //x,yå­˜é‚Šç”¨    bool visit[N];        cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;x[i]&gt;&gt;y[i];        G[x[i]].push_back(y[i]);        G[y[i]].push_back(x[i]);    &#125;    int sml = 0,big = 0;    for(int i=0;i&lt;m;i++)&#123;    //ä¿è­‰è¤‡é›œåº¦ç‚ºæ ¹è™Ÿçš„é—œéµ        if(G[x[i]].size()&lt;=G[y[i]].size())sml = x[i];        else sml = y[i];    //å°‹æ‰¾å“ªä¸€å€‹åº¦æ•¸æ¯”è¼ƒå°        big = x[i]+y[i]-sml;        for(int j : G[sml])&#123;   //è¨ªå•è·Ÿsmlæœ‰ç›¸é„°çš„æ‰€æœ‰é‚Šï¼Œçœ‹æœ‰æ²’æœ‰(j,big)            query[j].push_back(big);        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        //å‡æ”¤O(1)?        for(int j:G[i])&#123;            visit[j] = true;        &#125;        for(int j:query[i])&#123;            ans+=visit[j];        &#125;        for(int j:G[i])&#123;            visit[j] = false;        &#125;    &#125;    cout&lt;&lt;ans/3&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 213 ä¸­åœ‹äººæ’éšŠå•é¡Œ","url":"/sprout13-2/","content":"ä¸­åœ‹äººæ’éšŠå•é¡Œ\né¡Œç›®é€£çµå¦‚æœç”¨ä¸€å€‹vector å­˜æ•´å€‹åºåˆ—ï¼Œquery $O(1)$ï¼Œä½†æ–°å¢è·Ÿåˆªé™¤éƒ½æ˜¯$O(N)$å› æ­¤ï¼Œå¦‚æœæ”¹ç”¨åˆ†å¡Šçš„æ–¹æ³•ï¼Œç”¨dequeä¸‹å»ç ¸ï¼Œæ¯Kå€‹åˆ†æˆä¸€å¡Šï¼Œå°æ–¼æ’å…¥èˆ‡åˆªé™¤éƒ½æ˜¯$O(K+\\frac{N}{K})$ï¼Œè©¢å•æ˜¯$O(1)$æ ¹æ“šç®—å¹¾ä¸ç­‰å¼ï¼Œæˆ‘å€‘å¯ä»¥å–$K = \\sqrt{N}$ æ™‚ï¼Œè¤‡é›œåº¦å¯ä»¥é”åˆ°$O(\\sqrt{N})$ ï¼Œå¾ˆä¸éŒ¯å§ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;signed main()&#123;    ios;    int n,m,K;    cin&gt;&gt;n&gt;&gt;m;    K = sqrt(n);    deque&lt;int&gt; deq[n/K+(m/K)+10];    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        deq[i/K].push_back(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string a;cin&gt;&gt;a;        if(a[0]==&#x27;A&#x27;)&#123;            int x,y;cin&gt;&gt;y&gt;&gt;x;y--;            deq[y/K].insert(deq[y/K].begin()+(y%K), x);            int len = deq[y/K].size(),cur = y/K;            while(len&gt;K)&#123;                int temp = deq[cur].back();                deq[cur].pop_back();                cur++;                deq[cur].push_front(temp);                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;L&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            deq[x/K].erase(deq[x/K].begin()+(x%K));            int len = deq[x/K].size(),cur = x/K;            while(len&lt;K &amp;&amp; deq[cur+1].size()!=0)&#123;                int temp = deq[cur+1].front();                deq[cur+1].pop_front();                deq[cur].push_back(temp);                cur++;                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;Q&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            int len = x%K;            auto it = deq[x/K].begin();            cout&lt;&lt;*(it+len)&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 742 ç¬¬ Z å°","url":"/sprout13-3/","content":"ç¬¬ Z å°\né¡Œç›®é€£çµè¶…è¨å­ï¼Œä¸€ç›´REï¼Œçµæœæ˜¯å¡åœ¨æ²’æœ‰é–‹long longï¼Œå“­å•Šé€™ä¸€é¡Œæ˜¯å€¼åŸŸåˆ†å¡Šï¼Œä¸€æ¨£æ˜¯æ ¹æ“šå€¼åŸŸæ¯Kå€‹åˆ†æˆä¸€å¡Šï¼Œå»ç¶­è­·æ¯ä¸€å¤§å¡Šçš„æ•¸å­—æ•¸é‡ç¸½å’Œï¼Œé€™æ¨£åœ¨æŸ¥è©¢(query)çš„æ™‚å€™èŠ± $O(C/K)$ æ‰¾åˆ°ç›¸æ‡‰å¤§å¡Š(Cç‚ºå€¼åŸŸ)ï¼Œå†èŠ± $O(K)$ çš„æ™‚é–“æƒéå°å¡Šï¼Œè€ŒåŠ å€¼æ¸›å€¼éƒ½æ˜¯$O(1)$å¯ä»¥è™•ç†è¤‡é›œåº¦ï¼š$O(K+\\frac{C}{K})$ å– K=$\\sqrt{C}$ æœ‰æœ€å°å€¼ï¼š$O(Q\\sqrt{C})$\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100005using namespace std;    //å€¼åŸŸåˆ†å¡Šconst int K = 100;signed main()&#123;    ios;    int q,arr[N],mn[N/K+10];cin&gt;&gt;q;    memset(arr, 0, sizeof(arr));    while(q--)&#123;        int temp;cin&gt;&gt;temp;        if(temp==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]+=y;            mn[x/K]+=y;        &#125;        else if(temp==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]-=y;            mn[x/K]-=y;        &#125;        else if(temp==3)&#123;            int z,sum = 0,ind=0;cin&gt;&gt;z; //indæŸ¥è©¢ä½æ–¼ç¬¬å¹¾å¡Š            while(sum+mn[ind]&lt;z)sum+=mn[ind++];            int cur_ind = ind*K;            for(int i=0;i&lt;=K;i++)&#123;                if(arr[cur_ind+i])&#123;                    sum+=arr[cur_ind+i];                    if(sum&gt;=z)&#123;                        cout&lt;&lt;ind*K+i&lt;&lt;endl;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 722 å°å’²çš„ç©å…·","url":"/sprout13-4/","content":"å°å’²çš„ç©å…·\né¡Œç›®é€£çµé€™ä¸€é¡Œçš„å¸¸æ•¸è¶…ç·Šï¼Œå› æ­¤åœ¨å˜—è©¦ä½¿ç”¨hashæ™‚ç”¨unordredmapè¢«å¡TLEï¼Œåœ¨å¾ˆé›»çš„äººæç¤ºå¾Œï¼Œè¦ä½¿ç”¨é»‘é­”æ³•cc_hash_tableæ‰å¯èƒ½æœƒéé—œ\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;cc_hash_table&lt;int,int&gt;cc;\nä»–çš„ç”¨æ³•å…¶å¯¦è·Ÿunordered_mapå¹¾ä¹ä¸€æ¨£å§ï¼ˆè‡³å°‘åŸºæœ¬çš„insertè·Ÿfindçš„èªæ³•éƒ½ä¸€æ¨£ï¼‰ï¼Œä¸éä»–å¯ä»¥åšåˆ°æ¯”unordered_mapæ›´å¥½çš„æ•ˆç‡ã€‚ä¸éæˆ‘ç”¨æœ€è¿‘é»å°é€™ä¸€é¡Œæ¸¬è©¦æ•ˆç‡å»ç™¼ç¾é»‘é­”æ³•æœƒtleï¼Œå¯èƒ½æ˜¯åœ¨clearé€™ä¸€å€‹æ­¥é©Ÿçš„æ•ˆç‡ä¸¦ä¸æ˜¯å¾ˆå¥½å§ï¼\nç¸½ä¹‹ï¼Œå°±æ˜¯å°æ–¼æ¯ä¸€ç­†è©¢å•(x,y)ï¼Œä¸å¤±ä¸€èˆ¬æ€§å‡è¨­size_y &gt; size_xï¼Œå‰‡å°æ–¼yæ’åºä¸¦é è™•ç†å‰ç¶´å’Œï¼ŒåŒæ™‚æšèˆ‰xä¸­çš„æ‰€æœ‰é»ä¸¦äºŒåˆ†æœä»–åœ¨yçš„ä½ç½®æœ€é‡è¦çš„ï¼Œæ˜¯å°æ¯ä¸€ç­†è©¢å•éƒ½å„²å­˜èµ·ä¾†ï¼Œé€™æ¨£è¤‡é›œåº¦æœƒç¬é–“å°‘ä¸€å€‹Nè£œè¤‡é›œåº¦è­‰æ˜\n#include &lt;bits/stdc++.h&gt;using namespace std;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;#define int long long#define N 150006int n,k,q;vector&lt;int&gt; vec[N],pre[N];bool visit[N];cc_hash_table&lt;int,int&gt;cc; int HASH(int x,int y)&#123;    return x*1000000007+y;&#125;signed main()&#123;    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;k,&amp;q);    memset(visit, 0, sizeof(visit));    while(k--)&#123;        int c,p;scanf(&quot;%lld %lld&quot;,&amp;c,&amp;p);        vec[p].push_back(c);    &#125;    while(q--)&#123;        int x,y;scanf(&quot;%lld %lld&quot;,&amp;x,&amp;y);        if(vec[x].size()&gt;vec[y].size())swap(x, y);                if(cc.find(HASH(x,y))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(x,y))-&gt;second);            continue;        &#125;        else if(cc.find(HASH(y,x))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(y,x))-&gt;second);            continue;        &#125;                int len = vec[y].size();        if(!visit[y])&#123;            sort(vec[y].begin(),vec[y].end());            pre[y].resize(len+6);            for(int i=0;i&lt;=len;i++)pre[y][i+1] = pre[y][i]+vec[y][i];            visit[y] = 1;        &#125;                int ans = 0;        for(int j:vec[x])&#123;            int pos = lower_bound(vec[y].begin(), vec[y].end(),j)-vec[y].begin();            pos--;            if(pos&lt;0)ans+=(len*j);            else ans += (pre[y][pos+1]+j*(len-pos-1));        &#125;        printf(&quot;%lld\\n&quot;,ans);        cc.insert(make_pair(HASH(x,y),ans));        cc.insert(make_pair(HASH(y,x),ans));    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬åä¸‰é€±ï¼šæ ¹è™Ÿç®—æ³•","url":"/sprout13/","content":"ä¸Šèª²å…§å®¹å¥½å™å¿ƒå–”ï¼Œè¤‡é›œåº¦ç«Ÿç„¶å¸¶æ ¹è™Ÿï¼ï¼Ÿ æ ¹è™Ÿç®—æ³•æœ‰å¾ˆå¤šä¾‹é¡Œï¼Œæœ€å¸¸è½åˆ°ï¼ˆæˆ–é‡åˆ°ï¼Ÿï¼‰çš„å°±æ˜¯åˆ†å¡Šäº†ï¼æŠŠåºåˆ—åˆ†æˆ$\\sqrt{K}$ å¡Šï¼Œåœ¨åšRMQï¼ˆå€é–“åŠ å€¼ã€å€é–“æ±‚å’Œç­‰ï¼‰çš„å…¶ä¸­ä¸€ç¨®æ–¹å¼\n\nRMQå€é–“æ¥µå€¼è©¢å•ï¼ˆå¯ä»¥ç”¨åˆ†å¡Šåšã€ç·šæ®µæ¨¹ã€BITã€ç¨€ç–è¡¨sparse tableï¼‰\nCounting Triangle\nåˆ†å¡Šï¼ˆå€¼åŸŸåˆ†å¡Šã€å¡Šç‹€éŠè¡¨ç­‰ï¼‰\næ“ä½œåˆ†å¡Š\n\nå…¶å¯¦æ ¹è™Ÿç®—æ³•çš„é‡é»å…¶å¯¦åœ¨æ–¼è¤‡é›œåº¦åˆ†æï¼ˆè¬›å¸«èŠ±å¾ˆå¤šæ™‚é–“è¬›ä¸åŒä½œæ³•çš„è¤‡é›œåº¦åˆ†æï¼‰ï¼Œæ€éº¼æ¨£åˆ†æè®“è¤‡é›œåº¦è·‘å‡ºæ ¹è™Ÿ\n\nä¸Šæ©Ÿä½œæ¥­Counting Trianglesé¡Œç›®é€£çµæˆ‘å€‹äººèªç‚ºåšæ³•è¶…ç´šç²¾å¦™çš„ï¼æœ‰å¾ˆå¤šç¨®ä½œæ³•ï¼ŒæŒ‘ä¸€å€‹æ¯”è¼ƒå¥½å¯¦ä½œçš„ï¼š\n            å‡è¨­å¯ä»¥ $O(1)$ å›ç­” (x, y) æ˜¯å¦ç‚ºåœ–ä¸­çš„ä¸€å€‹é‚Šã€‚å°æ–¼æ¯æ¢é‚Š (u, v) ï¼Œä½ èŠ±$O(min(d_u, d_v))$å»ç®—å‡ºåŒ…å«é€™æ¢é‚Šçš„ä¸‰è§’å½¢å€‹æ•¸ç¸½è¤‡é›œåº¦ï¼š$O(M\\sqrt{M})$\n          \n\nå…¶ä¸­å°æ–¼å‡æ”¤æŸ¥è©¢ä¸€æ¢é‚Šæœ‰æ²’æœ‰åœ¨åœ–ä¸­ï¼Œç¸½é‚Šæ•¸$O(M)$ $\\div$ è©¢å•æ¯ä¸€æ¢é‚Š$O(M)$ = å‡æ”¤$O(1)$çš„è¤‡é›œåº¦ï¼Œå¯¦ä½œèµ·ä¾†éå¸¸ç°¡å–®\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100001#define M 100001using namespace std;int main()&#123;    ios;    vector&lt;int&gt; G[N],query[N];  //Gæ˜¯å­˜åœ–ã€queryæ˜¯å­˜è©¢å•    int n,m,x[M],y[M];  //x,yå­˜é‚Šç”¨    bool visit[N];        cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;m;i++)&#123;        cin&gt;&gt;x[i]&gt;&gt;y[i];        G[x[i]].push_back(y[i]);        G[y[i]].push_back(x[i]);    &#125;    int sml = 0,big = 0;    for(int i=0;i&lt;m;i++)&#123;    //ä¿è­‰è¤‡é›œåº¦ç‚ºæ ¹è™Ÿçš„é—œéµ        if(G[x[i]].size()&lt;=G[y[i]].size())sml = x[i];        else sml = y[i];    //å°‹æ‰¾å“ªä¸€å€‹åº¦æ•¸æ¯”è¼ƒå°        big = x[i]+y[i]-sml;        for(int j : G[sml])&#123;   //è¨ªå•è·Ÿsmlæœ‰ç›¸é„°çš„æ‰€æœ‰é‚Šï¼Œçœ‹æœ‰æ²’æœ‰(j,big)            query[j].push_back(big);        &#125;    &#125;    int ans = 0;    for(int i=0;i&lt;n;i++)&#123;        //å‡æ”¤O(1)?        for(int j:G[i])&#123;            visit[j] = true;        &#125;        for(int j:query[i])&#123;            ans+=visit[j];        &#125;        for(int j:G[i])&#123;            visit[j] = false;        &#125;    &#125;    cout&lt;&lt;ans/3&lt;&lt;endl;&#125;\nä¸­åœ‹äººæ’éšŠå•é¡Œé¡Œç›®é€£çµå¦‚æœç”¨ä¸€å€‹vector å­˜æ•´å€‹åºåˆ—ï¼Œquery $O(1)$ï¼Œä½†æ–°å¢è·Ÿåˆªé™¤éƒ½æ˜¯$O(N)$å› æ­¤ï¼Œå¦‚æœæ”¹ç”¨åˆ†å¡Šçš„æ–¹æ³•ï¼Œç”¨dequeä¸‹å»ç ¸ï¼Œæ¯Kå€‹åˆ†æˆä¸€å¡Šï¼Œå°æ–¼æ’å…¥èˆ‡åˆªé™¤éƒ½æ˜¯$O(K+\\frac{N}{K})$ï¼Œè©¢å•æ˜¯$O(1)$æ ¹æ“šç®—å¹¾ä¸ç­‰å¼ï¼Œæˆ‘å€‘å¯ä»¥å–$K = \\sqrt{N}$ æ™‚ï¼Œè¤‡é›œåº¦å¯ä»¥é”åˆ°$O(\\sqrt{N})$ ï¼Œå¾ˆä¸éŒ¯å§ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;signed main()&#123;    ios;    int n,m,K;    cin&gt;&gt;n&gt;&gt;m;    K = sqrt(n);    deque&lt;int&gt; deq[n/K+(m/K)+10];    for(int i=0;i&lt;n;i++)&#123;        int temp;cin&gt;&gt;temp;        deq[i/K].push_back(temp);    &#125;    for(int i=0;i&lt;m;i++)&#123;        string a;cin&gt;&gt;a;        if(a[0]==&#x27;A&#x27;)&#123;            int x,y;cin&gt;&gt;y&gt;&gt;x;y--;            deq[y/K].insert(deq[y/K].begin()+(y%K), x);            int len = deq[y/K].size(),cur = y/K;            while(len&gt;K)&#123;                int temp = deq[cur].back();                deq[cur].pop_back();                cur++;                deq[cur].push_front(temp);                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;L&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            deq[x/K].erase(deq[x/K].begin()+(x%K));            int len = deq[x/K].size(),cur = x/K;            while(len&lt;K &amp;&amp; deq[cur+1].size()!=0)&#123;                int temp = deq[cur+1].front();                deq[cur+1].pop_front();                deq[cur].push_back(temp);                cur++;                len = deq[cur].size();            &#125;        &#125;        else if(a[0]==&#x27;Q&#x27;)&#123;            int x;cin&gt;&gt;x;x--;            int len = x%K;            auto it = deq[x/K].begin();            cout&lt;&lt;*(it+len)&lt;&lt;endl;        &#125;    &#125;&#125;\nç¬¬ Z å°é¡Œç›®é€£çµè¶…è¨å­ï¼Œä¸€ç›´REï¼Œçµæœæ˜¯å¡åœ¨æ²’æœ‰é–‹long longï¼Œå“­å•Šé€™ä¸€é¡Œæ˜¯å€¼åŸŸåˆ†å¡Šï¼Œä¸€æ¨£æ˜¯æ ¹æ“šå€¼åŸŸæ¯Kå€‹åˆ†æˆä¸€å¡Šï¼Œå»ç¶­è­·æ¯ä¸€å¤§å¡Šçš„æ•¸å­—æ•¸é‡ç¸½å’Œï¼Œé€™æ¨£åœ¨æŸ¥è©¢(query)çš„æ™‚å€™èŠ± $O(C/K)$ æ‰¾åˆ°ç›¸æ‡‰å¤§å¡Š(Cç‚ºå€¼åŸŸ)ï¼Œå†èŠ± $O(K)$ çš„æ™‚é–“æƒéå°å¡Šï¼Œè€ŒåŠ å€¼æ¸›å€¼éƒ½æ˜¯$O(1)$å¯ä»¥è™•ç†è¤‡é›œåº¦ï¼š$O(K+\\frac{C}{K})$ å– K=$\\sqrt{C}$ æœ‰æœ€å°å€¼ï¼š$O(Q\\sqrt{C})$\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)#define N 100005using namespace std;    //å€¼åŸŸåˆ†å¡Šconst int K = 100;signed main()&#123;    ios;    int q,arr[N],mn[N/K+10];cin&gt;&gt;q;    memset(arr, 0, sizeof(arr));    while(q--)&#123;        int temp;cin&gt;&gt;temp;        if(temp==1)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]+=y;            mn[x/K]+=y;        &#125;        else if(temp==2)&#123;            int x,y;cin&gt;&gt;x&gt;&gt;y;            arr[x]-=y;            mn[x/K]-=y;        &#125;        else if(temp==3)&#123;            int z,sum = 0,ind=0;cin&gt;&gt;z; //indæŸ¥è©¢ä½æ–¼ç¬¬å¹¾å¡Š            while(sum+mn[ind]&lt;z)sum+=mn[ind++];            int cur_ind = ind*K;            for(int i=0;i&lt;=K;i++)&#123;                if(arr[cur_ind+i])&#123;                    sum+=arr[cur_ind+i];                    if(sum&gt;=z)&#123;                        cout&lt;&lt;ind*K+i&lt;&lt;endl;                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;\nå°å’²çš„ç©å…·é¡Œç›®é€£çµé€™ä¸€é¡Œçš„å¸¸æ•¸è¶…ç·Šï¼Œå› æ­¤åœ¨å˜—è©¦ä½¿ç”¨hashæ™‚ç”¨unordredmapè¢«å¡TLEï¼Œåœ¨å¾ˆé›»çš„äººæç¤ºå¾Œï¼Œè¦ä½¿ç”¨é»‘é­”æ³•cc_hash_tableæ‰å¯èƒ½æœƒéé—œ\n#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;cc_hash_table&lt;int,int&gt;cc;\nä»–çš„ç”¨æ³•å…¶å¯¦è·Ÿunordered_mapå¹¾ä¹ä¸€æ¨£å§ï¼ˆè‡³å°‘åŸºæœ¬çš„insertè·Ÿfindçš„èªæ³•éƒ½ä¸€æ¨£ï¼‰ï¼Œä¸éä»–å¯ä»¥åšåˆ°æ¯”unordered_mapæ›´å¥½çš„æ•ˆç‡ã€‚ä¸éæˆ‘ç”¨æœ€è¿‘é»å°é€™ä¸€é¡Œæ¸¬è©¦æ•ˆç‡å»ç™¼ç¾é»‘é­”æ³•æœƒtleï¼Œå¯èƒ½æ˜¯åœ¨clearé€™ä¸€å€‹æ­¥é©Ÿçš„æ•ˆç‡ä¸¦ä¸æ˜¯å¾ˆå¥½å§ï¼\nç¸½ä¹‹ï¼Œå°±æ˜¯å°æ–¼æ¯ä¸€ç­†è©¢å•(x,y)ï¼Œä¸å¤±ä¸€èˆ¬æ€§å‡è¨­size_y &gt; size_xï¼Œå‰‡å°æ–¼yæ’åºä¸¦é è™•ç†å‰ç¶´å’Œï¼ŒåŒæ™‚æšèˆ‰xä¸­çš„æ‰€æœ‰é»ä¸¦äºŒåˆ†æœä»–åœ¨yçš„ä½ç½®æœ€é‡è¦çš„ï¼Œæ˜¯å°æ¯ä¸€ç­†è©¢å•éƒ½å„²å­˜èµ·ä¾†ï¼Œé€™æ¨£è¤‡é›œåº¦æœƒç¬é–“å°‘ä¸€å€‹Nè£œè¤‡é›œåº¦è­‰æ˜\n#include &lt;bits/stdc++.h&gt;using namespace std;#include &lt;ext/pb_ds/assoc_container.hpp&gt;using namespace __gnu_pbds;#define int long long#define N 150006int n,k,q;vector&lt;int&gt; vec[N],pre[N];bool visit[N];cc_hash_table&lt;int,int&gt;cc; int HASH(int x,int y)&#123;    return x*1000000007+y;&#125;signed main()&#123;    scanf(&quot;%lld %lld %lld&quot;,&amp;n,&amp;k,&amp;q);    memset(visit, 0, sizeof(visit));    while(k--)&#123;        int c,p;scanf(&quot;%lld %lld&quot;,&amp;c,&amp;p);        vec[p].push_back(c);    &#125;    while(q--)&#123;        int x,y;scanf(&quot;%lld %lld&quot;,&amp;x,&amp;y);        if(vec[x].size()&gt;vec[y].size())swap(x, y);                if(cc.find(HASH(x,y))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(x,y))-&gt;second);            continue;        &#125;        else if(cc.find(HASH(y,x))!=cc.end())&#123;            printf(&quot;%lld\\n&quot;,cc.find(HASH(y,x))-&gt;second);            continue;        &#125;                int len = vec[y].size();        if(!visit[y])&#123;            sort(vec[y].begin(),vec[y].end());            pre[y].resize(len+6);            for(int i=0;i&lt;=len;i++)pre[y][i+1] = pre[y][i]+vec[y][i];            visit[y] = 1;        &#125;                int ans = 0;        for(int j:vec[x])&#123;            int pos = lower_bound(vec[y].begin(), vec[y].end(),j)-vec[y].begin();            pos--;            if(pos&lt;0)ans+=(len*j);            else ans += (pre[y][pos+1]+j*(len-pos-1));        &#125;        printf(&quot;%lld\\n&quot;,ans);        cc.insert(make_pair(HASH(x,y),ans));        cc.insert(make_pair(HASH(y,x),ans));    &#125;&#125;\næ‰‹å¯«ä½œæ¥­é€™å·²ç¶“æ˜¯æœ€å¾Œçš„ä¸€å ‚èª²äº†qqï¼Œ13é€±çš„èª²ç¨‹å°±é€™æ¨£çµæŸäº†ï¼æ‰‹å¯«ä½œæ¥­æ’å12ï¼Œä¸Šæ©Ÿä¸çŸ¥é“ï¼Œä½†äºŒéšæ®µå› ç‚ºå‰›å¥½äºŒæ®µçš„é—œä¿‚ï¼Œæœ‰ä¸€å€‹ç¦®æ‹œï¼ˆdp3ï¼‰çš„èª²çš„ä¸Šæ©Ÿä½œæ¥­å…¨éƒ¨æ”¾æ‰ï¼ˆæˆ‘åœ¨å¹¹å˜›qqï¼‰é‚£çœŸæ˜¯æ…˜å•Šï¼\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","æ ¹è™Ÿç®—æ³•"]},{"title":"[é¡Œè§£]NEOJ 59 Heap ç·´ç¿’","url":"/sprout3-1/","content":"Heap ç·´ç¿’\né¡Œç›®é€£çµåˆ»ä¸€å€‹heapå˜›ï¼Œä¸æƒ³åˆ»å°±call stl( std::priorityqueue å°±ä¸æ”¾ä¸Šä¾†äº†)è‡ªå·±åˆ»ä¸€å€‹binary heap ï¼Œæ²’æœ‰æƒ³è±¡ä¸­çš„ç°¡å–®ï¼Œæœ‰äº›ç´°ç¯€æœƒä¸å°å¿ƒæ¼æ‰\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int t,top=1,heap[1000005];//complete binary treevoid push(int n)&#123;    heap[top] = n;    int father_pos = top/2,pos = top;    while(father_pos&gt;0 &amp;&amp; heap[father_pos]&gt;heap[pos])&#123;        swap(heap[father_pos], heap[pos]);        pos = father_pos;        father_pos/=2;    &#125;    top = top+1;&#125;int pop()&#123;    int ans = heap[1];    heap[1] = heap[--top];    heap[top] = 0;    int now = 1,left = now*2, right = now*2+1;        int temp = min(heap[right],heap[left]);    while(heap[left]!=0 &amp;&amp; heap[right]!=0 &amp;&amp; heap[now]&gt;temp)&#123;        if(heap[now]&gt;heap[right] &amp;&amp; heap[left]&gt;heap[right])&#123;            swap(heap[right], heap[now]);            now = right;        &#125;        else if(heap[now]&gt;heap[left])&#123;            swap(heap[left], heap[now]);            now = left;        &#125;        right = now*2+1;        left = now*2;        temp = min(heap[right],heap[left]);    &#125;    if(heap[right]!=0 &amp;&amp; heap[now]&gt;heap[right])swap(heap[right], heap[now]);    else if(heap[left]!=0 &amp;&amp; heap[now]&gt;heap[left])swap(heap[left], heap[now]);    return ans;&#125;bool empty()&#123;    if(heap[1]==0)return 1;    else return 0;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    memset(heap, 0, sizeof(heap));    while(t--)&#123;        int a;cin&gt;&gt;a;        if(a==1)&#123;            int b;cin&gt;&gt;b;            push(b);        &#125;        else if(a==2)&#123;            if(empty())cout&lt;&lt;&quot;empty!&quot;&lt;&lt;endl;            else cout&lt;&lt;pop()&lt;&lt;endl;        &#125;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]TOJ 1101 å“ªè£¡æœ‰å¦ï¼Œå“ªè£¡å°±æœ‰æº","url":"/sprout3-2/","content":"å“ªè£¡æœ‰å¦ï¼Œå“ªè£¡å°±æœ‰æº(TOJ 1101)\né¡Œç›®é€£çµæ˜é¡¯çš„äºŒåˆ†åœ–æ°´é¡Œå–”ï½ç”¨ dfs æŠŠç¶“éçš„é»æ¨™å‡ºé»‘ç™½ï¼Œéç¨‹ä¸­å¦‚æœé‡åˆ°å•é¡Œå°±è¡¨ç¤ºéäºŒåˆ†åœ–äº†\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;bool visit[100005],color[100005];vector&lt;int&gt; edge[100005];bool dfs(int id, bool col)&#123;    visit[id] = 1;    color[id] = col;    int len = edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = edge[id][i];        if(visit[temp])&#123;            if(color[temp]==col)return 0;            else continue;        &#125;        if(!dfs(temp, !col))return 0;    &#125;    return 1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        int m;cin&gt;&gt;m;        for(int i=0;i&lt;n;i++)edge[i].clear();        memset(visit, 0, sizeof(visit));        memset(color, 0, sizeof(color));        while(m--)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            edge[b].push_back(a);        &#125;        bool f = 1;        for(int i=0;i&lt;n;i++)&#123;            if(!visit[i])&#123;                if(!dfs(i, 0))&#123;                    f = 0;                    break;                &#125;            &#125;        &#125;        if(f)cout&lt;&lt;&quot;NORMAL.&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;RAINBOW.&quot;&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 44 å–µå–µæŠ“ï¤´é¼ ","url":"/sprout3-3/","content":"å–µå–µæŠ“ï¤´é¼ \né¡Œç›®é€£çµé€™ä¸€é¡Œæ˜¯ç”¨BFSæ‰¾æœ€çŸ­è·¯å¾‘ï¼Œå› ç‚ºæ²’æœ‰æ¬Šé‡ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨BFSçœ‹å¤šä¹…æœƒæœ€å…ˆèµ°åˆ°è€é¼ x y åº§æ¨™åŸæœ¬ç”¨2å€‹queue åˆ†åˆ¥å­˜xè·Ÿy ï¼Œæ²’æƒ³åˆ°MLEäº†ï¼Œå¾Œä¾†æ”¹ç”¨structï¼Œé‚„æ˜¯MLE!!ä¸éåœ¨27è¡Œçš„åœ°æ–¹æœ‰ä¸€å€‹Bugï¼Œå®³æˆ‘æ‰¾äº†å¥½ä¹…â€¦å»å•äº†é›»ç¥ï¼Œæ‰ç™¼ç¾ visit æ‡‰è©²è¦åœ¨push çš„æ™‚å€™å°±ç´€éŒ„äº†ï¼Œä¸è¦ç­‰åˆ°popçš„æ™‚å€™ï¼Œä¸ç„¶å¾ˆå¤šé‡è¤‡çš„æœƒè¢«push é€²å»ï¼ˆç°¡å–®ä¾†èªªï¼Œä¸€å€‹ä½ç½®åªèƒ½è¢«pushä¸€æ¬¡ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define MAX 102using namespace std;int n,sx,sy;int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,-1,0,1&#125;;//å·¦ä¸‹å³ä¸Šchar maze[MAX][MAX];bool visit[MAX][MAX];struct node&#123;    int x,y,path;&#125;;queue&lt;node&gt; qq;int bfs()&#123;    int now_x = sx, now_y = sy;    qq.push(node&#123;sx,sy,0&#125;);    while(!qq.empty())&#123;        now_x = qq.front().x;        now_y = qq.front().y;        if(maze[now_x][now_y]==&#x27;@&#x27;)return qq.front().path;        int front = qq.front().path+1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i],ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]!=&#x27;#&#x27;)&#123;                qq.push(node&#123;nx,ny,front&#125;);                visit[nx][ny] = 1;            &#125;        &#125;        qq.pop();    &#125;    return -1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        memset(visit, 0, sizeof(visit));        while(!qq.empty())qq.pop();        for(int i=0;i&lt;n;i++)cin&gt;&gt;maze[i];                for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;strlen(maze[i]);j++)                if(maze[i][j]==&#x27;K&#x27;)&#123;                    sx = i;sy = j;                    break;                &#125;        int ans = bfs();        if(ans&gt;=0)cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;= =\\&quot;&quot;&lt;&lt;&quot;\\n&quot;;    &#125;    return 0;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 42 åº­é™¢è£¡çš„æ°´æ± ","url":"/sprout3-4/","content":"åº­é™¢è£¡çš„æ°´æ± \né¡Œç›®é€£çµçœ‹åœ–å½¢æœ‰å¹¾å€‹é€£é€šåœ–çš„åˆ¤æ–·çš„æ°´é¡Œï¼Œå¯ä»¥ç”¨dfs æˆ–bfs åšï¼Œå°å¿ƒindexä¸è¦æˆ³åˆ°è² çš„\nBFSä½œæ³•\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void bfs(int x,int y)&#123;    int now_x=x,now_y=y;    qx.push(x);    qy.push(y);    while(!qx.empty())&#123;        now_x = qx.front();now_y = qy.front();        visit[now_x][now_y]=1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i], ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;                qx.push(nx);                qy.push(ny);                visit[nx][ny] = 1;            &#125;        &#125;        qx.pop();        qy.pop();    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    bfs(i,j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nDFSä½œæ³•\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void dfs(int x, int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;4;i++)&#123;        int nx = x+dx[i], ny = y+dy[i];        if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;            dfs(nx, ny);        &#125;    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    dfs(i, j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\næ¯”è¼ƒä¸Šé¢å…©ç¨®æ–¹æ³•çš„è¤‡é›œåº¦BFSæ˜é¡¯å„ªæ–¼DFS å•Šï¼ï¼ˆéè¿´æœ¬èº«ä¾†èªªå°±å¾ˆè€—è¨˜æ†¶é«”?!æ‡‰è©²æ˜¯é€™é¡Œç‰¹æ®Šçš„åŸå› ï¼Œä¸ç„¶æ‡‰è©²ç”¨DFS è¼ƒå„ªï¼‰\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]ZJ d537 æŸ“è‰²éŠæˆ²","url":"/sprout3-5/","content":"æŸ“è‰²éŠæˆ²â€”å°åŒ—ç¸£98è³‡è¨Šå­¸ç§‘èƒ½åŠ›ç«¶è³½\né¡Œç›®é€£çµ1é¡Œç›®é€£çµ2\n\nä¸€é¡Œå¥½é¡Œå‹éç™¾é¡Œæ°´é¡Œ\n\nç¾åœ¨çµ‚æ–¼é«”æœƒåˆ°é€™ä¸€å¥è©±çš„ç²¾é«“ï¼é€™æ˜¯ä¸€é¡Œé›£é¡Œå‘€ï¼ˆneojçš„æ¸¬è³‡å¾ˆç·Šï¼‰é¦–å…ˆå…ˆçœ‹é¡è‰²å„²å­˜çš„æ–¹å¼å¦‚æœæˆ‘æƒ³è¦è®“æ··è‰²æ™‚ä¸€å€‹é‹ç®—é€²è¡Œï¼Œé‚£è¦å¦‚ä½•ä»¥æ•¸å­—å½¢å¼å„²å­˜é¡è‰²å°±é¡¯å¾·ç›¸ç•¶é‡è¦å¯ä»¥ç™¼ç¾ï¼Œç”¨åŠ æ³•ä¸¦ä¸æ˜¯å€‹ç²‰å¥½çš„æ–¹æ³•ï¼Œå› ç‚ºé¡è‰²çš„æ•¸å­—æœ‰å¯èƒ½è¶…é7å› æ­¤å¯ä»¥ç”¨å–ORçš„æ–¹å¼ä¾†å®Œæˆï¼š\n\nYELLOW : 001BLUE : 010GREEN : 011RED : 100ORANGE : 101PURPLE : 110DARK(BLACK) : 111\n\nå¦‚æœä»¥é€™æ¨£çš„ç·¨ç¢¼æ–¹å¼ï¼Œå‰›å‰›å¥½å¯ä»¥ä»¥ORé‹ç®—ä¾†å°±å¯ä»¥æ¨¡æ“¬æŸ“è‰²ï¼ˆé€™æ‡‰è©²åªèƒ½ç”¨è§€å¯Ÿå‡ºä¾†å§ï¼‰æœ‰äº†é¡è‰²çš„ç·¨ç¢¼æ–¹å¼ä¹‹å¾Œï¼Œæ¥ä¸‹ä¾†å°±æ˜¯è™•ç†é»æ“´æ•£çš„å•é¡Œç”± $n&lt;=1000$ å¯çŸ¥ï¼Œå¦‚æœè¦ç”¨2å€‹forè¿´åœˆèµ°è¨ªæ•´å€‹ç•«å¸ƒæ˜¯ä¸å¯è¡Œçš„å› ç‚ºé€™æ¨£å°±å·²ç¶“$10^6$ å¤šå¹¾å€‹å¸¸æ•¸å°±TLEäº†ã€‚ä¸èƒ½èµ°è¨ªæ¯ä¸€å€‹é»ï¼Œå°±åªèƒ½å¥½å¥½çš„æŠŠè¦çœ‹çš„é»pushé€²queueè£¡é¢æ¯ä¸€æ¬¡é‡å°è¦æ‰¾çš„ç¯€é»ï¼Œå°±èƒ½ç¯€çœä¸å¿…è¦çš„é‹ç®—\næœ€å¾Œï¼Œè¦æ€éº¼ç¶­è­·é»å‘¢ï¼Ÿç”¨ä¸€å€‹struct å„²å­˜ï¼Œé™¤äº†åº§æ¨™ä¹‹å¤–ï¼Œå°±æ˜¯å‡ºç¾çš„æ™‚é–“é‚„æœ‰é¡è‰²\n            æˆ‘é‡åˆ°TLE æˆ– WAçš„BUGï¼šç”¨ $n^2$ æƒææ•´å€‹ç•«å¸ƒâ€”TLEpushé€²ä¸€å€‹structæ™‚è¦åœ¨åå­—éƒ¨åˆ†æ‹¬è™Ÿèµ·ä¾†ï¼šqueue&lt;node&gt; q;q.push((node)&#123;1,2,3,4&#125;);æ²’æœ‰åŠ ä¸Šé‡åˆ°æ¸›å°‘å°±breakçš„æ¢ä»¶ï¼Œæ‰€ä»¥æ¯ä¸€æ¬¡éƒ½å¿…é ˆè¦æ•´å€‹ç•«å¸ƒéƒ½è®Šæˆé»‘è‰²æ‰æœƒè¼¸å‡ºâ€”TLEæ²’æœ‰ç´€éŒ„ä¸€å€‹é»æœ‰æ²’æœ‰è¢«ä¸‰åŸè‰²èµ°éï¼Œä¸€å€‹é»å¯èƒ½è¢«èµ°éå¾ˆå¤šæ¬¡â€”TLEé‚Šç•Œè¦å¥½å¥½ç¶­è­·ï¼Œä¸€å€‹è¼ƒæ–¹ä¾¿çš„ä½œæ³•ï¼Œè®“indexéƒ½å¾1é–‹å§‹ï¼Œé€™æ¨£ç›¸åŠ ç›¸æ¸›è®Šæˆ-1 æ™‚æ‰ä¸æœƒREæ™‚é–“å„ªåŒ–ï¼šæ˜é¡¯çŸ¥é“ç­”æ¡ˆï¼ˆå¦‚å•Dçš„æƒ…æ³ï¼‰ï¼Œå°±ç›´æ¥è¼¸å‡º$n^2$å°±å¥½\n          \n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,col[150],dx[8] = &#123;-1,0,1,1,1,0,-1,-1&#125;,    dy[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;,board[1005][1005];bool visit[1005][1005][5];//ä¸‰åŸè‰²æ¯ä¸€å€‹é»åªèƒ½è¢«èµ°ä¸€æ¬¡int encode(char a)&#123;    col[&#x27;Y&#x27;] = 1;col[&#x27;B&#x27;] = 2;col[&#x27;G&#x27;] = 3;col[&#x27;R&#x27;] = 4;    col[&#x27;O&#x27;] = 5;col[&#x27;P&#x27;] = 6;col[&#x27;D&#x27;] = 7;    return col[a];&#125;struct node&#123;    int x,y,time,color;&#125;;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        queue&lt;node&gt; qq;        memset(board, 0, sizeof(board));        memset(visit, 0, sizeof(visit));        char a;        for(int i=0;i&lt;3;i++)&#123;            int b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;b++;c++;            qq.push((node)&#123;b,c,1,encode(a)&#125;);            board[b][c] = encode(a);        &#125;        cin&gt;&gt;a;        int target = encode(a),cur_sum = 0,ans = 0,time = 1;        if(a==&#x27;B&#x27;||a==&#x27;Y&#x27;||a==&#x27;R&#x27;)cur_sum++;//ç•¶è¦æ±‚çš„æ˜¯ä¸‰åŸè‰²ï¼Œåˆå§‹çš„æ•¸é‡å¯ä»¥åŠ ä¸€                if(a==&#x27;D&#x27;)&#123;            cout&lt;&lt;n*n&lt;&lt;endl;            continue;        &#125;//å¦‚æœæ˜¯Dçš„è©±ï¼Œåªéœ€è¦è¼¸å‡ºn^2ï¼Œå¯ä»¥ç¯€çœä¸å°‘æ™‚é–“        while(!qq.empty())&#123;//BFS é–‹å§‹            while(!qq.empty() &amp;&amp; qq.front().time==time)&#123;//é–‹å§‹æ¯ä¸€å€‹æ™‚åˆ»çš„æ¨¡æ“¬                int nx = qq.front().x,ny = qq.front().y;                for(int i=0;i&lt;8;i++)&#123;                    int x = nx+dx[i],y = ny+dy[i];                    if(x&lt;=0 ||x&gt;n||y&lt;=0||y&gt;n||board[x][y]==7||                       visit[x][y][qq.front().color])continue;//è¶…å‡ºé‚Šç•Œæˆ–æ›¾æ‹œè¨ªæˆ–å·²å¡—é»‘å¯è·³é                    qq.push((node)&#123;x,y,time+1,qq.front().color&#125;);//pushä¸‹ä¸€æ™‚åˆ»çš„node                    int new_color = board[x][y]|qq.front().color;//æ¯”è¼ƒæ–°çš„é¡è‰²èˆ‡èˆŠçš„é¡è‰²                    if(new_color!=board[x][y])&#123;//é¡è‰²ä¸åŒæ™‚è¦æ¯”è¼ƒç‹€æ³                        if(new_color==target)cur_sum++;//æ–°é¡è‰²æ˜¯ä½†èˆŠé¡è‰²ä¸ä¸€æ¨£ å‰‡åŠ ä¸€                        else if(board[x][y]==target)cur_sum--;//èˆŠçš„æ˜¯æ–°çš„ä¸æ˜¯ å‰‡æ¸›ä¸€                    &#125;                    board[x][y]|=qq.front().color;//å°æ–°æ–¹å¡Šä¸Šè‰²                    visit[x][y][qq.front().color] = 1;//æ­¤é¡è‰²å·²ç¶“æ‹œè¨ª                &#125;                qq.pop();//pop from queue            &#125;            time++;//ä¸€è¼ªæ¨¡æ“¬çµæŸ            if(ans&gt;cur_sum)break;//å› ç‚ºæ•¸é‡æœƒå…ˆéåš´æ ¼éå¢ã€å¾Œéåš´æ ¼éæ¸›            ans = max(ans, cur_sum);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬ä¸‰é€±ï¼šåŸºç¤åœ–è«–ã€æ·¹æ°´å•é¡Œ","url":"/sprout3/","content":"å‰å…©æ¬¡ä¸Šèª²é‚„æ²’ä¾†å¾—åŠè£œé½Šï¼Œå…ˆä¾†ç´€éŒ„ä¸€ä¸‹ç¬¬ä¸‰é€±çš„å…§å®¹\nä¸Šèª²å…§å®¹é€™ä¸€é€±çš„ä¸»é¡Œæ˜¯åŸºç¤åœ–è«–ã€æ·¹æ°´å•é¡Œ(BFS)é‚„æœ‰Heap!æŠŠé€™å¹¾å€‹å–®å…ƒæ’åœ¨ä¸€èµ·çœŸçš„æ˜¯è² æ“”å¾ˆé‡QQ\n\nåŸºç¤åœ–è«–ä¹‹å‰å°±æœ‰è½éï¼Œæ‰€ä»¥åœ¨å¯«é¡Œç›®æ„Ÿè¦ºé‚„å¥½ï¼Œä¸æœƒå¾ˆåƒåŠ›\nHeapå‰‡æ˜¯æˆ‘ç¬¬ä¸€æ¬¡æ¥è§¸åˆ°çš„è³‡æ–™çµæ§‹ï¼Œç•¶å‘¨ä¸Šèª²å‰æŠŠå½±ç‰‡ï¼ˆä»‹ç´¹Binary Heapï¼‰ä¹‹å¾Œï¼Œä¸Šèª²å°±ç›´æ¥è¬›åˆä½µHeapã€é»‘é­”æ³•Heapã€å·¦åæ¨¹ç­‰ç­‰æŠŠæˆ‘é›»çˆ›çš„æ±è¥¿\næ·¹æ°´å•é¡Œï¼Œä¸Šèª²æ²’æœ‰ç‰¹åˆ¥ä»‹ç´¹ï¼Œå› ç‚ºè¬›å¸«èªªä»–ä¸å–œæ­¡Flood Fill æ¼”ç®—æ³•æ‰€ä»¥åªè¬›äº†å¯ä»¥ç”¨ dx å’Œ dy è¡¨ç¤ºä¸Šä¸‹å·¦å³çš„æ–¹ä½ï¼Œå…¶ä»–çš„éƒ½æ²’è¬›ï¼Œåªèƒ½è‡ªå·±çœ‹å½±ç‰‡äº†å‘€ï½\n\né€™ä¸€é€±æ˜¯æ®µè€ƒé€±å‘€ æˆ‘å¾—èŠ±ä¸€äº›æ™‚é–“è®€æ®µè€ƒï¼Œä¸ç„¶æ®µè€ƒè¦çˆ†ç‚¸äº†...\n\nä¸Šæ©Ÿä½œæ¥­Heap ç·´ç¿’é¡Œç›®é€£çµåˆ»ä¸€å€‹heapå˜›ï¼Œä¸æƒ³åˆ»å°±call stl( std::priorityqueue å°±ä¸æ”¾ä¸Šä¾†äº†)è‡ªå·±åˆ»ä¸€å€‹binary heap ï¼Œæ²’æœ‰æƒ³è±¡ä¸­çš„ç°¡å–®ï¼Œæœ‰äº›ç´°ç¯€æœƒä¸å°å¿ƒæ¼æ‰\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int t,top=1,heap[1000005];//complete binary treevoid push(int n)&#123;    heap[top] = n;    int father_pos = top/2,pos = top;    while(father_pos&gt;0 &amp;&amp; heap[father_pos]&gt;heap[pos])&#123;        swap(heap[father_pos], heap[pos]);        pos = father_pos;        father_pos/=2;    &#125;    top = top+1;&#125;int pop()&#123;    int ans = heap[1];    heap[1] = heap[--top];    heap[top] = 0;    int now = 1,left = now*2, right = now*2+1;        int temp = min(heap[right],heap[left]);    while(heap[left]!=0 &amp;&amp; heap[right]!=0 &amp;&amp; heap[now]&gt;temp)&#123;        if(heap[now]&gt;heap[right] &amp;&amp; heap[left]&gt;heap[right])&#123;            swap(heap[right], heap[now]);            now = right;        &#125;        else if(heap[now]&gt;heap[left])&#123;            swap(heap[left], heap[now]);            now = left;        &#125;        right = now*2+1;        left = now*2;        temp = min(heap[right],heap[left]);    &#125;    if(heap[right]!=0 &amp;&amp; heap[now]&gt;heap[right])swap(heap[right], heap[now]);    else if(heap[left]!=0 &amp;&amp; heap[now]&gt;heap[left])swap(heap[left], heap[now]);    return ans;&#125;bool empty()&#123;    if(heap[1]==0)return 1;    else return 0;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    memset(heap, 0, sizeof(heap));    while(t--)&#123;        int a;cin&gt;&gt;a;        if(a==1)&#123;            int b;cin&gt;&gt;b;            push(b);        &#125;        else if(a==2)&#123;            if(empty())cout&lt;&lt;&quot;empty!&quot;&lt;&lt;endl;            else cout&lt;&lt;pop()&lt;&lt;endl;        &#125;    &#125;&#125;\nå“ªè£¡æœ‰å¦ï¼Œå“ªè£¡å°±æœ‰æº(TOJ 1101)é¡Œç›®é€£çµæ˜é¡¯çš„äºŒåˆ†åœ–æ°´é¡Œå–”ï½ç”¨ dfs æŠŠç¶“éçš„é»æ¨™å‡ºé»‘ç™½ï¼Œéç¨‹ä¸­å¦‚æœé‡åˆ°å•é¡Œå°±è¡¨ç¤ºéäºŒåˆ†åœ–äº†\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long longusing namespace std;int n;bool visit[100005],color[100005];vector&lt;int&gt; edge[100005];bool dfs(int id, bool col)&#123;    visit[id] = 1;    color[id] = col;    int len = edge[id].size();    for(int i=0;i&lt;len;i++)&#123;        int temp = edge[id][i];        if(visit[temp])&#123;            if(color[temp]==col)return 0;            else continue;        &#125;        if(!dfs(temp, !col))return 0;    &#125;    return 1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n)&#123;        int m;cin&gt;&gt;m;        for(int i=0;i&lt;n;i++)edge[i].clear();        memset(visit, 0, sizeof(visit));        memset(color, 0, sizeof(color));        while(m--)&#123;            int a,b;cin&gt;&gt;a&gt;&gt;b;            edge[a].push_back(b);            edge[b].push_back(a);        &#125;        bool f = 1;        for(int i=0;i&lt;n;i++)&#123;            if(!visit[i])&#123;                if(!dfs(i, 0))&#123;                    f = 0;                    break;                &#125;            &#125;        &#125;        if(f)cout&lt;&lt;&quot;NORMAL.&quot;&lt;&lt;endl;        else cout&lt;&lt;&quot;RAINBOW.&quot;&lt;&lt;endl;    &#125;&#125;\nå–µå–µæŠ“ï¤´é¼ é¡Œç›®é€£çµé€™ä¸€é¡Œæ˜¯ç”¨BFSæ‰¾æœ€çŸ­è·¯å¾‘ï¼Œå› ç‚ºæ²’æœ‰æ¬Šé‡ï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥ç”¨BFSçœ‹å¤šä¹…æœƒæœ€å…ˆèµ°åˆ°è€é¼ x y åº§æ¨™åŸæœ¬ç”¨2å€‹queue åˆ†åˆ¥å­˜xè·Ÿy ï¼Œæ²’æƒ³åˆ°MLEäº†ï¼Œå¾Œä¾†æ”¹ç”¨structï¼Œé‚„æ˜¯MLE!!ä¸éåœ¨27è¡Œçš„åœ°æ–¹æœ‰ä¸€å€‹Bugï¼Œå®³æˆ‘æ‰¾äº†å¥½ä¹…â€¦å»å•äº†é›»ç¥ï¼Œæ‰ç™¼ç¾ visit æ‡‰è©²è¦åœ¨push çš„æ™‚å€™å°±ç´€éŒ„äº†ï¼Œä¸è¦ç­‰åˆ°popçš„æ™‚å€™ï¼Œä¸ç„¶å¾ˆå¤šé‡è¤‡çš„æœƒè¢«push é€²å»ï¼ˆç°¡å–®ä¾†èªªï¼Œä¸€å€‹ä½ç½®åªèƒ½è¢«pushä¸€æ¬¡ï¼‰\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define MAX 102using namespace std;int n,sx,sy;int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,-1,0,1&#125;;//å·¦ä¸‹å³ä¸Šchar maze[MAX][MAX];bool visit[MAX][MAX];struct node&#123;    int x,y,path;&#125;;queue&lt;node&gt; qq;int bfs()&#123;    int now_x = sx, now_y = sy;    qq.push(node&#123;sx,sy,0&#125;);    while(!qq.empty())&#123;        now_x = qq.front().x;        now_y = qq.front().y;        if(maze[now_x][now_y]==&#x27;@&#x27;)return qq.front().path;        int front = qq.front().path+1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i],ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]!=&#x27;#&#x27;)&#123;                qq.push(node&#123;nx,ny,front&#125;);                visit[nx][ny] = 1;            &#125;        &#125;        qq.pop();    &#125;    return -1;&#125;signed main()&#123;    ios;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        memset(visit, 0, sizeof(visit));        while(!qq.empty())qq.pop();        for(int i=0;i&lt;n;i++)cin&gt;&gt;maze[i];                for(int i=0;i&lt;n;i++)            for(int j=0;j&lt;strlen(maze[i]);j++)                if(maze[i][j]==&#x27;K&#x27;)&#123;                    sx = i;sy = j;                    break;                &#125;        int ans = bfs();        if(ans&gt;=0)cout&lt;&lt;ans&lt;&lt;&quot;\\n&quot;;        else cout&lt;&lt;&quot;= =\\&quot;&quot;&lt;&lt;&quot;\\n&quot;;    &#125;    return 0;&#125;\nåº­é™¢è£¡çš„æ°´æ± é¡Œç›®é€£çµçœ‹åœ–å½¢æœ‰å¹¾å€‹é€£é€šåœ–çš„åˆ¤æ–·çš„æ°´é¡Œï¼Œå¯ä»¥ç”¨dfs æˆ–bfs åšï¼Œå°å¿ƒindexä¸è¦æˆ³åˆ°è² çš„\nBFSä½œæ³•\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void bfs(int x,int y)&#123;    int now_x=x,now_y=y;    qx.push(x);    qy.push(y);    while(!qx.empty())&#123;        now_x = qx.front();now_y = qy.front();        visit[now_x][now_y]=1;        for(int i=0;i&lt;4;i++)&#123;            int nx = now_x+dx[i], ny = now_y+dy[i];            if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;                qx.push(nx);                qy.push(ny);                visit[nx][ny] = 1;            &#125;        &#125;        qx.pop();        qy.pop();    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    bfs(i,j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nDFSä½œæ³•\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;bool maze[1005][1005],visit[1005][1005];int dx[4]=&#123;-1,0,1,0&#125;, dy[4]=&#123;0,1,0,-1&#125;;queue&lt;int&gt; qx,qy;void dfs(int x, int y)&#123;    visit[x][y] = 1;    for(int i=0;i&lt;4;i++)&#123;        int nx = x+dx[i], ny = y+dy[i];        if(!visit[nx][ny] &amp;&amp; maze[nx][ny]==1)&#123;            dfs(nx, ny);        &#125;    &#125;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int a,b;cin&gt;&gt;a&gt;&gt;b;        memset(maze,0,sizeof(maze));        memset(visit,0,sizeof(visit));        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                char temp;cin&gt;&gt;temp;                if(temp==&#x27;#&#x27;)maze[i][j]=0;                else maze[i][j]=1;            &#125;        &#125;        int ans = 0;        for(int i=1;i&lt;=a;i++)&#123;            for(int j=1;j&lt;=b;j++)&#123;                if(maze[i][j]==1 &amp;&amp; visit[i][j]==0)&#123;                    dfs(i, j);                    ans++;                &#125;            &#125;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\næ¯”è¼ƒä¸Šé¢å…©ç¨®æ–¹æ³•çš„è¤‡é›œåº¦BFSæ˜é¡¯å„ªæ–¼DFS å•Šï¼ï¼ˆéè¿´æœ¬èº«ä¾†èªªå°±å¾ˆè€—è¨˜æ†¶é«”?!æ‡‰è©²æ˜¯é€™é¡Œç‰¹æ®Šçš„åŸå› ï¼Œä¸ç„¶æ‡‰è©²ç”¨DFS è¼ƒå„ªï¼‰\næŸ“è‰²éŠæˆ²â€”å°åŒ—ç¸£98è³‡è¨Šå­¸ç§‘èƒ½åŠ›ç«¶è³½é¡Œç›®é€£çµ1é¡Œç›®é€£çµ2\n\nä¸€é¡Œå¥½é¡Œå‹éç™¾é¡Œæ°´é¡Œ\n\nç¾åœ¨çµ‚æ–¼é«”æœƒåˆ°é€™ä¸€å¥è©±çš„ç²¾é«“ï¼é€™æ˜¯ä¸€é¡Œé›£é¡Œå‘€ï¼ˆneojçš„æ¸¬è³‡å¾ˆç·Šï¼‰é¦–å…ˆå…ˆçœ‹é¡è‰²å„²å­˜çš„æ–¹å¼å¦‚æœæˆ‘æƒ³è¦è®“æ··è‰²æ™‚ä¸€å€‹é‹ç®—é€²è¡Œï¼Œé‚£è¦å¦‚ä½•ä»¥æ•¸å­—å½¢å¼å„²å­˜é¡è‰²å°±é¡¯å¾·ç›¸ç•¶é‡è¦å¯ä»¥ç™¼ç¾ï¼Œç”¨åŠ æ³•ä¸¦ä¸æ˜¯å€‹ç²‰å¥½çš„æ–¹æ³•ï¼Œå› ç‚ºé¡è‰²çš„æ•¸å­—æœ‰å¯èƒ½è¶…é7å› æ­¤å¯ä»¥ç”¨å–ORçš„æ–¹å¼ä¾†å®Œæˆï¼š\n\nYELLOW : 001BLUE : 010GREEN : 011RED : 100ORANGE : 101PURPLE : 110DARK(BLACK) : 111\n\nå¦‚æœä»¥é€™æ¨£çš„ç·¨ç¢¼æ–¹å¼ï¼Œå‰›å‰›å¥½å¯ä»¥ä»¥ORé‹ç®—ä¾†å°±å¯ä»¥æ¨¡æ“¬æŸ“è‰²ï¼ˆé€™æ‡‰è©²åªèƒ½ç”¨è§€å¯Ÿå‡ºä¾†å§ï¼‰æœ‰äº†é¡è‰²çš„ç·¨ç¢¼æ–¹å¼ä¹‹å¾Œï¼Œæ¥ä¸‹ä¾†å°±æ˜¯è™•ç†é»æ“´æ•£çš„å•é¡Œç”± $n&lt;=1000$ å¯çŸ¥ï¼Œå¦‚æœè¦ç”¨2å€‹forè¿´åœˆèµ°è¨ªæ•´å€‹ç•«å¸ƒæ˜¯ä¸å¯è¡Œçš„å› ç‚ºé€™æ¨£å°±å·²ç¶“$10^6$ å¤šå¹¾å€‹å¸¸æ•¸å°±TLEäº†ã€‚ä¸èƒ½èµ°è¨ªæ¯ä¸€å€‹é»ï¼Œå°±åªèƒ½å¥½å¥½çš„æŠŠè¦çœ‹çš„é»pushé€²queueè£¡é¢æ¯ä¸€æ¬¡é‡å°è¦æ‰¾çš„ç¯€é»ï¼Œå°±èƒ½ç¯€çœä¸å¿…è¦çš„é‹ç®—\næœ€å¾Œï¼Œè¦æ€éº¼ç¶­è­·é»å‘¢ï¼Ÿç”¨ä¸€å€‹struct å„²å­˜ï¼Œé™¤äº†åº§æ¨™ä¹‹å¤–ï¼Œå°±æ˜¯å‡ºç¾çš„æ™‚é–“é‚„æœ‰é¡è‰²\n            æˆ‘é‡åˆ°TLE æˆ– WAçš„BUGï¼šç”¨ $n^2$ æƒææ•´å€‹ç•«å¸ƒâ€”TLEpushé€²ä¸€å€‹structæ™‚è¦åœ¨åå­—éƒ¨åˆ†æ‹¬è™Ÿèµ·ä¾†ï¼šqueue&lt;node&gt; q;q.push((node)&#123;1,2,3,4&#125;);æ²’æœ‰åŠ ä¸Šé‡åˆ°æ¸›å°‘å°±breakçš„æ¢ä»¶ï¼Œæ‰€ä»¥æ¯ä¸€æ¬¡éƒ½å¿…é ˆè¦æ•´å€‹ç•«å¸ƒéƒ½è®Šæˆé»‘è‰²æ‰æœƒè¼¸å‡ºâ€”TLEæ²’æœ‰ç´€éŒ„ä¸€å€‹é»æœ‰æ²’æœ‰è¢«ä¸‰åŸè‰²èµ°éï¼Œä¸€å€‹é»å¯èƒ½è¢«èµ°éå¾ˆå¤šæ¬¡â€”TLEé‚Šç•Œè¦å¥½å¥½ç¶­è­·ï¼Œä¸€å€‹è¼ƒæ–¹ä¾¿çš„ä½œæ³•ï¼Œè®“indexéƒ½å¾1é–‹å§‹ï¼Œé€™æ¨£ç›¸åŠ ç›¸æ¸›è®Šæˆ-1 æ™‚æ‰ä¸æœƒREæ™‚é–“å„ªåŒ–ï¼šæ˜é¡¯çŸ¥é“ç­”æ¡ˆï¼ˆå¦‚å•Dçš„æƒ…æ³ï¼‰ï¼Œå°±ç›´æ¥è¼¸å‡º$n^2$å°±å¥½\n          \n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int n,col[150],dx[8] = &#123;-1,0,1,1,1,0,-1,-1&#125;,    dy[8] = &#123;-1,-1,-1,0,1,1,1,0&#125;,board[1005][1005];bool visit[1005][1005][5];//ä¸‰åŸè‰²æ¯ä¸€å€‹é»åªèƒ½è¢«èµ°ä¸€æ¬¡int encode(char a)&#123;    col[&#x27;Y&#x27;] = 1;col[&#x27;B&#x27;] = 2;col[&#x27;G&#x27;] = 3;col[&#x27;R&#x27;] = 4;    col[&#x27;O&#x27;] = 5;col[&#x27;P&#x27;] = 6;col[&#x27;D&#x27;] = 7;    return col[a];&#125;struct node&#123;    int x,y,time,color;&#125;;int main()&#123;    ios;    int t;cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n;        queue&lt;node&gt; qq;        memset(board, 0, sizeof(board));        memset(visit, 0, sizeof(visit));        char a;        for(int i=0;i&lt;3;i++)&#123;            int b,c;cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;b++;c++;            qq.push((node)&#123;b,c,1,encode(a)&#125;);            board[b][c] = encode(a);        &#125;        cin&gt;&gt;a;        int target = encode(a),cur_sum = 0,ans = 0,time = 1;        if(a==&#x27;B&#x27;||a==&#x27;Y&#x27;||a==&#x27;R&#x27;)cur_sum++;//ç•¶è¦æ±‚çš„æ˜¯ä¸‰åŸè‰²ï¼Œåˆå§‹çš„æ•¸é‡å¯ä»¥åŠ ä¸€                if(a==&#x27;D&#x27;)&#123;            cout&lt;&lt;n*n&lt;&lt;endl;            continue;        &#125;//å¦‚æœæ˜¯Dçš„è©±ï¼Œåªéœ€è¦è¼¸å‡ºn^2ï¼Œå¯ä»¥ç¯€çœä¸å°‘æ™‚é–“        while(!qq.empty())&#123;//BFS é–‹å§‹            while(!qq.empty() &amp;&amp; qq.front().time==time)&#123;//é–‹å§‹æ¯ä¸€å€‹æ™‚åˆ»çš„æ¨¡æ“¬                int nx = qq.front().x,ny = qq.front().y;                for(int i=0;i&lt;8;i++)&#123;                    int x = nx+dx[i],y = ny+dy[i];                    if(x&lt;=0 ||x&gt;n||y&lt;=0||y&gt;n||board[x][y]==7||                       visit[x][y][qq.front().color])continue;//è¶…å‡ºé‚Šç•Œæˆ–æ›¾æ‹œè¨ªæˆ–å·²å¡—é»‘å¯è·³é                    qq.push((node)&#123;x,y,time+1,qq.front().color&#125;);//pushä¸‹ä¸€æ™‚åˆ»çš„node                    int new_color = board[x][y]|qq.front().color;//æ¯”è¼ƒæ–°çš„é¡è‰²èˆ‡èˆŠçš„é¡è‰²                    if(new_color!=board[x][y])&#123;//é¡è‰²ä¸åŒæ™‚è¦æ¯”è¼ƒç‹€æ³                        if(new_color==target)cur_sum++;//æ–°é¡è‰²æ˜¯ä½†èˆŠé¡è‰²ä¸ä¸€æ¨£ å‰‡åŠ ä¸€                        else if(board[x][y]==target)cur_sum--;//èˆŠçš„æ˜¯æ–°çš„ä¸æ˜¯ å‰‡æ¸›ä¸€                    &#125;                    board[x][y]|=qq.front().color;//å°æ–°æ–¹å¡Šä¸Šè‰²                    visit[x][y][qq.front().color] = 1;//æ­¤é¡è‰²å·²ç¶“æ‹œè¨ª                &#125;                qq.pop();//pop from queue            &#125;            time++;//ä¸€è¼ªæ¨¡æ“¬çµæŸ            if(ans&gt;cur_sum)break;//å› ç‚ºæ•¸é‡æœƒå…ˆéåš´æ ¼éå¢ã€å¾Œéåš´æ ¼éæ¸›            ans = max(ans, cur_sum);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\næ‰‹å¯«ä½œæ¥­é€™ä¸€é€±çš„æ‰‹å¯«ä½œæ¥­æ˜¯ä»‹ç´¹c++ çš„è¨˜æ†¶é«”ä½¿ç”¨æ–¹å¼ï¼Œä»€éº¼è®Šæ•¸æ‡‰è©²æœƒè¢«å­˜åœ¨ä»€éº¼ä½ç½®ä¹‹é¡çš„ï¼Œheap èˆ‡stack é‚„æœ‰è™›æ“¬è¨˜æ†¶é«”ï¼Œä»¥åŠç‚ºä»€éº¼æœ‰æ™‚å€™å¯«dfséè¿´ä¸‹å»æœƒREçš„å•é¡Œï¼ˆæˆ‘æ˜¯é‚„æ²’æœ‰é‡éå•¦ï¼‰ç¸½ä¹‹çµ‚æ–¼æ²’æœ‰æ•¸å­¸è­‰æ˜é¡Œäº†ï¼\n\nä»Šå¤©æ®µè€ƒæœç„¶ç‚¸è£‚äº†QQQQQQQ\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","åœ–è«–","æ·¹æ°´å•é¡Œ"]},{"title":"[é¡Œè§£]TIOJ 1025 æ•¸ç¨å•é¡Œ","url":"/sprout4-1/","content":"æ•¸ç¨\né¡Œç›®é€£çµé¦–å…ˆæ˜¯æ•¸ç¨ï¼Œå¾ˆæœ‰è¶£ï¼Œä¹‹å‰æœ‰åšéé¡ä¼¼çš„æ˜¯å…«çš‡åå•é¡Œç”¨åˆ°DFSå‰ªæï¼Œç­†è¨˜åœ¨é€™\n#include &lt;bits/stdc++.h&gt;using namespace std;class Sudoku&#123;private:    int maze[9][9];    bool flag = false;public:    void print(string s);//    void scan_maze();//    vector&lt;int&gt; select(int, int);    int next_empty(int, int);    void solving();    void dfs(int row, int col );    &#125;;void Sudoku::print(string s)&#123;    cout&lt;&lt;endl&lt;&lt;&quot;=====&quot;&lt;&lt;s&lt;&lt;&quot;======&quot;&lt;&lt;endl;    for (int i=0; i&lt;9;i++)&#123;        cout&lt;&lt;&quot;|&quot;;        for (int j=0;j&lt;9;j++)&#123;            cout&lt;&lt;maze[i][j];            if(j%3==2)cout&lt;&lt;&quot;|&quot;;        &#125;        cout&lt;&lt;endl;        if(i%3==2)cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;    &#125;&#125;vector&lt;int&gt; Sudoku::select(int r, int c)&#123;    bool box[9]=&#123;0&#125;;    for(int i=0;i&lt;9;i++)&#123;        if(maze[i][c]&gt;0)box[maze[i][c]-1] = 1;        if(maze[r][i]&gt;0)box[maze[r][i]-1] = 1;    &#125;    int row_start = 3*(r/3),col_start = 3*(c/3);    for(int i=0;i&lt;3;i++)&#123;        for(int j=0;j&lt;3;j++)&#123;            if(maze[row_start+i][col_start+j]&gt;0)                box[maze[row_start+i][col_start+j]-1] = 1;        &#125;    &#125;    vector&lt;int&gt; ans;    for(int i=0;i&lt;9;i++)        if(!box[i])ans.push_back(i+1);    return ans;&#125;int Sudoku::next_empty(int row, int col)&#123;    int ind = col;    for(int i=row;i&lt;9;i++)&#123;        while(ind&lt;9)&#123;            if(maze[i][ind]==0)&#123;                int pos = i*9+ind;                return pos;            &#125;            ind++;        &#125;        ind = 0;    &#125;    return -1;&#125;void Sudoku::dfs(int row, int col )&#123;    int pos = next_empty(row, col),nr,nc;    if(pos == -1)&#123;        flag = true;        return;    &#125;    vector&lt;int&gt; candidate = select(row, col);    int len = candidate.size();        for(int i=0;i&lt;len;i++)&#123;        maze[row][col] = candidate[i];        pos = next_empty(row, col);        nr = pos/9; nc = pos%9;        dfs(nr, nc);        if(flag)return;    &#125;    maze[row][col] = 0;&#125;void Sudoku::scan_maze()&#123;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 0;            else maze[i][j] = temp -&#x27;0&#x27;;        &#125;    &#125;&#125;void Sudoku::solving()&#123;    int first_empty = next_empty(0, 0),nr,nc;    nr = first_empty/9; nc = first_empty%9;    dfs(nr, nc);    bool f = false;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            vector&lt;int&gt; v = select(i,j);            if(v.size()&gt;0)f = true;        &#125;    &#125;    if(!flag || f)cout&lt;&lt;&quot;No solution.&quot;&lt;&lt;endl;    else&#123;        print(&quot;solved&quot;);    &#125;    flag = false;&#125;int main()&#123;    Sudoku sodoku1;    sodoku1.scan_maze();    sodoku1.print(&quot;begin&quot;);    sodoku1.solving();&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 63 Lotto(UVA)","url":"/sprout4-2/","content":"Lotto(UVA)\né¡Œç›®é€£çµé€™ä¸€é¡Œä¸»è¦å°±æ˜¯å»ºç«‹ä¸€å€‹æ’åˆ—æ¨¹ï¼ŒæŠŠæ¯ä¸€ç¨®å¯èƒ½çš„æƒ…æ³ç”¨éè¿´åˆ—å‡ºä¾†é€™ä¸€é¡Œç”¨DFSæ˜é¡¯æ¯”BFSä¾†å¾—å¥½ã€ç©ºé–“çœå¾ˆå¤šï¼ˆç”¨ä¸€ä¸‹è³‡èŠ½çš„åœ–XD)\nä¾†çœ‹ç¨‹å¼ç¢¼å§ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[15];void permutation(int arr_ind, int cur[],int cur_ind)&#123;    if(arr_ind&gt;n)return;    if(cur_ind&gt;=6)&#123;        for(int i=0;i&lt;6;i++)&#123;            if(i&gt;0)cout&lt;&lt;&quot; &quot;;            cout&lt;&lt;cur[i];        &#125;        cout&lt;&lt;endl;        return;    &#125;    for(int i = 0; i &lt;= n-(6-cur_ind); i++)&#123;        cur[cur_ind] = arr[arr_ind+i];        permutation(arr_ind+i+1, cur, cur_ind+1);    &#125;&#125;bool f=0;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;    if(f)cout&lt;&lt;endl;    memset(arr, 0, sizeof(arr));    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr, arr+n);    int cur[10];    permutation(0, cur, 0);    f=1;    &#125;&#125;\n\n            é€™ä¸€é¡Œå¿…é ˆå¾ˆå°å¿ƒè¼¸å…¥è¼¸å‡ºï¼Œå®ƒå€‘æœƒè®“ä½ WAå¾ˆä¹…å‘€ï¼è¡Œæœ«ä¸è¦å¤šé¤˜ç©ºç™½æ¸¬è³‡å…¨éƒ¨å°å‡ºä¾†å¾Œï¼Œæœ«ç«¯ä¸è¦å¤šé¤˜æ›è¡Œå¤§æ¦‚å°±é€™å…©é»\n          \n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 69 ç”°å¿Œè³½é¦¬(NPSC)","url":"/sprout4-3/","content":"ç”°å¿Œè³½é¦¬(NPSC)\né¡Œç›®é€£çµä¹‹å‰æœ‰å¯«éé€™ä¸€é¡Œï¼Œä¸éç¾åœ¨å†å¯«ä¸€æ¬¡é‚„æ˜¯WAäº†å¾ˆä¹…ï¼Œå°æ–¼äºŒåˆ†æœçš„ç¶­è­·ï¼ˆåˆ°åº•æ˜¯å–åˆ°0é‚„æ˜¯1ï¼‰é‚„è¦æ›´ç†Ÿæ‚‰é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘å› ç‚ºé‚Šç•Œå•é¡Œï¼ˆ$10^8$ æˆ–æ˜¯$10^8+1$ï¼‰æ²’æœ‰ä»”ç´°æ³¨æ„å°±ä¸€ç›´WA\n#include &lt;bits/stdc++.h&gt;#define N 10000 using namespace std;  lli n,k,t,M,upper = 100000000,lower = -1;  lli mine[N],develop[N],enemy[N],curr[N];  bool win(lli day)&#123;      int it = 0,sum = 0;      for(int i=0;i&lt;n;i++)          curr[i] = mine[i]+day*develop[i];      sort(curr, curr+n);      for(int i=0;i&lt;n;i++)&#123;          if(curr[i]&gt;enemy[it])&#123;              sum++;              it++;          &#125;      &#125;      return (sum&gt;=k);  &#125;    int main()&#123;      ios::sync_with_stdio(false);      cin.tie(0);      cin&gt;&gt;t;      while(t--)&#123;          upper = 100000000;lower = -1;          cin&gt;&gt;n&gt;&gt;k;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;mine[i]&gt;&gt;develop[i];          &#125;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;enemy[i];          &#125;          sort(enemy, enemy+n);          if(!win(upper))cout&lt;&lt;-1&lt;&lt;endl;          else&#123;              while(upper-lower!=1)&#123;                  M = (upper+lower)/2;                  if(win(M))upper = M;                  else lower = M;              &#125;              cout&lt;&lt;upper&lt;&lt;endl;          &#125;      &#125;  &#125;  \n\n            é€™æ¨£ç¶­è­·äºŒåˆ†æœä¹Ÿå¯ä»¥ï¼Œå°±æ˜¯ä¿è­‰ r ä¸€å®šæ˜¯1ï¼ˆlå°±ä¸ä¸€å®šï¼‰while(r&gt;l)&#123;    int mid = (l+r)/2, arr[n+5];    for(int i=0;i&lt;n;i++)arr[i] = mine[i]+mid*rate[i];        sort(arr, arr+n,greater&lt;int&gt;());        int f = can_win(arr, enemy);        if(f)r = mid;        else l = mid+1;    &#125;å–®ç´”äºŒåˆ†æœï¼Œæ‰¾01åˆ†ç•Œé»ï¼\n          \n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 72 Happiness Function","url":"/sprout4-4/","content":"Happiness Function(2013 å°æ¸…äº¤ç¨‹å¼è¨­è¨ˆç«¶è³½)\né¡Œç›®é€£çµå¾ˆé…·çš„é¡Œç›®ï¼Œé¦–å…ˆå¿…é ˆåšä¸€é»æ•¸å­¸ä¸Šçš„åˆ†æ\n            å‡è¨­é¡Œç›®çµ¦å®šçš„nå€‹äºŒæ¬¡å‡½æ•¸ä¾åºç‚º$A_1(x),A_2(x),â€¦,A_n(x)$ä»¤å‡½æ•¸$f(t)=max(A_j(t), 1&lt;=j&lt;=n)$å‰‡$f(t)$ç‚ºä¸€å€‹Uå‹å‡½æ•¸\n          æœ‰äº†é€™å€‹æ€§è³ªä¹‹å¾Œå°±å¯ä»¥åˆ©ç”¨ä¸‰åˆ†æœä¾†æ‰¾Uå‹å‡½æ•¸çš„æœ€å°å€¼!\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼š\n\nfloat æ˜¯å–®ç²¾åº¦æµ®é»æ•¸ã€double æ˜¯é›™ç²¾åº¦æµ®é»æ•¸ï¼Œæˆ‘ç”¨ floatåƒäº†å¥½å¹¾å€‹WAï¼Œçµæœç”¨double ç›´æ¥ AC\nwhile è¿´åœˆè£¡é¢çš„åˆ¤æ–·ä¸è¦ç”¨æµ®é»æ•¸ç›¸æ¸›ï¼Œæœƒå‡ºäº‹ï¼ˆTLEï¼‰\n\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define float ausing namespace std;int T,n;double a[12],b[12],c[12];double func(double t, int i)&#123;    return a[i]*(t-b[i])*(t-b[i])+c[i];&#125;int main()&#123;    ios;    cout&lt;&lt;fixed&lt;&lt;setprecision(5);    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];        double left = 0.0, right = 300.0;        double now_l = 0,now_r = 0,nl = 0,nr = 0;        int cnt = 0;        while(cnt&lt;=10000)&#123;            nl = (2*left+right)/3;            nr = (2*right+left)/3;            now_l = now_r = 0;            for(int i=0;i&lt;n;i++)now_r = max(now_r, func(nr,i));            for(int i=0;i&lt;n;i++)now_l = max(now_l, func(nl,i));            if(now_r &gt; now_l)right = nr;            else left = nl;            cnt++;        &#125;        cout&lt;&lt;now_l&lt;&lt;endl;    &#125;&#125;\nç°¡å–®çµ±æ•´ï¼Œå°±æ˜¯ä¸‰åˆ†æœæ‰¾æœ€ä½é»ï¼\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 73 æ±æ–¹å¤å¢“å¤æ–‡","url":"/sprout4-5/","content":"æ±æ–¹å¤å¢“å¤æ–‡\né¡Œç›®é€£çµé€™ä¸€é¡Œä¸»è¦æ˜¯äºŒåˆ†æœå·¥ä½œé‡ä¸Šé™Xï¼Œå¯«ä¸€å€‹å‡½æ•¸åˆ¤æ–·æ˜¯å¦å·¥ä½œé‡Xæ˜¯å¦å¯è¡ŒDebug è¶…ä¹…ï¼Œä¸çŸ¥é“åœ¨å¹¹å˜›ï¼Œçµæœæœ€å¾Œæ˜¯å¡åœ¨äºŒåˆ†æœçš„ä¸Šç•Œç¯„åœä¸å¤ å¤§è¦é–‹åˆ°$10^9$é€™éº¼å¤§ï¼æ™‚é–“è¤‡é›œåº¦ï¼š$N$$log$(ç¸½å·¥ä½œé‡)\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;int n,m,arr[100005];bool is_ok(int lim)&#123;    int sum = 0,ans = 1;    for(int i=0;i&lt;n;i++)&#123;        if(arr[i]&gt;lim)return 0;        sum += arr[i];        if(sum+arr[i+1] &gt; lim)&#123;            sum = 0;            ans++;        &#125;    &#125;    if(ans&gt;m)return 0;    else return 1;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n&gt;&gt;m;        memset(arr, 0, sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        arr[n] = -INT_MAX;        int r = 1000000001,l = 0;        while(r-l &gt; 1)&#123;            int mid = (l+r)/2;            if(is_ok(mid))r = mid;            else l = mid;        &#125;        if(r == 1000000001)cout&lt;&lt;1000000000&lt;&lt;endl;        else cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 60 æ¥µé€Ÿé¦¬æ‹‰æ¾","url":"/sprout4-6/","content":"æ¥µé€Ÿé¦¬æ‹‰æ¾\né¡Œç›®é€£çµé€™ä¸€é¡Œé›£çš„ä¸»è¦æ˜¯è®Šæ•¸å¤ªå¤šåªè¦ç†è§£å®ƒåˆ°åº•è¦å¹¹å˜›ï¼Œå°±å¯ä»¥ç™¼ç¾å¯ä»¥åˆ©ç”¨$O(N)$æšèˆ‰å‡ºå›ºå®šå»é–“å…§æœ€å¤§çš„è·é›¢ä¹‹å¾Œå†$O(logN)$ äºŒåˆ†æœæ™‚é–“å°±å¯ä»¥ç”¨$O(logN)$ ACé€™ä¸€é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int a,b,c,d,m,s,t;int func(int time)&#123;    int speed_time = m/c,max_distance = 0,cur_m = m%c;    int cur_distance = b*speed_time,cur_t = speed_time;    if(cur_t&lt;time)&#123;        int len = time-cur_t;        for(int i=0;i&lt;=len;i++)&#123;//æ™‚é™å…§æœ€å¤šå¯ä»¥è·‘å¤šé             cur_distance = b*speed_time;            cur_t = speed_time+i;            cur_m = (m%c)+d*i;            int step = min(cur_m/c,time-cur_t);            cur_m = cur_m-step*c;            cur_t+=step;            cur_distance += b*step;            cur_distance+=a*(time-cur_t);            max_distance = max(max_distance,cur_distance);        &#125;    &#125;    else max_distance = b*time;    return max_distance;&#125;signed main()&#123;    ios;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;m&gt;&gt;s&gt;&gt;t;    int max_distance = func(t);    if(s&gt;=max_distance)cout&lt;&lt;&quot;No&quot;&lt;&lt;endl&lt;&lt;max_distance&lt;&lt;endl;    else&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        int r = t,l = 0;        while(r-l&gt;1)&#123;            int mid = (r+l)/2;            if(func(mid)&gt;s)r = mid;            else l = mid;        &#125;        cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬å››é€±ï¼šæšèˆ‰ç®—æ³•","url":"/sprout4/","content":"ä¸Šèª²å…§å®¹é€™ä¸€é€±çš„ä¸»é¡Œæ˜¯æšèˆ‰(enumeration)ï¼Œå…§å®¹ä¸»è¦ç’°ç¹äºŒåˆ†æœã€ä¸‰åˆ†æœã€DFSå‰ªæé€™äº›éƒ¨åˆ†ã€‚é€™ä¸€é€±çš„å…§å®¹ç®—æ˜¯ç›¸å°è¼•é¬†ï¼Œè§£æ•¸ç¨çš„éƒ¨åˆ†ä¹Ÿæ˜¯è »æœ‰è¶£çš„ï¼\nä¸Šæ©Ÿä½œæ¥­æ•¸ç¨é¡Œç›®é€£çµé¦–å…ˆæ˜¯æ•¸ç¨ï¼Œå¾ˆæœ‰è¶£ï¼Œä¹‹å‰æœ‰åšéé¡ä¼¼çš„æ˜¯å…«çš‡åå•é¡Œç”¨åˆ°DFSå‰ªæï¼Œç­†è¨˜åœ¨é€™\n#include &lt;bits/stdc++.h&gt;using namespace std;class Sudoku&#123;private:    int maze[9][9];    bool flag = false;public:    void print(string s);//    void scan_maze();//    vector&lt;int&gt; select(int, int);    int next_empty(int, int);    void solving();    void dfs(int row, int col );    &#125;;void Sudoku::print(string s)&#123;    cout&lt;&lt;endl&lt;&lt;&quot;=====&quot;&lt;&lt;s&lt;&lt;&quot;======&quot;&lt;&lt;endl;    for (int i=0; i&lt;9;i++)&#123;        cout&lt;&lt;&quot;|&quot;;        for (int j=0;j&lt;9;j++)&#123;            cout&lt;&lt;maze[i][j];            if(j%3==2)cout&lt;&lt;&quot;|&quot;;        &#125;        cout&lt;&lt;endl;        if(i%3==2)cout&lt;&lt;&quot;-------------&quot;&lt;&lt;endl;    &#125;&#125;vector&lt;int&gt; Sudoku::select(int r, int c)&#123;    bool box[9]=&#123;0&#125;;    for(int i=0;i&lt;9;i++)&#123;        if(maze[i][c]&gt;0)box[maze[i][c]-1] = 1;        if(maze[r][i]&gt;0)box[maze[r][i]-1] = 1;    &#125;    int row_start = 3*(r/3),col_start = 3*(c/3);    for(int i=0;i&lt;3;i++)&#123;        for(int j=0;j&lt;3;j++)&#123;            if(maze[row_start+i][col_start+j]&gt;0)                box[maze[row_start+i][col_start+j]-1] = 1;        &#125;    &#125;    vector&lt;int&gt; ans;    for(int i=0;i&lt;9;i++)        if(!box[i])ans.push_back(i+1);    return ans;&#125;int Sudoku::next_empty(int row, int col)&#123;    int ind = col;    for(int i=row;i&lt;9;i++)&#123;        while(ind&lt;9)&#123;            if(maze[i][ind]==0)&#123;                int pos = i*9+ind;                return pos;            &#125;            ind++;        &#125;        ind = 0;    &#125;    return -1;&#125;void Sudoku::dfs(int row, int col )&#123;    int pos = next_empty(row, col),nr,nc;    if(pos == -1)&#123;        flag = true;        return;    &#125;    vector&lt;int&gt; candidate = select(row, col);    int len = candidate.size();        for(int i=0;i&lt;len;i++)&#123;        maze[row][col] = candidate[i];        pos = next_empty(row, col);        nr = pos/9; nc = pos%9;        dfs(nr, nc);        if(flag)return;    &#125;    maze[row][col] = 0;&#125;void Sudoku::scan_maze()&#123;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            char temp;cin&gt;&gt;temp;            if(temp==&#x27;.&#x27;)maze[i][j] = 0;            else maze[i][j] = temp -&#x27;0&#x27;;        &#125;    &#125;&#125;void Sudoku::solving()&#123;    int first_empty = next_empty(0, 0),nr,nc;    nr = first_empty/9; nc = first_empty%9;    dfs(nr, nc);    bool f = false;    for(int i=0;i&lt;9;i++)&#123;        for(int j=0;j&lt;9;j++)&#123;            vector&lt;int&gt; v = select(i,j);            if(v.size()&gt;0)f = true;        &#125;    &#125;    if(!flag || f)cout&lt;&lt;&quot;No solution.&quot;&lt;&lt;endl;    else&#123;        print(&quot;solved&quot;);    &#125;    flag = false;&#125;int main()&#123;    Sudoku sodoku1;    sodoku1.scan_maze();    sodoku1.print(&quot;begin&quot;);    sodoku1.solving();&#125;\nLotto(UVA)é¡Œç›®é€£çµé€™ä¸€é¡Œä¸»è¦å°±æ˜¯å»ºç«‹ä¸€å€‹æ’åˆ—æ¨¹ï¼ŒæŠŠæ¯ä¸€ç¨®å¯èƒ½çš„æƒ…æ³ç”¨éè¿´åˆ—å‡ºä¾†é€™ä¸€é¡Œç”¨DFSæ˜é¡¯æ¯”BFSä¾†å¾—å¥½ã€ç©ºé–“çœå¾ˆå¤šï¼ˆç”¨ä¸€ä¸‹è³‡èŠ½çš„åœ–XD)\nä¾†çœ‹ç¨‹å¼ç¢¼å§ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,arr[15];void permutation(int arr_ind, int cur[],int cur_ind)&#123;    if(arr_ind&gt;n)return;    if(cur_ind&gt;=6)&#123;        for(int i=0;i&lt;6;i++)&#123;            if(i&gt;0)cout&lt;&lt;&quot; &quot;;            cout&lt;&lt;cur[i];        &#125;        cout&lt;&lt;endl;        return;    &#125;    for(int i = 0; i &lt;= n-(6-cur_ind); i++)&#123;        cur[cur_ind] = arr[arr_ind+i];        permutation(arr_ind+i+1, cur, cur_ind+1);    &#125;&#125;bool f=0;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;    if(f)cout&lt;&lt;endl;    memset(arr, 0, sizeof(arr));    for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];    sort(arr, arr+n);    int cur[10];    permutation(0, cur, 0);    f=1;    &#125;&#125;\n\n            é€™ä¸€é¡Œå¿…é ˆå¾ˆå°å¿ƒè¼¸å…¥è¼¸å‡ºï¼Œå®ƒå€‘æœƒè®“ä½ WAå¾ˆä¹…å‘€ï¼è¡Œæœ«ä¸è¦å¤šé¤˜ç©ºç™½æ¸¬è³‡å…¨éƒ¨å°å‡ºä¾†å¾Œï¼Œæœ«ç«¯ä¸è¦å¤šé¤˜æ›è¡Œå¤§æ¦‚å°±é€™å…©é»\n          \nç”°å¿Œè³½é¦¬(NPSC)é¡Œç›®é€£çµä¹‹å‰æœ‰å¯«éé€™ä¸€é¡Œï¼Œä¸éç¾åœ¨å†å¯«ä¸€æ¬¡é‚„æ˜¯WAäº†å¾ˆä¹…ï¼Œå°æ–¼äºŒåˆ†æœçš„ç¶­è­·ï¼ˆåˆ°åº•æ˜¯å–åˆ°0é‚„æ˜¯1ï¼‰é‚„è¦æ›´ç†Ÿæ‚‰é™¤æ­¤ä¹‹å¤–ï¼Œæˆ‘å› ç‚ºé‚Šç•Œå•é¡Œï¼ˆ$10^8$ æˆ–æ˜¯$10^8+1$ï¼‰æ²’æœ‰ä»”ç´°æ³¨æ„å°±ä¸€ç›´WA\n#include &lt;bits/stdc++.h&gt;#define N 10000 using namespace std;  lli n,k,t,M,upper = 100000000,lower = -1;  lli mine[N],develop[N],enemy[N],curr[N];  bool win(lli day)&#123;      int it = 0,sum = 0;      for(int i=0;i&lt;n;i++)          curr[i] = mine[i]+day*develop[i];      sort(curr, curr+n);      for(int i=0;i&lt;n;i++)&#123;          if(curr[i]&gt;enemy[it])&#123;              sum++;              it++;          &#125;      &#125;      return (sum&gt;=k);  &#125;    int main()&#123;      ios::sync_with_stdio(false);      cin.tie(0);      cin&gt;&gt;t;      while(t--)&#123;          upper = 100000000;lower = -1;          cin&gt;&gt;n&gt;&gt;k;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;mine[i]&gt;&gt;develop[i];          &#125;          for(int i=0;i&lt;n;i++)&#123;              cin&gt;&gt;enemy[i];          &#125;          sort(enemy, enemy+n);          if(!win(upper))cout&lt;&lt;-1&lt;&lt;endl;          else&#123;              while(upper-lower!=1)&#123;                  M = (upper+lower)/2;                  if(win(M))upper = M;                  else lower = M;              &#125;              cout&lt;&lt;upper&lt;&lt;endl;          &#125;      &#125;  &#125;  \n\n            é€™æ¨£ç¶­è­·äºŒåˆ†æœä¹Ÿå¯ä»¥ï¼Œå°±æ˜¯ä¿è­‰ r ä¸€å®šæ˜¯1ï¼ˆlå°±ä¸ä¸€å®šï¼‰while(r&gt;l)&#123;    int mid = (l+r)/2, arr[n+5];    for(int i=0;i&lt;n;i++)arr[i] = mine[i]+mid*rate[i];        sort(arr, arr+n,greater&lt;int&gt;());        int f = can_win(arr, enemy);        if(f)r = mid;        else l = mid+1;    &#125;å–®ç´”äºŒåˆ†æœï¼Œæ‰¾01åˆ†ç•Œé»ï¼\n          \nHappiness Function(2013 å°æ¸…äº¤ç¨‹å¼è¨­è¨ˆç«¶è³½)é¡Œç›®é€£çµå¾ˆé…·çš„é¡Œç›®ï¼Œé¦–å…ˆå¿…é ˆåšä¸€é»æ•¸å­¸ä¸Šçš„åˆ†æ\n            å‡è¨­é¡Œç›®çµ¦å®šçš„nå€‹äºŒæ¬¡å‡½æ•¸ä¾åºç‚º$A_1(x),A_2(x),â€¦,A_n(x)$ä»¤å‡½æ•¸$f(t)=max(A_j(t), 1&lt;=j&lt;=n)$å‰‡$f(t)$ç‚ºä¸€å€‹Uå‹å‡½æ•¸\n          æœ‰äº†é€™å€‹æ€§è³ªä¹‹å¾Œå°±å¯ä»¥åˆ©ç”¨ä¸‰åˆ†æœä¾†æ‰¾Uå‹å‡½æ•¸çš„æœ€å°å€¼!\nå€¼å¾—æ³¨æ„çš„æ˜¯ï¼š\n\nfloat æ˜¯å–®ç²¾åº¦æµ®é»æ•¸ã€double æ˜¯é›™ç²¾åº¦æµ®é»æ•¸ï¼Œæˆ‘ç”¨ floatåƒäº†å¥½å¹¾å€‹WAï¼Œçµæœç”¨double ç›´æ¥ AC\nwhile è¿´åœˆè£¡é¢çš„åˆ¤æ–·ä¸è¦ç”¨æµ®é»æ•¸ç›¸æ¸›ï¼Œæœƒå‡ºäº‹ï¼ˆTLEï¼‰\n\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define float ausing namespace std;int T,n;double a[12],b[12],c[12];double func(double t, int i)&#123;    return a[i]*(t-b[i])*(t-b[i])+c[i];&#125;int main()&#123;    ios;    cout&lt;&lt;fixed&lt;&lt;setprecision(5);    cin&gt;&gt;T;    while(T--)&#123;        cin&gt;&gt;n;        for(int i=0;i&lt;n;i++)cin&gt;&gt;a[i]&gt;&gt;b[i]&gt;&gt;c[i];        double left = 0.0, right = 300.0;        double now_l = 0,now_r = 0,nl = 0,nr = 0;        int cnt = 0;        while(cnt&lt;=10000)&#123;            nl = (2*left+right)/3;            nr = (2*right+left)/3;            now_l = now_r = 0;            for(int i=0;i&lt;n;i++)now_r = max(now_r, func(nr,i));            for(int i=0;i&lt;n;i++)now_l = max(now_l, func(nl,i));            if(now_r &gt; now_l)right = nr;            else left = nl;            cnt++;        &#125;        cout&lt;&lt;now_l&lt;&lt;endl;    &#125;&#125;\nç°¡å–®çµ±æ•´ï¼Œå°±æ˜¯ä¸‰åˆ†æœæ‰¾æœ€ä½é»ï¼\næ±æ–¹å¤å¢“å¤æ–‡é¡Œç›®é€£çµé€™ä¸€é¡Œä¸»è¦æ˜¯äºŒåˆ†æœå·¥ä½œé‡ä¸Šé™Xï¼Œå¯«ä¸€å€‹å‡½æ•¸åˆ¤æ–·æ˜¯å¦å·¥ä½œé‡Xæ˜¯å¦å¯è¡ŒDebug è¶…ä¹…ï¼Œä¸çŸ¥é“åœ¨å¹¹å˜›ï¼Œçµæœæœ€å¾Œæ˜¯å¡åœ¨äºŒåˆ†æœçš„ä¸Šç•Œç¯„åœä¸å¤ å¤§è¦é–‹åˆ°$10^9$é€™éº¼å¤§ï¼æ™‚é–“è¤‡é›œåº¦ï¼š$N$$log$(ç¸½å·¥ä½œé‡)\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;int n,m,arr[100005];bool is_ok(int lim)&#123;    int sum = 0,ans = 1;    for(int i=0;i&lt;n;i++)&#123;        if(arr[i]&gt;lim)return 0;        sum += arr[i];        if(sum+arr[i+1] &gt; lim)&#123;            sum = 0;            ans++;        &#125;    &#125;    if(ans&gt;m)return 0;    else return 1;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;n&gt;&gt;m;        memset(arr, 0, sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        arr[n] = -INT_MAX;        int r = 1000000001,l = 0;        while(r-l &gt; 1)&#123;            int mid = (l+r)/2;            if(is_ok(mid))r = mid;            else l = mid;        &#125;        if(r == 1000000001)cout&lt;&lt;1000000000&lt;&lt;endl;        else cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\næ¥µé€Ÿé¦¬æ‹‰æ¾é¡Œç›®é€£çµé€™ä¸€é¡Œé›£çš„ä¸»è¦æ˜¯è®Šæ•¸å¤ªå¤šåªè¦ç†è§£å®ƒåˆ°åº•è¦å¹¹å˜›ï¼Œå°±å¯ä»¥ç™¼ç¾å¯ä»¥åˆ©ç”¨$O(N)$æšèˆ‰å‡ºå›ºå®šå»é–“å…§æœ€å¤§çš„è·é›¢ä¹‹å¾Œå†$O(logN)$ äºŒåˆ†æœæ™‚é–“å°±å¯ä»¥ç”¨$O(logN)$ ACé€™ä¸€é¡Œ\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int a,b,c,d,m,s,t;int func(int time)&#123;    int speed_time = m/c,max_distance = 0,cur_m = m%c;    int cur_distance = b*speed_time,cur_t = speed_time;    if(cur_t&lt;time)&#123;        int len = time-cur_t;        for(int i=0;i&lt;=len;i++)&#123;//æ™‚é™å…§æœ€å¤šå¯ä»¥è·‘å¤šé             cur_distance = b*speed_time;            cur_t = speed_time+i;            cur_m = (m%c)+d*i;            int step = min(cur_m/c,time-cur_t);            cur_m = cur_m-step*c;            cur_t+=step;            cur_distance += b*step;            cur_distance+=a*(time-cur_t);            max_distance = max(max_distance,cur_distance);        &#125;    &#125;    else max_distance = b*time;    return max_distance;&#125;signed main()&#123;    ios;    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;m&gt;&gt;s&gt;&gt;t;    int max_distance = func(t);    if(s&gt;=max_distance)cout&lt;&lt;&quot;No&quot;&lt;&lt;endl&lt;&lt;max_distance&lt;&lt;endl;    else&#123;        cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;        int r = t,l = 0;        while(r-l&gt;1)&#123;            int mid = (r+l)/2;            if(func(mid)&gt;s)r = mid;            else l = mid;        &#125;        cout&lt;&lt;r&lt;&lt;endl;    &#125;&#125;\näººç”Ÿä½æ½®é¡Œç›®é€£çµ\næ‰‹å¯«ä½œæ¥­æ‰‹å¯«ä½œæ¥­ä»‹ç´¹å­—ä¸²æ¯”å°ã€å„ç¨®æ’åºæ¼”ç®—æ³•ã€‚é€™æ˜¯æˆ‘ç®—æ˜¯ç¬¬ä¸€æ¬¡ææ‡‚å¿«é€Ÿæ’åºåœ¨å¹¹å˜›ï¼Œä¸ç„¶ä¹‹å‰éƒ½æ˜¯çœ‹å…©å€‹æŒ‡é‡åœ¨æŒ‡ä¾†æŒ‡å»ä¸çŸ¥é“ç¢ºåˆ‡çš„åŠŸèƒ½æ˜¯ä»€éº¼ã€‚é™¤äº†å¿«æ’ä¹‹å¤–ï¼ŒåŸºæ•¸æ’åºä¹Ÿæ˜¯ç¬¬ä¸€æ¬¡çœ‹åˆ°ï¼ŒåŸä¾†æ’åºå¯ä»¥åšåˆ°ç·šæ€§æ™‚é–“è¤‡é›œåº¦ï¼å¤§é–‹çœ¼ç•Œï¼ï¼ˆä¸éåªæ˜¯ç”¨æ–¼æ•´æ•¸æ’åºï¼‰é€™æ¬¡æ‰‹å¯«è¦ºå¾—æœ‰äº›å›°é›£ï¼Œä¸éå­¸åˆ°äº†å¾ˆå¤šæ±è¥¿ï¼ï¼ˆå¯ä»¥ä¾†åšä¸€å€‹å„ç¨®æ’åºæ¼”ç®—çš„ç­†è¨˜ï¼‰\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","æšèˆ‰"]},{"title":"[é¡Œè§£]NEOJ 70 Add all(UVA)","url":"/sprout5-1/","content":"Add all(UVA)\né¡Œç›®é€£çµé€™ä¸€é¡Œå¯ä»¥è¼•é¬†è§€å¯Ÿå‡ºè¦å¾‹ï¼šæ•¸å­—è¶Šæ—©è¢«ç›¸åŠ ï¼Œè¢«åŠ ç¸½çš„æ¬¡æ•¸å°±æœƒè¶Šå¤šå› æ­¤ï¼Œç¶­è­·ä¸€å€‹priority_queueï¼Œæ¯æ¬¡popå‡ºæœ€å°çš„å…©å€‹æ•¸å­—å†push å›å»ï¼Œå¯ä»¥ä¿è­‰ç¸½å’Œä¸€å®šæœƒæ˜¯æœ€å°çš„\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    ios;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qq;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            qq.push(temp);        &#125;        int ans = 0;        while(qq.size()&gt;1)&#123;            int a,b;            a = qq.top();qq.pop();            b = qq.top();qq.pop();            qq.push(a+b);            ans+=(a+b);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;        qq.pop();    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 74 å††å††æ”»ç•¥é»ƒæ²³(TIOJ)","url":"/sprout5-2/","content":"å††å††æ”»ç•¥é»ƒæ²³(TIOJ)\né¡Œç›®é€£çµé€™ä¸€é¡Œè¦æ±‚æœ€é•·çš„é•·çŸ­ç›¸é–“çš„åºåˆ—é•·åº¦ï¼Œé›–ç„¶çŸ¥é“æ˜¯Greedy ï¼Œä½†ç¬¬ä¸€æ™‚é–“æƒ³ä¸åˆ°å…·é«”çš„ä½œæ³•å¡äº†æœ‰ä¸€é»ä¹…ï¼Œç¸½å…±å˜—è©¦äº†ä¸‰æ¬¡ï¼Œå‰å…©æ¬¡ä»¥ç‚ºå°ï¼Œä½†WA å¾Œé‚„æ˜¯ç™¼ç¾å…¶ä¸­çš„Bug\n\nå¾ç¬¬ä¸€å€‹æ•¸å­—é–‹å§‹ï¼Œæ‰¾åˆ°ä¸‹ä¸€å€‹æ¯”è‡ªå·±å°çš„æ•¸å­—ï¼Œå†æ‰¾æ¯”é‚£ä¸€å€‹å¤§çš„ï¼Œé‡è¤‡å¹¾æ¬¡ç›´åˆ°çµæŸ\n            å•é¡Œåœ¨æ–¼ï¼Œç¬¬ä¸€å€‹æ•¸å­—å¯èƒ½å¾ˆå°ï¼Œå°è‡´æ¥ä¸‹ä¾†çš„åºåˆ—é•·åº¦å¾ˆçŸ­\n          \næ‰¾åˆ°ç¬¬ä¸€å€‹ã€Œä¸‹ä¸€å€‹æ•¸æ¯”è‡ªå·±å°ã€çš„æ•¸å­—ï¼Œæ¥è‘—é‡è¤‡ç¬¬1é»çš„æ­¥é©Ÿ\n            å› ç‚ºè¦ä¿è­‰åºåˆ—æ˜¯æœ€é•·çš„ï¼Œæœƒå¸Œæœ›åœ¨æ‰¾æ¯”è‡ªå·±å¤§æˆ–å°çš„æ•¸å­—æ™‚å¯ä»¥ç›¡é‡æœ€å¤§æˆ–æœ€å°ï¼Œæ‰å¯ä»¥ç¢ºä¿æ‰€æœ‰æ•¸å­—èƒ½æœ‰æ©Ÿæœƒè¢«åŒ…å«é€²å»\n          \nå°æ¯ä¸€å€‹æ•¸å­—å¦‚æœè¦æ‰¾å¤§æ–¼è‡ªå·±çš„ï¼Œå°±ä¸€ç›´ç¹¼çºŒå¾€ä¸Šæ‰¾ç›´åˆ°æœ€å¤§ï¼Œå¦‚æœè¦æ‰¾æœ€å°çš„ä¹Ÿæ˜¯ä¸€æ¨£\n            ä»¥ 5 1 2 4 5 3 6 ä¾†èªªï¼Œå°±æ˜¯å¾5é–‹å§‹ï¼Œæ¥ä¸‹ä¾†æ˜¯1ï¼ˆæœ€å°äº†ï¼‰ï¼Œæ¥ä¸‹ä¾†å¾€ä¸Šæ‰¾ï¼Œå¯ä»¥æ‰¾åˆ°2, 4, 5ï¼Œè€Œç‚ºäº†ç›¡é‡è®“æ•¸å­—å¤§æ‰èƒ½åŒ…åˆ°æ¥ä¸‹ä¾†çš„æ•¸å­—ï¼ˆå¦‚æœé¸2ä¸‹ä¸€å€‹å°±ä¸èƒ½æ˜¯3ï¼‰ï¼Œæ‰€ä»¥é¸5ï¼Œå†ä¾†å°±æ˜¯3 è·Ÿ6 ã€‚æ‰€ä»¥åºåˆ—ç‚ºï¼š 5 1 5 3 6 ï¼Œ é•·åº¦ç‚º5\n          \næƒ³èªªæ‡‰è©²è¦AC äº†ï¼Œæ²’æƒ³åˆ°æ²’æœ‰memset æ‰€ä»¥åƒäº†ä¸€å€‹WA ï¼\n\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    int n,arr[1000005];    while(t--)&#123;        cin&gt;&gt;n;        memset(arr,0,sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int height = 0, ind = 0, ans = 1;//0-&gt;down 1-&gt;up        while(ind&lt;n &amp;&amp; arr[ind]&lt;=arr[ind+1])ind++;                while(ind&lt;n)&#123;            if(height == 0 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&gt;=arr[ind+1])ind++;                height = 1;            &#125;            else if(height == 1 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&lt;=arr[ind+1])ind++;                height = 0;                ans+=2;            &#125;            ind++;//å¦‚æœæœ‰é€£çºŒç›¸åŒæ•¸å­—éœ€è¦åŠ         &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]TIOJ 1072 èª°å…ˆæ™šé¤ ","url":"/sprout5-3/","content":"èª°å…ˆæ™šé¤\né¡Œç›®é€£çµæŒ‰ç…§Greegy çš„æƒ³æ³•ï¼Œåƒæœ€æ…¢çš„äººè¦æœ€å…ˆåƒï¼Œåƒæœ€å¿«çš„äººè¦å¾Œåƒï¼Œæ‰èƒ½è®“æ•´å€‹æ™‚é–“ç›¡é‡çš„ç¸®çŸ­é€™ä¸€é¡Œä¹‹å‰å­¸é•·è¬›è§£éï¼Œæ‰€ä»¥è‡ªç„¶æ˜¯æ¯”è¼ƒç°¡å–®ã€‚But! è¦æ€éº¼è­‰æ˜é€™æ¨£å¯ä»¥å¾—åˆ°æœ€ä½³è§£å‘¢ï½ç•™åˆ°æ‰‹å¯«ä½œæ¥­ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct student&#123;    int eat,cook;&#125;people[10005];bool comp(student a,student b)&#123;    return a.eat &gt; b.eat;&#125;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;people[i].cook&gt;&gt;people[i].eat;        &#125;        sort(people, people+n, comp);        int ans = 0,cook = 0;        for(int i=0;i&lt;n;i++)&#123;            cook+=people[i].cook;//ç…®é£¯æ™‚é–“ä¸€å®šç¸½æ•¸ä¸æœƒæ”¹è®Š            int leave = cook+people[i].eat;            ans = max(ans, leave);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 78 åŒ…è£ç¦®ç‰©","url":"/sprout5-4/","content":"åŒ…è£ç¦®ç‰©\né¡Œç›®é€£çµä¸€ç›´åƒWA ï¼Œåƒåˆ°æ‡·ç–‘äººç”Ÿå“ï½æƒ³æ³•ï¼šç”±å¤§æ–¹å¡Šåˆ°å°æ–¹å¡Šï¼Œç›¡é‡å¡«æ»¿ï¼Œå¦‚æœéç¨‹ä¸­å¤§å°ç‚º4çš„æ–¹å¡Šè®Šæˆè² çš„ï¼Œå¯ä»¥å…ˆæ¬ è‘—ï¼Œç›´åˆ°æœ€å¾Œä¸€æ¬¡ç”±å¤§å°ç‚º1çš„ä¾†è£œï¼Œé€™æ¨£å¯ä»¥ç¢ºä¿æ¯ä¸€æ ¼æ–¹å¡Šä¸æ˜¯è¢«1*1çš„å¡«æ»¿å°±æ˜¯å‰©ä¸‹æœ€å°‘çš„ç©ºæ ¼\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int a,b,c,d,e,f;signed main()&#123;    ios;    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f)&#123;        if(a==0&amp;&amp;b==0&amp;&amp;c==0&amp;&amp;d==0&amp;&amp;e==0&amp;&amp;f==0)break;        int ans = f+e+d;        a = a - 11*e;//5*5å¯ä»¥ç”¨11å€‹1*1å¡«        b = b - 5*d;//ä¸€å€‹4*4å¯ä»¥ç”¨5å€‹2*2å¡«        ans+=(c/4);        if(c%4!=0)ans++;        if(c%4==1)&#123;            a = a - 7;            b = b - 5;        &#125;        else if(c%4==2)&#123;            a = a - 6;            b = b - 3;        &#125;        else if(c%4==3)&#123;            a = a - 5;            b = b - 1;        &#125;        if(b&gt;0)&#123;            ans+=(b/9);            if(b%9!=0)ans++;            a = a-(36-4*(b%9));        &#125;        else if(b&lt;0)a = a-(4*(-b));//å¦‚æœbæœ‰æ¬ ï¼Œå¯ä»¥ç”¨aä¾†è£œ        if(a&gt;0)&#123;            ans+=a/36;            if(a%36!=0)ans++;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 91 èª¿æ ¡é«˜æ£•æ«š","url":"/sprout5-5/","content":"èª¿æ ¡é«˜æ£•æ«š\né¡Œç›®é€£çµå¦‚æœæƒ³è¦è®“æ•¸å­—ç›¡é‡å°ï¼Œé‚£å‹¢å¿…è¦è®“æ•¸å­—çš„ä½æ•¸ç›¡é‡å°‘å› æ­¤å¯ä»¥å…ˆæŠŠ3å€‹2åˆä½µæˆ8ï¼Œ2å€‹3åˆä½µæˆ9è€Œå‰©ä¸‹çš„2è·Ÿ3å¯ä»¥æœ‰6 ç¨®çµ„åˆï¼š\n\n\n\n\næ•¸å­—å€‹æ•¸\n0å€‹2\n1å€‹2\n2å€‹2\n\n\n\n\n0å€‹3\nç„¡\n2\n4\n\n\n1å€‹3\n2\n6\n2,6\n\n\n\n\nå…ˆæŠŠæ•¸å­—åšè³ªå› æ•¸åˆ†è§£ï¼Œå¦‚æœæœ‰è³ªæ•¸å¤§æ–¼10ï¼Œå°±è¼¸å‡º-1æ¥ä¸‹ä¾†ï¼Œå†ç”¨é€™6ç¨®çµ„åˆç”¨if æ’åˆ—çµ„åˆå°±å®Œæˆäº†\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[11]=&#123;0&#125;;cin&gt;&gt;n;        if(n==1)&#123;            cout&lt;&lt;1&lt;&lt;endl;            continue;        &#125;        int ind = 2;        while(ind&lt;=9)&#123;            if(n%ind==0)&#123;                n /= ind;                arr[ind]++;            &#125;            else ind++;        &#125;        if(n&gt;10)&#123;            cout&lt;&lt;-1&lt;&lt;endl;            continue;        &#125;        vector&lt;int&gt;vec;                for(int i=0;i&lt;arr[2]/3;i++)vec.push_back(8);        arr[2]=arr[2]%3;        for(int i=0;i&lt;arr[3]/2;i++)vec.push_back(9);        arr[3]=arr[3]%2;                if(arr[2]==1 &amp;&amp; arr[3]==0)vec.push_back(2);        if(arr[2]==2 &amp;&amp; arr[3]==0)vec.push_back(4);        if(arr[2]==0 &amp;&amp; arr[3]==1)vec.push_back(3);        if(arr[2]==1 &amp;&amp; arr[3]==1)vec.push_back(6);        if(arr[2]==2 &amp;&amp; arr[3]==1)&#123;            vec.push_back(2);            vec.push_back(6);        &#125;        for(int i=0;i&lt;arr[5];i++)vec.push_back(5);        for(int i=0;i&lt;arr[7];i++)vec.push_back(7);        sort(vec.begin(),vec.end());        for(auto i:vec)cout&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬äº”é€±ï¼šè²ªå¿ƒç®—æ³•","url":"/sprout5/","content":"é€™ä¸€é€±ä¸»é¡Œæ˜¯Greedyï¼Œå…¶å¯¦è²ªå¿ƒæ³•çš„é¡Œç›®è¦é›£å¯ä»¥åˆ°å¾ˆé›£ï¼Œæœ‰é»åƒä¸€å€‹æŠ½è±¡çš„æƒ³æ³•ï¼Œéœ€è¦é€éåè¦†çš„å¯¦ä½œèˆ‡ç·´ç¿’ï¼ˆé¡¯ç„¶æˆ‘ç¼ºä¹ï¼‰ï¼Œä¾†æ›´å®¹æ˜“çš„æƒ³åˆ°é¡Œç›®çš„è§£æ³•ï¼\nä¸Šèª²å…§å®¹å½±ç‰‡çš„å…§å®¹ä¸»è¦æ˜¯åœ¨è­‰æ˜greedy çš„æ­£ç¢ºæ€§ï¼Œè¶…è¤‡é›œçš„æ•¸å­¸è­‰æ˜ï¼ˆåˆæ˜¯æ•¸å­¸è­‰æ˜ï¼ï¼‰åŸæœ¬ä»¥ç‚ºä¸Šèª²æœƒå»¶çºŒè­‰æ˜çš„å…§å®¹ï¼Œæ²’æƒ³åˆ°å®Œå…¨æ²’æœ‰è¬›åˆ°è­‰æ˜çš„å…§å®¹ï¼Œéƒ½æ˜¯åœ¨è¬›è§£ä¾‹é¡Œï¼ˆä¹Ÿä¸éŒ¯ï¼Œæœ‰å¾ˆå¤šé¡Œéœ€è¦æ…¢æ…¢ç†è§£ï¼‰æ‰€ä»¥åˆ—äº†ä¸Šèª²è¬›éçš„ä¾‹é¡Œï¼Œä¸€å®šè¦ææ‡‚ï¼\n\nçµ•å°ä¸è¦è¼•å¿½ Greedy å•Šï¼Œæƒ³æ³•çœ‹ä¼¼å–®ç´”ï¼Œè¦æƒ³å‡ºè§£æ³•ï¼Œé‚„æ˜¯éœ€è¦ç¶“é©—çš„ï¼\nä¸Šæ©Ÿä½œæ¥­Add all(UVA)é¡Œç›®é€£çµé€™ä¸€é¡Œå¯ä»¥è¼•é¬†è§€å¯Ÿå‡ºè¦å¾‹ï¼šæ•¸å­—è¶Šæ—©è¢«ç›¸åŠ ï¼Œè¢«åŠ ç¸½çš„æ¬¡æ•¸å°±æœƒè¶Šå¤šå› æ­¤ï¼Œç¶­è­·ä¸€å€‹priority_queueï¼Œæ¯æ¬¡popå‡ºæœ€å°çš„å…©å€‹æ•¸å­—å†push å›å»ï¼Œå¯ä»¥ä¿è­‰ç¸½å’Œä¸€å®šæœƒæ˜¯æœ€å°çš„\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;signed main()&#123;    ios;    priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt;qq;    while(cin&gt;&gt;n &amp;&amp; n!=0)&#123;        for(int i=0;i&lt;n;i++)&#123;            int temp;cin&gt;&gt;temp;            qq.push(temp);        &#125;        int ans = 0;        while(qq.size()&gt;1)&#123;            int a,b;            a = qq.top();qq.pop();            b = qq.top();qq.pop();            qq.push(a+b);            ans+=(a+b);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;        qq.pop();    &#125;&#125;\nå††å††æ”»ç•¥é»ƒæ²³(TIOJ)é¡Œç›®é€£çµé€™ä¸€é¡Œè¦æ±‚æœ€é•·çš„é•·çŸ­ç›¸é–“çš„åºåˆ—é•·åº¦ï¼Œé›–ç„¶çŸ¥é“æ˜¯Greedy ï¼Œä½†ç¬¬ä¸€æ™‚é–“æƒ³ä¸åˆ°å…·é«”çš„ä½œæ³•å¡äº†æœ‰ä¸€é»ä¹…ï¼Œç¸½å…±å˜—è©¦äº†ä¸‰æ¬¡ï¼Œå‰å…©æ¬¡ä»¥ç‚ºå°ï¼Œä½†WA å¾Œé‚„æ˜¯ç™¼ç¾å…¶ä¸­çš„Bug\n\nå¾ç¬¬ä¸€å€‹æ•¸å­—é–‹å§‹ï¼Œæ‰¾åˆ°ä¸‹ä¸€å€‹æ¯”è‡ªå·±å°çš„æ•¸å­—ï¼Œå†æ‰¾æ¯”é‚£ä¸€å€‹å¤§çš„ï¼Œé‡è¤‡å¹¾æ¬¡ç›´åˆ°çµæŸ\n            å•é¡Œåœ¨æ–¼ï¼Œç¬¬ä¸€å€‹æ•¸å­—å¯èƒ½å¾ˆå°ï¼Œå°è‡´æ¥ä¸‹ä¾†çš„åºåˆ—é•·åº¦å¾ˆçŸ­\n          \næ‰¾åˆ°ç¬¬ä¸€å€‹ã€Œä¸‹ä¸€å€‹æ•¸æ¯”è‡ªå·±å°ã€çš„æ•¸å­—ï¼Œæ¥è‘—é‡è¤‡ç¬¬1é»çš„æ­¥é©Ÿ\n            å› ç‚ºè¦ä¿è­‰åºåˆ—æ˜¯æœ€é•·çš„ï¼Œæœƒå¸Œæœ›åœ¨æ‰¾æ¯”è‡ªå·±å¤§æˆ–å°çš„æ•¸å­—æ™‚å¯ä»¥ç›¡é‡æœ€å¤§æˆ–æœ€å°ï¼Œæ‰å¯ä»¥ç¢ºä¿æ‰€æœ‰æ•¸å­—èƒ½æœ‰æ©Ÿæœƒè¢«åŒ…å«é€²å»\n          \nå°æ¯ä¸€å€‹æ•¸å­—å¦‚æœè¦æ‰¾å¤§æ–¼è‡ªå·±çš„ï¼Œå°±ä¸€ç›´ç¹¼çºŒå¾€ä¸Šæ‰¾ç›´åˆ°æœ€å¤§ï¼Œå¦‚æœè¦æ‰¾æœ€å°çš„ä¹Ÿæ˜¯ä¸€æ¨£\n            ä»¥ 5 1 2 4 5 3 6 ä¾†èªªï¼Œå°±æ˜¯å¾5é–‹å§‹ï¼Œæ¥ä¸‹ä¾†æ˜¯1ï¼ˆæœ€å°äº†ï¼‰ï¼Œæ¥ä¸‹ä¾†å¾€ä¸Šæ‰¾ï¼Œå¯ä»¥æ‰¾åˆ°2, 4, 5ï¼Œè€Œç‚ºäº†ç›¡é‡è®“æ•¸å­—å¤§æ‰èƒ½åŒ…åˆ°æ¥ä¸‹ä¾†çš„æ•¸å­—ï¼ˆå¦‚æœé¸2ä¸‹ä¸€å€‹å°±ä¸èƒ½æ˜¯3ï¼‰ï¼Œæ‰€ä»¥é¸5ï¼Œå†ä¾†å°±æ˜¯3 è·Ÿ6 ã€‚æ‰€ä»¥åºåˆ—ç‚ºï¼š 5 1 5 3 6 ï¼Œ é•·åº¦ç‚º5\n          \næƒ³èªªæ‡‰è©²è¦AC äº†ï¼Œæ²’æƒ³åˆ°æ²’æœ‰memset æ‰€ä»¥åƒäº†ä¸€å€‹WA ï¼\n\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    int n,arr[1000005];    while(t--)&#123;        cin&gt;&gt;n;        memset(arr,0,sizeof(arr));        for(int i=0;i&lt;n;i++)cin&gt;&gt;arr[i];        int height = 0, ind = 0, ans = 1;//0-&gt;down 1-&gt;up        while(ind&lt;n &amp;&amp; arr[ind]&lt;=arr[ind+1])ind++;                while(ind&lt;n)&#123;            if(height == 0 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&gt;=arr[ind+1])ind++;                height = 1;            &#125;            else if(height == 1 &amp;&amp; arr[ind]!=arr[ind+1])&#123;                while(arr[ind]&lt;=arr[ind+1])ind++;                height = 0;                ans+=2;            &#125;            ind++;//å¦‚æœæœ‰é€£çºŒç›¸åŒæ•¸å­—éœ€è¦åŠ         &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nèª°å…ˆæ™šé¤é¡Œç›®é€£çµæŒ‰ç…§Greegy çš„æƒ³æ³•ï¼Œåƒæœ€æ…¢çš„äººè¦æœ€å…ˆåƒï¼Œåƒæœ€å¿«çš„äººè¦å¾Œåƒï¼Œæ‰èƒ½è®“æ•´å€‹æ™‚é–“ç›¡é‡çš„ç¸®çŸ­é€™ä¸€é¡Œä¹‹å‰å­¸é•·è¬›è§£éï¼Œæ‰€ä»¥è‡ªç„¶æ˜¯æ¯”è¼ƒç°¡å–®ã€‚But! è¦æ€éº¼è­‰æ˜é€™æ¨£å¯ä»¥å¾—åˆ°æœ€ä½³è§£å‘¢ï½ç•™åˆ°æ‰‹å¯«ä½œæ¥­ï¼\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n;struct student&#123;    int eat,cook;&#125;people[10005];bool comp(student a,student b)&#123;    return a.eat &gt; b.eat;&#125;int main()&#123;    ios;    while(cin&gt;&gt;n)&#123;        if(n==0)break;        for(int i=0;i&lt;n;i++)&#123;            cin&gt;&gt;people[i].cook&gt;&gt;people[i].eat;        &#125;        sort(people, people+n, comp);        int ans = 0,cook = 0;        for(int i=0;i&lt;n;i++)&#123;            cook+=people[i].cook;//ç…®é£¯æ™‚é–“ä¸€å®šç¸½æ•¸ä¸æœƒæ”¹è®Š            int leave = cook+people[i].eat;            ans = max(ans, leave);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nåŒ…è£ç¦®ç‰©é¡Œç›®é€£çµä¸€ç›´åƒWA ï¼Œåƒåˆ°æ‡·ç–‘äººç”Ÿå“ï½æƒ³æ³•ï¼šç”±å¤§æ–¹å¡Šåˆ°å°æ–¹å¡Šï¼Œç›¡é‡å¡«æ»¿ï¼Œå¦‚æœéç¨‹ä¸­å¤§å°ç‚º4çš„æ–¹å¡Šè®Šæˆè² çš„ï¼Œå¯ä»¥å…ˆæ¬ è‘—ï¼Œç›´åˆ°æœ€å¾Œä¸€æ¬¡ç”±å¤§å°ç‚º1çš„ä¾†è£œï¼Œé€™æ¨£å¯ä»¥ç¢ºä¿æ¯ä¸€æ ¼æ–¹å¡Šä¸æ˜¯è¢«1*1çš„å¡«æ»¿å°±æ˜¯å‰©ä¸‹æœ€å°‘çš„ç©ºæ ¼\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int a,b,c,d,e,f;signed main()&#123;    ios;    while(cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f)&#123;        if(a==0&amp;&amp;b==0&amp;&amp;c==0&amp;&amp;d==0&amp;&amp;e==0&amp;&amp;f==0)break;        int ans = f+e+d;        a = a - 11*e;//5*5å¯ä»¥ç”¨11å€‹1*1å¡«        b = b - 5*d;//ä¸€å€‹4*4å¯ä»¥ç”¨5å€‹2*2å¡«        ans+=(c/4);        if(c%4!=0)ans++;        if(c%4==1)&#123;            a = a - 7;            b = b - 5;        &#125;        else if(c%4==2)&#123;            a = a - 6;            b = b - 3;        &#125;        else if(c%4==3)&#123;            a = a - 5;            b = b - 1;        &#125;        if(b&gt;0)&#123;            ans+=(b/9);            if(b%9!=0)ans++;            a = a-(36-4*(b%9));        &#125;        else if(b&lt;0)a = a-(4*(-b));//å¦‚æœbæœ‰æ¬ ï¼Œå¯ä»¥ç”¨aä¾†è£œ        if(a&gt;0)&#123;            ans+=a/36;            if(a%36!=0)ans++;        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nèª¿æ ¡é«˜æ£•æ«šé¡Œç›®é€£çµå¦‚æœæƒ³è¦è®“æ•¸å­—ç›¡é‡å°ï¼Œé‚£å‹¢å¿…è¦è®“æ•¸å­—çš„ä½æ•¸ç›¡é‡å°‘å› æ­¤å¯ä»¥å…ˆæŠŠ3å€‹2åˆä½µæˆ8ï¼Œ2å€‹3åˆä½µæˆ9è€Œå‰©ä¸‹çš„2è·Ÿ3å¯ä»¥æœ‰6 ç¨®çµ„åˆï¼š\n\n\n\n\næ•¸å­—å€‹æ•¸\n0å€‹2\n1å€‹2\n2å€‹2\n\n\n\n\n0å€‹3\nç„¡\n2\n4\n\n\n1å€‹3\n2\n6\n2,6\n\n\n\n\nå…ˆæŠŠæ•¸å­—åšè³ªå› æ•¸åˆ†è§£ï¼Œå¦‚æœæœ‰è³ªæ•¸å¤§æ–¼10ï¼Œå°±è¼¸å‡º-1æ¥ä¸‹ä¾†ï¼Œå†ç”¨é€™6ç¨®çµ„åˆç”¨if æ’åˆ—çµ„åˆå°±å®Œæˆäº†\n#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[11]=&#123;0&#125;;cin&gt;&gt;n;        if(n==1)&#123;            cout&lt;&lt;1&lt;&lt;endl;            continue;        &#125;        int ind = 2;        while(ind&lt;=9)&#123;            if(n%ind==0)&#123;                n /= ind;                arr[ind]++;            &#125;            else ind++;        &#125;        if(n&gt;10)&#123;            cout&lt;&lt;-1&lt;&lt;endl;            continue;        &#125;        vector&lt;int&gt;vec;                for(int i=0;i&lt;arr[2]/3;i++)vec.push_back(8);        arr[2]=arr[2]%3;        for(int i=0;i&lt;arr[3]/2;i++)vec.push_back(9);        arr[3]=arr[3]%2;                if(arr[2]==1 &amp;&amp; arr[3]==0)vec.push_back(2);        if(arr[2]==2 &amp;&amp; arr[3]==0)vec.push_back(4);        if(arr[2]==0 &amp;&amp; arr[3]==1)vec.push_back(3);        if(arr[2]==1 &amp;&amp; arr[3]==1)vec.push_back(6);        if(arr[2]==2 &amp;&amp; arr[3]==1)&#123;            vec.push_back(2);            vec.push_back(6);        &#125;        for(int i=0;i&lt;arr[5];i++)vec.push_back(5);        for(int i=0;i&lt;arr[7];i++)vec.push_back(7);        sort(vec.begin(),vec.end());        for(auto i:vec)cout&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\næ‰‹å¯«ä½œæ¥­é€™ä¸€é€±æ‰‹å¯«ä½œæ¥­æ˜¯greedy æ­£ç¢ºæ€§çš„è­‰æ˜ï¼ŒæŠŠè¦ºå¾—æ‡‰è©²æ€éº¼åšçš„æƒ³æ³•è½‰æ›æˆæ•¸å­¸å¼å­è¡¨é”ï¼Œæ‰èƒ½è®“æˆ‘å€‘å®‰å¿ƒçš„ä½¿ç”¨greedy ï¼è »é–‹å¿ƒçš„ï¼Œä¸Šä¸€æ¬¡ä»¥ç‚ºåˆ†æ•¸æœƒå¾ˆä½çš„æ‰‹å¯«ä½œæ¥­ç«Ÿç„¶æ‹¿åˆ°äº†100/110ï¼Œå°±å·®ä¸€é»å°±å¯ä»¥æ‹¿æ»¿åˆ†äº†QQ\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","è²ªå¿ƒ"]},{"title":"[é¡Œè§£]NEOJ 125 é€†åºæ•¸å°","url":"/sprout6-1/","content":"é€†åºæ•¸å°\né¡Œç›®é€£çµé€™æ˜¯è¦æ±‚é€†åºæ•¸å°çš„å…©å€‹æ•¸å­—çš„å’Œï¼Œç¸½å…±å¡äº†å…©å€‹åœ°æ–¹ï¼š\n\nTLE è¨ˆç®—å’Œçš„è¤‡é›œåº¦çˆ†äº†\nWA æ•¸å­—æº¢ä½å¾Œçˆ†äº†\n\nç¬¬ä¸€é»çš„è§£æ±ºæ–¹å¼ï¼šå°æ–¼æ¯ä¸€å±¤åˆ©ç”¨O(N)çš„æ™‚é–“ç®—å‰å¢œå’Œç¬¬äºŒé»çš„è§£æ±ºæ–¹å¼ï¼šæ¯åšå®Œä¸€å€‹é‹ç®—å°±mod ä¸€æ¬¡\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int ans = 0,n,arr[N],pre[N];void merge_sort(int l,int r)&#123;    if(r-l&lt;=1)return;    int mid = (l+r)/2;    merge_sort(l,mid);    merge_sort(mid,r);        int nl = l,nr = mid,ind = 0,temp[r-l];    pre[l-1] = 0;    for(int i=l;i&lt;=mid;++i)pre[i] = pre[i-1]+arr[i];    for(;nl&lt;mid;nl++,ind++)&#123;        while(arr[nr]&lt;arr[nl] &amp;&amp; nr&lt;r)&#123;            int times = mid-nl;//é€†åºæ•¸å°çš„æ•¸é‡            ans+=pre[mid-1]-pre[nl-1];            ans+=arr[nr]*times;            ans = ans%10000019;            temp[ind] = arr[nr];            nr++;ind++;        &#125;        temp[ind] = arr[nl];    &#125;    while(nr&lt;r)&#123;//æŠŠå‰©ä¸‹æ²’æ”¾çš„æ”¾é€²å»        temp[ind] = arr[nr];        nr++;ind++;    &#125;    for(int i=0;i&lt;r-l;++i)arr[i+l] = temp[i];&#125;signed main()&#123;    cin&gt;&gt;n;    memset(arr, 0, sizeof(arr));    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;arr[i]);    merge_sort(1,n+1);    printf(&quot;%lld\\n&quot;,ans%10000019);&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 789 å¥½çš„åºåˆ—","url":"/sprout6-2/","content":"å¥½çš„åºåˆ—\né¡Œç›®é€£çµé¡Œç›®ç°¡å–®ä¾†èªªï¼Œå°±æ˜¯çµ¦å®šnï¼Œè¦æ§‹é€ å‡ºä¸€å€‹1~nçš„åºåˆ—ï¼Œå…¶ä¸­ä¸åŒ…å«3å€‹æ•¸å­—ä»¥ä¸Šçš„ç­‰å·®æ•¸åˆ—è§£é¡Œæƒ³æ³•ï¼š æˆ‘çœ‹ä¸æ‡‚è³‡èŠ½çš„è§£æ³•QQä¸Šç¶²æ‰£åˆ¥äººçš„æ‰£ï¼Œçœ‹å¹¾ä¹éƒ½æ˜¯åŒæ¨£ä¸€å€‹å¯«æ³•ï¼ŒæŠŠå¥‡æ•¸é …çš„æ”¾å‰é¢ï¼Œå¶æ•¸é …çš„æ”¾å¾Œé¢ï¼Œä¹‹å¾Œä¸æ–·åˆ†æ²»ä¸‹å»ç›´æ¥å¯¦ä½œç„¶å¾ŒAC ï¼Œæ–¼æ˜¯æˆ‘ä¸€ç›´æƒ³åˆ°åº•è¦æ€éº¼è­‰æ˜é€™å€‹æ–¹æ³•æ˜¯æ­£ç¢ºçš„æ–¼æ˜¯æˆ‘å¤§æ¦‚æƒ³åˆ°äº†ä¸€å€‹ä¸Šé»‘è‰²ç™½è‰²çš„ä¸€å€‹ç®—åˆç†çš„æ¨å€’å§\n            é¦–å…ˆï¼Œæˆ‘å€‘æŠŠé•·åº¦ç‚º$n$çš„åºåˆ—åˆ†åˆ¥äº¤éŒ¯å¡—ä¸Šé»‘ç™½å†ä¾†ï¼ŒæŠŠé•·åº¦ç‚º$n$çš„åºåˆ—ç•«ä¸€æ¢ç·šåˆ†æˆ$[1,\\dfrac{n}{2}]$ èˆ‡$[\\dfrac{n}{2}+1,n]$å…©å€‹åºåˆ—ï¼ŒæŠŠå¥‡æ•¸æ¬¡é …çš„æ•¸å­—æ”¾å…¥ç¬¬ä¸€å€‹åºåˆ—ï¼Œå†æŠŠå¶æ•¸æ¬¡é …çš„åºåˆ—æ”¾å…¥ç¬¬äºŒå€‹æˆ‘å€‘å¯ä»¥ç™¼ç¾ï¼Œè€ƒæ…®æ©«è·¨ä¸­é–“ç·šçš„å…©é‚Šæ˜¯å¦æœ‰å¯èƒ½å½¢æˆç­‰å·®æ•¸åˆ—ï¼Œå¯ä»¥ç™¼ç¾æ˜¯ä¸å¯èƒ½ï¼Œå› ç‚ºå¦‚æœè¦æ©«è·¨å…©é‚Šï¼Œå‹¢å¿…è¦å¾ä¸€é‚Šé¸å‡ºå…©å€‹ï¼Œå¦ä¸€é‚Šé¸ä¸€å€‹ï¼Œè€ŒåŒé¡è‰²çš„å·®ç‚ºå¶æ•¸ï¼Œä¸åŒé¡è‰²çš„å·®å¿…ç‚ºå¥‡æ•¸ï¼Œå› æ­¤ä¸å¯èƒ½æ§‹é€ å‡ºæ©«è·¨å…©é‚Šçš„ç­‰å·®æ•¸åˆ—ä½†å¯ä»¥æ˜é¡¯ç™¼ç¾ï¼ŒåŒä¸€é¡è‰²æ˜¯ç­‰å·®æ•¸åˆ—ï¼Œå…¶å¯¦åªè¦åˆ†å…©é‚Šåˆ†åˆ¥éè¿´ä¸‹å»å°±å¯ä»¥äº†ï¼Œéè¿´è™•ç†å®Œå°±æ˜¯è§£ç­”éè¿´ç›´åˆ°é•·åº¦ç‚º2æ™‚å°±å¯ä»¥return äº†\n          \nç¨‹å¼ç¢¼ï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 100005using namespace std;int ans = 0,n,arr[N],temp[N];void DC(int l,int r)&#123;    if(r-l&lt;=1)return;    int ind = l,mid = (l+r)/2;    for(int i=l;i&lt;=r;i++)temp[i] = arr[i];    for(int i=l;i&lt;=r;i+=2)arr[ind++] = temp[i];    for(int i=l+1;i&lt;=r;i+=2)arr[ind++] = temp[i];    DC(l, mid);    DC(mid+1, r);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)arr[i] = i;    DC(1, n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 124 ç‹è€å…ˆç”Ÿæœ‰å¡Šåœ°å–”","url":"/sprout6-3/","content":"ç‹è€å…ˆç”Ÿæœ‰å¡Šåœ°å–”\né¡Œç›®é€£çµé€™ä¸€é¡Œæœ€éœ€è¦é—œæ³¨çš„å°±æ˜¯æŠŠå•é¡Œç¸®å°çš„é—œéµå¤§ç¯„åœä¸æœƒåšï¼ŒæŠŠè¦æ¨¡ç¸®åˆ°$2\\times2$ å¤§å°çš„æ–¹æ ¼ç¸½å¯ä»¥åšäº†å§ã€æƒ³è¾¦æ³•è®“æ¯ä¸€å€‹$2\\times2$ å¤§å°çš„æ–¹æ ¼éƒ½æœ‰ä¸€æ ¼æ˜¯è¢«å¡«æ»¿çš„å‰©ä¸‹ä¸‰æ ¼å°±å¾ˆå®¹æ˜“æ”¾é€²å»æ³¨æ„ï¼š è¡Œè·Ÿåˆ—çš„ç¶­è­·å¾ˆé‡è¦ï¼Œä¸€é–‹å§‹å°±è¦æƒ³å¥½è¦æ€éº¼æ¨£å®šç¾©å„²å­˜æ ¼ï¼Œä¸€ç¶­äºŒç¶­è©²æ”¾ä»€éº¼\n#include &lt;bits/stdc++.h&gt;bool maze[1025][1025];void DC(int,int,int);void solve(int,int,int);void solve(int N,int X,int Y)&#123;    memset(maze, 0, sizeof(maze));    maze[X][Y] = 1;    DC(1,1,N);&#125;void DC(int x,int y,int n)&#123;    if(n&lt;=1)return;    int new_N = n/2,x_pos=0,y_pos=0;    for(int i=x;i&lt;x+n;i++)&#123;        for(int j=y;j&lt;y+n;j++)&#123;            if(maze[i][j] == 1)&#123;                x_pos = i;                y_pos = j;                break;            &#125;        &#125;    &#125;    int pos;    if(x_pos&gt;=x+new_N)&#123;        if(y_pos&gt;=y+new_N)pos = 4;        else pos = 3;    &#125;    else&#123;        if(y_pos&gt;=y+new_N)pos = 2;        else pos = 1;    &#125;    int nx = x+new_N,ny = y+new_N;    switch (pos) &#123;        case 1:            Report(nx, ny, nx-1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 2:            ny = ny-1;            Report(nx, ny, nx-1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny+1] = 1;            break;        case 3:            nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 4:            ny = ny-1;nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny+1] = 1;            break;        default:            break;    &#125;    DC(x, y, new_N);    DC(x+new_N, y, new_N);    DC(x, y+new_N, new_N);    DC(x+new_N, y+new_N, new_N);&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 128 ç³Ÿç³•é™£åˆ—","url":"/sprout6-4/","content":"ç³Ÿç³•é™£åˆ—\né¡Œç›®é€£çµå…¶ä¸­ä¸€ç¨®æ§‹é€ æ–¹å¼ï¼šå°æ–¼ç¬¬iåˆ—ç¬¬iè¡Œçš„ã€Œç³Ÿç³•é™£åˆ—ã€ï¼Œå¿…é ˆæ»¿è¶³è¯é›†ç‚º ${1,2,â€¦,2k-1}$çš„æ•¸å­—ï¼Œæˆ‘å€‘å¯ä»¥å…ˆæ§‹é€ å‡º2*2çš„ç³Ÿç³•é™£åˆ—ï¼ŒæŠŠå®ƒè¤‡è£½åˆ°å³é‚Šï¼ˆåŠ ä¸Šé‚Šé•·ï¼‰ã€å³ä¸‹ã€èˆ‡ä¸‹æ–¹ï¼ˆåŠ ä¸Šé‚Šé•·ï¼Œè¤‡è£½å®Œä¹‹å¾Œå› ç‚ºæœƒæœ‰é‡è¤‡ä¸€å€‹æ•¸å­—ï¼Œæ‰£æ‰å°±å¥½\n#include &lt;bits/stdc++.h&gt;using namespace std;int maze[1026][1026];void solve(int);void DC(int n);void solve(int N)&#123;    memset(maze, 0, sizeof(maze));    maze[1][1] = 1;    maze[1][2] = 2;    maze[2][1] = 3;    maze[2][2] = 1;    int temp = 4;    while(temp&lt;=N)&#123;        DC(temp);        temp = temp*2;    &#125;    for(int i=1;i&lt;=N;i++)&#123;        for(int j=1;j&lt;=N;j++)&#123;            Report(maze[i][j]);        &#125;    &#125;&#125;void DC(int n)&#123;    int now_N = n/2;    for(int i=1;i&lt;=now_N;i++)&#123;        for(int j=1;j&lt;=now_N;j++)&#123;            maze[i+now_N][j] = maze[i][j]+n;            maze[i][j+now_N] = maze[i][j]+n;            maze[i+now_N][j+now_N] = maze[i][j];            if(maze[i][j]==1)maze[i][j+now_N]--;        &#125;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 138 å††å††æ•¸ç£ç£š","url":"/sprout7-1/","content":"å††å††æ•¸ç£ç£š\né¡Œç›®é€£çµæˆ‘ä¸æœƒå¯«è½‰ç§»å¼å­å•Šâ€¦é¦–å…ˆå¯ä»¥è§€å¯Ÿåˆ°ï¼Œå› ç‚ºå…©å€‹ç£ç£šçš„æ’æ³•æœ‰3ç¨®ï¼Œé¦–å…ˆå¯ä»¥åˆ—å‡º$f(n) = 3\\times f(n-2)$ é€™å€‹å¼å­ï¼Œä½†è§€å¯Ÿä¹‹å¾Œå¯ä»¥ç™¼ç¾ï¼Œå¦‚æœæ’åˆ—çš„ç£ç£šä¸èƒ½è¢«å…©å…©åˆ†å‰²ï¼Œä¹Ÿå¯æ˜¯ä¸€ç¨®æ–°çš„æ’æ³•ã€‚è€Œå°æ–¼å›ºå®šçš„å°ºå¯¸å¤§å°åªæœƒæœ‰ä¸€ç¨®æ’æ³•ï¼Œä½†å› ç‚ºå¯ä»¥é¡›å€’æ”¾ï¼Œå› æ­¤è¦–ç‚ºå…©ç¨®çµ„åˆã€‚è½‰ç§»å¼ï¼š$f(n) = 3\\times f(n-2)+2\\times(f(n-4)+f(n-6)â€¦)$ç¶“éæ•¸å­¸å¸¶å…¥æ¶ˆå»ï¼š$f(n-2) = 3\\times f(n-4)+2\\times(f(n-6)+f(n-8)â€¦)$$f(n) = 4\\times f(n-2)-f(n-4)$\né‚Šç•Œï¼š$dp[0] = 1, dp[2] = 3$\n#include &lt;bits/stdc++.h&gt;#define int unsigned long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    int dp[100005];    memset(dp, 0, sizeof(dp));    dp[0] = 1;dp[2] = 3;dp[3] = 0;    for(int i=4;i&lt;=100001;i+=2)dp[i] =(4*dp[i-2]-dp[i-4]+1000007)%1000007;    while(t--)&#123;        int n;cin&gt;&gt;n;        cout&lt;&lt;dp[n]&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬å…­é€±ï¼šåˆ†æ²»ç®—æ³•","url":"/sprout6/","content":"ä¸Šèª²å…§å®¹åˆ†æ²»æ³•ï¼Œä¸€é–‹å§‹è¬›äº†ä¸‰å€‹è­‰æ˜éè¿´è¤‡é›œåº¦çš„æ–¹æ³•ï¼š\n\nå–ä»£æ³•ï¼šä¸‰æ­¥é©Ÿï¼šGuess, Verify, Solveé ç¶“é©—å‡è¨­ï¼Œä¸¦é©—è­‰ï¼ˆåŠ ä¸€äº›å¸¸æ•¸ä¹‹é¡çš„ï¼‰\néè¿´æ¨¹æ³•ä¸å¤ªåš´è¬¹ï¼Œæä¾›çŒœç­”æ¡ˆæƒ³æ³•ï¼Œæœ€å¾Œç”¨å–ä»£æ³•é©—è­‰ç•«å‡ºéè¿´æ¨¹\nä¸»å®šç†ï¼ˆMaster Theoremï¼‰æ¯”è¼ƒf(n) å’Œ n^(logba)çš„é—œä¿‚å¤§æ–¼ç­‰æ–¼å°æ–¼æœ‰ä¸‰å€‹è¤‡é›œåº¦\n\n\né‚„æœ‰ä¾‹é¡Œï¼š\n\nå€é–“é€£çºŒæœ€å¤§å’Œhttps://zerojudge.tw/ShowProblem?problemid=d784ä¸­é–“åˆ‡ä¸€åŠï¼Œmax(å·¦å³æœ€å¤§å€¼,è·¨éä¸­é–“çš„æœ€å¤§å€¼)æ™‚é–“è¤‡é›œåº¦ï¼šO(NlogN)æœ‰è¾¦æ³•O(n)?\nå¤šé …å¼ä¹˜æ³•Tioj 1064FFT? ï¼ˆå¿«é€Ÿé»çš„ä¹˜æ³•ï¼‰Karatsuba algorithmï¼Œè¤‡é›œåº¦O(N^1.58)ï¼Œé‚„å¯ä»¥ç”¨åœ¨çŸ©é™£ä¹˜æ³•\nå¹³é¢æœ€è¿‘é»å° cf429Dï¼ŒTiojå¹³é¢åˆ†æ²»æ¼”ç®—æ³•å¾ˆå¤šéƒ½é€™æ¨£åšï¼Œå…ˆç…§xåº§æ¨™æ’åºï¼Œä¸­é–“åˆ‡å‰²ï¼šmax(å…©é»éƒ½åœ¨å·¦é‚Šã€å…©é»éƒ½åœ¨å³é‚Šã€è·¨éåˆ†å‰²ç·šç­”æ¡ˆ)æ±‚è·¨éåˆ†å‰²ç·šç­”æ¡ˆï¼šç…§yåº§æ¨™æ’åºï¼Œè·é›¢è¶…édçš„ä¸è¦çœ‹ï¼Œå› ç‚ºé™„è¿‘çš„é»æ˜¯æœ‰é™å€‹ï¼ˆæœ€è¿‘é»è·é›¢dï¼‰ï¼Œå¤§æ¦‚æœ€å¤šåªéœ€è¦çœ‹7å€‹é»ï¼Œå¯ä»¥åœ¨å¸¸æ•¸æ™‚é–“çœ‹å®Œæ‰€æœ‰é»\nå°‹æ‰¾ç¬¬kå¤§ O(N)å°‹æ‰¾ç¬¬kå¤§-åˆ©ç”¨åˆ†æ²»\n\nä¸Šæ©Ÿä½œæ¥­é€†åºæ•¸å°é¡Œç›®é€£çµé€™æ˜¯è¦æ±‚é€†åºæ•¸å°çš„å…©å€‹æ•¸å­—çš„å’Œï¼Œç¸½å…±å¡äº†å…©å€‹åœ°æ–¹ï¼š\n\nTLE è¨ˆç®—å’Œçš„è¤‡é›œåº¦çˆ†äº†\nWA æ•¸å­—æº¢ä½å¾Œçˆ†äº†\n\nç¬¬ä¸€é»çš„è§£æ±ºæ–¹å¼ï¼šå°æ–¼æ¯ä¸€å±¤åˆ©ç”¨O(N)çš„æ™‚é–“ç®—å‰å¢œå’Œç¬¬äºŒé»çš„è§£æ±ºæ–¹å¼ï¼šæ¯åšå®Œä¸€å€‹é‹ç®—å°±mod ä¸€æ¬¡\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 1000005using namespace std;int ans = 0,n,arr[N],pre[N];void merge_sort(int l,int r)&#123;    if(r-l&lt;=1)return;    int mid = (l+r)/2;    merge_sort(l,mid);    merge_sort(mid,r);        int nl = l,nr = mid,ind = 0,temp[r-l];    pre[l-1] = 0;    for(int i=l;i&lt;=mid;++i)pre[i] = pre[i-1]+arr[i];    for(;nl&lt;mid;nl++,ind++)&#123;        while(arr[nr]&lt;arr[nl] &amp;&amp; nr&lt;r)&#123;            int times = mid-nl;//é€†åºæ•¸å°çš„æ•¸é‡            ans+=pre[mid-1]-pre[nl-1];            ans+=arr[nr]*times;            ans = ans%10000019;            temp[ind] = arr[nr];            nr++;ind++;        &#125;        temp[ind] = arr[nl];    &#125;    while(nr&lt;r)&#123;//æŠŠå‰©ä¸‹æ²’æ”¾çš„æ”¾é€²å»        temp[ind] = arr[nr];        nr++;ind++;    &#125;    for(int i=0;i&lt;r-l;++i)arr[i+l] = temp[i];&#125;signed main()&#123;    cin&gt;&gt;n;    memset(arr, 0, sizeof(arr));    for(int i=1;i&lt;=n;++i)scanf(&quot;%lld&quot;,&amp;arr[i]);    merge_sort(1,n+1);    printf(&quot;%lld\\n&quot;,ans%10000019);&#125;\nå¥½çš„åºåˆ—é¡Œç›®é€£çµé¡Œç›®ç°¡å–®ä¾†èªªï¼Œå°±æ˜¯çµ¦å®šnï¼Œè¦æ§‹é€ å‡ºä¸€å€‹1~nçš„åºåˆ—ï¼Œå…¶ä¸­ä¸åŒ…å«3å€‹æ•¸å­—ä»¥ä¸Šçš„ç­‰å·®æ•¸åˆ—è§£é¡Œæƒ³æ³•ï¼š æˆ‘çœ‹ä¸æ‡‚è³‡èŠ½çš„è§£æ³•QQä¸Šç¶²æ‰£åˆ¥äººçš„æ‰£ï¼Œçœ‹å¹¾ä¹éƒ½æ˜¯åŒæ¨£ä¸€å€‹å¯«æ³•ï¼ŒæŠŠå¥‡æ•¸é …çš„æ”¾å‰é¢ï¼Œå¶æ•¸é …çš„æ”¾å¾Œé¢ï¼Œä¹‹å¾Œä¸æ–·åˆ†æ²»ä¸‹å»ç›´æ¥å¯¦ä½œç„¶å¾ŒAC ï¼Œæ–¼æ˜¯æˆ‘ä¸€ç›´æƒ³åˆ°åº•è¦æ€éº¼è­‰æ˜é€™å€‹æ–¹æ³•æ˜¯æ­£ç¢ºçš„æ–¼æ˜¯æˆ‘å¤§æ¦‚æƒ³åˆ°äº†ä¸€å€‹ä¸Šé»‘è‰²ç™½è‰²çš„ä¸€å€‹ç®—åˆç†çš„æ¨å€’å§\n            é¦–å…ˆï¼Œæˆ‘å€‘æŠŠé•·åº¦ç‚º$n$çš„åºåˆ—åˆ†åˆ¥äº¤éŒ¯å¡—ä¸Šé»‘ç™½å†ä¾†ï¼ŒæŠŠé•·åº¦ç‚º$n$çš„åºåˆ—ç•«ä¸€æ¢ç·šåˆ†æˆ$[1,\\dfrac{n}{2}]$ èˆ‡$[\\dfrac{n}{2}+1,n]$å…©å€‹åºåˆ—ï¼ŒæŠŠå¥‡æ•¸æ¬¡é …çš„æ•¸å­—æ”¾å…¥ç¬¬ä¸€å€‹åºåˆ—ï¼Œå†æŠŠå¶æ•¸æ¬¡é …çš„åºåˆ—æ”¾å…¥ç¬¬äºŒå€‹æˆ‘å€‘å¯ä»¥ç™¼ç¾ï¼Œè€ƒæ…®æ©«è·¨ä¸­é–“ç·šçš„å…©é‚Šæ˜¯å¦æœ‰å¯èƒ½å½¢æˆç­‰å·®æ•¸åˆ—ï¼Œå¯ä»¥ç™¼ç¾æ˜¯ä¸å¯èƒ½ï¼Œå› ç‚ºå¦‚æœè¦æ©«è·¨å…©é‚Šï¼Œå‹¢å¿…è¦å¾ä¸€é‚Šé¸å‡ºå…©å€‹ï¼Œå¦ä¸€é‚Šé¸ä¸€å€‹ï¼Œè€ŒåŒé¡è‰²çš„å·®ç‚ºå¶æ•¸ï¼Œä¸åŒé¡è‰²çš„å·®å¿…ç‚ºå¥‡æ•¸ï¼Œå› æ­¤ä¸å¯èƒ½æ§‹é€ å‡ºæ©«è·¨å…©é‚Šçš„ç­‰å·®æ•¸åˆ—ä½†å¯ä»¥æ˜é¡¯ç™¼ç¾ï¼ŒåŒä¸€é¡è‰²æ˜¯ç­‰å·®æ•¸åˆ—ï¼Œå…¶å¯¦åªè¦åˆ†å…©é‚Šåˆ†åˆ¥éè¿´ä¸‹å»å°±å¯ä»¥äº†ï¼Œéè¿´è™•ç†å®Œå°±æ˜¯è§£ç­”éè¿´ç›´åˆ°é•·åº¦ç‚º2æ™‚å°±å¯ä»¥return äº†\n          \nç¨‹å¼ç¢¼ï¼š\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0)#define int long long#define N 100005using namespace std;int ans = 0,n,arr[N],temp[N];void DC(int l,int r)&#123;    if(r-l&lt;=1)return;    int ind = l,mid = (l+r)/2;    for(int i=l;i&lt;=r;i++)temp[i] = arr[i];    for(int i=l;i&lt;=r;i+=2)arr[ind++] = temp[i];    for(int i=l+1;i&lt;=r;i+=2)arr[ind++] = temp[i];    DC(l, mid);    DC(mid+1, r);&#125;signed main()&#123;    ios;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)arr[i] = i;    DC(1, n);    for(int i=1;i&lt;=n;i++)cout&lt;&lt;arr[i]&lt;&lt;&quot; &quot;;    cout&lt;&lt;endl;&#125;\nç‹è€å…ˆç”Ÿæœ‰å¡Šåœ°å–”é¡Œç›®é€£çµé€™ä¸€é¡Œæœ€éœ€è¦é—œæ³¨çš„å°±æ˜¯æŠŠå•é¡Œç¸®å°çš„é—œéµå¤§ç¯„åœä¸æœƒåšï¼ŒæŠŠè¦æ¨¡ç¸®åˆ°$2\\times2$ å¤§å°çš„æ–¹æ ¼ç¸½å¯ä»¥åšäº†å§ã€æƒ³è¾¦æ³•è®“æ¯ä¸€å€‹$2\\times2$ å¤§å°çš„æ–¹æ ¼éƒ½æœ‰ä¸€æ ¼æ˜¯è¢«å¡«æ»¿çš„å‰©ä¸‹ä¸‰æ ¼å°±å¾ˆå®¹æ˜“æ”¾é€²å»æ³¨æ„ï¼š è¡Œè·Ÿåˆ—çš„ç¶­è­·å¾ˆé‡è¦ï¼Œä¸€é–‹å§‹å°±è¦æƒ³å¥½è¦æ€éº¼æ¨£å®šç¾©å„²å­˜æ ¼ï¼Œä¸€ç¶­äºŒç¶­è©²æ”¾ä»€éº¼\n#include &lt;bits/stdc++.h&gt;bool maze[1025][1025];void DC(int,int,int);void solve(int,int,int);void solve(int N,int X,int Y)&#123;    memset(maze, 0, sizeof(maze));    maze[X][Y] = 1;    DC(1,1,N);&#125;void DC(int x,int y,int n)&#123;    if(n&lt;=1)return;    int new_N = n/2,x_pos=0,y_pos=0;    for(int i=x;i&lt;x+n;i++)&#123;        for(int j=y;j&lt;y+n;j++)&#123;            if(maze[i][j] == 1)&#123;                x_pos = i;                y_pos = j;                break;            &#125;        &#125;    &#125;    int pos;    if(x_pos&gt;=x+new_N)&#123;        if(y_pos&gt;=y+new_N)pos = 4;        else pos = 3;    &#125;    else&#123;        if(y_pos&gt;=y+new_N)pos = 2;        else pos = 1;    &#125;    int nx = x+new_N,ny = y+new_N;    switch (pos) &#123;        case 1:            Report(nx, ny, nx-1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 2:            ny = ny-1;            Report(nx, ny, nx-1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx-1][ny] = 1;            maze[nx][ny+1] = 1;            break;        case 3:            nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny-1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny-1] = 1;            break;        case 4:            ny = ny-1;nx = nx-1;            Report(nx, ny, nx+1, ny, nx, ny+1);            maze[nx][ny] = 1;            maze[nx+1][ny] = 1;            maze[nx][ny+1] = 1;            break;        default:            break;    &#125;    DC(x, y, new_N);    DC(x+new_N, y, new_N);    DC(x, y+new_N, new_N);    DC(x+new_N, y+new_N, new_N);&#125;\nç³Ÿç³•é™£åˆ—é¡Œç›®é€£çµå…¶ä¸­ä¸€ç¨®æ§‹é€ æ–¹å¼ï¼šå°æ–¼ç¬¬iåˆ—ç¬¬iè¡Œçš„ã€Œç³Ÿç³•é™£åˆ—ã€ï¼Œå¿…é ˆæ»¿è¶³è¯é›†ç‚º ${1,2,â€¦,2k-1}$çš„æ•¸å­—ï¼Œæˆ‘å€‘å¯ä»¥å…ˆæ§‹é€ å‡º2*2çš„ç³Ÿç³•é™£åˆ—ï¼ŒæŠŠå®ƒè¤‡è£½åˆ°å³é‚Šï¼ˆåŠ ä¸Šé‚Šé•·ï¼‰ã€å³ä¸‹ã€èˆ‡ä¸‹æ–¹ï¼ˆåŠ ä¸Šé‚Šé•·ï¼Œè¤‡è£½å®Œä¹‹å¾Œå› ç‚ºæœƒæœ‰é‡è¤‡ä¸€å€‹æ•¸å­—ï¼Œæ‰£æ‰å°±å¥½\n#include &lt;bits/stdc++.h&gt;using namespace std;int maze[1026][1026];void solve(int);void DC(int n);void solve(int N)&#123;    memset(maze, 0, sizeof(maze));    maze[1][1] = 1;    maze[1][2] = 2;    maze[2][1] = 3;    maze[2][2] = 1;    int temp = 4;    while(temp&lt;=N)&#123;        DC(temp);        temp = temp*2;    &#125;    for(int i=1;i&lt;=N;i++)&#123;        for(int j=1;j&lt;=N;j++)&#123;            Report(maze[i][j]);        &#125;    &#125;&#125;void DC(int n)&#123;    int now_N = n/2;    for(int i=1;i&lt;=now_N;i++)&#123;        for(int j=1;j&lt;=now_N;j++)&#123;            maze[i+now_N][j] = maze[i][j]+n;            maze[i][j+now_N] = maze[i][j]+n;            maze[i+now_N][j+now_N] = maze[i][j];            if(maze[i][j]==1)maze[i][j+now_N]--;        &#125;    &#125;&#125;\næ‰‹å¯«ä½œæ¥­å¢å€ç®—æ³•ï¼ä¸»è¦æ˜¯ä»‹ç´¹å‹•æ…‹é™£åˆ—ï¼Œåˆ†æè¤‡é›œåº¦ç­‰ç­‰çš„æ±è¥¿ä¸Šä¸€é€±çš„æ‰‹å¯«ä½œæ¥­è¢«æ‰£çˆ†ï¼\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["è³‡èŠ½ç­†è¨˜","åˆ†æ²»"]},{"title":"[é¡Œè§£]NEOJ 140 å††å††é€ç¦®ç‰©","url":"/sprout7-2/","content":"å††å††é€ç¦®ç‰©\né¡Œç›®é€£çµä»¥å¾Œå¯«DPå¹¾ç¨®çµ„åˆå•é¡Œå°±æ˜¯åƒé€™ä¸€é¡Œä¸€æ¨£æš´åŠ›ç ´è§£æŠŠæ¯ä¸€ç¨®æƒ…æ³éƒ½å¯«æ¸…æ¥šï¼Œä¸æƒœé–‹ä¸‰ç¶­é™£åˆ—ä¹Ÿæ²’é—œä¿‚ç¸½ä¹‹ï¼Œ$dp[i][k][j]$ ä»£è¡¨é•·åº¦ç‚ºiï¼Œå·¦é‚Šç‚ºé¡è‰²kï¼Œå³é‚Šç‚ºé¡è‰²jï¼ˆç´…è‰²ï¼š0ã€ç¶ è‰²ï¼š1ã€è—è‰²ï¼š2ï¼‰åˆ—å‡ºæ¯ä¸€ç¨®ç‹€æ…‹çš„è½‰ç§»å¼å°±å¥½ä¸éï¼Œå³ä½¿é ­å°¾æ˜¯ä¸€è—ä¸€ç¶ ï¼Œä½†ä¹Ÿå¿…é ˆè½‰ç§»ï¼Œå› ç‚ºä¸€è—ä¸€ç¶ å¯ä»¥åœ¨é ­æˆ–å°¾åŠ ä¸Šå…¶ä»–é¡è‰²ï¼Œçµ„æˆåˆæ³•è§£ï¼Œä¸éä¸è¦è¼¸å‡ºå°±å¥½äº†\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int t;signed main()&#123;    ios;    int dp[100005][3][3];//0:red,1:green,2:blue    dp[1][0][0] = 1;dp[1][1][1] = 1;dp[1][2][2] = 1;    dp[2][0][0] = dp[2][0][1] = dp[2][0][2] = 1;    dp[2][1][0] = dp[2][1][1] = dp[2][2][0] = dp[2][2][2] = 1;    dp[2][1][2] = dp[2][2][1] = 0;    for(int i=3;i&lt;100005;i++)&#123;        dp[i][0][0] = (dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2])%1000007;        dp[i][0][1] = (dp[i-1][0][0]+dp[i-1][0][1])%1000007;        dp[i][0][2] = (dp[i-1][0][0]+dp[i-1][0][2])%1000007;                dp[i][1][0] = (dp[i-1][1][0]+dp[i-1][1][1]+dp[i-1][1][2])%1000007;        dp[i][1][1] = (dp[i-1][1][0]+dp[i-1][1][1])%1000007;        dp[i][1][2] = (dp[i-1][1][0]+dp[i-1][1][2])%1000007;                dp[i][2][0] = (dp[i-1][2][0]+dp[i-1][2][1]+dp[i-1][2][2])%1000007;        dp[i][2][1] = (dp[i-1][2][0]+dp[i-1][2][1])%1000007;        dp[i][2][2] = (dp[i-1][2][0]+dp[i-1][2][2])%1000007;            &#125;    int n;cin&gt;&gt;n;    while(n--)&#123;        int a;cin&gt;&gt;a;        cout&lt;&lt;(dp[a][0][0]+dp[a][0][1]+dp[a][0][2]+dp[a][1][0]+dp[a][1][1]+dp[a][2][0]+dp[a][2][2])%1000007&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 141 å–æ•¸å­—1","url":"/sprout7-3/","content":"å–æ•¸å­—1\né¡Œç›®é€£çµå®šç¾©ï¼š$dp[i]$ ç‚ºå–ç¬¬iå€‹æ•¸å­—çš„çš„æœ€å¤§å€¼è½‰ç§»å¼ï¼š$dp[i] = max(dp[i-2]+dp[i-2])+arr[i]$å¯ä»¥ç™¼ç¾åˆ°ï¼Œå› ç‚º$arr[i]$ éƒ½æ˜¯æ­£æ•¸ï¼Œå› æ­¤åŠ è¶Šå¤šæ•¸å­—å°±ä»£è¡¨æœ€å¾Œçš„æ•¸å€¼è¶Šå¤§ï¼Œè€Œç›¸é„°çš„å…©é …ä¸èƒ½è½‰ç§»ï¼Œå› æ­¤å°±è¦çœ‹$dp[i-2],dp[i-2]$å…¶ä¸­i-4ä¸ç”¨çœ‹æ˜¯å› ç‚ºå·²ç¶“åŒ…å«åœ¨i-2è£¡é¢äº†é‚Šç•Œï¼š$dp[1] = arr[1],dp[2] = arr[2],dp[3] = arr[1]+arr[3]$\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        int dp[10005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        dp[1] = arr[1];dp[2] = arr[2];dp[3] = arr[1]+arr[3];        for(int i=4;i&lt;=n+1;i++)&#123;            dp[i] = max(dp[i-2],dp[i-3])+arr[i];        &#125;        cout&lt;&lt;max(dp[n],dp[n-1])&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 142 å–æ•¸å­—2","url":"/sprout7-4/","content":"å–æ•¸å­—2\né¡Œç›®é€£çµä¸Šé¢å–æ•¸å­—1çš„é€²éšç‰ˆï¼Œå¯ä»¥ä¸€æ¨£å®šç¾©ï¼Œä¸éè½‰ç§»å¼è¦ç¨å¾®æ”¹è®Šï¼ˆå…¶å¯¦å°±åªæ˜¯æŠŠåŸæœ¬åªæœ‰2çš„å€é–“æ“´å¤§æˆkï¼‰å®šç¾©ï¼š$dp[i]$ ç‚ºå–ç¬¬iå€‹æ•¸å­—çš„çš„æœ€å¤§å€¼è½‰ç§»å¼ï¼š$dp[i]=max(arr[j]+arr[i]),2k\\leq i \\leq n,i-2k\\leq j \\leq i-k$è½‰ç§»å¼æ¯”è¼ƒè¤‡é›œä¸€é»ï¼Œä¸éå°±æ˜¯å–æ•¸å­—1çš„å»¶ä¼¸é‚Šç•Œï¼š$dp[i] = arr[i],1\\leq i \\leq k$$dp[i]=max(arr[j]+arr[i]),k+1\\leq i \\leq 2k,1\\leq j \\leq i-k$\né‚Šç•Œçš„è©±ï¼Œå¦‚æœè¦èªªæˆæ˜¯è½‰ç§»å¼ä¹Ÿæ˜¯å¯ä»¥å•¦\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005],k;cin&gt;&gt;n&gt;&gt;k;        int dp[100005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        //[1,k]çš„é‚Šç•Œè½‰ç§»        for(int i=1;i&lt;=k;i++)dp[i] = arr[i];        //[k+1,2k]çš„é‚Šç•Œè½‰ç§»        for(int i=k+1;i&lt;=2*k;i++)&#123;            for(int j=1;j&lt;=i-k;j++)&#123;//çœ‹å¯ä»¥é…ä¸Š[1,k]æœ€å¤§çš„é‚£ä¸€å€‹                dp[i]=max(dp[i],arr[j]+arr[i]);            &#125;        &#125;        for(int i=2*k+1;i&lt;=n;i++)&#123;            for(int j = i-2*k;j&lt;=i-k;j++)&#123;//é–‹å§‹è½‰ç§»ï¼Œæƒækæ¬¡                dp[i] = max(dp[i],dp[j]+arr[i]);            &#125;        &#125;        cout&lt;&lt;max_element(dp, dp+n+1)&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 143 åˆæˆå††å††","url":"/sprout7-5/","content":"åˆæˆå††å††\né¡Œç›®é€£çµé–‹å§‹æ¥è§¸åˆ°å€é–“DPï¼Œæ¯”å–®ç´”çš„DPåˆå¤šäº†ä¸€äº›è¦æ³¨æ„çš„åœ°æ–¹ä¸Šç¶²æŸ¥é—œæ–¼å€é–“DPçš„è³‡æ–™ï¼Œä¸€èˆ¬éƒ½æœƒæœ‰é€™äº›å…§å®¹ï¼š\nfor (æšèˆ‰å€é–“é•·åº¦)    for (æšèˆ‰å·¦ç«¯é»)        for (æšèˆ‰åˆ†å‰²é»)            f[l, r] = f[l, k] + f[k, r] + val(l, r)\nä¸»è¦å°±æ˜¯ï¼Œå¾å°çš„å€é–“é•·åº¦é–‹å§‹ï¼ˆå¤§çš„å€é–“éœ€è¦å°çš„å€é–“çš„ç­”æ¡ˆï¼‰ï¼Œæšèˆ‰å·¦ç«¯é»å¯ä»¥çŸ¥é“å€é–“çš„ç¯„åœï¼Œæ¥è‘—å†ä¾åºæšèˆ‰åœ¨å€é–“å…§åˆ†å‰²é»ï¼ŒæŠŠé•·åº¦ç‚ºnçš„å€é–“é•·åº¦è·‘å®Œä¹‹å¾Œå°±å®Œæˆäº†æœ‰äº†é€™ä¸€å€‹$O(n^3)$ çš„æ¼”ç®—æ³•ï¼Œå°±å¯ä»¥é–‹å§‹ä¾†å¯¦ä½œ\nå®šç¾©ï¼š$dp[i][j]$ $(1 \\leq i,j \\leq n)$ ç‚ºåˆä½µå€é–“ $[i,j]$ æ‰€éœ€è¦çš„èŠ±è²»è½‰ç§»å¼ï¼š$dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum_{i,j}),i \\leq k \\leq j$åˆä½µå€é–“$dp[i][k],dp[k+1][j]$çš„èŠ±è²»ç‚ºå…©è€…ç›¸åŠ å†åŠ ä¸Šå€é–“[i,j]çš„ç¸½å’Œï¼ˆå¯ä»¥ç”¨å‰ç¶´ç¶­è­·ï¼‰é‚Šç•Œï¼š$dp[i][i] = 0,1 \\leq i \\leq n$\né€™å€‹æ¼”ç®—æ³•çš„è¤‡é›œåº¦æ˜¯$O(n^3)$ï¼Œä¹‹å¾Œå¯ä»¥ç”¨dpå„ªåŒ–çš„æŠ€å·§åšåˆ°æ›´å¿«\n\n            å•é¡Œï¼šé€™é¡Œå¯ä¸å¯ä»¥ç”¨Greedyï¼Ÿæˆ‘å€‘å¦‚æœæ¯ä¸€æ¬¡éƒ½æ‰¾å…©å…©ç›¸é„°ç›¸åŠ ç¸½å’Œæœ€å°çš„å…©å€‹åŠ èµ·ä¾†ï¼Œåšn-1æ¬¡ï¼Œæ˜¯ä¸æ˜¯å¯ä»¥æ‰¾åˆ°æœ€ä½³è§£ï¼Ÿï¼ˆå¦‚æœå¯ä»¥ï¼Œé‚£å¹¹å˜›é‚„è¦è¾›è‹¦ç¶­è­·$n^3$çš„ç®—æ³•XDï¼‰Q:ç­”æ¡ˆæ˜¯ä¸è¡Œï¼Œé‚£è¦åä¾‹ä½•æ™‚å‡ºç¾ï¼Ÿ10 7 6 7é€™ä¸€çµ„æ¸¬è³‡å¦‚æœç”¨Greedyåšæ˜¯63ï¼Œç”¨dpåšæ˜¯60ï¼Œå¯ä»¥ç™¼ç¾åˆ°ï¼Œå¦‚æœæ•¸å­—å…©å…©ç›¸åŠ ç›¸ç­‰ï¼Œé‚£å…ˆåŠ å¾ŒåŠ çš„é †åºå°±å¾ˆé‡è¦ï¼Œæœ‰å¯èƒ½å› ç‚ºé †åºä¸å°ï¼ˆå…ˆåŠ ä¸­é–“çš„7è·Ÿ6ï¼‰ï¼Œå°è‡´7æ²’è¾¦æ³•è·Ÿ10åˆä½µç”¢ç”Ÿæ›´åŠ çš„è§£æ³•ï¼æ‰¾åä¾‹çš„æ–¹æ³•ï¼š é€™ä¸€ç­†æ¸¬è³‡æ˜¯åˆ©ç”¨éš¨æ©Ÿç”Ÿæˆå¤§é‡çš„æ•¸å­—å»æ‰¾å‡ºæœ‰æ²’æœ‰ä¸ä¸€æ¨£ï¼Œæ–¹æ³•by:\n          \né€™ä¸€é¡Œå°±å…ˆé€™æ¨£ï¼Œä¸éå€é–“DPæ„Ÿè¦ºå°±æ˜¯å¯ä»¥å¾ˆé›£çš„æ±è¥¿æ™‚é–“è¤‡é›œåº¦$O(n^3)$\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[105],pre[105];cin&gt;&gt;n;        int dp[105][105];        memset(pre, 0, sizeof(pre));        memset(dp, 0x3f3f3f3f, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            cin&gt;&gt;arr[i];            pre[i] = pre[i-1]+arr[i];            dp[i][i] = 0;        &#125;                for(int len = 2;len&lt;=n;len++)&#123;            for(int i=1;i+len-1&lt;=n;i++)&#123;//å€é–“[i,j]é•·åº¦ç‚ºlenï¼Œå‰‡j = i+len-1                int j = i+len-1;                for(int k=i;k&lt;=j;k++)&#123;                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬ä¸ƒé€±ï¼šå‹•æ…‹è¦åŠƒï¼ˆä¸€ï¼‰","url":"/sprout7/","content":"ä¸Šèª²å…§å®¹\nä½¿ç”¨DPæ™‚æ©Ÿï¼š\n\næœ€å„ªè§£å•é¡Œ\nè¨ˆæ•¸å•é¡Œ\né‡è¤‡å­å•é¡Œ\n\n\nDP ä½¿ç”¨éç¨‹\n\nå®šç¾©ç‹€æ…‹\nç‹€æ…‹è½‰ç§»\næ‰¾åˆ°ä¸€å€‹æœƒACçš„ä½œæ³•ï¼Œå†æ…¢æ…¢å„ªåŒ–\n\n\n\n\n\nä½¿ç”¨æ³¨æ„äº‹é …ï¼š\n\nå¯«å¥½æ™‚é–“è¤‡é›œåº¦\nç”¨ã€Œæ‹‰ã€çš„\nç”¨ã€Œæ¨ã€çš„\nç›¡é‡ä½¿ç”¨ç”±ä¸‹è€Œä¸Š\n\n\nDPä¾‹é¡Œ\n\nè·‘æ­¥å•é¡Œï¼ˆzj b589ï¼‰\næœ€å¤§é€£çºŒå’Œ\næœ€å¤§ä¸é€£çºŒå’Œï¼ˆnpsc 2017ï¼‰\nChest of Drawers (UVA 11420)\næœ€å¤§å’ŒçŸ©é™£å•é¡Œ\nçŸ©é™£æœ€å¤§æ–¹å½¢\nçŸ©é™£ä¹˜æ³•å•é¡Œ\næ¶ˆæ¶ˆæ¨‚ï¼ˆUVA 10559 Blocksï¼‰\n\n\n\nä¸Šæ©Ÿä½œæ¥­å††å††æ•¸ç£ç£šé¡Œç›®é€£çµæˆ‘ä¸æœƒå¯«è½‰ç§»å¼å­å•Šâ€¦é¦–å…ˆå¯ä»¥è§€å¯Ÿåˆ°ï¼Œå› ç‚ºå…©å€‹ç£ç£šçš„æ’æ³•æœ‰3ç¨®ï¼Œé¦–å…ˆå¯ä»¥åˆ—å‡º$f(n) = 3\\times f(n-2)$ é€™å€‹å¼å­ï¼Œä½†è§€å¯Ÿä¹‹å¾Œå¯ä»¥ç™¼ç¾ï¼Œå¦‚æœæ’åˆ—çš„ç£ç£šä¸èƒ½è¢«å…©å…©åˆ†å‰²ï¼Œä¹Ÿå¯æ˜¯ä¸€ç¨®æ–°çš„æ’æ³•ã€‚è€Œå°æ–¼å›ºå®šçš„å°ºå¯¸å¤§å°åªæœƒæœ‰ä¸€ç¨®æ’æ³•ï¼Œä½†å› ç‚ºå¯ä»¥é¡›å€’æ”¾ï¼Œå› æ­¤è¦–ç‚ºå…©ç¨®çµ„åˆã€‚è½‰ç§»å¼ï¼š$f(n) = 3\\times f(n-2)+2\\times(f(n-4)+f(n-6)â€¦)$ç¶“éæ•¸å­¸å¸¶å…¥æ¶ˆå»ï¼š$f(n-2) = 3\\times f(n-4)+2\\times(f(n-6)+f(n-8)â€¦)$$f(n) = 4\\times f(n-2)-f(n-4)$\né‚Šç•Œï¼š$dp[0] = 1, dp[2] = 3$\n#include &lt;bits/stdc++.h&gt;#define int unsigned long longusing namespace std;int t;signed main()&#123;    cin&gt;&gt;t;    int dp[100005];    memset(dp, 0, sizeof(dp));    dp[0] = 1;dp[2] = 3;dp[3] = 0;    for(int i=4;i&lt;=100001;i+=2)dp[i] =(4*dp[i-2]-dp[i-4]+1000007)%1000007;    while(t--)&#123;        int n;cin&gt;&gt;n;        cout&lt;&lt;dp[n]&lt;&lt;endl;    &#125;&#125;\nå††å††é€ç¦®ç‰©é¡Œç›®é€£çµä»¥å¾Œå¯«DPå¹¾ç¨®çµ„åˆå•é¡Œå°±æ˜¯åƒé€™ä¸€é¡Œä¸€æ¨£æš´åŠ›ç ´è§£æŠŠæ¯ä¸€ç¨®æƒ…æ³éƒ½å¯«æ¸…æ¥šï¼Œä¸æƒœé–‹ä¸‰ç¶­é™£åˆ—ä¹Ÿæ²’é—œä¿‚ç¸½ä¹‹ï¼Œ$dp[i][k][j]$ ä»£è¡¨é•·åº¦ç‚ºiï¼Œå·¦é‚Šç‚ºé¡è‰²kï¼Œå³é‚Šç‚ºé¡è‰²jï¼ˆç´…è‰²ï¼š0ã€ç¶ è‰²ï¼š1ã€è—è‰²ï¼š2ï¼‰åˆ—å‡ºæ¯ä¸€ç¨®ç‹€æ…‹çš„è½‰ç§»å¼å°±å¥½ä¸éï¼Œå³ä½¿é ­å°¾æ˜¯ä¸€è—ä¸€ç¶ ï¼Œä½†ä¹Ÿå¿…é ˆè½‰ç§»ï¼Œå› ç‚ºä¸€è—ä¸€ç¶ å¯ä»¥åœ¨é ­æˆ–å°¾åŠ ä¸Šå…¶ä»–é¡è‰²ï¼Œçµ„æˆåˆæ³•è§£ï¼Œä¸éä¸è¦è¼¸å‡ºå°±å¥½äº†\n#include &lt;bits/stdc++.h&gt;#define int long long#define ios ios::sync_with_stdio(0),cin.tie(0);using namespace std;int t;signed main()&#123;    ios;    int dp[100005][3][3];//0:red,1:green,2:blue    dp[1][0][0] = 1;dp[1][1][1] = 1;dp[1][2][2] = 1;    dp[2][0][0] = dp[2][0][1] = dp[2][0][2] = 1;    dp[2][1][0] = dp[2][1][1] = dp[2][2][0] = dp[2][2][2] = 1;    dp[2][1][2] = dp[2][2][1] = 0;    for(int i=3;i&lt;100005;i++)&#123;        dp[i][0][0] = (dp[i-1][0][0]+dp[i-1][0][1]+dp[i-1][0][2])%1000007;        dp[i][0][1] = (dp[i-1][0][0]+dp[i-1][0][1])%1000007;        dp[i][0][2] = (dp[i-1][0][0]+dp[i-1][0][2])%1000007;                dp[i][1][0] = (dp[i-1][1][0]+dp[i-1][1][1]+dp[i-1][1][2])%1000007;        dp[i][1][1] = (dp[i-1][1][0]+dp[i-1][1][1])%1000007;        dp[i][1][2] = (dp[i-1][1][0]+dp[i-1][1][2])%1000007;                dp[i][2][0] = (dp[i-1][2][0]+dp[i-1][2][1]+dp[i-1][2][2])%1000007;        dp[i][2][1] = (dp[i-1][2][0]+dp[i-1][2][1])%1000007;        dp[i][2][2] = (dp[i-1][2][0]+dp[i-1][2][2])%1000007;            &#125;    int n;cin&gt;&gt;n;    while(n--)&#123;        int a;cin&gt;&gt;a;        cout&lt;&lt;(dp[a][0][0]+dp[a][0][1]+dp[a][0][2]+dp[a][1][0]+dp[a][1][1]+dp[a][2][0]+dp[a][2][2])%1000007&lt;&lt;endl;    &#125;&#125;\nå–æ•¸å­—1é¡Œç›®é€£çµå®šç¾©ï¼š$dp[i]$ ç‚ºå–ç¬¬iå€‹æ•¸å­—çš„çš„æœ€å¤§å€¼è½‰ç§»å¼ï¼š$dp[i] = max(dp[i-2]+dp[i-2])+arr[i]$å¯ä»¥ç™¼ç¾åˆ°ï¼Œå› ç‚º$arr[i]$ éƒ½æ˜¯æ­£æ•¸ï¼Œå› æ­¤åŠ è¶Šå¤šæ•¸å­—å°±ä»£è¡¨æœ€å¾Œçš„æ•¸å€¼è¶Šå¤§ï¼Œè€Œç›¸é„°çš„å…©é …ä¸èƒ½è½‰ç§»ï¼Œå› æ­¤å°±è¦çœ‹$dp[i-2],dp[i-2]$å…¶ä¸­i-4ä¸ç”¨çœ‹æ˜¯å› ç‚ºå·²ç¶“åŒ…å«åœ¨i-2è£¡é¢äº†é‚Šç•Œï¼š$dp[1] = arr[1],dp[2] = arr[2],dp[3] = arr[1]+arr[3]$\n#include &lt;bits/stdc++.h&gt;using namespace std;int t;int main()&#123;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005];cin&gt;&gt;n;        int dp[10005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        dp[1] = arr[1];dp[2] = arr[2];dp[3] = arr[1]+arr[3];        for(int i=4;i&lt;=n+1;i++)&#123;            dp[i] = max(dp[i-2],dp[i-3])+arr[i];        &#125;        cout&lt;&lt;max(dp[n],dp[n-1])&lt;&lt;endl;    &#125;&#125;\nå–æ•¸å­—2é¡Œç›®é€£çµä¸Šé¢å–æ•¸å­—1çš„é€²éšç‰ˆï¼Œå¯ä»¥ä¸€æ¨£å®šç¾©ï¼Œä¸éè½‰ç§»å¼è¦ç¨å¾®æ”¹è®Šï¼ˆå…¶å¯¦å°±åªæ˜¯æŠŠåŸæœ¬åªæœ‰2çš„å€é–“æ“´å¤§æˆkï¼‰å®šç¾©ï¼š$dp[i]$ ç‚ºå–ç¬¬iå€‹æ•¸å­—çš„çš„æœ€å¤§å€¼è½‰ç§»å¼ï¼š$dp[i]=max(arr[j]+arr[i]),2k\\leq i \\leq n,i-2k\\leq j \\leq i-k$è½‰ç§»å¼æ¯”è¼ƒè¤‡é›œä¸€é»ï¼Œä¸éå°±æ˜¯å–æ•¸å­—1çš„å»¶ä¼¸é‚Šç•Œï¼š$dp[i] = arr[i],1\\leq i \\leq k$$dp[i]=max(arr[j]+arr[i]),k+1\\leq i \\leq 2k,1\\leq j \\leq i-k$\né‚Šç•Œçš„è©±ï¼Œå¦‚æœè¦èªªæˆæ˜¯è½‰ç§»å¼ä¹Ÿæ˜¯å¯ä»¥å•¦\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[100005],k;cin&gt;&gt;n&gt;&gt;k;        int dp[100005];        memset(dp,0,sizeof(dp));        memset(arr,0,sizeof(arr));        for(int i=1;i&lt;=n;i++)cin&gt;&gt;arr[i];        //[1,k]çš„é‚Šç•Œè½‰ç§»        for(int i=1;i&lt;=k;i++)dp[i] = arr[i];        //[k+1,2k]çš„é‚Šç•Œè½‰ç§»        for(int i=k+1;i&lt;=2*k;i++)&#123;            for(int j=1;j&lt;=i-k;j++)&#123;//çœ‹å¯ä»¥é…ä¸Š[1,k]æœ€å¤§çš„é‚£ä¸€å€‹                dp[i]=max(dp[i],arr[j]+arr[i]);            &#125;        &#125;        for(int i=2*k+1;i&lt;=n;i++)&#123;            for(int j = i-2*k;j&lt;=i-k;j++)&#123;//é–‹å§‹è½‰ç§»ï¼Œæƒækæ¬¡                dp[i] = max(dp[i],dp[j]+arr[i]);            &#125;        &#125;        cout&lt;&lt;max_element(dp, dp+n+1)&lt;&lt;endl;    &#125;&#125;\nåˆæˆå††å††é¡Œç›®é€£çµé–‹å§‹æ¥è§¸åˆ°å€é–“DPï¼Œæ¯”å–®ç´”çš„DPåˆå¤šäº†ä¸€äº›è¦æ³¨æ„çš„åœ°æ–¹ä¸Šç¶²æŸ¥é—œæ–¼å€é–“DPçš„è³‡æ–™ï¼Œä¸€èˆ¬éƒ½æœƒæœ‰é€™äº›å…§å®¹ï¼š\nfor (æšèˆ‰å€é–“é•·åº¦)    for (æšèˆ‰å·¦ç«¯é»)        for (æšèˆ‰åˆ†å‰²é»)            f[l, r] = f[l, k] + f[k, r] + val(l, r)\nä¸»è¦å°±æ˜¯ï¼Œå¾å°çš„å€é–“é•·åº¦é–‹å§‹ï¼ˆå¤§çš„å€é–“éœ€è¦å°çš„å€é–“çš„ç­”æ¡ˆï¼‰ï¼Œæšèˆ‰å·¦ç«¯é»å¯ä»¥çŸ¥é“å€é–“çš„ç¯„åœï¼Œæ¥è‘—å†ä¾åºæšèˆ‰åœ¨å€é–“å…§åˆ†å‰²é»ï¼ŒæŠŠé•·åº¦ç‚ºnçš„å€é–“é•·åº¦è·‘å®Œä¹‹å¾Œå°±å®Œæˆäº†æœ‰äº†é€™ä¸€å€‹$O(n^3)$ çš„æ¼”ç®—æ³•ï¼Œå°±å¯ä»¥é–‹å§‹ä¾†å¯¦ä½œ\nå®šç¾©ï¼š$dp[i][j]$ $(1 \\leq i,j \\leq n)$ ç‚ºåˆä½µå€é–“ $[i,j]$ æ‰€éœ€è¦çš„èŠ±è²»è½‰ç§»å¼ï¼š$dp[i][j] = min(dp[i][k]+dp[k+1][j]+sum_{i,j}),i \\leq k \\leq j$åˆä½µå€é–“$dp[i][k],dp[k+1][j]$çš„èŠ±è²»ç‚ºå…©è€…ç›¸åŠ å†åŠ ä¸Šå€é–“[i,j]çš„ç¸½å’Œï¼ˆå¯ä»¥ç”¨å‰ç¶´ç¶­è­·ï¼‰é‚Šç•Œï¼š$dp[i][i] = 0,1 \\leq i \\leq n$\né€™å€‹æ¼”ç®—æ³•çš„è¤‡é›œåº¦æ˜¯$O(n^3)$ï¼Œä¹‹å¾Œå¯ä»¥ç”¨dpå„ªåŒ–çš„æŠ€å·§åšåˆ°æ›´å¿«\n\n            å•é¡Œï¼šé€™é¡Œå¯ä¸å¯ä»¥ç”¨Greedyï¼Ÿæˆ‘å€‘å¦‚æœæ¯ä¸€æ¬¡éƒ½æ‰¾å…©å…©ç›¸é„°ç›¸åŠ ç¸½å’Œæœ€å°çš„å…©å€‹åŠ èµ·ä¾†ï¼Œåšn-1æ¬¡ï¼Œæ˜¯ä¸æ˜¯å¯ä»¥æ‰¾åˆ°æœ€ä½³è§£ï¼Ÿï¼ˆå¦‚æœå¯ä»¥ï¼Œé‚£å¹¹å˜›é‚„è¦è¾›è‹¦ç¶­è­·$n^3$çš„ç®—æ³•XDï¼‰Q:ç­”æ¡ˆæ˜¯ä¸è¡Œï¼Œé‚£è¦åä¾‹ä½•æ™‚å‡ºç¾ï¼Ÿ10 7 6 7é€™ä¸€çµ„æ¸¬è³‡å¦‚æœç”¨Greedyåšæ˜¯63ï¼Œç”¨dpåšæ˜¯60ï¼Œå¯ä»¥ç™¼ç¾åˆ°ï¼Œå¦‚æœæ•¸å­—å…©å…©ç›¸åŠ ç›¸ç­‰ï¼Œé‚£å…ˆåŠ å¾ŒåŠ çš„é †åºå°±å¾ˆé‡è¦ï¼Œæœ‰å¯èƒ½å› ç‚ºé †åºä¸å°ï¼ˆå…ˆåŠ ä¸­é–“çš„7è·Ÿ6ï¼‰ï¼Œå°è‡´7æ²’è¾¦æ³•è·Ÿ10åˆä½µç”¢ç”Ÿæ›´åŠ çš„è§£æ³•ï¼æ‰¾åä¾‹çš„æ–¹æ³•ï¼š é€™ä¸€ç­†æ¸¬è³‡æ˜¯åˆ©ç”¨éš¨æ©Ÿç”Ÿæˆå¤§é‡çš„æ•¸å­—å»æ‰¾å‡ºæœ‰æ²’æœ‰ä¸ä¸€æ¨£ï¼Œæ–¹æ³•by:\n          \né€™ä¸€é¡Œå°±å…ˆé€™æ¨£ï¼Œä¸éå€é–“DPæ„Ÿè¦ºå°±æ˜¯å¯ä»¥å¾ˆé›£çš„æ±è¥¿æ™‚é–“è¤‡é›œåº¦$O(n^3)$\n#include &lt;bits/stdc++.h&gt;#define ios ios::sync_with_stdio(0),cin.tie(0);#define int long longusing namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,arr[105],pre[105];cin&gt;&gt;n;        int dp[105][105];        memset(pre, 0, sizeof(pre));        memset(dp, 0x3f3f3f3f, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            cin&gt;&gt;arr[i];            pre[i] = pre[i-1]+arr[i];            dp[i][i] = 0;        &#125;                for(int len = 2;len&lt;=n;len++)&#123;            for(int i=1;i+len-1&lt;=n;i++)&#123;//å€é–“[i,j]é•·åº¦ç‚ºlenï¼Œå‰‡j = i+len-1                int j = i+len-1;                for(int k=i;k&lt;=j;k++)&#123;                    dp[i][j] = min(dp[i][j],dp[i][k]+dp[k+1][j]+pre[j]-pre[i-1]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[1][n]&lt;&lt;endl;    &#125;&#125;\næ‰‹å¯«ä½œæ¥­é€™ä¸€é€±æ²’æœ‰æ‰‹å¯«ï¼å› ç‚ºä¸‹ç¦®æ‹œæ˜¯ç¬¬ä¸€éšæ®µèªè­‰è€ƒ\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["å‹•æ…‹è¦åŠƒ","DP","è³‡èŠ½ç­†è¨˜"]},{"title":"[é¡Œè§£]NEOJ 157 é«˜æ£•æ«šè¾²å ´","url":"/sprout8-1/","content":"é«˜æ£•æ«šè¾²å ´\né¡Œç›®é€£çµé€™ä¸€é¡Œä¸èƒ½ç”¨é‡é‡åšï¼Œå› ç‚ºé‡é‡çš„ç¯„åœå¯ä»¥åˆ°$10^5$ï¼Œå› æ­¤åªèƒ½ç”¨åƒ¹å€¼ä¾†åšæœ‰ä¸€å€‹è¦é»ï¼Œç„¡é™å¤§å¯ä»¥memsetå®šç¾©ç‚º0x3f3f3f3fï¼Œä»¥åé€²ä½è¡¨ç¤º1061109567ï¼Œåœ¨intçš„ç¯„åœä½†ä¸æœƒè¶…é\nå®šç¾©å®šç¾©$f(n,m)$ç‚ºå–næ¨£ç‰©å“,åƒ¹å€¼æ°ç‚ºm,é‡é‡ç¸½å’Œæœ€å°å€¼\nè½‰ç§»æ–¹å¼$f(n,m) = min(f(n-1,m), f(n-1,m-v_n)+w_n), m â‰§ v_n$$f(n,m) = f(n-1,m), m &lt; v_n$\né‚Šç•Œæ¢ä»¶f(0,0) = 0, f(0,k) = INF (k&gt;0)$å› ç‚ºå–é›¶æ¨£ç‰©å“åƒ¹å€¼è¦kä¸å¯èƒ½é”åˆ°ï¼Œå› æ­¤é‡é‡è¨­ç‚ºç„¡é™å¤§\næˆ‘å€‘å¯ä»¥è—‰ç”±æ»¾å‹•dpä¾†ç¯€çœç©ºé–“ï¼Œå£“æˆä¸€ç¶­ï¼ˆè·Ÿç”¨é‡é‡ä½œç‚ºç‹€æ…‹ä¸€æ¨£ï¼‰æœ€å¾Œï¼Œåœ¨å¾dpè£¡é¢å–å‡ºmax(k), for all f(N,k) â‰¦ W\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,val[105],weight[100005];cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[100005];        //å®šç¾©f(n,m)å–næ¨£ç‰©å“,åƒ¹å€¼ç‚ºm,é‡é‡ç¸½å’Œæœ€å°        //dp[i]ï¼šåƒ¹å€¼ç‚ºiæ™‚,é‡é‡æœ€å°ç‚ºdp[i]        memset(dp,INF,sizeof(dp));        dp[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=10000;j&gt;=val[i];j--)&#123;                dp[j] = min(dp[j],dp[j-val[i]]+weight[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;=10000;i++)            if(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 158 é«˜æ£•æ«šè¾²å ´2","url":"/sprout8-2/","content":"é«˜æ£•æ«šè¾²å ´2\né¡Œç›®é€£çµæœ‰äº›ç´°ç¯€æ˜¯å¿…é ˆè¦æ³¨æ„çš„ï¼Œä¹Ÿå°±æ˜¯åˆå§‹åŒ–çš„ç´°ç¯€ã€‚\n            èƒŒåŒ…å•é¡Œæ˜¯å¦æ°å¥½è£æ»¿å°æ–¼åŸæœ¬åˆå§‹åŒ–dp[0] = 0ï¼Œä»£è¡¨å°æ–¼é‡é‡é™åˆ¶ç‚º0çš„èƒŒåŒ…åƒ¹å€¼æœ€é«˜ç‚º0æ¥ä¸‹ä¾†æœ‰å…©ç¨®æƒ…æ³éœ€è¦è¨è«–ï¼Œç¬¬ä¸€ç¨®æ˜¯é‡é‡é™åˆ¶ç‚ºwçš„èƒŒåŒ…æœ€å¤šçš„åƒ¹å€¼1. æ°å¥½è£æ»¿æ­¤æ™‚å¿…é ˆåˆå§‹åŒ–dp[i] = -INFï¼Œæ˜¯å› ç‚ºè¦æ°å¥½è£æ»¿çš„é—œä¿‚ï¼Œåˆå§‹åŒ–çš„dp æ•¸çµ„äº‹å¯¦ä¸Šå°±æ˜¯åœ¨æ²’æœ‰ä»»ä½•ç‰©å“å¯ä»¥æ”¾å…¥èƒŒåŒ…æ™‚çš„åˆæ³•ç‹€æ…‹ï¼Œå…¶ä»–é™¤äº†0ä¹‹å¤–å®¹é‡çš„èƒŒåŒ…å‡æ²’æœ‰åˆæ³•çš„è§£ï¼Œå±¬æ–¼æœªå®šç¾©çš„ç‹€æ…‹ï¼Œæ‰€ä»¥éƒ½æ‡‰è©²è¢«è³¦å€¼ç‚º âˆ’âˆ ã€‚ç•¶å‰çš„åˆæ³•è§£ï¼Œä¸€å®šæ˜¯å¾ä¹‹å‰çš„åˆæ³•ç‹€æ…‹æ¨å¾—çš„(âˆ’âˆè·Ÿâˆ’âˆå–maxé‚„æ˜¯âˆ’âˆ)2. ä¸éœ€æ°å¥½è£æ»¿å¦‚æœèƒŒåŒ…ä¸¦éå¿…é ˆè¢«è£æ»¿ï¼Œé‚£éº¼ä»»ä½•å®¹é‡çš„èƒŒåŒ…éƒ½æœ‰ä¸€å€‹åˆæ³•è§£â€œä»€éº¼ä¹Ÿä¸è£â€ï¼Œé€™å€‹è§£çš„åƒ¹å€¼ç‚º0,æ‰€ä»¥åˆå§‹åŒ–æ™‚ç‹€æ…‹çš„å€¼ä¹Ÿå°±å…¨éƒ¨ç‚º0äº†ã€‚å¦‚æœä¾†çœ‹è½‰ç§»å¼ï¼Œ$dp[j] = max(dp[j],dp[j-weight[i]]+val[i])$ï¼Œå¦‚æœå…©è€…çš„ç‹€æ…‹éƒ½å±¬æ–¼æœªå®šç¾©ï¼Œå°æ–¼éœ€æ°å¥½è£æ»¿çš„ç‹€æ³ï¼Œå…©è€…éƒ½æ˜¯âˆ’âˆï¼Œè¡¨ç¤ºæ²’æœ‰åˆæ³•çš„ç‹€æ…‹å¯ä»¥æ§‹æˆæ­¤é‡é‡ã€‚åŒæ™‚ï¼Œå¦‚æœä¸éœ€æ°å¥½è£æ»¿çš„æƒ…æ³ï¼Œå³ä½¿$dp[j]$å’Œ$dp[j-weight[i]]$éƒ½æœªå®šç¾©(ç­‰æ–¼0)ï¼Œé‚„æ˜¯å¯ä»¥è¢«æ›´æ–°ï¼ˆåœ¨æ²’æœ‰è£æ»¿çš„æƒ…æ³ä¸‹ï¼Œdp[j] = val[i]ï¼‰\n          é€™ä¸€é¡Œé™¤äº†ä»¥ä¸Šç™¼ç¾ï¼Œé‚„æœ‰ä¸€å€‹å¾ˆé‡è¦çš„æ±è¥¿ï¼Œå°±æ˜¯è¿´åœˆåˆ°åº•è¦æ”¾å“ªä¸€å±¤çš„å•é¡Œã€‚ä¸»è¦æ˜¯å¡åœ¨ for(int p=1;p&lt;=k;p++)åˆ°åº•è¦æ”¾åœ¨å“ªä¸€å±¤çš„å•é¡Œï¼Œçµæœæ˜¯è¦æ”¾åœ¨ç¬¬ä¸‰å±¤ã€‚\n            å•é¡Œä¸€ï¼šdp[j][p]å–æ±ºæ–¼dp[j][p] å’Œdp[j-weight[i]][p-1]ï¼Œè€Œä¸”å°æ–¼ä¸€å€‹ç‰©å“æœ€å¤šåªèƒ½æ”¾ä¸€æ¬¡ï¼Œå¦‚æœæ”¾åœ¨ç¬¬äºŒå±¤ï¼Œdp[j-weight[i]][p-1] å°±å·²ç¶“è¢«æ›´æ–°éäº†ï¼Œæœ‰å¯èƒ½å·²ç¶“å–äº†ç¬¬ i æ¨£ç‰©å“æœƒæœ‰é‡è¤‡å–çš„å•é¡Œï¼Œå¦‚æœæ”¾åœ¨ç¬¬ä¸‰å±¤ï¼Œä»£è¡¨å°æ¯ä¸€ç¨®ä¸åŒçš„é‡é‡å…ˆæ›´æ–°æ”¾å…¥å¹¾æ¨£ç‰©å“çš„1åˆ°kï¼Œå†æ›´æ–°é‡é‡ï¼Œé€™æ¨£å°±å¯ä»¥ä¿è­‰dp[j][p]ä¸æœƒå–åˆ°å·²ç¶“æ›´æ–°çš„æ ¼å­ï¼ˆdp[j][p] æ²’è¢«æ›´æ–°ã€dp[j-weight[i]][p-1] å…¶ä¸­ç¬¬ä¸€ç¶­çš„j-weight[i] ä¹Ÿé‚„æ²’è¢«æ›´æ–°ï¼‰å•é¡ŒäºŒï¼špè¦å¾1åˆ°ké‚„æ˜¯kåˆ°1ï¼Œé€™å…¶å¯¦éƒ½å¯ä»¥ï¼Œå› ç‚ºè¦å–çš„æ ¼å­ä¸ç®¡å¾å‰å¾€å¾Œæˆ–å¾Œå¾€å‰å–éƒ½åªæœƒå–åˆ°ä¸Šä¸€è¼ª(i-1) çš„æ›´æ–°æ±è¥¿ï¼Œå› æ­¤ä¸å½±éŸ¿ã€‚é‚„æœ‰ï¼Œå› ç‚ºæ˜¯å®šç¾©æœ€å¤šå–pæ¨£ç‰©å“ï¼Œæ‰€ä»¥ç„¡è«–iç‚ºå¤šå°‘ï¼Œæ¯ä¸€æ¬¡pçš†è¦æ›´æ–°çš„kï¼ˆå¦‚æœk=5ï¼Œå–ä¸€æ¨£ç‰©å“ä¹Ÿç¬¦åˆæƒ…æ³ï¼‰\n          \nå®šç¾©å®šç¾©$f(j,p)$çœ‹å®Œ i æ¨£ç‰©å“å¾Œï¼Œé‡é‡é™åˆ¶ç‚ºjï¼Œæœ€å¤šå–pæ¨£ç‰©å“çš„æœ€å¤§åƒ¹å€¼\nè½‰ç§»æ–¹å¼$dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i])$\né‚Šç•Œæ¢ä»¶$dp[i][j] = 0$ (for all elements in dp)\n#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,k,val[105],weight[10005];cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[1005][105];        memset(dp, 0, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            for(int j=m;j&gt;=weight[i];j--)&#123;                for(int p=1;p&lt;=k;p++)&#123;                    dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[m][k]&lt;&lt;endl;    &#125;&#125;/* 0 4 5 6 6 6 0 4 5 6 9 10 0 4 5 6 9 10*/\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 416 ç©é›»æ¢¯","url":"/sprout8-3/","content":"ç©é›»æ¢¯\né¡Œç›®é€£çµé¡Œç›®é€£çµ2\né€™ä¸€é¡Œè¦ç”¨åˆ°3å€‹é‡è¦çš„æŠ€å·§ï¼šå‰ç¶´å’Œã€å·®åˆ†ã€æ»¾å‹•dpå·®åˆ†åœ¨æŸä¸€æ¬¡æ‰‹å¯«ä½œæ¥­æœ‰å¯«åˆ°ï¼Œä¸éé‚£æ™‚å€™æ²’æœ‰å¾ˆæ³¨æ„é€™å€‹éƒ¨åˆ†å°±æ˜¯äº†\n            å·®åˆ†å·®åˆ†æ˜¯å‰ç¶´å’Œçš„é€†é‹ç®—ï¼Œä¹Ÿå°±æ˜¯èªªï¼ŒæŠŠå…©é …çš„å·®ç®—å‡ºä¾†å°±æ˜¯å·®åˆ†ã€‚å®šç¾©å¦‚ä¸‹ï¼šb_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}å·®åˆ†çš„ä½¿ç”¨æ™‚æ©Ÿæ˜¯å€é–“åŠ å€¼ï¼Œä¸€å€‹å€é–“å…§çš„æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å®šå€¼ï¼Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨åˆ°å·®åˆ†çš„æŠ€å·§ã€‚ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼Œç•¶æˆ‘è¦åœ¨å€é–“ $[l,r]$ çš„æ¯ä¸€å€‹æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å€¼$v$ï¼Œä»¥ä¸‹æ­¥é©Ÿï¼šå®šç¾©ä¸€å€‹æ–°çš„é™£åˆ— $b_i$ è¡¨ç¤ºæ¯ä¸€é …å·®åˆ†è¨­ $bl = b_l+v$ï¼Œ$b{r+1} = b_{r+1}-v$å°‡å·®åˆ†çš„æ¯ä¸€é …åŠ ä¸Šå‰ä¸€é …ï¼Œå³ç‚ºåŸæ•¸åˆ— $bi = b{i-1}+b_i$ç¬¬äºŒæ­¥é©Ÿå¯ä»¥é‡è¤‡å¥½å¹¾æ¬¡åšï¼Œé€™æ¨£è¤‡é›œåº¦å¾åŸæœ¬çš„$O(n)$å°±è®Šæˆäº†O(1)äº†ï¼\n          \né€™ä¸€é¡Œä½¿ç”¨åˆ°å·®åˆ†çš„æŠ€å·§ï¼Œè®“åŸæœ¬çš„$O(kn^2)$æ¸›å°‘æˆ$O(kn)$ï¼Œç„¶å¾Œå°±å¯ä»¥éäº†ï¼\nå®šç¾©å®šç¾© $dp[i][j]$ ç‚ºç¬¬ i æ¬¡èµ°åˆ°æ¨“å±¤jçš„æ–¹æ³•æ•¸\nè½‰ç§»å¼é€™é¡Œå¦‚æœç”¨æ‹‰çš„æ¯”è¼ƒä¸å¥½æƒ³ï¼Œæ‰€ä»¥æ”¹ç”¨æ¨çš„è©¦è©¦çœ‹$dp[i+1][j] = dp[i+1][j]+dp[i][p],$ for $j\\in[p-r],[p+1,p+r],r = |p-b|-1$\né‚Šç•Œæ¢ä»¶$dp[0][a] = 1$\nè½‰ç§»å¼æ¯”è¼ƒè¤‡é›œä¸€é»ï¼Œä¸éå¯ä»¥ç”¨å·®åˆ†å„ªåŒ–æ­é…å‰ç¶´å’ŒæŠŠåŸæœ¬$O(n)$çš„æ™‚é–“é™åˆ°$O(1)$å¾é€™ä¸€é¡Œå¯ä»¥ç™¼ç¾åˆ°ï¼Œç”¨æ‹‰çš„å’Œç”¨æ¨çš„æœ‰ä¸åŒçš„ä½¿ç”¨æ™‚æ©Ÿï¼Œå¯ä»¥ä»¥æ€è€ƒæ–¹å¼æ¯”è¼ƒæ¸…æ¥šçš„æƒ³æ³•å»æƒ³è½‰ç§»å¼ã€‚\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define ios ios::sync_with_stdio(0)using namespace std;int n,a,b,k,dp[2][2005];int modify(int x)&#123;    return (x%mod+mod)%mod;&#125;void sec(int l,int r,int v,int id)&#123;     l = max(l,(long long)1);    r = min(r,n);    dp[(id+1)%2][l] = modify(dp[(id+1)%2][l]+v);    dp[(id+1)%2][r+1] = modify(dp[(id+1)%2][r+1]-v);&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;k;    memset(dp,0,sizeof(dp));    dp[0][a] = 1;    for(int s=0;s&lt;k;s++)&#123;  //æ¯ä¸€æ¬¡é›»æ¢¯ç§»å‹•        for(int i=1;i&lt;=n;i++)&#123; //æ¯ä¸€æ¨“å±¤è½‰ç§»            int d = abs(b-i)-1;            sec(i-d,i-1,dp[s%2][i],s);            sec(i+1,i+d,dp[s%2][i],s);        &#125;        for(int i=1;i&lt;=n;i++)&#123;            dp[(s+1)%2][i] += dp[(s+1)%2][i-1];            dp[(s+1)%2][i] = modify(dp[(s+1)%2][i]);        &#125;        for(int i=1;i&lt;=n;i++)dp[(s)%2][i] = 0;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=dp[k%2][i];        ans = modify(ans);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;//8æ¨“ã€2æ¨“é–‹å§‹ã€5æ¨“ä¸èƒ½å»ã€2æ¬¡é›»æ¢¯\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 421 å–åå­—å¥½å›°é›£QQ","url":"/sprout8-4/","content":"å–åå­—å¥½å›°é›£QQ\né¡Œç›®é€£çµè·Ÿé¡Œç›®ä¸€æ¨£ï¼Œæˆ‘è¦ºå¾—è¦é€šéˆæ‰èƒ½æƒ³åˆ°é€™ä¸€é¡Œçš„ä½œæ³•ï¼çµæœæ˜¯å•äº†åˆ¥äººæ‰å¤§æ¦‚æ„Ÿå—åˆ°é€™ä¸€ç¨®ä½œæ³•ï¼ï¼ï¼\næˆ‘å€‘æ—¢ç„¶ä¸çŸ¥é“åˆ°åº•ä¸€å€‹æ•¸å­—è¦ä¸è¦ä¹˜2ï¼Œæˆ‘å€‘å¯ä»¥é€éåšLISçš„éç¨‹ä¾†åšæ±ºå®šã€‚ç•¶æˆ‘å€‘æŠŠä¹˜èˆ‡2ä¹‹å¾Œçš„æ•¸å­—è·ŸåŸæœ¬æ•¸å­—ä¸€èµ·pushé€²å»ï¼Œå°±å¯ä»¥ç™¼ç¾åˆ°LISä¸å¯èƒ½åŒæ™‚å–åˆ°2å€‹æ•¸å­—ã€‚åˆ©ç”¨é€™å€‹æ–¹æ³•å°±å¯ä»¥ç”¨LISçš„éç¨‹æ±ºå®šä¸€å€‹æ•¸å­—åˆ°åº•æ‡‰è©²è¦è®Š2å€é‚„æ˜¯ä¸ç”¨ã€‚è¦æ‰¾åˆ°æœ€é•·çš„éåš´æ ¼éå¢åºåˆ—ï¼Œæœ€å¤§çš„å·®åˆ¥å°±æ˜¯è¦æŠŠåŸæœ¬çš„lower_boundæ”¹æˆupper_boundã€‚ä¸€æ•´å¤©æƒ³ä¸€é¡Œçš„æ„Ÿè¦ºè¶…ç´šç³Ÿç³•QQ\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    vector&lt;int&gt;vec;    FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        if(2*temp&lt;m)continue;        else if(temp&lt;m)&#123;            temp*=2;            vec.push_back(temp);        &#125;        else&#123;            vec.push_back(2*temp);            vec.push_back(temp);        &#125;    &#125;    if(vec.size()&lt;1)&#123;        cout&lt;&lt;0&lt;&lt;endl;        return;    &#125;        //æ­£å¸¸åšLIS    vector&lt;int&gt; lis;int len = vec.size();    lis.push_back(vec[0]);    for(int i=1;i&lt;len;i++)&#123;        if(lis.back()&lt;=vec[i])lis.push_back(vec[i]);        else *upper_bound(lis.begin(),lis.end(),vec[i]) = vec[i];    &#125;    cout&lt;&lt;lis.size()&lt;&lt;endl;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬å…«é€±ï¼šå‹•æ…‹è¦åŠƒï¼ˆäºŒï¼‰","url":"/sprout8/","content":"é€™å…©é€±çœŸæ˜¯é¢¨é¢¨é›¨é›¨ï¼Œé¦–å…ˆç¬¬ä¸€é€±æ˜¯æ®µè€ƒé€±ï¼Œæ‰€ä»¥æœ‰å¾ˆå¤šæ™‚é–“æ‹¿å»æƒ¡è£œæ®µè€ƒã€‚ç¬¬äºŒé€±å‰‡æ˜¯ç–«æƒ…é—œä¿‚è¦åœ¨å®¶è£¡ç·šä¸Šä¸Šèª²ï¼Œçµæœé€²åº¦å°±è¾£äº†ä¸€å¤§æˆªâ€¦è¶•å¿«è¿½QQï¼\nä¸Šèª²å…§å®¹ä¸€å †çš„èƒŒåŒ…å•é¡Œï¼ˆçœŸçš„å¾ˆå¤šç¨®è€¶ï¼‰\n01èƒŒåŒ…å•é¡Œç„¡é™èƒŒåŒ…å•é¡Œ\n\nå…ˆå›ºå®šèƒŒåŒ…æ•¸é‡çœ‹åƒ¹å€¼è·Ÿå…ˆå›ºå®šåƒ¹å€¼çœ‹èƒŒåŒ…æ•¸é‡å¯ä»¥äº’æ›\n\næœ‰é™èƒŒåŒ…å•é¡Œ\n\nå¤šæšèˆ‰æ¯å€‹ç‰©å“è¦æ”¾å…¥çš„æ•¸é‡\n\næ‹†åˆ†ï¼šæŠŠåŒé‡é‡çš„ç‰©å“çœ‹æˆä¸åŒçš„ç‰©å“ï¼ˆè¤‡é›œåº¦ä¸è®Šï¼‰\næŠŠ$t_i$ å€‹ç‰©å“æ‹†æˆ$\\lfloor \\log_2 t_i+1\\rfloor$å€‹ç‰©å“\nåˆ†æˆçš„å †æ•¸æœ€å°‘ï¼š$\\lceil \\log{t_i}+1\\rceil$(å› ç‚ºåˆ†æˆ $k$ å †æœ€å¤šåªå¯èƒ½æœ‰ $2^k$ å€‹å€¼)\nè¤‡é›œåº¦ï¼š$O(n\\log{max(t_i)}W)$\n\næ··åˆèƒŒåŒ…å•é¡Œ\n\né‡åˆ°ä»€éº¼æ¨£çš„ç‰©å“å°±æ€éº¼åšï¼ˆå°æœ‰é™å€‹èƒŒåŒ…æ‹†åˆ†ï¼‰\nåˆ†æˆ01èƒŒåŒ…è·Ÿç„¡é™èƒŒåŒ…åš\n\näºŒç¶­èƒŒåŒ…å•é¡Œ\n\nå¤šä¸€ç¶­åº¦ç‹€æ…‹è½‰ç§»ï¼ˆå¯ä»¥å£“æ‰ä¸€å€‹ç¶­åº¦ï¼‰\n\nåˆ†çµ„èƒŒåŒ…å•é¡Œ\n\nå†å¤šä¸€ç¶­å„²å­˜ç¬¬å¹¾çµ„\n\nèƒŒåŒ…åˆä½µ\n\nç›´æ¥æŠŠç‰©å“æ··èµ·ä¾†åš\n\nèƒŒåŒ…å•é¡Œè®ŠåŒ–\n\n(1)æ±‚æœ€å¤§åƒ¹å€¼çš„æ–¹æ³•ç¸½æ•¸\nç”¨g[i] å„²å­˜é‡é‡i çš„æ–¹æ³•æ•¸\n\n\n(2)æ±‚æœ€å¤§åƒ¹å€¼çš„ä¸€çµ„æ–¹æ¡ˆ\ng[i] çœ‹æœ‰æ²’æœ‰è¢«æ›´æ–°éï¼Œæœ‰å°±g[I] = 1ï¼Œå›æº¯æ‰¾\n\n\n(3)æ±‚æœ€å¤§åƒ¹å€¼çš„å­—å…¸åºæœ€å°çš„ä¸€çµ„æ–¹æ¡ˆ\næŠŠç‰©å“å€’éä¾†ï¼ˆç”±å¤§åˆ°å°ï¼‰å› ç‚ºè¶Šå°çš„(1)è¦æœ€å¾Œè€ƒæ…®ï¼Œå¦å‰‡1å…ˆè€ƒæ…®å¾Œé¢çš„å¤§çš„æ•¸å­—æœƒæŠŠ1è¦†è“‹æ‰ï¼Œå­—å…¸åºå°±è®Šå¤§\n\n\n(4)æ±‚æ¬¡å¤§åƒ¹å€¼çš„è§£/ç¬¬Kå¤§åƒ¹å€¼çš„è§£\nçœ‹æŠ•å½±ç‰‡\n\n\n\nåˆ†æ•¸èƒŒåŒ…\n\nGreedy\n\nä¸åŒåšæ³•è¤‡é›œåº¦\n\nç”¨åƒ¹å€¼åšç‹€æ…‹\nç”¨é‡é‡åšç‹€æ…‹\nV, Wéƒ½å¾ˆå¤§ä½†nå¾ˆå°ï¼Ÿ\næšèˆ‰$2^n$ \n\n\nå¦‚æœV, Wéƒ½å¾ˆå¤§nä¹Ÿè »å¤§ï¼Ÿ\næŠ˜åŠæšèˆ‰ï¼ˆmeet in the middleï¼‰æ ¹è™Ÿç®—æ³•\n\n\n\nä¸Šæ©Ÿä½œæ¥­èƒŒåŒ…å•é¡Œä¸»è¦æœ‰ä¸‰å€‹è®Šé‡ï¼šåƒ¹å€¼ã€é‡é‡ã€ç‰©å“æ•¸é‡ï¼Œå› æ­¤å¯ä»¥æœ‰ä¸‰å€‹ä½œæ³•ï¼š\n\nä»¥ç‰©å“æ•¸é‡n ä½œç‚ºç‹€æ…‹ï¼Œçˆ†æœï¼Œè¤‡é›œåº¦ï¼š$O(2^n)$\nä»¥åƒ¹å€¼v ä½œç‚ºç‹€æ…‹(vç‚ºç‰©å“åƒ¹å€¼ç¸½å’Œï¼‰ï¼Œdpä½œï¼Œè¤‡é›œåº¦ï¼š$O(NV)$\nä»¥é‡é‡w ä½œç‚ºç‹€æ…‹(wç‚ºç‰©å“é‡é‡ä¸Šé™ï¼‰ï¼Œdpä½œï¼Œè¤‡é›œåº¦ï¼š$O(NW)$\n\né«˜æ£•æ«šè¾²å ´é¡Œç›®é€£çµé€™ä¸€é¡Œä¸èƒ½ç”¨é‡é‡åšï¼Œå› ç‚ºé‡é‡çš„ç¯„åœå¯ä»¥åˆ°$10^5$ï¼Œå› æ­¤åªèƒ½ç”¨åƒ¹å€¼ä¾†åšæœ‰ä¸€å€‹è¦é»ï¼Œç„¡é™å¤§å¯ä»¥memsetå®šç¾©ç‚º0x3f3f3f3fï¼Œä»¥åé€²ä½è¡¨ç¤º1061109567ï¼Œåœ¨intçš„ç¯„åœä½†ä¸æœƒè¶…é\nå®šç¾©å®šç¾©$f(n,m)$ç‚ºå–næ¨£ç‰©å“,åƒ¹å€¼æ°ç‚ºm,é‡é‡ç¸½å’Œæœ€å°å€¼\nè½‰ç§»æ–¹å¼$f(n,m) = min(f(n-1,m), f(n-1,m-v_n)+w_n), m â‰§ v_n$$f(n,m) = f(n-1,m), m &lt; v_n$\né‚Šç•Œæ¢ä»¶f(0,0) = 0, f(0,k) = INF (k&gt;0)$å› ç‚ºå–é›¶æ¨£ç‰©å“åƒ¹å€¼è¦kä¸å¯èƒ½é”åˆ°ï¼Œå› æ­¤é‡é‡è¨­ç‚ºç„¡é™å¤§\næˆ‘å€‘å¯ä»¥è—‰ç”±æ»¾å‹•dpä¾†ç¯€çœç©ºé–“ï¼Œå£“æˆä¸€ç¶­ï¼ˆè·Ÿç”¨é‡é‡ä½œç‚ºç‹€æ…‹ä¸€æ¨£ï¼‰æœ€å¾Œï¼Œåœ¨å¾dpè£¡é¢å–å‡ºmax(k), for all f(N,k) â‰¦ W\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,val[105],weight[100005];cin&gt;&gt;n&gt;&gt;m;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[100005];        //å®šç¾©f(n,m)å–næ¨£ç‰©å“,åƒ¹å€¼ç‚ºm,é‡é‡ç¸½å’Œæœ€å°        //dp[i]ï¼šåƒ¹å€¼ç‚ºiæ™‚,é‡é‡æœ€å°ç‚ºdp[i]        memset(dp,INF,sizeof(dp));        dp[0] = 0;        for(int i=1;i&lt;=n;i++)&#123;            for(int j=10000;j&gt;=val[i];j--)&#123;                dp[j] = min(dp[j],dp[j-val[i]]+weight[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;=10000;i++)            if(dp[i] &lt;= m &amp;&amp; i &gt; ans)ans = i;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\né«˜æ£•æ«šè¾²å ´2é¡Œç›®é€£çµæœ‰äº›ç´°ç¯€æ˜¯å¿…é ˆè¦æ³¨æ„çš„ï¼Œä¹Ÿå°±æ˜¯åˆå§‹åŒ–çš„ç´°ç¯€ã€‚\n            èƒŒåŒ…å•é¡Œæ˜¯å¦æ°å¥½è£æ»¿å°æ–¼åŸæœ¬åˆå§‹åŒ–dp[0] = 0ï¼Œä»£è¡¨å°æ–¼é‡é‡é™åˆ¶ç‚º0çš„èƒŒåŒ…åƒ¹å€¼æœ€é«˜ç‚º0æ¥ä¸‹ä¾†æœ‰å…©ç¨®æƒ…æ³éœ€è¦è¨è«–ï¼Œç¬¬ä¸€ç¨®æ˜¯é‡é‡é™åˆ¶ç‚ºwçš„èƒŒåŒ…æœ€å¤šçš„åƒ¹å€¼1. æ°å¥½è£æ»¿æ­¤æ™‚å¿…é ˆåˆå§‹åŒ–dp[i] = -INFï¼Œæ˜¯å› ç‚ºè¦æ°å¥½è£æ»¿çš„é—œä¿‚ï¼Œåˆå§‹åŒ–çš„dp æ•¸çµ„äº‹å¯¦ä¸Šå°±æ˜¯åœ¨æ²’æœ‰ä»»ä½•ç‰©å“å¯ä»¥æ”¾å…¥èƒŒåŒ…æ™‚çš„åˆæ³•ç‹€æ…‹ï¼Œå…¶ä»–é™¤äº†0ä¹‹å¤–å®¹é‡çš„èƒŒåŒ…å‡æ²’æœ‰åˆæ³•çš„è§£ï¼Œå±¬æ–¼æœªå®šç¾©çš„ç‹€æ…‹ï¼Œæ‰€ä»¥éƒ½æ‡‰è©²è¢«è³¦å€¼ç‚º âˆ’âˆ ã€‚ç•¶å‰çš„åˆæ³•è§£ï¼Œä¸€å®šæ˜¯å¾ä¹‹å‰çš„åˆæ³•ç‹€æ…‹æ¨å¾—çš„(âˆ’âˆè·Ÿâˆ’âˆå–maxé‚„æ˜¯âˆ’âˆ)2. ä¸éœ€æ°å¥½è£æ»¿å¦‚æœèƒŒåŒ…ä¸¦éå¿…é ˆè¢«è£æ»¿ï¼Œé‚£éº¼ä»»ä½•å®¹é‡çš„èƒŒåŒ…éƒ½æœ‰ä¸€å€‹åˆæ³•è§£â€œä»€éº¼ä¹Ÿä¸è£â€ï¼Œé€™å€‹è§£çš„åƒ¹å€¼ç‚º0,æ‰€ä»¥åˆå§‹åŒ–æ™‚ç‹€æ…‹çš„å€¼ä¹Ÿå°±å…¨éƒ¨ç‚º0äº†ã€‚å¦‚æœä¾†çœ‹è½‰ç§»å¼ï¼Œ$dp[j] = max(dp[j],dp[j-weight[i]]+val[i])$ï¼Œå¦‚æœå…©è€…çš„ç‹€æ…‹éƒ½å±¬æ–¼æœªå®šç¾©ï¼Œå°æ–¼éœ€æ°å¥½è£æ»¿çš„ç‹€æ³ï¼Œå…©è€…éƒ½æ˜¯âˆ’âˆï¼Œè¡¨ç¤ºæ²’æœ‰åˆæ³•çš„ç‹€æ…‹å¯ä»¥æ§‹æˆæ­¤é‡é‡ã€‚åŒæ™‚ï¼Œå¦‚æœä¸éœ€æ°å¥½è£æ»¿çš„æƒ…æ³ï¼Œå³ä½¿$dp[j]$å’Œ$dp[j-weight[i]]$éƒ½æœªå®šç¾©(ç­‰æ–¼0)ï¼Œé‚„æ˜¯å¯ä»¥è¢«æ›´æ–°ï¼ˆåœ¨æ²’æœ‰è£æ»¿çš„æƒ…æ³ä¸‹ï¼Œdp[j] = val[i]ï¼‰\n          é€™ä¸€é¡Œé™¤äº†ä»¥ä¸Šç™¼ç¾ï¼Œé‚„æœ‰ä¸€å€‹å¾ˆé‡è¦çš„æ±è¥¿ï¼Œå°±æ˜¯è¿´åœˆåˆ°åº•è¦æ”¾å“ªä¸€å±¤çš„å•é¡Œã€‚ä¸»è¦æ˜¯å¡åœ¨ for(int p=1;p&lt;=k;p++)åˆ°åº•è¦æ”¾åœ¨å“ªä¸€å±¤çš„å•é¡Œï¼Œçµæœæ˜¯è¦æ”¾åœ¨ç¬¬ä¸‰å±¤ã€‚\n            å•é¡Œä¸€ï¼šdp[j][p]å–æ±ºæ–¼dp[j][p] å’Œdp[j-weight[i]][p-1]ï¼Œè€Œä¸”å°æ–¼ä¸€å€‹ç‰©å“æœ€å¤šåªèƒ½æ”¾ä¸€æ¬¡ï¼Œå¦‚æœæ”¾åœ¨ç¬¬äºŒå±¤ï¼Œdp[j-weight[i]][p-1] å°±å·²ç¶“è¢«æ›´æ–°éäº†ï¼Œæœ‰å¯èƒ½å·²ç¶“å–äº†ç¬¬ i æ¨£ç‰©å“æœƒæœ‰é‡è¤‡å–çš„å•é¡Œï¼Œå¦‚æœæ”¾åœ¨ç¬¬ä¸‰å±¤ï¼Œä»£è¡¨å°æ¯ä¸€ç¨®ä¸åŒçš„é‡é‡å…ˆæ›´æ–°æ”¾å…¥å¹¾æ¨£ç‰©å“çš„1åˆ°kï¼Œå†æ›´æ–°é‡é‡ï¼Œé€™æ¨£å°±å¯ä»¥ä¿è­‰dp[j][p]ä¸æœƒå–åˆ°å·²ç¶“æ›´æ–°çš„æ ¼å­ï¼ˆdp[j][p] æ²’è¢«æ›´æ–°ã€dp[j-weight[i]][p-1] å…¶ä¸­ç¬¬ä¸€ç¶­çš„j-weight[i] ä¹Ÿé‚„æ²’è¢«æ›´æ–°ï¼‰å•é¡ŒäºŒï¼špè¦å¾1åˆ°ké‚„æ˜¯kåˆ°1ï¼Œé€™å…¶å¯¦éƒ½å¯ä»¥ï¼Œå› ç‚ºè¦å–çš„æ ¼å­ä¸ç®¡å¾å‰å¾€å¾Œæˆ–å¾Œå¾€å‰å–éƒ½åªæœƒå–åˆ°ä¸Šä¸€è¼ª(i-1) çš„æ›´æ–°æ±è¥¿ï¼Œå› æ­¤ä¸å½±éŸ¿ã€‚é‚„æœ‰ï¼Œå› ç‚ºæ˜¯å®šç¾©æœ€å¤šå–pæ¨£ç‰©å“ï¼Œæ‰€ä»¥ç„¡è«–iç‚ºå¤šå°‘ï¼Œæ¯ä¸€æ¬¡pçš†è¦æ›´æ–°çš„kï¼ˆå¦‚æœk=5ï¼Œå–ä¸€æ¨£ç‰©å“ä¹Ÿç¬¦åˆæƒ…æ³ï¼‰\n          \nå®šç¾©å®šç¾©$f(j,p)$çœ‹å®Œ i æ¨£ç‰©å“å¾Œï¼Œé‡é‡é™åˆ¶ç‚ºjï¼Œæœ€å¤šå–pæ¨£ç‰©å“çš„æœ€å¤§åƒ¹å€¼\nè½‰ç§»æ–¹å¼$dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i])$\né‚Šç•Œæ¢ä»¶$dp[i][j] = 0$ (for all elements in dp)\n#include &lt;bits/stdc++.h&gt;#define int long long#define INF 0x3f3f3f3f#define ios ios::sync_with_stdio(0),cin.tie(0)using namespace std;int t;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        int n,m,k,val[105],weight[10005];cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;        for(int i=1;i&lt;=n;i++)cin&gt;&gt;weight[i]&gt;&gt;val[i];        int dp[1005][105];        memset(dp, 0, sizeof(dp));        for(int i=1;i&lt;=n;i++)&#123;            for(int j=m;j&gt;=weight[i];j--)&#123;                for(int p=1;p&lt;=k;p++)&#123;                    dp[j][p] = max(dp[j][p],dp[j-weight[i]][p-1]+val[i]);                &#125;            &#125;        &#125;        cout&lt;&lt;dp[m][k]&lt;&lt;endl;    &#125;&#125;/* 0 4 5 6 6 6 0 4 5 6 9 10 0 4 5 6 9 10*/\nç©é›»æ¢¯é¡Œç›®é€£çµé¡Œç›®é€£çµ2\né€™ä¸€é¡Œè¦ç”¨åˆ°3å€‹é‡è¦çš„æŠ€å·§ï¼šå‰ç¶´å’Œã€å·®åˆ†ã€æ»¾å‹•dpå·®åˆ†åœ¨æŸä¸€æ¬¡æ‰‹å¯«ä½œæ¥­æœ‰å¯«åˆ°ï¼Œä¸éé‚£æ™‚å€™æ²’æœ‰å¾ˆæ³¨æ„é€™å€‹éƒ¨åˆ†å°±æ˜¯äº†\n            å·®åˆ†å·®åˆ†æ˜¯å‰ç¶´å’Œçš„é€†é‹ç®—ï¼Œä¹Ÿå°±æ˜¯èªªï¼ŒæŠŠå…©é …çš„å·®ç®—å‡ºä¾†å°±æ˜¯å·®åˆ†ã€‚å®šç¾©å¦‚ä¸‹ï¼šb_i = \\begin{cases}a_i-a_{i-1}, &\\text{if }i\\gt 1 \\\\a_1, & \\text{if } i = 1\\end{cases}å·®åˆ†çš„ä½¿ç”¨æ™‚æ©Ÿæ˜¯å€é–“åŠ å€¼ï¼Œä¸€å€‹å€é–“å…§çš„æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å®šå€¼ï¼Œé€™æ™‚å€™å°±å¯ä»¥ä½¿ç”¨åˆ°å·®åˆ†çš„æŠ€å·§ã€‚ä½¿ç”¨æ–¹å¼å¦‚ä¸‹ï¼Œç•¶æˆ‘è¦åœ¨å€é–“ $[l,r]$ çš„æ¯ä¸€å€‹æ•¸å­—éƒ½åŠ ä¸Šä¸€å€‹å€¼$v$ï¼Œä»¥ä¸‹æ­¥é©Ÿï¼šå®šç¾©ä¸€å€‹æ–°çš„é™£åˆ— $b_i$ è¡¨ç¤ºæ¯ä¸€é …å·®åˆ†è¨­ $bl = b_l+v$ï¼Œ$b{r+1} = b_{r+1}-v$å°‡å·®åˆ†çš„æ¯ä¸€é …åŠ ä¸Šå‰ä¸€é …ï¼Œå³ç‚ºåŸæ•¸åˆ— $bi = b{i-1}+b_i$ç¬¬äºŒæ­¥é©Ÿå¯ä»¥é‡è¤‡å¥½å¹¾æ¬¡åšï¼Œé€™æ¨£è¤‡é›œåº¦å¾åŸæœ¬çš„$O(n)$å°±è®Šæˆäº†O(1)äº†ï¼\n          \né€™ä¸€é¡Œä½¿ç”¨åˆ°å·®åˆ†çš„æŠ€å·§ï¼Œè®“åŸæœ¬çš„$O(kn^2)$æ¸›å°‘æˆ$O(kn)$ï¼Œç„¶å¾Œå°±å¯ä»¥éäº†ï¼\nå®šç¾©å®šç¾© $dp[i][j]$ ç‚ºç¬¬ i æ¬¡èµ°åˆ°æ¨“å±¤jçš„æ–¹æ³•æ•¸\nè½‰ç§»å¼é€™é¡Œå¦‚æœç”¨æ‹‰çš„æ¯”è¼ƒä¸å¥½æƒ³ï¼Œæ‰€ä»¥æ”¹ç”¨æ¨çš„è©¦è©¦çœ‹$dp[i+1][j] = dp[i+1][j]+dp[i][p],$ for $j\\in[p-r],[p+1,p+r],r = |p-b|-1$\né‚Šç•Œæ¢ä»¶$dp[0][a] = 1$\nè½‰ç§»å¼æ¯”è¼ƒè¤‡é›œä¸€é»ï¼Œä¸éå¯ä»¥ç”¨å·®åˆ†å„ªåŒ–æ­é…å‰ç¶´å’ŒæŠŠåŸæœ¬$O(n)$çš„æ™‚é–“é™åˆ°$O(1)$å¾é€™ä¸€é¡Œå¯ä»¥ç™¼ç¾åˆ°ï¼Œç”¨æ‹‰çš„å’Œç”¨æ¨çš„æœ‰ä¸åŒçš„ä½¿ç”¨æ™‚æ©Ÿï¼Œå¯ä»¥ä»¥æ€è€ƒæ–¹å¼æ¯”è¼ƒæ¸…æ¥šçš„æƒ³æ³•å»æƒ³è½‰ç§»å¼ã€‚\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define ios ios::sync_with_stdio(0)using namespace std;int n,a,b,k,dp[2][2005];int modify(int x)&#123;    return (x%mod+mod)%mod;&#125;void sec(int l,int r,int v,int id)&#123;     l = max(l,(long long)1);    r = min(r,n);    dp[(id+1)%2][l] = modify(dp[(id+1)%2][l]+v);    dp[(id+1)%2][r+1] = modify(dp[(id+1)%2][r+1]-v);&#125;signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;k;    memset(dp,0,sizeof(dp));    dp[0][a] = 1;    for(int s=0;s&lt;k;s++)&#123;  //æ¯ä¸€æ¬¡é›»æ¢¯ç§»å‹•        for(int i=1;i&lt;=n;i++)&#123; //æ¯ä¸€æ¨“å±¤è½‰ç§»            int d = abs(b-i)-1;            sec(i-d,i-1,dp[s%2][i],s);            sec(i+1,i+d,dp[s%2][i],s);        &#125;        for(int i=1;i&lt;=n;i++)&#123;            dp[(s+1)%2][i] += dp[(s+1)%2][i-1];            dp[(s+1)%2][i] = modify(dp[(s+1)%2][i]);        &#125;        for(int i=1;i&lt;=n;i++)dp[(s)%2][i] = 0;    &#125;    int ans = 0;    for(int i=1;i&lt;=n;i++)&#123;        ans+=dp[k%2][i];        ans = modify(ans);    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;//8æ¨“ã€2æ¨“é–‹å§‹ã€5æ¨“ä¸èƒ½å»ã€2æ¬¡é›»æ¢¯\nå–åå­—å¥½å›°é›£QQé¡Œç›®é€£çµè·Ÿé¡Œç›®ä¸€æ¨£ï¼Œæˆ‘è¦ºå¾—è¦é€šéˆæ‰èƒ½æƒ³åˆ°é€™ä¸€é¡Œçš„ä½œæ³•ï¼çµæœæ˜¯å•äº†åˆ¥äººæ‰å¤§æ¦‚æ„Ÿå—åˆ°é€™ä¸€ç¨®ä½œæ³•ï¼ï¼ï¼\næˆ‘å€‘æ—¢ç„¶ä¸çŸ¥é“åˆ°åº•ä¸€å€‹æ•¸å­—è¦ä¸è¦ä¹˜2ï¼Œæˆ‘å€‘å¯ä»¥é€éåšLISçš„éç¨‹ä¾†åšæ±ºå®šã€‚ç•¶æˆ‘å€‘æŠŠä¹˜èˆ‡2ä¹‹å¾Œçš„æ•¸å­—è·ŸåŸæœ¬æ•¸å­—ä¸€èµ·pushé€²å»ï¼Œå°±å¯ä»¥ç™¼ç¾åˆ°LISä¸å¯èƒ½åŒæ™‚å–åˆ°2å€‹æ•¸å­—ã€‚åˆ©ç”¨é€™å€‹æ–¹æ³•å°±å¯ä»¥ç”¨LISçš„éç¨‹æ±ºå®šä¸€å€‹æ•¸å­—åˆ°åº•æ‡‰è©²è¦è®Š2å€é‚„æ˜¯ä¸ç”¨ã€‚è¦æ‰¾åˆ°æœ€é•·çš„éåš´æ ¼éå¢åºåˆ—ï¼Œæœ€å¤§çš„å·®åˆ¥å°±æ˜¯è¦æŠŠåŸæœ¬çš„lower_boundæ”¹æˆupper_boundã€‚ä¸€æ•´å¤©æƒ³ä¸€é¡Œçš„æ„Ÿè¦ºè¶…ç´šç³Ÿç³•QQ\n#include &lt;bits/stdc++.h&gt;#define int long long#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,m;cin&gt;&gt;n&gt;&gt;m;    vector&lt;int&gt;vec;    FOR(i,n)&#123;        int temp;cin&gt;&gt;temp;        if(2*temp&lt;m)continue;        else if(temp&lt;m)&#123;            temp*=2;            vec.push_back(temp);        &#125;        else&#123;            vec.push_back(2*temp);            vec.push_back(temp);        &#125;    &#125;    if(vec.size()&lt;1)&#123;        cout&lt;&lt;0&lt;&lt;endl;        return;    &#125;        //æ­£å¸¸åšLIS    vector&lt;int&gt; lis;int len = vec.size();    lis.push_back(vec[0]);    for(int i=1;i&lt;len;i++)&#123;        if(lis.back()&lt;=vec[i])lis.push_back(vec[i]);        else *upper_bound(lis.begin(),lis.end(),vec[i]) = vec[i];    &#125;    cout&lt;&lt;lis.size()&lt;&lt;endl;&#125;signed main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\næ‰‹å¯«ä½œæ¥­é€™ä¸€é€±æ˜¯è¬›æ­¸ç´„æ³•ï¼Œä½œæ¥­å¦‚ä¸‹ï¼šé€™ä¸€é€±æ‰‹å¯«ä½œæ¥­çš„ç‹€æ³é‚„ä¸éŒ¯ï¼Œ71/75ï¼Œä¸éç¬¬ä¸€é¡Œæ˜¯ç·Šæ€¥å‘åˆ¥äººæ±‚æ•‘æ‰æŠŠç­”æ¡ˆæ”¹æ‰åŸæœ¬æ˜¯å¯«Bï¼Œå¾Œä¾†æ”¹Aï¼ŒåŸå› æœ‰ä»¥ä¸‹å…©é»ï¼š\n\nå› ç‚ºå‡½æ•¸åœ¨ return æ™‚ä¸æœƒæŠŠ stack memory ä¸Šçš„è³‡æ–™æ¸…ç©ºï¼Œæ‰€ä»¥æ‰€æœ‰çš„å€åŸŸè®Šæ•¸éƒ½æœƒè¢«ç•™åœ¨ stack memory ä¸Šï¼Œå…¶ä»–å‡½æ•¸å¯èƒ½æœƒå…±ç”¨åˆ°åŒä¸€å¡Šè¨˜æ†¶é«”ç©ºé–“ã€‚\næœ‰å¯èƒ½æœƒå°éæ³•çš„é™£åˆ—ä½å€å–å€¼(REçš„æƒ…æ³)ï¼Œè€Œå­˜å–åˆ°åˆ¥çš„å‡½æ•¸çš„å€åŸŸè®Šæ•¸ã€‚\n\næ‰€ä»¥Aæ˜¯éŒ¯èª¤çš„ï¼ä¸‹é¢æ˜¯è§£ç­”çš„ç•«æ³•ï¼Œå…¶å¯¦è·Ÿæˆ‘è »åƒçš„XDD\n","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["å‹•æ…‹è¦åŠƒ","DP","è³‡èŠ½ç­†è¨˜"]},{"title":"[é¡Œè§£]NEOJ 188 å††å††è³£æ¼¢å ¡","url":"/sprout9-1/","content":"å††å††è³£æ¼¢å ¡\né¡Œç›®é€£çµé¦–å…ˆåœ¨åšä»»ä½•å„ªåŒ–ä¹‹å‰ï¼Œéƒ½å¿…é ˆå…ˆåˆ—å‡ºå®šç¾©èˆ‡è½‰ç§»å¼ã€‚\nå®šç¾©å®šç¾©$dp[i]$ç‚ºåœ¨ç¬¬1åˆ°iå€‹é»é–‹åº—ï¼Œä¸”ç¬¬iå€‹é»æœ‰é–‹åº—æ™‚çš„æœ€å¤§ç›ˆåˆ©\nè½‰ç§»å¼$dp[i] = val[i]+max(dp[j]-c(i-j)),i-kâ‰¤jâ‰¤i-1$\né‚Šç•Œ$dp[i] = 0, 1â‰¤iâ‰¤n$\nåšå®Œä»¥ä¸Šçš„å®šç¾©èˆ‡è½‰ç§»å¼ä¹‹å¾Œï¼Œå¯ä»¥å¾—åˆ°è¤‡é›œåº¦ï¼š$O(NK)$å°±å¯ä»¥å¾—åˆ°ä»¥ä¸‹çš„çµæœï¼šè©¦è‘—åˆ©ç”¨å–®èª¿éšŠåˆ—å„ªåŒ–ï¼ŒæŠŠè¤‡é›œåº¦é™åˆ°$O(N)$åˆ©ç”¨å–®èª¿éšŠåˆ—å¯ä»¥ç¢ºä¿æ‰€æœ‰çš„æ•¸å­—éƒ½åªæœƒè¢«pushèˆ‡popä¸€æ¬¡ï¼Œå› æ­¤ç¸½è¤‡é›œåº¦ç‚º$O(n)$å·®ä¸€å€‹Kæ™‚é–“å°±å·®å¾ˆå¤šï¼\nå…·é«”çš„ä½œæ³•å¦‚ä¸‹ï¼Œå› ç‚ºæˆ‘å€‘è¦ç¶­è­·çš„å–®èª¿éšŠåˆ—çš„dpå¾Œé¢æœ‰ä¸€äº›æ±è¥¿ï¼Œå› æ­¤æˆ‘å€‘è¦åšä¸€äº›èª¿æ•´ï¼ŒæŠŠæœ‰içš„æå‡ºä¾†ï¼ˆä¸ç„¶ç•¶iä¸ä¸€æ¨£çš„æ™‚å€™å°±å¾ˆé›£è™•ç†ï¼‰\n\\begin{split}dp[i] &= val[i]+max(dp[j]-c(i-j)),i-kâ‰¤jâ‰¤i-1\\\\&=val[i]-ci+max(dp[j]+cj)\\end{split}é€™æ™‚å€™ä»¤ $t[j] = dp[j]+cj$ï¼Œå¯ä»¥æŠŠåŠ ä¸Š $cj$ æƒ³åƒæˆè·Ÿé ­çš„è·é›¢ï¼ˆè·Ÿç•¶å‰çš„ $-ci$ åˆåœ¨ä¸€èµ·å°±æ˜¯æˆ‘å€‘è¦çš„è·é›¢ï¼‰ï¼Œå‰‡ $max(t[j]),i-kâ‰¤jâ‰¤i-1$ å°±å¯ä»¥ä½¿ç”¨å–®èª¿éšŠåˆ—å„ªåŒ–ï¼\n\n            å–®èª¿éšŠåˆ—å„ªåŒ–å–®èª¿éšŠåˆ—å„ªåŒ–åç¨±çš„ç”±ä¾†æ˜¯å› ç‚ºç¶­è­·çš„å®¹å™¨å…·æœ‰å–®èª¿æ€§ï¼ˆåœ¨é€™è£¡ç”¨åˆ°çš„æ˜¯å–®èª¿éæ¸›ï¼‰ï¼Œé€™ä¸€æ¬¡å˜—è©¦çš„æ˜¯ç”¨deque","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 187 é«˜æ£•æ«šè§€å…‰è¾²å ´ï¼šæ—…è¡ŒéŠ·å”®å“¡å•é¡ŒTSP","url":"/sprout9-2/","content":"é«˜æ£•æ«šè§€å…‰è¾²å ´ï¼šæ—…è¡ŒéŠ·å”®å“¡å•é¡ŒTSP\né¡Œç›®é€£çµç¬¬ä¸€æ¬¡å¯«TSP(Traveling Salesman Problem)ï¼Œé¡Œç›®æ•˜è¿°å¦‚ä¸‹ï¼š\n\nçµ¦å®šä¸€ç³»åˆ—åŸå¸‚å’Œæ¯å°åŸå¸‚ä¹‹é–“çš„è·é›¢ï¼Œæ±‚è§£å­˜å–æ¯ä¸€åº§åŸå¸‚ä¸€æ¬¡ä¸¦å›åˆ°èµ·å§‹åŸå¸‚çš„æœ€çŸ­è¿´è·¯ã€‚\n\né€™æ˜¯ä¸€å€‹å·²ç¶“è¢«è­‰æ˜$NP-Hard$ çš„å•é¡Œï¼Œæš´åŠ›ä½œæ³•æ˜¯è¦æª¢æŸ¥æ‰€æœ‰è·¯å¾‘çš„æƒ…æ³ï¼Œå› ç‚ºå…±æœ‰nå€‹é»ï¼Œæ¯ä¸€å€‹é»åˆé€£æ¥n-1å€‹é»ï¼Œç¹¼çºŒä¸‹å»ç¸½å…±æœƒæœ‰N!ç¨®æƒ…æ³ï¼Œå› æ­¤è¤‡é›œåº¦ç‚º$O(n!)$ã€‚ç¸½å…±çš„é»æ•¸å…±æœ‰nå€‹ï¼Œæ ¹æ“šå¤šé‚Šå½¢çš„é‚Šæ•¸å…¬å¼å¯ä»¥çŸ¥é“ä¸€å…±æœ‰$\\frac{n^2-n}{2}$æ¢é‚Šï¼Œæ¯ä¸€æ¢é‚Šéƒ½æœ‰å„è‡ªçš„è·é›¢ã€‚å¦‚æœæ”¹ç”¨DPåšï¼Œæ™‚é–“è¤‡é›œåº¦å¯ä»¥å£“åˆ°æ™‚é–“è¤‡é›œåº¦$O(n^2\\cdot2^n)$ï¼Œæ¯”$O(n!)$é‚„å„ªç§€ï¼é€™ä¸€é¡Œç”¨åˆ°çš„æ˜¯DPå„ªåŒ–ä¸­çš„ç‹€æ…‹å£“ç¸®ï¼Œå…·é«”çš„å¯¦ä½œç´°ç¯€å¦‚ä¸‹ï¼š\n\n            ä½å…ƒé‹ç®—åœ¨é€™ä¸€é¡Œéœ€è¦ç”¨åˆ°ä½å…ƒé‹ç®—ï¼Œç”¨16å€‹bitè¡¨ç¤ºæ¯ä¸€å€‹é»æœ‰æ²’æœ‰è¢«èµ°è¨ªéã€‚ç”¨é€™æ¨£çš„è¡¨ç¤ºæ–¹æ³•å¯ä»¥è®“codeæ›´ç‚ºç¯€å„‰ï¼Œä¹Ÿå°±æ˜¯ç‹€æ…‹å£“ç¸®çš„æ¦‚å¿µã€‚å·¦ç§»é‹ç®—å­(&lt;&lt;)é€™ä¸€é¡Œæœƒä¸€ç›´åè¦†è¢«ç”¨åˆ°ï¼Œ1&lt;&lt;tä»£è¡¨æŠŠ1å¾€å·¦ç§»å‹•tå–®ä½ï¼Œç”¨10é€²ä½è¡¨ç¤ºå°±æ˜¯$2^t$ã€‚æ¯å¾€å·¦ç§»å‹•ä¸€æ ¼ï¼Œæ•¸å­—å°±æœƒè®ŠæˆåŸä¾†çš„å…©å€ï¼ç‹€æ…‹å£“ç¸®å°‡åé€²ä½æ•´æ•¸sä»¥äºŒé€²ä½è¡¨ç¤ºï¼Œæœƒå¾—åˆ°ä¸€ä¸²01å­—ä¸²ï¼Œå‡è¨­s=10ï¼Œå‰‡ $s = 1010_{(2)}$ã€‚ä»¥é€™é¡Œä¾†èªªï¼Œé€™æ¨£çš„å­—ä¸²æˆ‘å€‘å¯ä»¥ç”¨ä¾†è¡¨ç¤ºç¬¬4å’Œç¬¬2å€‹é»å·²ç¶“è¢«æ‹œè¨ªï¼Œè€Œç¬¬3è·Ÿç¬¬1å€‹é»é‚„æ²’æœ‰è¢«æ‹œè¨ªã€‚\n          \nå®šç¾©å®šç¾© $dp[n][s]$ è¡¨ç¤ºç›®å‰åœ¨ç¬¬né»ä¸Šï¼Œsç‚ºèµ°éçš„é»ï¼ˆç‹€æ…‹å£“ç¸®ï¼‰çš„æœ€çŸ­è·é›¢\nè½‰ç§»å¼$dp[n][s] = min(dp[i][s-(1&lt;&lt;n)]+dis[i][n])$, for all i such that s&amp;(1&lt;&lt;i)!=0\né€™å€‹è½‰ç§»å¼å¾ˆæœ‰æ„æ€ï¼Œå› ç‚ºsä»£è¡¨äº†æ¯ä¸€å€‹é»æ˜¯å¦æœ‰è¢«èµ°éï¼Œç•¶æˆ‘è¦æ›´æ–°dp[n][s]æ™‚ï¼Œæˆ‘è¦ç¢ºä¿æ­¤æ™‚çš„ç‹€æ…‹sä¸­çš„é»nå¿…é ˆç‚º1ã€‚åŒæ™‚ï¼Œå› ç‚º1&lt;&lt;iç”¨äºŒé€²ä½è¡¨ç¤ºåªæœ‰ç¬¬iä½æœƒæ˜¯1å…¶ä»–éƒ½æ˜¯0ï¼Œåšandé‹ç®—å°±çœ‹sçš„ç¬¬iä½æ±ºå®šçµæœã€‚\nå°æ–¼æ¯ä¸€å€‹iå¿…é ˆç¢ºä¿ç¬¬ié»åœ¨ç‹€æ…‹sä¸­æœ‰è¢«é€ è¨ªï¼Œå› æ­¤æœ‰äº†å¾Œé¢çš„æ¢ä»¶ã€‚å¦å¤–è½‰ç§»å¼ä¸­çš„s-(1&lt;&lt;N)æ˜¯æŠŠç¬¬nå€‹é»å¾æœªé€ è¨ªçš„ç‹€æ…‹è½‰ç§»ã€‚\né‚Šç•Œ$dp[0][1] = 0,\\quad dp[i][j]= \\infty$\nè·é›¢çš„é è¨­ç‹€æ…‹ç‚ºç„¡é™å¤§ï¼Œç¬¬ä¸€å€‹é»çš„åˆå§‹ç‹€æ…‹æ˜¯æœ€çŸ­è·é›¢0\nå¯¦ä½œå°ç´°ç¯€è¿´åœˆé †åºåœ¨è½‰ç§»çš„éç¨‹ä¸­ï¼Œè¿´åœˆçš„ç¬¬ä¸€å±¤å¿…é ˆæ˜¯ç‹€æ…‹ï¼Œç¬¬äºŒå±¤æ‰æ˜¯åŸå¸‚ã€‚å¦‚æœé¡›å€’éä¾†çš„è©±ï¼Œæœƒå°è‡´å‰é¢çš„åŸå¸‚åœ¨ç‹€æ…‹é‚„æ²’æœ‰è¢«æ›´æ–°çš„æ™‚å€™å°±å·²ç¶“å¤±å»äº†ä¹‹å¾Œè¢«æ›´æ–°çš„æ©Ÿæœƒï¼Œå› æ­¤åŸå¸‚çš„è¿´åœˆå¿…é ˆæ”¾åœ¨ç¬¬äºŒå±¤ï¼\næ±‚ç­”æ¡ˆå› ç‚ºæˆ‘å€‘è¦æ±‚çš„æ˜¯å›åˆ°åŸé»çš„æœ€çŸ­è·é›¢ï¼Œå› æ­¤åœ¨å…¨éƒ¨è½‰ç§»å®Œæˆä¹‹å¾Œï¼Œåˆ©ç”¨ä¸€å€‹è¿´åœˆæŠŠå›å»åŸé»çš„è·¯çš„è·é›¢åŠ ä¸Šå»ï¼Œæ±‚å¾—æœ€å°å€¼ã€‚\n#include &lt;bits/stdc++.h&gt;#define N 16#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,dis[20][20];cin&gt;&gt;n;    memset(dis,0,sizeof(dis));        for(int i=0;i&lt;n-1;i++)&#123;        for(int j=i+1;j&lt;n;j++)&#123;            cin&gt;&gt;dis[i][j];            dis[j][i] = dis[i][j];        &#125;    &#125;        int dp[N][66000],m = 1&lt;&lt;n;    memset(dp,0x3f3f3f3f,sizeof(dp));    dp[0][1] = 0;   //å°‡0é»åˆ°è‡ªå·±çš„è·é›¢è¨­ç‚º1        //O(n^2 2^n)    for(int i=0;i&lt;m;i++)&#123;            //iè¡¨ç¤º2^næ¯ä¸€ç¨®ç‹€æ…‹        for(int j=0;j&lt;n;j++)&#123;        //jè¡¨ç¤ºåŸå¸‚            if(!(i&amp;(1&lt;&lt;j)))continue; //jåŸå¸‚è¦æ˜¯è¢«é€ è¨ªéçš„ç‹€æ…‹            for(int k=0;k&lt;n;k++)&#123;    //å¯ä»¥åˆ°çš„æ‰€æœ‰é»ä¸­çš„ç‹€æ…‹                if(i &amp; 1&lt;&lt;k)&#123;        //ç¢ºä¿è½‰ç§»éå»çš„æœ‰è¢«é€ è¨ªé                    dp[j][i] = min(dp[j][i],dp[k][i-(1&lt;&lt;j)]+dis[j][k]);                &#125;            &#125;        &#125;    &#125;    int ans = INT_MAX;    for(int i=0;i&lt;n;i++)ans = min(ans,dp[i][m-1]+dis[i][0]);    cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 159 ç¡¬å¹£å•é¡Œ","url":"/sprout9-4/","content":"ç¡¬å¹£å•é¡Œ\né¡Œç›®é€£çµ\næœ‰é»è¨ç•°ï¼ŒåŸæœ¬æƒ³èªªæŠŠcodeä¸Ÿä¸Šå»æ¸¬ä¸€ä¸‹ï¼Œçœ‹çœ‹èƒ½éå‰é¢å¹¾ç­†æ¸¬è³‡ï¼Œçµæœå»ç›´æ¥å…¨éƒ¨éäº†ï¼æˆ‘ä¹Ÿæ²’æœ‰åšä»€éº¼ç‰¹åˆ¥çš„DPå„ªåŒ–ï¼Œä¸Ÿä¸Šå»å»ç›´æ¥Acceptäº†ï¼é€™é¡Œè·ŸåŸæœ¬çš„ç¡¬å¹£å•é¡Œæœ‰äº›è¨±çš„ä¸åŒï¼Œåœ¨æ–¼ä»–æœ‰é™åˆ¶æ¯ä¸€ç¨®ç¡¬å¹£çš„æ•¸é‡ï¼Œé¢é¡ç‚º $C_i$ çš„ç¡¬å¹£å…±æœ‰ $K_i$ å€‹ï¼Œä¹Ÿå°±æ˜¯è¦å•ä½ èƒ½å¦ç”¨é€™äº›å›ºå®šæ•¸é‡çš„ç¡¬å¹£æ¹Šå‡ºç‰¹å®šçš„é¢é¡ã€‚\næˆ‘å€‘å¯ä»¥è¨è«–ä¸åŒçš„é¢é¡çš„é¤˜æ•¸ï¼Œæ™‚é–“è¤‡é›œåº¦åˆ†æä¼°è¨ˆç´„ç‚ºï¼š$O(N\\times C_i\\times \\frac{M}{C_i})=O(NM)$ï¼Œç…§ç†ä¾†èªªå› ç‚ºè¦åŸ·è¡Œtæ¬¡ï¼Œç®—ä¸‹ä¾†æœ‰å¯èƒ½æœƒTLEï¼Œä¸éé€™ä¸€é¡Œæ²’æœ‰å¡å°±æ˜¯äº†ã€‚\n#include &lt;bits/stdc++.h&gt;#define N 105#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)#define ios ios::sync_with_stdio(0)using namespace std;int t;void solve()&#123;    int n,m,val[N],num[N];cin&gt;&gt;n&gt;&gt;m;    for(int i=0;i&lt;n;i++)cin&gt;&gt;val[i]&gt;&gt;num[i];        bool dp[20005];    memset(dp,0,sizeof(dp));    dp[0] = 1;        for(int i=0;i&lt;n;i++)&#123;        for(int k=0;k&lt;val[i];k++)&#123;            int left = num[i];            for(int j=k+val[i];j&lt;=m;j+=val[i])&#123;                if(dp[j]!=0)left = num[i];                else if(left&gt;0 &amp;&amp; dp[j-val[i]])&#123;                    left--;                    dp[j] = 1;                &#125;            &#125;        &#125;    &#125;    if(dp[m]==1)cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl;    else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125;int main()&#123;    ios;    cin&gt;&gt;t;    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 255 æ†¤æ€’çš„å°é³¥","url":"/sprout9-3/","content":"æ†¤æ€’çš„å°é³¥\né¡Œç›®é€£çµSubmissionç©æ†¤æ€’é³¥éŠæˆ²çš„æ¦‚å¿µï¼Œçµ¦å®šäºŒç¶­å¹³é¢ä¸Šnå€‹é»ä»£è¡¨nå€‹è±¬ï¼ˆçš†åœ¨ç¬¬ä¸€è±¡é™ï¼‰ï¼Œé€™æ™‚å€™å¯ä»¥å¾åŸé»(0,0)çš„ä½ç½®ç™¼å°„è»Œè·¡ç‚ºæ‹‹ç‰©ç·šçš„å°é³¥ï¼Œæ‰“åˆ°è±¬è±¬å¾Œä¸¦ä¸æœƒæ”¹è®Šé£›è¡Œçš„è»Œè·¡ï¼Œé¡Œç›®æƒ³è¦å•æœ€å°‘è¦ç™¼å°„å¹¾å€‹å°é³¥æ‰èƒ½å°„ä¸‹æ‰€æœ‰çš„è±¬è±¬ï¼Ÿ\n\nç¯„ä¾‹æ¸¬è³‡71 32 43 32 64 81 11 2\n\nå¦‚æœç•«åœ¨åœ–ä¸Šå°±é•·é€™æ¨£ï¼š\nå¦‚æœæŠŠæ‹‹ç‰©ç·šç•«å‡ºä¾†å°±åƒé€™æ¨£ï¼š\nå› ç‚º$n\\le24$ï¼Œæ‰€ä»¥å¯ä»¥çŸ¥é“é€™ä¸€é¡Œå¯èƒ½åªèƒ½æŠŠæ‰€æœ‰æƒ…æ³éƒ½æƒä¸€éï¼ˆæ‰ä¸æ˜¯å› ç‚ºå‰›å¥½è¬›ç‹€æ…‹å£“ç¸®XDï¼‰\nä½œæ³•1ï¼š æ™‚é–“è¤‡é›œåº¦$O(n^2\\cdot 2^n)$æˆ‘å€‘å¯ä»¥åˆ©ç”¨ä¸€å€‹äºŒç¶­é™£åˆ—g[i][j]è¡¨ç¤ºç¶“éiè±¬å’Œjè±¬èˆ‡åŸé»æ‰€å½¢æˆçš„æ‹‹ç‰©ç·šæ‰€èƒ½ç¶“éçš„æ‰€æœ‰é»çš„ç‹€æ…‹ã€‚é€™æ¨£æˆ‘å€‘å¯ä»¥åˆ©ç”¨$O(n^3)$çš„æ™‚é–“å®Œæˆé è™•ç†ï¼ŒçŸ¥é“ä¸€æ¢ç”±iè±¬å’Œjè±¬å½¢æˆçš„æ‹‹ç‰©ç·šèƒ½ç¶“éçš„é»çš„ç‹€æ…‹ï¼ˆç”¨äºŒé€²ä½è¡¨ç¤ºï¼‰ï¼Œåœ¨dpè½‰ç§»çš„æ™‚å€™å‰‡éœ€æšèˆ‰æ‰€æœ‰çš„iå’Œjï¼Œæ‰€éœ€æ™‚é–“æ˜¯$n^2$ã€‚è½‰ç§»å¼çš„è©±ä¸€é–‹å§‹æ˜¯å¯«ç”¨æ¨çš„ï¼š$dp[s|g[i][j]] = min(dp[s]+1)$ï¼Œæ¯”è¼ƒç›´è¦ºä¸€é»ã€‚\nä½œæ³•2ï¼š æ™‚é–“è¤‡é›œåº¦$O(n\\cdot 2^n)$ç•¶æˆ‘å€‘åœ¨åšç‹€æ…‹sçš„æ™‚å€™ï¼Œå¦‚æœæ˜¯ä¸Šé¢çš„æ–¹æ³•å°±æ˜¯$n^2$æƒéæ‰€æœ‰çš„é»çš„çµ„åˆï¼Œå…¶å¯¦æˆ‘å€‘å¯ä»¥åªè¦æ‰¾åˆ°så…¶ä¸­ä¸€ä½ç¬¬kä½æ˜¯1çš„ï¼Œå› ç‚ºé‚£ä¸€ä½æ‰€å°æ‡‰åˆ°çš„è±¬è±¬ä¸€å®šæœƒç¶“éï¼Œæ‰€ä»¥å°±å¯ä»¥é‡å°é‚£ä¸€ä½åšè½‰ç§»ï¼Œå¦‚æ­¤ä¸€ä¾†è·ŸkåŒåœ¨ä¸€å€‹æ‹‹ç‰©ç·šçš„æœ€å¤šåªæœƒæœ‰nå€‹ï¼Œè¤‡é›œåº¦å°±é™åˆ°äº†$O(n\\cdot 2^n)$ã€‚é€™è£¡å¯ä»¥æ­é…ä¸€å€‹vectorline[N]è£æ¯ä¸€ä½æœ‰ç¶“éçš„å¯èƒ½çš„ç‹€æ…‹ã€‚\nå®šç¾©$dp[s]$ç‚ºç‹€æ…‹ç‚ºsçš„æ™‚å€™çš„æœ€å°æ‹‹ç‰©ç·šæ•¸é‡\nè½‰ç§»å¼$dp[s]=min(dp[s\\&amp;(\\sim mask)]+1)$\né€™å€‹è½‰ç§»å¼æŒºæœ‰è¶£çš„ï¼Œæˆ‘å€‘çŸ¥é“å¦‚æœè¦å¾ç‹€æ…‹på¾—åˆ°ç‹€æ…‹sï¼Œå°æ–¼sæ˜¯0çš„bitï¼Œpä¹Ÿæ‡‰è©²æ˜¯0ï¼›å°æ–¼sæ˜¯1çš„bitï¼Œè‹¥maskæ˜¯1ï¼Œå‰‡pçš„bitè¦æ˜¯0ï¼Œåä¹‹å‰‡æ˜¯1ã€‚\nst=&gt;start: for each bit p in ssub1=&gt;subroutine: My Subroutinecond=&gt;condition: if p=1e=&gt;operation: set dp[i] to 0io=&gt;condition: if mask[i]=1ss=&gt;operation: set dp[i] to 1sp1=&gt;operation: set dp[i] to 0sp2=&gt;operation: set dp[i] to 1st-&gt;cond-&gt;iocond(yes)-&gt;io-&gt;econd(no)-&gt;eio(yes)-&gt;sp1io(no)-&gt;sp2\né€™å€‹è½‰ç§»å¼å¯ä»¥æœ‰å¦å¤–ä¸€å€‹è¡¨ç¤ºçš„æ–¹å¼ï¼Œå¯ä»¥é”åˆ°åŒæ¨£çš„æ•ˆæœï¼š$dp[s]=min(dp[s\\&amp;(i\\oplus mask)]+1)$\né‚Šç•Œ$for\\ each\\ dp[i]=0$\nä»¥ä¸‹ç¨‹å¼ç¢¼æ˜¯ä»¥$O(n^3)$çš„é è™•ç†ï¼Œ$O(n\\cdot 2^n)$çš„è½‰ç§»ï¼Œå› æ­¤ç¸½æ™‚é–“è¤‡é›œåº¦æ˜¯$O(2^n)$ï¼Œåœ¨æ™‚é™å…§æ˜¯å¯ä»¥éçš„ï¼\n\n[time=Thu, Sep 16, 2021 3:03 PM]æ›´æ–°\n\nçµæœå‘¢ï¼Œæœ‰äººå•äº†æˆ‘é€™ä¸€é¡Œï¼Œæˆ‘å›å»çœ‹æˆ‘çš„codeï¼Œçµæœç™¼ç¾æ˜æ˜æ‡‰è©²æ˜¯ $O(n\\cdot 2^n)$ è½‰ç§»ï¼Œä½†æ¯ä¸€å€‹line_maskä¸­åœ¨worst caseå»æœ‰ $n^2$ å€‹ç‹€æ…‹ï¼Œé€™æ¨£å­ä¸‹ä¾†ä¸€æ¨£é‚„æ˜¯ $O(n^2\\cdot 2^n)$ æ²’æœ‰é€²æ­¥ã€‚ç™¼ç¾å•é¡Œåœ¨æ–¼ï¼Œç•¶å…¨éƒ¨çš„é»éƒ½åœ¨åŒä¸€æ¢æ‹‹ç‰©ç·šä¸Šçš„æ™‚å€™ï¼Œæœƒæœ‰é‡è¤‡çš„ç‹€æ…‹è¢«pushå¾ˆå¤šæ¬¡çš„å•é¡Œï¼Œæ‰€ä»¥åªè¦ç”¨visitå»ç´€éŒ„é€™ç¨®ç‹€æ…‹æ˜¯å¦å‡ºç¾éï¼Œè®“æœ€å¤šè¢«æ¨å…¥ä¸€æ¬¡å°±å¥½!\n\n#include &lt;bits/stdc++.h&gt;#define long long ll#define N 24#define mod 1000000007#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int t,n,x[N],y[N];void solve()&#123;    vector&lt;int&gt;line_mask[N];    scanf(&quot;%d&quot;,&amp;n);    for(int i = 0;i &lt; n;i++)scanf(&quot;%d %d&quot;,&amp;x[i],&amp;y[i]);    int m = 1&lt;&lt;n,dp[m];    bool visit[m];memset(visit,0,sizeof(visit));    //calculate all lines O(n^3)    for(int i=0;i&lt;n;i++)&#123;        line_mask[i].push_back(1&lt;&lt;i);       //æœ‰å¯èƒ½æ­¤é»å­¤ç«‹ä¸€äººï¼Œè¦ç¢ºä¿ä¹Ÿåœ¨è£¡é¢        for(int j=i+1;j&lt;n;j++)&#123;            int x1 = x[i],y1 = y[i];            int x2 = x[j],y2 = y[j];            if(x1==x2)continue;            double a = (double)((x1*y2)-(x2*y1))/(x1*x2*(x2-x1));            double b = (double)(y1-a*x1*x1)/x1;            if(a &gt;= 0)continue;            int mask1 = 1&lt;&lt;i|1&lt;&lt;j;            for(int k = 0;k &lt; n;k++)&#123;                if(fabs((double)a*x[k]*x[k]+b*x[k]-y[k])&lt;=1e-6)mask1|=(1&lt;&lt;k);            &#125;            if(visit[mask1])continue;            for(int k = 0;k &lt; n;k++)&#123;                if((mask1&gt;&gt;k) &amp; 1)line_mask[k].push_back(mask1);            &#125;            visit[mask1] = 1;            //éké»çš„æ‰€æœ‰ç¶“éçš„é»çš„ç‹€æ…‹        &#125;    &#125;    memset(dp,0x3f3f3f,sizeof(dp));    dp[0] = 0;    //O(n 2^nè½‰ç§»)    for(int s = 1;s &lt; m;s++)&#123;        int cur = __lg(s),len = line_mask[cur].size();        for(int i = 0;i &lt; len;i++)&#123;            int mk = line_mask[cur][i];            dp[s] = min(dp[s], dp[(s&amp;(~mk))] + 1);            if(dp[s] == 1)break;        &#125;    &#125;    printf(&quot;%d\\n&quot;,dp[m-1]);&#125;int main()&#123;    scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        solve();    &#125;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"[é¡Œè§£]NEOJ 185 çƒé¾œç–Šç–Šæ¨‚---æ˜“","url":"/sprout9-5/","content":"çƒé¾œç–Šç–Šæ¨‚â€”-æ˜“\né¡Œç›®é€£çµé€™é¡Œç°¡å–®ä¾†èªªï¼Œæ˜¯çµ¦å®šä¸€å€‹æ•¸åˆ—ï¼Œè¦å˜—è©¦åˆ†é…æˆå¥½å¹¾å †ï¼Œæ¯ä¸€å †çš„æ•¸é‡ä¸è¶…ékå€‹ã€‚å…¶ä¸­ç¬¬iå †çš„ç¸½å’Œä¹˜ä¸Š(i-1)ï¼Œç®—å‡ºä¾†çš„ç¸½å’Œè¦æœ€å°ã€‚ç”±é¡Œç›®æ•˜è¿°å¯ä»¥çŸ¥é“ï¼Œæ¯ä¸€å †åˆ°å¾Œé¢ä¹˜ä¸Šçš„æ•¸å­—æ˜¯è¶Šä¾†è¶Šå¤§ï¼Œä¹Ÿå°±æ˜¯è¢«åŠ ä¸Šçš„æ¬¡æ•¸æœƒè¶Šä¾†è¶Šå¤šï¼Œå¦‚æœæˆ‘å€‘å°‡æ•¸åˆ—å€’éä¾†dpæœƒæ¯”æ­£é¢åšä¾†å¾—å®¹æ˜“ç¶­è­·ã€‚\n\n            è½‰ç§»å¼dp[i] = max(dp[j]+pref[j]),for i-kâ‰¤jâ‰¤i-1ï¼Œprefæ˜¯ç¶­è­·å·²ç¶“ååºéå¾Œçš„æ•¸åˆ—ä¹‹å‰ç¶´å’Œã€‚ä»¥ç¯„æ¸¬ç‚ºä¾‹ï¼Œç•¶k=2æ™‚ï¼Œdp[i]å¯ä»¥é¸æ“‡çš„å°±æ˜¯å¾dp[i-1]è·Ÿdp[i-2]è½‰ç§»ï¼Œå¦‚æœé¸æ“‡dp[i-2]å°±è¡¨ç¤ºç¬¬ié …æœƒå’Œç¬¬i-1é …åˆä½µæˆä¸€å †ï¼ŒåŠ ä¸Špref[i-2]ä¹Ÿå°±æ˜¯æŠŠå‰é¢çš„æ¯ä¸€å †çš„æ•¸é‡ä¹˜ä¸Šçš„æ•¸å­—éƒ½åŠ ä¸€ï¼Œä¹Ÿå°±æ˜¯åŠ ä¸Šä¸€å€‹å‰ç¶´å’Œï¼ˆç”±æ–¼æ¯ä¸€å€‹æ•¸å­—åªæœƒè¢«åˆä½µä¸€æ¬¡ï¼‰å°è­‰æ˜ï¼šæ¯ä¸€å€‹æ•¸å­—åªæœƒè¢«åˆä½µä¸€æ¬¡åœ¨è½‰ç§»çš„éç¨‹ä¸­ï¼Œæœ‰æ²’æœ‰å¯èƒ½æœƒç™¼ç”Ÿdp[i]è¦è½‰ç§»çš„å°è±¡æ˜¯dp[i-2]ï¼Œä½†dp[i-1]å»å·²ç¶“è¢«èåˆéäº†ï¼Œé€ æˆä¸‰å€‹çƒé¾œèåˆåœ¨ä¸€èµ·çš„æƒ…æ³ï¼Ÿä¹Ÿå°±æ˜¯ä¸‹åœ–é€™ä¸€ç¨®æƒ…æ³ï¼Œdp[i-1]ã€dp[i-2]åˆä½µï¼Œdp[i]ã€dp[i-1]åˆä½µï¼Œè®Šæˆä¸‰å€‹èåˆè¶…ékçš„æƒ…æ³ï¼ˆdp[i-2],dp[i-1],dp[i]åˆä½µï¼‰ã€‚ç­”æ¡ˆï¼šä¸æœƒé¦–å…ˆå…ˆå¾dp[i-3]è½‰ç§»çš„dp[i-1]è¡¨ç¤ºç¬¬i-2è·Ÿi-1æ˜¯åˆä½µæˆä¸€å †ï¼Œæ¥ä¸‹ä¾†çš„dp[i]å¾dp[i-2]è½‰ç§»ï¼ŒåŠ ä¸Šäº†pref[i-2]ï¼Œä¹Ÿå°±æ˜¯æŠŠi-2ç¨ç«‹å‡ºå»ï¼Œiè·Ÿi-1åˆä½µæˆä¸€å †ï¼Œå› æ­¤ä¸æœƒæœ‰å¤§æ–¼kå€‹çƒé¾œåˆä½µåœ¨ä¸€èµ·çš„æƒ…æ³ã€‚\n          \né€™ä¸€é¡Œçš„è½‰ç§»å¼ä¸å¥½æƒ³ï¼Œè¦æŠŠæ±è¥¿ååºä¹‹å¾Œæ¯”è¼ƒå¥½dpï¼Œè½‰ç§»å¼ä¹Ÿæ¯”è¼ƒå¥½å¯«å‡ºä¾†ï¼è§€å¯Ÿåˆ°è¶Šå¾Œé¢çš„æ•¸å­—è¢«é‡è¤‡åŠ çš„æ©Ÿæœƒæ¯”è¼ƒå¤§ï¼ˆé«˜åº¦è¶Šé«˜ï¼‰ï¼Œå› æ­¤å°‡æ•¸åˆ—çš„é †çºŒé¡›å€’æ­é…å‰ç¶´å’Œå°±èƒ½æ¯”è¼ƒæ–¹ä¾¿çš„è½‰ç§»ï¼\nå®šç¾©$dp[i]$å®šç¾©ç‚ºä½¿ç”¨1åˆ°iå€‹çƒé¾œï¼Œé•å’Œåº¦çš„æœ€å¤§å€¼\nè½‰ç§»å¼$dp[i] = max(dp[j]+pref[j]),for\\ i-kâ‰¤jâ‰¤i-1$é€™å€‹è½‰ç§»å¼æ˜¯å»ºç«‹åœ¨é †åºé¡›å€’çš„æƒ…æ³ï¼Œåœ¨è¼¸å…¥çš„æ™‚å€™é †ä¾¿æŠŠé€†åºã€‚\né‚Šç•Œ$for\\ each\\ dp[i] = 0$\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 500005#define ios ios::sync_with_stdio(0)#define FOR(i,n) for(int i=0;i&lt;n;i++)using namespace std;int n,k,arr[N],pref[N];signed main()&#123;    ios;    cin&gt;&gt;n&gt;&gt;k;    for(int i=n;i&gt;0;i--)cin&gt;&gt;arr[i];    for(int i=1;i&lt;=n;i++)pref[i] = pref[i-1]+arr[i];        int dp[N];    memset(dp,0,sizeof(dp));        deque&lt;pair&lt;int,int&gt;&gt; deq;    deq.push_back(make_pair(0,0));        for(int i=1;i&lt;=n;i++)&#123;        while(!deq.empty() &amp;&amp; deq.front().second&lt;i-k)deq.pop_front();        dp[i] = deq.front().first;        while(!deq.empty() &amp;&amp; deq.back().first &lt;= dp[i]+pref[i])deq.pop_back();        deq.push_back(make_pair(dp[i]+pref[i],i));    &#125;    cout&lt;&lt;dp[n]&lt;&lt;endl;&#125;\n","categories":["è³‡èŠ½é¡Œè§£"],"tags":["é¡Œè§£","è³‡è¨Šä¹‹èŠ½"]},{"title":"è³‡èŠ½ç¬¬ä¹é€±ï¼šå‹•æ…‹è¦åŠƒï¼ˆä¸‰ï¼‰","url":"/sprout9/","content":"ä¸Šèª²å…§å®¹é¦–å…ˆæ˜¯å½±ç‰‡çš„é‡é»æ•´ç†ï¼Œä¸»é¡Œæ˜¯DPå„ªåŒ–ï¼š\nDPå„ªåŒ–\n\nçŸ©é™£å¿«é€Ÿå†ªå„ªåŒ–\nè²»æ°æ•¸åˆ—ï¼šO(n)-&gt;O(logN)\nDC\næŠŠå¾ˆå¤§çš„nåšçŸ©é™£å¿«é€Ÿå†ªé™åˆ°logN\n\n\nç‹€æ…‹å£“ç¸®\n\nTSPæ—…è¡ŒéŠ·å”®å“¡å•é¡Œ\næ¬Šé‡æœ€å°çš„æ¼¢ç±³é “è¿´è·¯\næš´åŠ›åšï¼šnå€‹é»ã€n-1é»ã€â€¦ã€1å€‹é»\næš´åŠ›è¤‡é›œåº¦ï¼šO(N!)\nä½¿ç”¨ä½å…ƒç´€éŒ„\nDP[n][s]ç”¨sçš„äºŒé€²ä½ç¬¬iä½è¡¨ç¤ºæ˜¯å¦å»éè©²åŸå¸‚\nè¤‡é›œåº¦ï¼šè½‰ç§»$O(N)\\times O(N\\times 2^N)=O(n^2\\times 2^n)$\n\n\nè³‡æ–™çµæ§‹å„ªåŒ–ï¼ˆå–®èª¿éšŠåˆ—å„ªåŒ–ï¼‰\n\né–‹ä¸€å€‹æ–°çš„dpMAXï¼ŒO(n^2)-&gt;O(n)\nä¸å¤§æ–¼Kï¼Œç”¨heapä¾†O(nlogn)ç¶­è­·éå¢çš„å›ºå®šå€é–“æœ€å¤§å€¼\næ–¹æ³•ä¸‰ï¼šç”¨Dequeå¯¦ä½œï¼ŒO(n)\nIdp[j] å…·æœ‰å–®èª¿æ€§ï¼ˆå–®èª¿éæ¸›ï¼‰\n\n\nå††å††é–‹åº—\n\ndp[n] = val[n]+max(dp[i]-c(n-i)),n-kâ‰¤iâ‰¤n-1\nO(NK)-&gt;O(N)ä½¿ç”¨å–®èª¿éšŠåˆ—å„ªåŒ–\nä»¤t[I] = dp[i]+c*i\n\n\næœ‰é™èƒŒåŒ…å•é¡Œå„ªåŒ–\n\nåˆ†æ¨æ¹Šå‡ºæ¯ä¸€ç¨®é‡é‡\nå¦‚ä½•åˆ†æ¨ï¼šäºŒé€²ä½ ${1,2,4,8,â€¦,2^p,q}$ï¼Œä½¿ $2^{p+1}-1$ ä¸å¤§æ–¼k[i]çš„æœ€å¤§æ•´æ•¸\nåŸO(NWK) -&gt; O(NW*logK)\nåˆ©ç”¨å–®èª¿éšŠåˆ—å„ªåŒ–ï¼šO(NW)!!!\n\n\n\nä¸Šæ©Ÿä½œæ¥­å††å††è³£æ¼¢å ¡é¡Œç›®é€£çµé¦–å…ˆåœ¨åšä»»ä½•å„ªåŒ–ä¹‹å‰ï¼Œéƒ½å¿…é ˆå…ˆåˆ—å‡ºå®šç¾©èˆ‡è½‰ç§»å¼ã€‚\nå®šç¾©å®šç¾©$dp[i]$ç‚ºåœ¨ç¬¬1åˆ°iå€‹é»é–‹åº—ï¼Œä¸”ç¬¬iå€‹é»æœ‰é–‹åº—æ™‚çš„æœ€å¤§ç›ˆåˆ©\nè½‰ç§»å¼$dp[i] = val[i]+max(dp[j]-c(i-j)),i-kâ‰¤jâ‰¤i-1$\né‚Šç•Œ$dp[i] = 0, 1â‰¤iâ‰¤n$\nåšå®Œä»¥ä¸Šçš„å®šç¾©èˆ‡è½‰ç§»å¼ä¹‹å¾Œï¼Œå¯ä»¥å¾—åˆ°è¤‡é›œåº¦ï¼š$O(NK)$å°±å¯ä»¥å¾—åˆ°ä»¥ä¸‹çš„çµæœï¼šè©¦è‘—åˆ©ç”¨å–®èª¿éšŠåˆ—å„ªåŒ–ï¼ŒæŠŠè¤‡é›œåº¦é™åˆ°$O(N)$åˆ©ç”¨å–®èª¿éšŠåˆ—å¯ä»¥ç¢ºä¿æ‰€æœ‰çš„æ•¸å­—éƒ½åªæœƒè¢«pushèˆ‡popä¸€æ¬¡ï¼Œå› æ­¤ç¸½è¤‡é›œåº¦ç‚º$O(n)$å·®ä¸€å€‹Kæ™‚é–“å°±å·®å¾ˆå¤šï¼\nå…·é«”çš„ä½œæ³•å¦‚ä¸‹ï¼Œå› ç‚ºæˆ‘å€‘è¦ç¶­è­·çš„å–®èª¿éšŠåˆ—çš„dpå¾Œé¢æœ‰ä¸€äº›æ±è¥¿ï¼Œå› æ­¤æˆ‘å€‘è¦åšä¸€äº›èª¿æ•´ï¼ŒæŠŠæœ‰içš„æå‡ºä¾†ï¼ˆä¸ç„¶ç•¶iä¸ä¸€æ¨£çš„æ™‚å€™å°±å¾ˆé›£è™•ç†ï¼‰\n\\begin{split}dp[i] &= val[i]+max(dp[j]-c(i-j)),i-kâ‰¤jâ‰¤i-1\\\\&=val[i]-ci+max(dp[j]+cj)\\end{split}é€™æ™‚å€™ä»¤ $t[j] = dp[j]+cj$ï¼Œå¯ä»¥æŠŠåŠ ä¸Š $cj$ æƒ³åƒæˆè·Ÿé ­çš„è·é›¢ï¼ˆè·Ÿç•¶å‰çš„ $-ci$ åˆåœ¨ä¸€èµ·å°±æ˜¯æˆ‘å€‘è¦çš„è·é›¢ï¼‰ï¼Œå‰‡ $max(t[j]),i-kâ‰¤jâ‰¤i-1$ å°±å¯ä»¥ä½¿ç”¨å–®èª¿éšŠåˆ—å„ªåŒ–ï¼\n\n            å–®èª¿éšŠåˆ—å„ªåŒ–å–®èª¿éšŠåˆ—å„ªåŒ–åç¨±çš„ç”±ä¾†æ˜¯å› ç‚ºç¶­è­·çš„å®¹å™¨å…·æœ‰å–®èª¿æ€§ï¼ˆåœ¨é€™è£¡ç”¨åˆ°çš„æ˜¯å–®èª¿éæ¸›ï¼‰ï¼Œé€™ä¸€æ¬¡å˜—è©¦çš„æ˜¯ç”¨deque","categories":["è³‡è¨Šä¹‹èŠ½ç­†è¨˜"],"tags":["å‹•æ…‹è¦åŠƒ","DP","è³‡èŠ½ç­†è¨˜"]},{"title":"å­—ä¸²æ¼”ç®—æ³• (String)","url":"/string1/","content":"é€™å€‹æš‘å‡çœ‹äº†å‹•æ…‹è¦åŠƒ(1),(2)ï¼Œç·šæ®µæ¨¹ã€æœ€çŸ­è·¯å¾‘ã€è¨ˆç®—å¹¾ä½•ã€å­—ä¸²æ¼”ç®—æ³•ï¼Œé€™ä¸€ç¯‡çš„å®Œæˆç®—æ˜¯æš‘å‡çš„ä¸€å€‹é‡Œç¨‹å§ï¼æ¥ä¸‹ä¾†ç¹¼çºŒå­¸ç¿’ä¸åŒçš„ä¸»é¡Œï¼Œå†æŠŠç­†è¨˜æ›´æ–°åˆ°éƒ¨è½æ ¼ä¸­ï¼\nèª²ç¨‹å…§å®¹å­—ä¸²\nå®šç¾©\nå¤§å¯« $\\Sigma$ è¡¨ç¤ºå­—å…ƒé›†\nå­—ä¸²ï¼šæœ‰é™å€‹å­—å…ƒé›†çµ„æˆ\n$|\\Sigma|$ å­—å…ƒé›†å¤§å°ã€|S|å­—ä¸²é•·åº¦\nS[a:b]è¡¨ç¤ºé€£çºŒå¾å­—å…ƒaåˆ°b\n\n\nå­å­—ä¸²ï¼šS[a:b]\nå‰ç¶´ï¼šS[0:b]\nå¾Œç¶´ï¼šS[a:|S|-1]\n\nå­—å…¸æ¨¹Trie\nå®šç¾©\nä¾‹é¡Œï¼šå­—ä¸²å‡ºç¾æ¬¡æ•¸\nä¸€é¡†ç”±æ ¹ã€é‚Šä¸€ç¶ å¾€ä¸‹æŒ‡çš„æœ‰å‘æ¨¹\næ¯å€‹é‚Šç‚ºå­—å…ƒã€æ¯ä¸€é»ä»£è¡¨å­—ä¸²\næ¯ç¶“éä¸€æ¢é‚Šï¼Œå­—ä¸²åŠ ä¸Šé‚Šçš„å­—å…ƒ\næ ¹ç¯€é»ç‚ºç©ºå­—ä¸²ï¼\n\n\næ“ä½œ\næŸ¥è©¢å­—ä¸²ï¼š$O(L)$ï¼Œç”±æ ¹é †è‘—é‚Šå¾€ä¸‹æ‰¾\næ’å…¥å­—ä¸²ï¼š$O(L)$ï¼Œä¸æ–·å¾€ä¸‹èµ°ç›´åˆ°ç©ºç¯€é»ï¼Œåœ¨TrieåŠ å…¥ä¸€å€‹ç¯€é»\nç¯€é»å¿…é ˆè¨˜éŒ„ç•¶å‰æ˜¯å¦ç‚ºæœ‰æ•ˆå­—ä¸²\nTrieçµæ§‹ä¸­åŒ…å«ï¼šå­—ä¸²ã€ç´€éŒ„å­—ä¸²å‡ºç¾æ¬¡æ•¸\n\n\n\nKMP\nåŠŸèƒ½ï¼šé€²è¡Œå­—ä¸²åŒ¹é…\nä¾‹é¡Œï¼šå­—ä¸²Såœ¨å­—ä¸²Tå“ªäº›ä½ç½®å‡ºç¾\næš´åŠ›åŒ¹é…ï¼šæ™‚é–“ $O(|S|\\times|T|)$\n\n\nF[i]è¡¨ç¤ºç•¶é…å°æˆåŠŸA[0:i]å¾Œå³é…å°å¤±æ•—ï¼Œå°‡A[F[i]]å°é½ŠåŸæœ¬A[i]çš„ä½ç½®\næ­é…F[i]èª¿æ•´åœ¨ä¸²ç§»å‹•çš„é•·åº¦\nåŒ¹é…ï¼šè¤‡é›œåº¦ $O(|T|)$ï¼Œå»ºç«‹Få‡½æ•¸ï¼š$O(|S|)$\n\næ¼¢æ˜è·é›¢(Hamming distance)\nå…©å€‹ç­‰é•·å­—ç¬¦ä¸²å°æ‡‰ä½ç½®çš„ä¸åŒå­—ç¬¦çš„å€‹æ•¸\n\nZ-value\nz[i] æ˜¯æŒ‡ç”± s[i] é–‹å§‹çš„å­—ä¸²ï¼Œèˆ‡ s[0] é–‹å§‹çš„å­—ä¸²å¯ä»¥åŒ¹é…åˆ°å¤šé•·\nS[0:k-1] = S[i:i+k-1]\nz[0] = 0\n\nRolling Hash\nä¹‹å‰éš¨æ©Ÿè¬›é\n\nå¾Œç¶´æ•¸çµ„ï¼ˆSuffix Arrayï¼‰\nå°‡ä¸€å€‹å­—ä¸²çš„æ‰€æœ‰å¾Œç¶´é€²è¡Œæ’åº\nåŸºæ•¸æ’åºï¼ˆRadix Sortï¼‰\n\næœ€é•·å…±åŒå‰ç¶´ï¼ˆLCP,Longest Common Prefixï¼‰\nå…©å­—ä¸²çš„æœ€é•·å…±åŒå‰ç¶´\nå°‡æœ€é•·å…±åŒå‰ç¶´è½‰æ›æˆå€é–“æœ€å°å€¼å•é¡Œ\n\nå­—ä¸²æ¼”ç®—æ³•ä¸»é¡Œå­—å…¸æ¨¹Trieå­—å…¸æ¨¹æ˜¯ä»¥æŒ‡æ¨™å‹æ…‹å»ºç«‹çš„ä¸€æ£µæ¨¹ï¼Œé‚Šä»£è¡¨ä¸€å€‹å­—å…ƒã€ç¯€é»ä»£è¡¨å¾æ ¹ä¸€è·¯èµ°ä¾†çš„é‚Šå½¢æˆçš„å­—ä¸²ï¼Œå¾æ ¹ç¯€é»é–‹å§‹ï¼ˆæ ¹ç¯€é»ç‚ºç©ºï¼‰ï¼Œæ¯ç¶“éä¸€æ¢é‚Šï¼Œå°±æŠŠå­—ä¸²åŠ ä¸Šé‚£ä¸€æ¢é‚Šå°æ‡‰çš„å­—å…ƒï¼Œç›´åˆ°æ‰¾å‡ºè¦åŒ¹é…çš„å­—ä¸²ã€‚å¦‚æœæœ‰å¤šç­†ç¨ç«‹çš„è©¢å•ï¼Œåªè¦åŠ ä¸ŠDeleteå‡½æ•¸å°±å¯ä»¥äº†ï¼\nTrieçµæ§‹å¯¦ä½œä¸Šçš„é™£åˆ—cæŒ‡å‘å€‹åˆ¥çš„å­—å…ƒï¼Œä¸ä¸€å®šè¦ç”¨cntï¼Œæ ¹æ“šé¡Œç›®çš„æ‰€æ±‚èª¿æ•´ä¸åŒçš„è®Šæ•¸è¨­å®šã€‚\nstruct Trie&#123;        //åˆ©ç”¨æŒ‡æ¨™å»ºç«‹ä¸€æ£µæ¨¹    Trie* c[26];    //å°æ‡‰a-zæ¯ä¸€æ¢é‚Š    int cnt;        //å­—ä¸²å‡ºç¾æ¬¡æ•¸    Trie(): cnt(0)&#123; //åˆå§‹è¨­å®š        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root;\nInsertå‡½æ•¸åœ¨æ’å…¥çš„éç¨‹ä¸­è¨€éŒ„æ–°å¢è·¯å¾‘ï¼Œä¸€æ¨£å˜¢å¯ä»¥æ ¹æ“šé¡Œç›®è¦æ±‚åœ¨éç¨‹ä¸­é€²è¡Œè®Šæ•¸ç´€éŒ„ç­‰ã€‚å¦‚NEOJ 267 è‡ªå‹•å®Œæˆç³»çµ±ã€‚\nvoid insert(char *s)&#123;    Trie *ptr = root;           //å¾æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //å¦‚æœæ¨¹ä¸Šç„¡æ­¤å­—å…ƒå‰‡new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //ç¹¼çºŒé€ è¨ªTrie        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    ptr-&gt;cnt += 1;              //å­—ä¸²å‡ºç¾æ¬¡æ•¸(å­—ä¸²å°æ‡‰å”¯ä¸€è‘‰ç¯€é»)&#125;\næŸ¥è©¢å‡½æ•¸ä¸€å€‹å­—ä¸²å°æ‡‰åˆ°å”¯ä¸€çš„è·¯å¾‘ï¼Œå¾æ ¹ç¯€é»æ ¹æ“šæ¯ä¸€å€‹å­—å…ƒæ±ºå®šè·¯å¾‘ã€‚\nint find(char *s)&#123;              //æŸ¥æ‰¾å­—ä¸²s    Trie *ptr = root;           //æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;                  //ç„¡æ­¤å­—ä¸²ï¼Œå›å‚³æ¬¡æ•¸0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    return ptr-&gt;cnt;            //å›å‚³å­—ä¸²å‡ºç¾æ¬¡æ•¸&#125;\nDeleteå‡½æ•¸void clear(Trie *s)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(s-&gt;c[i])&#123;            clear(s-&gt;c[i]);            delete s-&gt;c[i];            s-&gt;c[i] = nullptr;    //å¾ˆé‡è¦        &#125;    &#125;&#125;\nKMP Algorithmé¦–å…ˆè¦æ±‚å‡ºFailure Functionï¼Œå®ƒå¯ä»¥åœ¨ $O(|S|)$ å»ºç«‹ã€‚å¤±æ•—å‡½æ•¸çš„å®šç¾©æ˜¯ï¼š\n\n$F[i]$ è¡¨ç¤ºç•¶æˆåŠŸé…å° $A[0:i]$ ä¹‹å¾Œï¼Œé…å°å¤±æ•—æ™‚ï¼Œæˆ‘å€‘æœƒå°‡ $A[ F[i]]$ å°é½ŠåŸæœ¬ $A[i]$ çš„ä½ç½®\n\nå¦‚æœå¯«æˆæ•¸å­¸å¼çš„å®šç¾©ï¼š\nF_A(J)=\\left\\{\n\\begin{array}{l}\n-1,&&\\text{if j = 0}\\\\\nmax\\{p:A_{0...p} = A_{j-p...j} \\text{ and 0â‰¤p","categories":["C++é€²éšä¸»é¡Œ","å­—ä¸²æ¼”ç®—æ³•"],"tags":["æ¼”ç®—æ³•","å­—ä¸²"]},{"title":"[é¡Œè§£]NEOJ 266 æº«åŠ›çš„æ•…äº‹","url":"/string2-1/","content":"NEOJ 266 æº«åŠ›çš„æ•…äº‹\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ nå€‹å­—ä¸²mç­†è©¢å•ä¸€å€‹å­—ä¸²ï¼Œå°æ¯ä¸€ç­†è©¢å•è¼¸å‡ºè©¢å•åœ¨nå€‹å­—ä¸²ä¸­å‡ºç¾çš„æ¬¡æ•¸ã€‚\n\né€™ä¸€é¡Œåœ¨éš¨æ©Ÿç®—æ³•åšéï¼Œä»Šå¤©ç”¨å­—å…¸æ¨¹Trieåšä¸€æ¬¡ã€‚åœ¨éš¨æ©Ÿç®—æ³•ä¸­ï¼Œé€éRolling Hashçš„å…¬å¼ï¼Œå°æ¯ä¸€å€‹å­—ä¸²ç”Ÿæˆä¸€å€‹å€¼ï¼Œåˆ©ç”¨é€™å€‹å€¼æŸ¥è©¢å‡ºç¾çš„æ¬¡æ•¸ã€‚å¦‚æœæˆ‘å€‘ç”¨Trieçš„è©±ï¼Œå‰‡æ˜¯å»ºç«‹ä¸€æ£µæŒ‡æ¨™æ¨¹ï¼Œé€éèµ°æ³•é€™ä¸€æ£µå­—å…¸æ¨¹å¾—çŸ¥è©¢å•å­—ä¸²å‡ºç¾çš„æ¬¡æ•¸ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;        //åˆ©ç”¨æŒ‡æ¨™å»ºç«‹ä¸€æ£µæ¨¹    Trie* c[26];    //å°æ‡‰a-zæ¯ä¸€æ¢é‚Š    int cnt;        //å­—ä¸²å‡ºç¾æ¬¡æ•¸    Trie(): cnt(0)&#123; //åˆå§‹è¨­å®š        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void insert(char *s)&#123;    Trie *ptr = root;           //å¾æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //å¦‚æœæ¨¹ä¸Šç„¡æ­¤å­—å…ƒå‰‡new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //ç¹¼çºŒé€ è¨ªTrie        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    ptr-&gt;cnt += 1;              //å­—ä¸²å‡ºç¾æ¬¡æ•¸(å­—ä¸²å°æ‡‰å”¯ä¸€è‘‰ç¯€é»)&#125;int find(char *s)&#123;              //æŸ¥æ‰¾å­—ä¸²s    Trie *ptr = root;           //æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;                  //ç„¡æ­¤å­—ä¸²ï¼Œå›å‚³æ¬¡æ•¸0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    return ptr-&gt;cnt;            //å›å‚³å­—ä¸²å‡ºç¾æ¬¡æ•¸&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,n-1)&#123;        char s[105];cin&gt;&gt;s;        insert(s);    &#125;    rep(i,0,m-1)&#123;        char s[105];cin&gt;&gt;s;        cout&lt;&lt;find(s)&lt;&lt;endl;    &#125;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]TIOJ 1497 å–é†‰çš„å®¿ä¸» The drunk host","url":"/string2-10/","content":"TIOJ 1497 å–é†‰çš„å®¿ä¸» The drunk host\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°è£¸å¾Œç¶´æ•¸çµ„ã€‚\n\nå¾Œç¶´æ•¸çµ„æˆ‘çœ‹äº†å¥½ä¹…ï¼ˆå¤§æ¦‚æœ‰4å¤©å§ï¼‰ï¼Œä¸€ç›´å°è‘—å®ƒç™¼å‘†ï¼Œä¸çŸ¥é“å®ƒçš„ç²¾é«“åˆ°åº•åœ¨å“ªè£¡ã€‚ã€‚å‰›å¥½åˆé‡åˆ°é–‹å­¸ï¼Œä¸èƒ½æ•´å¤©å¿«æ¨‚å¯«é¡ŒXD\nå€å¢å„ªåŒ–å°è‘—è¢å¹•ç™¼å‘†çš„æ—¥å­çµ‚æ–¼çµæŸäº†ï¼Œç›´åˆ°æˆ‘çœ‹äº†é€™ä¸€ç¯‡ï¼ˆé›–ç„¶èªªæˆ‘å‰å¹¾å¤©ä¹Ÿæœ‰çœ‹ä½†çœ‹ä¸æ‡‚ï¼Œå¯èƒ½æ˜¯æ¶ˆåŒ–çš„å¤©æ•¸ä¸å¤ å¤šå§ï¼‰ï¼Œå°¤å…¶æ˜¯è£¡é¢çš„ä¸€å¼µåœ–ï¼Œæ·±åˆ»èªªæ˜äº†å€å¢çš„ç²¾é«“ã€‚\nå¾Œç¶´æ•¸çµ„æ±‚æ³•å°±ä¸å¤šè§£é‡‹ï¼ˆä¸Šé¢æœ‰ï¼‰ï¼Œæ”¾å¹¾å€‹å¯¦ä½œä¸Šçš„å°ç´°ç¯€ã€‚\n\n            å¯¦ä½œå°ç´°ç¯€æˆ‘å€‘è¦æ±‚é€²è¡Œ $O(\\log n)$ å±¤çš„å€å¢ï¼Œå¯ä»¥ä½¿ç”¨C++å…§å»ºçš„log10()å†ç”¨ceilå»è™•ç†ï¼Œä½†é¡¯ç„¶æœ‰é»æ…¢ï¼Œå¦‚æœå¥—ç”¨ä»¥ä¸‹å‡½æ•¸ï¼Œå®ƒæœƒå›å‚³æ•¸å­—äºŒé€²ä½ä¹‹å¾Œæœ€å¤§çš„1å‰é¢ç¸½å…±æœ‰å¤šå°‘å€‹0ï¼ˆå‰ç¶´0çš„æ•¸é‡ï¼‰ï¼Œèˆ‡32ç›¸æ¸›ï¼ˆ32æ˜¯long longçš„é—œä¿‚ï¼‰å°±æ˜¯æˆ‘å€‘è¦çš„logçš„æ¬¡æ•¸ã€‚int lg = __builtin_clz(n)å¦å¤–ä¸€å€‹å°å°ç´°ç¯€ï¼Œå°±æ˜¯åœ¨å­—ä¸²çš„å¾ŒåŠéƒ¨åˆ†ï¼Œå¦‚æœè·Ÿå‰é¢ä¸€æ¨£å€å¢ä¸€å€‹æ¯”è¼ƒå¤§çš„æ•¸å­—ï¼Œæœ‰å¯èƒ½æœƒè¶…å‡ºç¯„åœï¼Œé€™æ™‚å€™åˆå§‹å€¼å°±å¾ˆé‡è¦äº†ï¼åˆå§‹è¨­å®šrk[n] = -1ï¼Œå°è‡´ä»»ä½•åªè¦è¶…å‡ºç¯„åœçš„éƒ½æœƒå–åˆ°é€™å€‹-1ï¼Œè¡¨ç¤ºåªè¦å¾Œé¢æ²’æœ‰å­—ä¸²ã€å¦‚æœå‰é¢éƒ½ç›¸åŒä½†é•·åº¦æ¯”è¼ƒé•·çš„å­—ä¸²æ¯”èµ·ä¾†ï¼Œè¼ƒçŸ­çš„æœƒæ’åœ¨æ¯”è¼ƒå‰é¢çš„ä½ç½®ï¼\n          \né€™å€‹ç®—æ³•æ˜¯ $O(n\\log^2 n)$ï¼ŒTIOJé€™ä¸€é¡Œå¯ä»¥éï¼Œä¸éåˆ°SPOJå°±æœƒè¢«å¡TLE\n\n$O(n^2 log(n))$ is expected to score about 20-30. (Naive sorting all suffixes)$O(n log^2(n))$ is expected to score about 40. (OK for most programming contest problems)$O(n log n)$ is expected to score about 60-70. (Use counting sort for small alphabet size)$O(n)$ without tweaks is expected to score about 80-90.$O(n)$ with tweaks is expected to score 100. (This is meant for fun only :)\n\nè¶Šå¾Œé¢å°±è¶Šæ¯’ç˜¤XD\n\ntest 1 - AC (score=0.000000, sig=0, time=0.009123, mem=5372)test 2 - AC (score=0.000000, sig=0, time=0.006427, mem=5508)test 3 - AC (score=0.000000, sig=0, time=0.014975, mem=5468)test 4 - AC (score=0.000000, sig=0, time=0.031332, mem=5536)test 5 - AC (score=0.000000, sig=0, time=0.026948, mem=5456)test 6 - AC (score=0.000000, sig=0, time=0.023113, mem=5396)test 7 - TLE (score=0.000000, sig=0, time=0.210000, mem=7340)test 8 - TLE (score=0.000000, sig=0, time=0.210000, mem=7152)test 9 - AC (score=0.000000, sig=0, time=0.170094, mem=7284)test 10 - AC (score=0.000000, sig=0, time=0.140098, mem=7340)\n\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//ç¬¬ä¸€ä½ã€ç¬¬äºŒä½æ¯”è¼ƒä»¥åŠå¾Œç¶´ç·¨è™Ÿbool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //å›å‚³ç¬¬ä¸€å€‹1ä¹‹å‰0çš„å€‹æ•¸ï¼ˆäºŒé€²ä½ï¼‰    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //ç¾åœ¨å€å¢çš„å¤§å°        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)&#123;            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //è¨­å®šrkï¼Œèˆ‡å‰ä¸€å€‹ç›¸åŒå‰‡è¨­å®šè·Ÿå‰ä¸€å€‹ä¸€æ¨£        &#125;        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\nRadix Sort å„ªåŒ–Submission\næ¯”è¼ƒä¸€ä¸‹ $O(n\\log^2 n)$ ä»¥åŠ $O(n\\log n)$ çš„æ™‚é–“ï¼Œå…©è€…èŠ±äº†è¿‘å…©å€çš„æ™‚é–“å·®è·ã€‚çœ‹äº†ä¸€ä¸‹é€™ä¸€é¡Œçš„TopCoderï¼Œç«Ÿç„¶å¯ä»¥åšåˆ°åä½æ•¸æ¯«ç§’ï¼å¦‚æœè¦ç¹¼çºŒå„ªåŒ–æˆç·šæ€§ $O(n)$ çš„è¤‡é›œåº¦ï¼Œå°±æœƒä½¿ç”¨åˆ° DC3 çš„æ¼”ç®—æ³•ï¼Œé›–ç„¶å¥½åƒå¾ˆè¤‡é›œä¸å¯¦ç”¨QQ\n\n\n\nä½¿ç”¨ $O(n\\log^2n)$ çš„ç®—æ³•æœƒTLEç¬¬å…«ã€ä¹ç­†æ¸¬è³‡ï¼Œä¸éä½¿ç”¨åŸºæ•¸æ’åºå°±å¯ä»¥ACäº†ï¼\n\ntest 1 - AC (score=0.000000, sig=0, time=0.006565, mem=6048)test 2 - AC (score=0.000000, sig=0, time=0.006594, mem=6300)test 3 - AC (score=0.000000, sig=0, time=0.012431, mem=7860)test 4 - AC (score=0.000000, sig=0, time=0.012267, mem=7208)test 5 - AC (score=0.000000, sig=0, time=0.011158, mem=6804)test 6 - AC (score=0.000000, sig=0, time=0.012057, mem=7892)test 7 - AC (score=0.000000, sig=0, time=0.140876, mem=17720)test 8 - AC (score=0.000000, sig=0, time=0.077631, mem=21952)test 9 - AC (score=0.000000, sig=0, time=0.074905, mem=21340)test 10 - AC (score=0.000000, sig=0, time=0.076732, mem=30160)\n\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//ç¬¬ä¸€ä½ã€ç¬¬äºŒä½æ¯”è¼ƒä»¥åŠå¾Œç¶´ç·¨è™Ÿvector&lt;pt&gt; temp,box[N];void init()&#123;    temp.clear();    rep(i,0,n-1)box[i].clear();&#125;bool cmp(pt a,pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void raddix_sort(vector&lt;pt&gt; &amp;cur)&#123;    init();    rep(i,0,n-1)&#123;        if(cur[i].y == -1)temp.push_back(cur[i]);        else box[cur[i].y].push_back(cur[i]);    &#125;    rep(i,0,n-1)        for(auto j : box[i])temp.push_back(j);    rep(i,0,n-1)box[i].clear();    rep(i,0,n-1)        box[temp[i].x].push_back(temp[i]);    cur.clear();    rep(i,0,n-1)        for(auto j : box[i])cur.push_back(j);&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);//å›å‚³ç¬¬ä¸€å€‹1ä¹‹å‰0çš„å€‹æ•¸ï¼ˆäºŒé€²ä½ï¼‰    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1) cur[i] = &#123;S[i],0,i&#125;;    sort(all(cur),cmp);    rk[cur[0].id] = 0;    rep(i,1,n-1)        rk[cur[i].id] = (cur[i]==cur[i-1])?rk[cur[i-1].id]:i;    rep(i,0,n-1)cur[i] = &#123;rk[i],0,i&#125;;    rep(p,0,lg)&#123;                //é€²è¡ŒO(lgn)æ¬¡        int k = 1 &lt;&lt; p;         //ç¾åœ¨å€å¢çš„å¤§å°        raddix_sort(cur);        rk[cur[0].id] = 0;        rep(i,1,n-1)            //è¨­å®šrkï¼Œèˆ‡å‰ä¸€å€‹ç›¸åŒå‰‡è¨­å®šè·Ÿå‰ä¸€å€‹ä¸€æ¨£            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);        rep(i,0,n-1)            //å€å¢pairçš„second            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;    &#125;    raddix_sort(cur);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]TIOJ 1515 Problem E. ä¼¼æ›¾ç›¸è­˜","url":"/string2-11/","content":"TIOJ 1515 Problem E. ä¼¼æ›¾ç›¸è­˜\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°è£¸å¾Œç¶´æ•¸çµ„ LCPã€‚\n\né€™é¡Œæˆ‘æƒ³å¥½ä¹…ï¼Œä¸€ç›´æƒ³ä¸é€šè½‰ç§»çš„æ¢ä»¶ä»¥åŠk-1çš„åŸå› ï¼Œä¸éæœ€å¾Œé‚„æ˜¯æƒ³é€šäº†ï¼é€™ä¸€é¡Œåªè¦æŠŠ $lcp$ æ±‚å‡ºä¾†ä¹‹å¾Œï¼Œæ‰¾æœ€å¤§å€¼å°±æ˜¯é¡Œç›®è¦æ±‚çš„ç­”æ¡ˆã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 200005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//ç¬¬ä¸€ä½ã€ç¬¬äºŒä½æ¯”è¼ƒä»¥åŠå¾Œç¶´ç·¨è™Ÿbool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //å›å‚³ç¬¬ä¸€å€‹1ä¹‹å‰0çš„å€‹æ•¸ï¼ˆäºŒé€²ä½ï¼‰    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //ç¾åœ¨å€å¢çš„å¤§å°        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //è¨­å®šrkï¼Œèˆ‡å‰ä¸€å€‹ç›¸åŒå‰‡è¨­å®šè·Ÿå‰ä¸€å€‹ä¸€æ¨£        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;vector&lt;int&gt; LCP(string s)&#123;    vector&lt;int&gt; rk(n,0),lcp(n,0);    rep(i,0,n-1)rk[sa[i]] = i;      //åˆ©ç”¨saåå‡½æ•¸å¾—åˆ°rk    int k = 0;    rep(i,0,n-1)&#123;        if(k)k--;        if(rk[i] == n-1)continue;   //rk[n-1]æœªå®šç¾©        int j = sa[rk[i]+1];        //ä¸‹ä¸€åå¾Œç¶´å¾ä½•é–‹å§‹        while(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;        lcp[rk[i]] = k;    &#125;    return lcp;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;cin.ignore();    string S;getline(cin,S);    suffix_array(S);    vector&lt;int&gt; lcp = LCP(S);        int ans = 0;    rep(i,0,n-1)ans = max(lcp[i],ans);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]NEOJ 265 æ¬¸è¿ªçš„å­—ä¸²","url":"/string2-2/","content":"NEOJ 265 æ¬¸è¿ªçš„å­—ä¸²\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å­—ä¸²Så’Œå­—ä¸²Tï¼Œæ±‚å‡ºSåœ¨Tä¸­å‡ºç¾çš„ä½ç½®\n\né€™ä¸€é¡Œåœ¨éš¨æ©Ÿæ¼”ç®—æ³•ä¹Ÿæœ‰å‡ºç¾éï¼Œç•¶æ™‚æ˜¯ç”¨Rolling Hashçš„æ–¹å¼é€éæ‰£æ‰Hashçš„æ–¹æ³•æ¯”å°å­—ä¸²æ˜¯å¦ç›¸åŒï¼ˆæ¨ä¸€ä¸‹å…¬å¼å°±çŸ¥é“ï¼‰ã€‚ç¾åœ¨è¦ç”¨çš„æ˜¯KMPæ¼”ç®—æ³•ï¼Œå¾ˆè¤‡é›œä¸å¥½æƒ³ã€‚\næ¯”è¼ƒä¸€ä¸‹éš¨æ©Ÿè·ŸKMPçš„æ™‚é–“ï¼Œä¸‹æ–¹ç‚ºKMPï¼Œä¸Šæ–¹å‰‡æ˜¯éš¨æ©Ÿç®—æ³•ï¼Œå…©è€…æ™‚é–“å·®äº†å°‡è¿‘1å€ï¼Œé›–ç„¶å…©è€…éƒ½å¯ä»¥åœ¨O(|T|)æ™‚é–“å…§é€²è¡ŒåŒ¹é…ï¼Œä½†æ˜¯å»ºç«‹Rolling Hashçš„å¸¸æ•¸æ˜¯æ¯”è¼ƒå¤§çš„ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;vector&lt;int&gt; KMP_match(char *S,int *F,char *T)&#123;    vector&lt;int&gt; ans;            //å›å‚³åŒ¹é…ç›¸åŒåœ°æ–¹    int p = -1;                 //ç´€éŒ„çŸ­å­—ä¸²æœ‰å¤šå°‘è¢«åŒ¹é…    for(int i=0;T[i];i++)&#123;      //æ¯ä¸€è¿´åœˆéƒ½è®“T[i]è¢«åŒ¹é…åˆ°        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];           //ä½¿T[i]ä¸€å®šå¯ä»¥è¢«åŒ¹é…åˆ°        if(S[p+1] == T[i])            p += 1;             //Tçš„ç¬¬iå€‹èˆ‡Sçš„p+1å¯ä»¥åŒ¹é…        if(!S[p+1])&#123;            //S[p]å·²ç¶“åŒ¹é…å®Œæˆ            ans.push_back(i-p); //å›æ¨åŒ¹é…é–‹é ­            p = F[p];           //ç¹¼çºŒä¸‹ä¸€è¼ªåŒ¹é…        &#125;    &#125;    return ans;&#125;//O(|S|)è¦é…å°çš„å­—ä¸²ä»¥åŠFail Functionvoid KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;              //åˆå§‹è¨­å®šç‚º-1    for(int i=1;S[i];i++)&#123;          //1åˆ°æ¥ä¸‹ä¾†å­—å…ƒ        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];               //ç„¡æ³•ç¹¼çºŒé…å°ï¼Œå°‹æ‰¾æ›´çŸ­å­—ä¸²        if(S[p+1] == S[i])          //é…å°æˆåŠŸ(å¦‚éƒ½æ²’æœ‰ä¸€æ¨£çš„å°±-1)            p += 1;        F[i] = p;                   //è¨­å®šF[i]    &#125;&#125;signed main()&#123;    Orz;    char S[N],T[N];     //è©¢å•çŸ­å­—ä¸²ã€é•·åœ¨ä¸²    int F[N];           //å¤±æ•—å‡½æ•¸    cin&gt;&gt;S&gt;&gt;T;    KMP_build(S,F);    vector&lt;int&gt; ans = KMP_match(S,F,T);    if(ans.size()&gt;0)&#123;        cout&lt;&lt;ans[0];        rep(i,1,ans.size()-1)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];    &#125;    cout&lt;&lt;endl;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]NEOJ 267 è‡ªå‹•å®Œæˆç³»çµ±","url":"/string2-3/","content":"NEOJ 267 è‡ªå‹•å®Œæˆç³»çµ±\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°é»é€™è£¡æœ‰FB Hacker Cupçš„åŸé¡Œé€£çµï¼Œç°¡å–®ä¾†èªªå°±æ˜¯æƒ³åƒæ‰‹æ©Ÿçš„è‡ªå‹•å¡«å…¥ç³»çµ±ï¼Œæ¯åŠ å…¥ä¸€å€‹å­—ä¸²æœƒè¨˜éŒ„åˆ°è³‡æ–™åº«ä¸­ï¼Œç•¶è³‡æ–™åº«è£¡é¢æ²’æœ‰ç›¸åŒå‰ç¶´çš„å­—ä¸²æ™‚å°±è¼¸å‡ºå‰ç¶´é•·åº¦ã€‚\n\nç”¨å­—å…¸æ¨¹Trieæ’å…¥æ¯ä¸€å€‹å­—ä¸²ï¼Œæ’å…¥éç¨‹ä¸­è¿”å›å¾é ­åˆ°é–‹å§‹newæ–°çš„ç¯€é»ä¹‹é–“ç¶“éçš„ç¯€é»æ¨¹ï¼Œä»£è¡¨éœ€è¦è¼¸å…¥å¤šå°‘å€‹å­—å…ƒæ‰èƒ½è§¸ç™¼è‡ªå‹•å®Œæˆç³»çµ±ã€‚é€™ä¸€é¡Œæ˜¯åŸºç¤çš„Trieæ‡‰ç”¨ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n;char S[N];int ch(char a)&#123;    return a-&#x27;a&#x27;;&#125;struct Trie&#123;    Trie* c[26];    Trie()&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie *root = new Trie();int insert(char *S)&#123;    Trie *ptr = root;    int step = 0,f = 1;    while(*S)&#123;        if(f)step++;        if(!ptr-&gt;c[ch(*S)])&#123;            ptr-&gt;c[ch(*S)] = new Trie();            f = 0;        &#125;        ptr = ptr-&gt;c[ch(*S)];        S++;    &#125;    return step;&#125;void clear(Trie *s)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(s-&gt;c[i])&#123;            clear(s-&gt;c[i]);            delete s-&gt;c[i];            s-&gt;c[i] = nullptr;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;t;    int cnt = 0;    while(t--)&#123;        cnt++;        cin&gt;&gt;n;        int step = 0;        rep(i,0,n-1)&#123;            cin&gt;&gt;S;            step +=insert(S);        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;step&lt;&lt;endl;        clear(root);    &#125;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]NEOJ 264 æ¬¸è¿ªçš„å­—ä¸²","url":"/string2-4/","content":"NEOJ 264 æ¬¸è¿ªçš„å­—ä¸²\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å­—ä¸²Sï¼Œæ±‚ä¸€å€‹æœ€çŸ­å­—ä¸²Tçš„é•·åº¦ï¼Œæ»¿è¶³ç¶“ç”±è¤‡è£½è‹¥å¹²æ¬¡å¾Œæ¥èµ·ä¾†æœƒæ˜¯å­—ä¸²Sã€‚\n\né€™ä¸€é¡Œåœ¨ä¸€é–‹å§‹çœ‹åˆ°æ„Ÿè¦ºå¥½é›£ï¼Œä¸éåœ¨æ…¢æ…¢ç†è§£ Z_Algorithm ä¹‹å¾Œï¼Œåœ¨è¬›ç¾©ä¸­ç™¼ç¾åˆ°é€™å€‹å•é¡Œä¹Ÿå¯ä»¥ç”¨é€™å€‹æ¼”ç®—æ³•ä¾†è§£æ±ºï¼å› ç‚ºZå‡½æ•¸æ˜¯æ»¿è¶³å¾ié–‹å§‹çš„æœ€é•·å‰ç¶´ï¼Œå› æ­¤ç•¶ $i$ ç‚º å­—ä¸²é•·åº¦ $n$ çš„å› æ•¸çš„æ™‚å€™ï¼Œåªè¦ $i+Z[i+1]=n$ æˆç«‹ï¼Œå°±å¿…å®šå¯ä»¥ç”¨ $S[1:i]$ çµ„æˆå­—ä¸² $S$ ã€‚å¯¦ä½œä¸Šè¦æ³¨æ„å­—ä¸²æ˜¯0-baseï¼Œi+1å°±ç›¸ç­‰æ–¼å­—ä¸²ç¬¬iå€‹ä½ç½®ï¼Œè™•ç†ä¸Šè¦ç‰¹åˆ¥æ³¨æ„ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;void Z_algo(char *S,int *Z)&#123;    int l = 0,r = 0;    Z[0] = 0;    for(int i=1;S[i];i++)&#123;        Z[i] = max(0,min(Z[i-l],r-i));        while(S[Z[i]]&amp;&amp;S[Z[i]] == S[i+Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    char s[N];cin&gt;&gt;s;    int Z[N],n = strlen(s),ans = n;    Z_algo(s,Z);        rep(i,1,n-1)&#123;        if(n%i==0 &amp;&amp; i+Z[i]==n)&#123;            ans = i;            break;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]ZJ d518: æ–‡å­—æŠ„å¯« II","url":"/string2-5/","content":"ZJ d518: æ–‡å­—æŠ„å¯« II\né¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°è‹¥é€™å€‹å­—ä¸²ä¹‹å‰å·²ç¶“å‡ºç¾éï¼Œå‰‡è¼¸å‡ºçš„å‡ºç¾è™Ÿç¢¼ï¼Œè‹¥æ²’æœ‰å‰‡è¼¸å‡ºå®ƒå°‡è¢«ç·¨å¯«çš„è™Ÿç¢¼.\n\nè£¸é¡ŒTrieï¼Œä¸éè¦æ³¨æ„æ¯ä¸€æ¬¡è¦é‡ç½®ï¼Œå°‡æ‰€æœ‰çš„å¯¦é«”Deleteæ‰ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 110#define Orz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;    Trie* c[26];    int ind;    Trie(): ind(0)&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void clear(Trie *cur)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(cur-&gt;c[i])&#123;            clear(cur-&gt;c[i]);            delete[] cur-&gt;c[i];            cur-&gt;c[i] = NULL;        &#125;    &#125;&#125;void insert(char *s,int num)&#123;    Trie *ptr = root;           //å¾æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //å¦‚æœæ¨¹ä¸Šç„¡æ­¤å­—å…ƒå‰‡new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //ç¹¼çºŒé€ è¨ªTrie        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    ptr-&gt;ind = num;&#125;int find(char *s)&#123;              //æŸ¥æ‰¾å­—ä¸²s    Trie *ptr = root;           //æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;                  //ç„¡æ­¤å­—ä¸²ï¼Œå›å‚³æ¬¡æ•¸0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    return ptr-&gt;ind;&#125;signed main()&#123;    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;        int ans,cur_id = 1;        rep(i,1,n)&#123;            char s[N];scanf(&quot;%s&quot;,s);            ans = find(s);            if(ans == 0)&#123;                printf(&quot;New! %d\\n&quot;,cur_id);                insert(s,cur_id);                cur_id += 1;            &#125;            else&#123;                printf(&quot;Old! %d\\n&quot;,ans);            &#125;        &#125;        clear(root);    &#125;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]TIOJ 1306 å­—ä¸²ä¸­çš„å­—ä¸²","url":"/string2-6/","content":"TIOJ 1306 å­—ä¸²ä¸­çš„å­—ä¸²\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°è£¸å­—ä¸²åŒ¹é…ã€‚å°æ–¼æ¯å€‹è©¢å•è¼¸å‡º $S$ åœ¨ $T$ ä¸­å‡ºç¾éå¹¾æ¬¡ã€‚\n\nè£¸KMPå­—ä¸²åŒ¹é…ï¼Œçµ±è¨ˆå‡ºç¾æ¬¡æ•¸ã€‚å¯ä»¥å˜—è©¦ä¸è¦çœ‹è³‡æ–™è‡ªå·±å¯«ä¸€æ¬¡ï¼Œæœƒæ›´äº†è§£KMPç®—æ³•ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n,F[N];;char T[N],S[N];int KMP_match(char *S,char *T,int *F)&#123;    int p = -1,ans = 0;    for(int i=0;T[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];        if(S[p+1] == T[i])            p += 1;        if(!S[p+1])&#123;            ans += 1;            p = F[p];        &#125;    &#125;    return ans;&#125;void KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;    for(int i=1;S[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];        if(S[p+1] == S[i])            p += 1;        F[i] = p;    &#125;&#125;void solve()&#123;    while(n--)&#123;        memset(F,0,sizeof(F));        cin&gt;&gt;S;        KMP_build(S,F);        cout&lt;&lt;KMP_match(S,T,F)&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T&gt;&gt;n;        solve();    &#125;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]TIOJ 1321 å¥½å¤šå›æ–‡ ndromePali","url":"/string2-7/","content":"TIOJ 1321 å¥½å¤šå›æ–‡ ndromePali\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä¸€å€‹é•·åº¦ â‰¤ $10^6$ çš„å­—ä¸² Aï¼Œå•æœ‰å¹¾ç¨®æŠŠè©²å­—ä¸²çš„æŸå‰ç¶´æ¬åˆ°æœ€å¾Œé¢çš„æ–¹æ³•ï¼Œä½¿å¾—æœ€å¾Œçš„å­—ä¸²ç‚ºå›æ–‡ã€‚(æç¤º:å¯ä»¥ç”¨é¡ä¼¼ Z å‡½æ•¸çš„æ¦‚å¿µè¨ˆç®—å‡ºä»¥æŸå­—å…ƒç‚ºä¸­å¿ƒçš„æœ€é•·å›æ–‡é•·åº¦ã€‚)\n\né€™ä¸€é¡Œæå¾—æˆ‘å¿«æ›äº†QQQã€‚ç‚ºä»€éº¼å‘¢ï¼Ÿçœ‹çœ‹ä»¥ä¸‹ç…§ç‰‡å°±çŸ¥é“äº†ï¼š\n\næ ¹æ“šä¸Šé¢çš„ã€Œæç¤ºã€ï¼Œè¦ç”¨é¡ä¼¼Zå‡½æ•¸çš„æ¦‚å¿µæŠŠä»¥æŸé»ç‚ºä¸­å¿ƒçš„æœ€é•·å›æ–‡ç®—å‡ºä¾†ã€‚ä¸€å€‹Naiveè£¸çš„ä½œæ³•ï¼ŒæŠŠç”¨ $O(n)$ æšèˆ‰æ¯ä¸€å€‹é»ç‚ºåˆ†å‰²é»ï¼ŒæŠŠåˆ†å‰²é»å‰é¢çš„å­å­—ä¸²æ¥åˆ°å¾Œé¢ï¼Œç”¨ $O(n)$ çš„æ™‚é–“çœ‹æ˜¯å¦ç‚ºä¸€å›æ–‡å­—ä¸²ã€‚å¦‚æ­¤ä¸€ä¾†æ™‚é–“è¤‡é›œåº¦ç‚º $O(n^2)$ ï¼Œå°é€™ä¸€é¡Œä¾†èªªé¡¯ç„¶æ˜¯ä¸å¯è¡Œçš„ï¼Œå› ç‚ºå­—ä¸²é•·åº¦é”åˆ° $10^6$ï¼\nç•¶æˆ‘å€‘ç”¨Manacherâ€™s Algorithm $O(n)$ çš„æ™‚é–“æ¯ä¸€å€‹å­—å…ƒçš„æœ€å¤§å›æ–‡ä¹‹å¾Œï¼Œå°±å¯ä»¥æšèˆ‰æ¯ä¸€å€‹å¯ä»¥ä½œç‚ºåˆ†å‰²é»çš„åœ°æ–¹ï¼Œæª¢æŸ¥å›æ–‡çš„ç‹€æ³ã€‚è¨è«–åˆ†å‰²é»åœ¨å‰åŠéƒ¨åˆ†çš„æƒ…æ³ä¸‹ï¼Œä¹Ÿå°±æ˜¯æŠŠçŸ­çš„ï¼ˆé•·åº¦å°æ–¼ä¸€åŠï¼‰å‰ç¶´æ¬åˆ°å¾Œé¢çš„ç‹€æ³ã€‚ç•¶åˆ†å‰²çš„ç´¢å¼•å€¼ç‚º $i$ ï¼Œå¿…é ˆä¿è­‰ $s[0:i]$ è·Ÿ $s[i:2i]$ å°ç¨±ï¼Œç§»åˆ°å­—ä¸²å°¾å·´æ‰èƒ½æˆç‚ºå›æ–‡ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä¹Ÿå¿…é ˆæ»¿è¶³ $Z[mid+i] = mid-i$ çš„æƒ…æ³ï¼Œä»¥å°±æ˜¯å‰©ä¸‹ä¸æ˜¯åˆ†å‰²é»å…©å´çš„å­—ä¸²å¿…é ˆæ˜¯å›æ–‡ï¼ŒæŠŠå‰ç¶´æ¥åˆ°å¾Œé¢ä¹‹å¾Œæ‰èƒ½å°ç¨±ï¼\nå¯¦ä½œä¸Šå¾ˆå¤šç´°ç¯€ï¼Œæˆ‘DEBUGè¶…ä¹…æœ€å¾Œæ‰æƒ³åˆ°ä¸èƒ½æšèˆ‰æ‰€æœ‰å­—å…ƒï¼Œæœƒå‡ºäº‹ï¼ˆå°±åƒä¸Šé¢çš„ä¸‰è‰²WAï¼‰ï¼Œåªè¦æšèˆ‰ä»¥ $â€™.â€™$ ç‚ºåˆ†å‰²é»çš„æƒ…æ³ï¼ˆåˆ†å‰²åœ¨å­—å…ƒä¸Šå°±ä¸è¡Œï¼‰ï¼Œé‚„æœ‰å¾ˆå¤šç´°ç¯€ï¼ŒWAå¾ˆå¤šæ¬¡æ‰æœƒçŸ¥é“XD\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N];bool ans[2*N];char S[2*N],T[N];//TåŸå­—ä¸²ã€Sæ’å…¥é»å­—ä¸²void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;T;    Longest();        for(int i=0;i&lt;m;i++)Z[i]--;    memset(ans,0,sizeof(ans));        int mid = (m-1)/2,i;        if(Z[mid] == mid)ans[0] = 1;    for(i=2;i&lt;mid;i+=2)&#123;        if(Z[i] == i &amp;&amp; Z[mid+i] == mid-i)&#123;            ans[(i/2)] = 1;        &#125;    &#125;    for(;i&lt;m;i+=2)&#123;        if(Z[i] == m-i-1 &amp;&amp; Z[i-mid] == i-mid)&#123;            ans[(i/2)] = 1;        &#125;    &#125;        int sum = 0;    for(int i=0;i&lt;n;i++)if(ans[i])sum++;    if(sum == 0)cout&lt;&lt;&quot;none&quot;&lt;&lt;endl;    else&#123;        cout&lt;&lt;sum&lt;&lt;&quot;:&quot;;        for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;&quot; &quot;&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]ZJ d978: æœ€é•¿å›æ–‡å­—ä¸²","url":"/string2-8/","content":"ZJ d978: æœ€é•¿å›æ–‡å­—ä¸²\né¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°é¡Œç›®å³é¡Œæ„ï¼Œçµ¦ä½ ä¸€å€‹å­—ä¸²ï¼Œæ±‚å‡ºæœ€é•·çš„å›æ–‡å­—ä¸²é•·åº¦ç‚ºä½•ï¼Ÿ\n\nä¸€é¡ŒLPSçš„è£¸é¡Œï¼Œç”¨Manacherâ€™s Algorithmå¯ä»¥å°‡æ™‚é–“è¤‡é›œåº¦åšåˆ° $O(n)$ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N],t;bool ans[2*N];char S[2*N],T[N];//TåŸå­—ä¸²ã€Sæ’å…¥é»å­—ä¸²void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T;        Longest();        int ans = 0;        for(int i=0;i&lt;m;i++)&#123;            int z = (Z[i]-1);            ans = max(ans,z);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"[é¡Œè§£]TIOJ 1725 Massacre at Camp Happy","url":"/string2-9/","content":"TIOJ 1725 Massacre at Camp Happy\né¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ï¼šå®šç¾©å­—ä¸² A å’Œ Bã€Œk-å¹¾ä¹ç›¸åŒã€ä»£è¡¨æŠŠå­—ä¸² A çš„å‰ k å­—å…ƒæ¬åˆ°æœ€å¾Œé¢æ™‚ï¼Œèˆ‡ B æ°æœ‰ä¸€å€‹å­—å…ƒç›¸ç•°ã€‚çµ¦ä½ å…©å€‹é•·åº¦ â‰¤ $10^6$ çš„å­—ä¸² A å’Œ Bï¼Œæ±‚æ‰€æœ‰ä½¿ A å’Œ Bã€Œk-å¹¾ä¹ç›¸åŒã€æˆç«‹çš„ k å€¼ã€‚\n\né€™ä¸€é¡Œå¥½ç‰¹åˆ¥ï¼Œä¸€æ¨£è¦ç”¨ $O(n)$ çš„æ™‚é–“æ±‚å‡ºç­”æ¡ˆï¼Œå°æ–¼æ¯ä¸€å€‹æ“ä½œå°‡å‰kå€‹å­—å…ƒæ¬åˆ°å¾Œé¢ï¼Œåªèƒ½ç”¨ $O(1)$ ç®—å‡ºä¾†åˆ°åº•ç¬¦ä¸ç¬¦åˆä¸€å­—å…ƒç›¸ç•°çš„æ¢ä»¶ã€‚ä»¥å…©å€‹ç›¸ç­‰é•·åº¦çš„å­—ä¸² $A,B$ ç‚ºä¾‹ï¼Œé•·åº¦ç‚º $l$ï¼Œå‡è¨­ $A=aabba,B = aacba$ï¼Œå…©è€…ç›¸å·®ä¸€å€‹å­—å…ƒçš„æƒ…æ³ä¸‹ï¼Œå¿…å®šæœƒæ»¿è¶³$l = LCP(A,B)+LCP(rev(A),rev(B))+1$ï¼Œå…¶ä¸­revå‡½æ•¸è¡¨ç¤ºreverseã€‚\næˆ‘å€‘è¦åšçš„å°±æ˜¯åœ¨ $O(1)$ çš„æ™‚é–“å…§æ±‚å‡ºLCPï¼Œå› ç‚ºé¡Œç›®çš„å­—ä¸² $A$ è¦æ±‚ä¸åŒçš„èµ·å§‹ä½ç½®ï¼Œå› æ­¤æˆ‘å€‘å‡è¨­ä¸€å€‹éå¸¸ç‰¹åˆ¥çš„å­—ä¸² $B@AA$ ï¼Œå…¶ä¸­@ç‚ºä»»æ„æ²’å‡ºç¾éçš„å­—å…ƒã€‚åªè¦è¨ˆç®—é€™ä¸€å€‹å­—ä¸²çš„Zå‡½æ•¸ï¼Œå°±è¡¨ç¤ºäº† $A$ å’Œ $B$ çš„æœ€é•·å…±åŒå‰ç¶´ï¼Œéœ€è¦å…©å€‹Açš„åŸå› æ˜¯å› ç‚ºæ¨¡æ“¬ä¸åŒçš„k-ä½ç§»ä¸‹æƒ…å½¢ã€‚\n\n\n            å¯¦ä½œå°ç´°ç¯€ç¨‹å¼ç¢¼çš„ç¬¬42è¡Œå¯ä»¥è©¦è‘—æ¨æ¨çœ‹é€†åºä¹‹å¾Œçš„å°¾å·´çš„ç´¢å¼•å€¼ç‚ºä½•ã€‚æˆ‘æ˜¯åˆ©ç”¨åˆ—å‡ºå¹¾å€‹æ•¸å­—ä¹‹å¾Œæ¨å‡ºä¾†çš„ï¼Œä¸éæ‡‰è©²å¯ä»¥å¯«æˆæ¯”è¼ƒåš´è¬¹çš„æ•¸å­¸è­‰æ˜ï¼Z1[n+1+i]+Z2[2*n-i+1]+1 == n\n          \næ™‚é–“è¤‡é›œåº¦$O(n)$ å»ºç«‹zå‡½æ•¸ï¼Œ$O(n)$ æšèˆ‰æ¯ä¸€å€‹èµ·å§‹é»ï¼Œç¸½æ™‚é–“ç‚º $O(n)$ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z1[3*N],Z2[3*N];char A[3*N],B[3*N];void Z_algo(int *z,char *S)&#123;    int l = 0,r = 0;    z[0] = 0;    for(int i=1;i&lt;m;i++)&#123;        z[i] = max(min(z[i-l],r-i),0);        while(S[i+z[i]] &amp;&amp; S[z[i]] == S[i+z[i]])&#123;            l = i;r = i+z[i];            z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;    m = 3*n+1;    B[n] = &#x27;@&#x27;;    //æ­£å¸¸åºåˆ—æ±‚Z value    rep(i,n+1,2*n)B[i] = A[i-n-1];    rep(i,2*n+1,3*n)B[i] = A[i-2*n-1];    Z_algo(Z1,B);    //é€†åºæ±‚Z value    reverse(B,B+n);reverse(B+n+1,B+m);    Z_algo(Z2,B);        vector&lt;int&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        if(Z1[n+1+i]+Z2[2*n-i+1]+1 == n)vec.push_back(i);    &#125;    if(vec.size())&#123;        cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl;        for(auto i:vec)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;    &#125;//[0,n-1][n,n][n+1,2n][2n+1,3n]\n","categories":["å­—ä¸²é¡Œè§£"],"tags":["é¡Œè§£","å­—ä¸²"]},{"title":"å­—ä¸²æ¼”ç®—æ³•ä¾‹é¡Œ (String)","url":"/string2/","content":"é¡Œç›®ç›®éŒ„\nNEOJ 266 æº«åŠ›çš„æ•…äº‹\nNEOJ 265 æ¬¸è¿ªçš„å­—ä¸²\nNEOJ 267 è‡ªå‹•å®Œæˆç³»çµ±\nNEOJ 264 æ¬¸è¿ªçš„å­—ä¸²\nZJ d518: æ–‡å­—æŠ„å¯« II\nTIOJ 1306 å­—ä¸²ä¸­çš„å­—ä¸²\nTIOJ 1321 å¥½å¤šå›æ–‡ ndromePali\nZJ d978: æœ€é•¿å›æ–‡å­—ä¸²\nTIOJ 1725 Massacre at Camp Happy\nTIOJ 1497 å–é†‰çš„å®¿ä¸» The drunk host\nTIOJ 1515 Problem E. ä¼¼æ›¾ç›¸è­˜\n\n\nNEOJ 266 æº«åŠ›çš„æ•…äº‹é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ nå€‹å­—ä¸²mç­†è©¢å•ä¸€å€‹å­—ä¸²ï¼Œå°æ¯ä¸€ç­†è©¢å•è¼¸å‡ºè©¢å•åœ¨nå€‹å­—ä¸²ä¸­å‡ºç¾çš„æ¬¡æ•¸ã€‚\n\né€™ä¸€é¡Œåœ¨éš¨æ©Ÿç®—æ³•åšéï¼Œä»Šå¤©ç”¨å­—å…¸æ¨¹Trieåšä¸€æ¬¡ã€‚åœ¨éš¨æ©Ÿç®—æ³•ä¸­ï¼Œé€éRolling Hashçš„å…¬å¼ï¼Œå°æ¯ä¸€å€‹å­—ä¸²ç”Ÿæˆä¸€å€‹å€¼ï¼Œåˆ©ç”¨é€™å€‹å€¼æŸ¥è©¢å‡ºç¾çš„æ¬¡æ•¸ã€‚å¦‚æœæˆ‘å€‘ç”¨Trieçš„è©±ï¼Œå‰‡æ˜¯å»ºç«‹ä¸€æ£µæŒ‡æ¨™æ¨¹ï¼Œé€éèµ°æ³•é€™ä¸€æ£µå­—å…¸æ¨¹å¾—çŸ¥è©¢å•å­—ä¸²å‡ºç¾çš„æ¬¡æ•¸ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 2000#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;        //åˆ©ç”¨æŒ‡æ¨™å»ºç«‹ä¸€æ£µæ¨¹    Trie* c[26];    //å°æ‡‰a-zæ¯ä¸€æ¢é‚Š    int cnt;        //å­—ä¸²å‡ºç¾æ¬¡æ•¸    Trie(): cnt(0)&#123; //åˆå§‹è¨­å®š        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void insert(char *s)&#123;    Trie *ptr = root;           //å¾æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //å¦‚æœæ¨¹ä¸Šç„¡æ­¤å­—å…ƒå‰‡new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //ç¹¼çºŒé€ è¨ªTrie        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    ptr-&gt;cnt += 1;              //å­—ä¸²å‡ºç¾æ¬¡æ•¸(å­—ä¸²å°æ‡‰å”¯ä¸€è‘‰ç¯€é»)&#125;int find(char *s)&#123;              //æŸ¥æ‰¾å­—ä¸²s    Trie *ptr = root;           //æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;                  //ç„¡æ­¤å­—ä¸²ï¼Œå›å‚³æ¬¡æ•¸0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    return ptr-&gt;cnt;            //å›å‚³å­—ä¸²å‡ºç¾æ¬¡æ•¸&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;m;    rep(i,0,n-1)&#123;        char s[105];cin&gt;&gt;s;        insert(s);    &#125;    rep(i,0,m-1)&#123;        char s[105];cin&gt;&gt;s;        cout&lt;&lt;find(s)&lt;&lt;endl;    &#125;&#125;\nNEOJ 265 æ¬¸è¿ªçš„å­—ä¸²é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å­—ä¸²Så’Œå­—ä¸²Tï¼Œæ±‚å‡ºSåœ¨Tä¸­å‡ºç¾çš„ä½ç½®\n\né€™ä¸€é¡Œåœ¨éš¨æ©Ÿæ¼”ç®—æ³•ä¹Ÿæœ‰å‡ºç¾éï¼Œç•¶æ™‚æ˜¯ç”¨Rolling Hashçš„æ–¹å¼é€éæ‰£æ‰Hashçš„æ–¹æ³•æ¯”å°å­—ä¸²æ˜¯å¦ç›¸åŒï¼ˆæ¨ä¸€ä¸‹å…¬å¼å°±çŸ¥é“ï¼‰ã€‚ç¾åœ¨è¦ç”¨çš„æ˜¯KMPæ¼”ç®—æ³•ï¼Œå¾ˆè¤‡é›œä¸å¥½æƒ³ã€‚\næ¯”è¼ƒä¸€ä¸‹éš¨æ©Ÿè·ŸKMPçš„æ™‚é–“ï¼Œä¸‹æ–¹ç‚ºKMPï¼Œä¸Šæ–¹å‰‡æ˜¯éš¨æ©Ÿç®—æ³•ï¼Œå…©è€…æ™‚é–“å·®äº†å°‡è¿‘1å€ï¼Œé›–ç„¶å…©è€…éƒ½å¯ä»¥åœ¨O(|T|)æ™‚é–“å…§é€²è¡ŒåŒ¹é…ï¼Œä½†æ˜¯å»ºç«‹Rolling Hashçš„å¸¸æ•¸æ˜¯æ¯”è¼ƒå¤§çš„ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;vector&lt;int&gt; KMP_match(char *S,int *F,char *T)&#123;    vector&lt;int&gt; ans;            //å›å‚³åŒ¹é…ç›¸åŒåœ°æ–¹    int p = -1;                 //ç´€éŒ„çŸ­å­—ä¸²æœ‰å¤šå°‘è¢«åŒ¹é…    for(int i=0;T[i];i++)&#123;      //æ¯ä¸€è¿´åœˆéƒ½è®“T[i]è¢«åŒ¹é…åˆ°        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];           //ä½¿T[i]ä¸€å®šå¯ä»¥è¢«åŒ¹é…åˆ°        if(S[p+1] == T[i])            p += 1;             //Tçš„ç¬¬iå€‹èˆ‡Sçš„p+1å¯ä»¥åŒ¹é…        if(!S[p+1])&#123;            //S[p]å·²ç¶“åŒ¹é…å®Œæˆ            ans.push_back(i-p); //å›æ¨åŒ¹é…é–‹é ­            p = F[p];           //ç¹¼çºŒä¸‹ä¸€è¼ªåŒ¹é…        &#125;    &#125;    return ans;&#125;//O(|S|)è¦é…å°çš„å­—ä¸²ä»¥åŠFail Functionvoid KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;              //åˆå§‹è¨­å®šç‚º-1    for(int i=1;S[i];i++)&#123;          //1åˆ°æ¥ä¸‹ä¾†å­—å…ƒ        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];               //ç„¡æ³•ç¹¼çºŒé…å°ï¼Œå°‹æ‰¾æ›´çŸ­å­—ä¸²        if(S[p+1] == S[i])          //é…å°æˆåŠŸ(å¦‚éƒ½æ²’æœ‰ä¸€æ¨£çš„å°±-1)            p += 1;        F[i] = p;                   //è¨­å®šF[i]    &#125;&#125;signed main()&#123;    Orz;    char S[N],T[N];     //è©¢å•çŸ­å­—ä¸²ã€é•·åœ¨ä¸²    int F[N];           //å¤±æ•—å‡½æ•¸    cin&gt;&gt;S&gt;&gt;T;    KMP_build(S,F);    vector&lt;int&gt; ans = KMP_match(S,F,T);    if(ans.size()&gt;0)&#123;        cout&lt;&lt;ans[0];        rep(i,1,ans.size()-1)cout&lt;&lt;&quot; &quot;&lt;&lt;ans[i];    &#125;    cout&lt;&lt;endl;&#125;\nNEOJ 267 è‡ªå‹•å®Œæˆç³»çµ±é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°é»é€™è£¡æœ‰FB Hacker Cupçš„åŸé¡Œé€£çµï¼Œç°¡å–®ä¾†èªªå°±æ˜¯æƒ³åƒæ‰‹æ©Ÿçš„è‡ªå‹•å¡«å…¥ç³»çµ±ï¼Œæ¯åŠ å…¥ä¸€å€‹å­—ä¸²æœƒè¨˜éŒ„åˆ°è³‡æ–™åº«ä¸­ï¼Œç•¶è³‡æ–™åº«è£¡é¢æ²’æœ‰ç›¸åŒå‰ç¶´çš„å­—ä¸²æ™‚å°±è¼¸å‡ºå‰ç¶´é•·åº¦ã€‚\n\nç”¨å­—å…¸æ¨¹Trieæ’å…¥æ¯ä¸€å€‹å­—ä¸²ï¼Œæ’å…¥éç¨‹ä¸­è¿”å›å¾é ­åˆ°é–‹å§‹newæ–°çš„ç¯€é»ä¹‹é–“ç¶“éçš„ç¯€é»æ¨¹ï¼Œä»£è¡¨éœ€è¦è¼¸å…¥å¤šå°‘å€‹å­—å…ƒæ‰èƒ½è§¸ç™¼è‡ªå‹•å®Œæˆç³»çµ±ã€‚é€™ä¸€é¡Œæ˜¯åŸºç¤çš„Trieæ‡‰ç”¨ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n;char S[N];int ch(char a)&#123;    return a-&#x27;a&#x27;;&#125;struct Trie&#123;    Trie* c[26];    Trie()&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie *root = new Trie();int insert(char *S)&#123;    Trie *ptr = root;    int step = 0,f = 1;    while(*S)&#123;        if(f)step++;        if(!ptr-&gt;c[ch(*S)])&#123;            ptr-&gt;c[ch(*S)] = new Trie();            f = 0;        &#125;        ptr = ptr-&gt;c[ch(*S)];        S++;    &#125;    return step;&#125;void clear(Trie *s)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(s-&gt;c[i])&#123;            clear(s-&gt;c[i]);            delete s-&gt;c[i];            s-&gt;c[i] = nullptr;        &#125;    &#125;&#125;int main()&#123;    cin&gt;&gt;t;    int cnt = 0;    while(t--)&#123;        cnt++;        cin&gt;&gt;n;        int step = 0;        rep(i,0,n-1)&#123;            cin&gt;&gt;S;            step +=insert(S);        &#125;        cout&lt;&lt;&quot;Case #&quot;&lt;&lt;cnt&lt;&lt;&quot;: &quot;&lt;&lt;step&lt;&lt;endl;        clear(root);    &#125;&#125;\nNEOJ 264 æ¬¸è¿ªçš„å­—ä¸²é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä½ å­—ä¸²Sï¼Œæ±‚ä¸€å€‹æœ€çŸ­å­—ä¸²Tçš„é•·åº¦ï¼Œæ»¿è¶³ç¶“ç”±è¤‡è£½è‹¥å¹²æ¬¡å¾Œæ¥èµ·ä¾†æœƒæ˜¯å­—ä¸²Sã€‚\n\né€™ä¸€é¡Œåœ¨ä¸€é–‹å§‹çœ‹åˆ°æ„Ÿè¦ºå¥½é›£ï¼Œä¸éåœ¨æ…¢æ…¢ç†è§£ Z_Algorithm ä¹‹å¾Œï¼Œåœ¨è¬›ç¾©ä¸­ç™¼ç¾åˆ°é€™å€‹å•é¡Œä¹Ÿå¯ä»¥ç”¨é€™å€‹æ¼”ç®—æ³•ä¾†è§£æ±ºï¼å› ç‚ºZå‡½æ•¸æ˜¯æ»¿è¶³å¾ié–‹å§‹çš„æœ€é•·å‰ç¶´ï¼Œå› æ­¤ç•¶ $i$ ç‚º å­—ä¸²é•·åº¦ $n$ çš„å› æ•¸çš„æ™‚å€™ï¼Œåªè¦ $i+Z[i+1]=n$ æˆç«‹ï¼Œå°±å¿…å®šå¯ä»¥ç”¨ $S[1:i]$ çµ„æˆå­—ä¸² $S$ ã€‚å¯¦ä½œä¸Šè¦æ³¨æ„å­—ä¸²æ˜¯0-baseï¼Œi+1å°±ç›¸ç­‰æ–¼å­—ä¸²ç¬¬iå€‹ä½ç½®ï¼Œè™•ç†ä¸Šè¦ç‰¹åˆ¥æ³¨æ„ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;void Z_algo(char *S,int *Z)&#123;    int l = 0,r = 0;    Z[0] = 0;    for(int i=1;S[i];i++)&#123;        Z[i] = max(0,min(Z[i-l],r-i));        while(S[Z[i]]&amp;&amp;S[Z[i]] == S[i+Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    char s[N];cin&gt;&gt;s;    int Z[N],n = strlen(s),ans = n;    Z_algo(s,Z);        rep(i,1,n-1)&#123;        if(n%i==0 &amp;&amp; i+Z[i]==n)&#123;            ans = i;            break;        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nZJ d518: æ–‡å­—æŠ„å¯« IIé¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°è‹¥é€™å€‹å­—ä¸²ä¹‹å‰å·²ç¶“å‡ºç¾éï¼Œå‰‡è¼¸å‡ºçš„å‡ºç¾è™Ÿç¢¼ï¼Œè‹¥æ²’æœ‰å‰‡è¼¸å‡ºå®ƒå°‡è¢«ç·¨å¯«çš„è™Ÿç¢¼.\n\nè£¸é¡ŒTrieï¼Œä¸éè¦æ³¨æ„æ¯ä¸€æ¬¡è¦é‡ç½®ï¼Œå°‡æ‰€æœ‰çš„å¯¦é«”Deleteæ‰ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 110#define Orz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m;struct Trie&#123;    Trie* c[26];    int ind;    Trie(): ind(0)&#123;        memset(c,0,sizeof(c));    &#125;&#125;;Trie* root = new Trie();int ch(char temp)&#123;    return temp-&#x27;a&#x27;;&#125;void clear(Trie *cur)&#123;    for(int i=0;i&lt;26;i++)&#123;        if(cur-&gt;c[i])&#123;            clear(cur-&gt;c[i]);            delete[] cur-&gt;c[i];            cur-&gt;c[i] = NULL;        &#125;    &#125;&#125;void insert(char *s,int num)&#123;    Trie *ptr = root;           //å¾æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;        if(!ptr-&gt;c[ch(*s)])     //å¦‚æœæ¨¹ä¸Šç„¡æ­¤å­—å…ƒå‰‡new            ptr-&gt;c[ch(*s)] = new Trie();        ptr = ptr-&gt;c[ch(*s)];   //ç¹¼çºŒé€ è¨ªTrie        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    ptr-&gt;ind = num;&#125;int find(char *s)&#123;              //æŸ¥æ‰¾å­—ä¸²s    Trie *ptr = root;           //æ ¹ç¯€é»å°‹æ‰¾    while(*s)&#123;                  //ç„¡æ­¤å­—ä¸²ï¼Œå›å‚³æ¬¡æ•¸0        if(!ptr-&gt;c[ch(*s)])return 0;        ptr = ptr-&gt;c[ch(*s)];        s += 1;                 //å­—ä¸²ä¸‹ä¸€å€‹å­—å…ƒ    &#125;    return ptr-&gt;ind;&#125;signed main()&#123;    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;        int ans,cur_id = 1;        rep(i,1,n)&#123;            char s[N];scanf(&quot;%s&quot;,s);            ans = find(s);            if(ans == 0)&#123;                printf(&quot;New! %d\\n&quot;,cur_id);                insert(s,cur_id);                cur_id += 1;            &#125;            else&#123;                printf(&quot;Old! %d\\n&quot;,ans);            &#125;        &#125;        clear(root);    &#125;&#125;\nTIOJ 1306 å­—ä¸²ä¸­çš„å­—ä¸²é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°è£¸å­—ä¸²åŒ¹é…ã€‚å°æ–¼æ¯å€‹è©¢å•è¼¸å‡º $S$ åœ¨ $T$ ä¸­å‡ºç¾éå¹¾æ¬¡ã€‚\n\nè£¸KMPå­—ä¸²åŒ¹é…ï¼Œçµ±è¨ˆå‡ºç¾æ¬¡æ•¸ã€‚å¯ä»¥å˜—è©¦ä¸è¦çœ‹è³‡æ–™è‡ªå·±å¯«ä¸€æ¬¡ï¼Œæœƒæ›´äº†è§£KMPç®—æ³•ï¼\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 10005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int t,n,F[N];;char T[N],S[N];int KMP_match(char *S,char *T,int *F)&#123;    int p = -1,ans = 0;    for(int i=0;T[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=T[i])            p = F[p];        if(S[p+1] == T[i])            p += 1;        if(!S[p+1])&#123;            ans += 1;            p = F[p];        &#125;    &#125;    return ans;&#125;void KMP_build(char *S,int *F)&#123;    int p = F[0] = -1;    for(int i=1;S[i];i++)&#123;        while(p!=-1 &amp;&amp; S[p+1]!=S[i])            p = F[p];        if(S[p+1] == S[i])            p += 1;        F[i] = p;    &#125;&#125;void solve()&#123;    while(n--)&#123;        memset(F,0,sizeof(F));        cin&gt;&gt;S;        KMP_build(S,F);        cout&lt;&lt;KMP_match(S,T,F)&lt;&lt;endl;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T&gt;&gt;n;        solve();    &#125;&#125;\nTIOJ 1321 å¥½å¤šå›æ–‡ ndromePalié¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°çµ¦ä¸€å€‹é•·åº¦ â‰¤ $10^6$ çš„å­—ä¸² Aï¼Œå•æœ‰å¹¾ç¨®æŠŠè©²å­—ä¸²çš„æŸå‰ç¶´æ¬åˆ°æœ€å¾Œé¢çš„æ–¹æ³•ï¼Œä½¿å¾—æœ€å¾Œçš„å­—ä¸²ç‚ºå›æ–‡ã€‚(æç¤º:å¯ä»¥ç”¨é¡ä¼¼ Z å‡½æ•¸çš„æ¦‚å¿µè¨ˆç®—å‡ºä»¥æŸå­—å…ƒç‚ºä¸­å¿ƒçš„æœ€é•·å›æ–‡é•·åº¦ã€‚)\n\né€™ä¸€é¡Œæå¾—æˆ‘å¿«æ›äº†QQQã€‚ç‚ºä»€éº¼å‘¢ï¼Ÿçœ‹çœ‹ä»¥ä¸‹ç…§ç‰‡å°±çŸ¥é“äº†ï¼š\n\næ ¹æ“šä¸Šé¢çš„ã€Œæç¤ºã€ï¼Œè¦ç”¨é¡ä¼¼Zå‡½æ•¸çš„æ¦‚å¿µæŠŠä»¥æŸé»ç‚ºä¸­å¿ƒçš„æœ€é•·å›æ–‡ç®—å‡ºä¾†ã€‚ä¸€å€‹Naiveè£¸çš„ä½œæ³•ï¼ŒæŠŠç”¨ $O(n)$ æšèˆ‰æ¯ä¸€å€‹é»ç‚ºåˆ†å‰²é»ï¼ŒæŠŠåˆ†å‰²é»å‰é¢çš„å­å­—ä¸²æ¥åˆ°å¾Œé¢ï¼Œç”¨ $O(n)$ çš„æ™‚é–“çœ‹æ˜¯å¦ç‚ºä¸€å›æ–‡å­—ä¸²ã€‚å¦‚æ­¤ä¸€ä¾†æ™‚é–“è¤‡é›œåº¦ç‚º $O(n^2)$ ï¼Œå°é€™ä¸€é¡Œä¾†èªªé¡¯ç„¶æ˜¯ä¸å¯è¡Œçš„ï¼Œå› ç‚ºå­—ä¸²é•·åº¦é”åˆ° $10^6$ï¼\nç•¶æˆ‘å€‘ç”¨Manacherâ€™s Algorithm $O(n)$ çš„æ™‚é–“æ¯ä¸€å€‹å­—å…ƒçš„æœ€å¤§å›æ–‡ä¹‹å¾Œï¼Œå°±å¯ä»¥æšèˆ‰æ¯ä¸€å€‹å¯ä»¥ä½œç‚ºåˆ†å‰²é»çš„åœ°æ–¹ï¼Œæª¢æŸ¥å›æ–‡çš„ç‹€æ³ã€‚è¨è«–åˆ†å‰²é»åœ¨å‰åŠéƒ¨åˆ†çš„æƒ…æ³ä¸‹ï¼Œä¹Ÿå°±æ˜¯æŠŠçŸ­çš„ï¼ˆé•·åº¦å°æ–¼ä¸€åŠï¼‰å‰ç¶´æ¬åˆ°å¾Œé¢çš„ç‹€æ³ã€‚ç•¶åˆ†å‰²çš„ç´¢å¼•å€¼ç‚º $i$ ï¼Œå¿…é ˆä¿è­‰ $s[0:i]$ è·Ÿ $s[i:2i]$ å°ç¨±ï¼Œç§»åˆ°å­—ä¸²å°¾å·´æ‰èƒ½æˆç‚ºå›æ–‡ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä¹Ÿå¿…é ˆæ»¿è¶³ $Z[mid+i] = mid-i$ çš„æƒ…æ³ï¼Œä»¥å°±æ˜¯å‰©ä¸‹ä¸æ˜¯åˆ†å‰²é»å…©å´çš„å­—ä¸²å¿…é ˆæ˜¯å›æ–‡ï¼ŒæŠŠå‰ç¶´æ¥åˆ°å¾Œé¢ä¹‹å¾Œæ‰èƒ½å°ç¨±ï¼\nå¯¦ä½œä¸Šå¾ˆå¤šç´°ç¯€ï¼Œæˆ‘DEBUGè¶…ä¹…æœ€å¾Œæ‰æƒ³åˆ°ä¸èƒ½æšèˆ‰æ‰€æœ‰å­—å…ƒï¼Œæœƒå‡ºäº‹ï¼ˆå°±åƒä¸Šé¢çš„ä¸‰è‰²WAï¼‰ï¼Œåªè¦æšèˆ‰ä»¥ $â€™.â€™$ ç‚ºåˆ†å‰²é»çš„æƒ…æ³ï¼ˆåˆ†å‰²åœ¨å­—å…ƒä¸Šå°±ä¸è¡Œï¼‰ï¼Œé‚„æœ‰å¾ˆå¤šç´°ç¯€ï¼ŒWAå¾ˆå¤šæ¬¡æ‰æœƒçŸ¥é“XD\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N];bool ans[2*N];char S[2*N],T[N];//TåŸå­—ä¸²ã€Sæ’å…¥é»å­—ä¸²void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;T;    Longest();        for(int i=0;i&lt;m;i++)Z[i]--;    memset(ans,0,sizeof(ans));        int mid = (m-1)/2,i;        if(Z[mid] == mid)ans[0] = 1;    for(i=2;i&lt;mid;i+=2)&#123;        if(Z[i] == i &amp;&amp; Z[mid+i] == mid-i)&#123;            ans[(i/2)] = 1;        &#125;    &#125;    for(;i&lt;m;i+=2)&#123;        if(Z[i] == m-i-1 &amp;&amp; Z[i-mid] == i-mid)&#123;            ans[(i/2)] = 1;        &#125;    &#125;        int sum = 0;    for(int i=0;i&lt;n;i++)if(ans[i])sum++;    if(sum == 0)cout&lt;&lt;&quot;none&quot;&lt;&lt;endl;    else&#123;        cout&lt;&lt;sum&lt;&lt;&quot;:&quot;;        for(int i=0;i&lt;n;i++)if(ans[i])cout&lt;&lt;&quot; &quot;&lt;&lt;i;        cout&lt;&lt;endl;    &#125;&#125;\nZJ d978: æœ€é•¿å›æ–‡å­—ä¸²é¡Œç›®é€£çµ\n\né¡Œç›®æ•˜è¿°é¡Œç›®å³é¡Œæ„ï¼Œçµ¦ä½ ä¸€å€‹å­—ä¸²ï¼Œæ±‚å‡ºæœ€é•·çš„å›æ–‡å­—ä¸²é•·åº¦ç‚ºä½•ï¼Ÿ\n\nä¸€é¡ŒLPSçš„è£¸é¡Œï¼Œç”¨Manacherâ€™s Algorithmå¯ä»¥å°‡æ™‚é–“è¤‡é›œåº¦åšåˆ° $O(n)$ï¼\n#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 500005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z[2*N],t;bool ans[2*N];char S[2*N],T[N];//TåŸå­—ä¸²ã€Sæ’å…¥é»å­—ä¸²void Longest()&#123;    n = strlen(T);m = 2*n+1;    memset(S,&#x27;.&#x27;,m);    for(int i=0;i&lt;n;i++)S[2*i+1] = T[i];    Z[0] = 1;    int l = 0,r = 0;    for(int i=1;i&lt;m;i++)&#123;        Z[i] = max(min(Z[2*l-i],r-i),1);        while(i-Z[i]&gt;=0 &amp;&amp; i+Z[i] &lt; m &amp;&amp; S[i+Z[i]]==S[i-Z[i]])&#123;            l = i;r = i+Z[i];            Z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;t;    while(t--)&#123;        cin&gt;&gt;T;        Longest();        int ans = 0;        for(int i=0;i&lt;m;i++)&#123;            int z = (Z[i]-1);            ans = max(ans,z);        &#125;        cout&lt;&lt;ans&lt;&lt;endl;    &#125;&#125;\nTIOJ 1725 Massacre at Camp Happyé¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°ï¼šå®šç¾©å­—ä¸² A å’Œ Bã€Œk-å¹¾ä¹ç›¸åŒã€ä»£è¡¨æŠŠå­—ä¸² A çš„å‰ k å­—å…ƒæ¬åˆ°æœ€å¾Œé¢æ™‚ï¼Œèˆ‡ B æ°æœ‰ä¸€å€‹å­—å…ƒç›¸ç•°ã€‚çµ¦ä½ å…©å€‹é•·åº¦ â‰¤ $10^6$ çš„å­—ä¸² A å’Œ Bï¼Œæ±‚æ‰€æœ‰ä½¿ A å’Œ Bã€Œk-å¹¾ä¹ç›¸åŒã€æˆç«‹çš„ k å€¼ã€‚\n\né€™ä¸€é¡Œå¥½ç‰¹åˆ¥ï¼Œä¸€æ¨£è¦ç”¨ $O(n)$ çš„æ™‚é–“æ±‚å‡ºç­”æ¡ˆï¼Œå°æ–¼æ¯ä¸€å€‹æ“ä½œå°‡å‰kå€‹å­—å…ƒæ¬åˆ°å¾Œé¢ï¼Œåªèƒ½ç”¨ $O(1)$ ç®—å‡ºä¾†åˆ°åº•ç¬¦ä¸ç¬¦åˆä¸€å­—å…ƒç›¸ç•°çš„æ¢ä»¶ã€‚ä»¥å…©å€‹ç›¸ç­‰é•·åº¦çš„å­—ä¸² $A,B$ ç‚ºä¾‹ï¼Œé•·åº¦ç‚º $l$ï¼Œå‡è¨­ $A=aabba,B = aacba$ï¼Œå…©è€…ç›¸å·®ä¸€å€‹å­—å…ƒçš„æƒ…æ³ä¸‹ï¼Œå¿…å®šæœƒæ»¿è¶³$l = LCP(A,B)+LCP(rev(A),rev(B))+1$ï¼Œå…¶ä¸­revå‡½æ•¸è¡¨ç¤ºreverseã€‚\næˆ‘å€‘è¦åšçš„å°±æ˜¯åœ¨ $O(1)$ çš„æ™‚é–“å…§æ±‚å‡ºLCPï¼Œå› ç‚ºé¡Œç›®çš„å­—ä¸² $A$ è¦æ±‚ä¸åŒçš„èµ·å§‹ä½ç½®ï¼Œå› æ­¤æˆ‘å€‘å‡è¨­ä¸€å€‹éå¸¸ç‰¹åˆ¥çš„å­—ä¸² $B@AA$ ï¼Œå…¶ä¸­@ç‚ºä»»æ„æ²’å‡ºç¾éçš„å­—å…ƒã€‚åªè¦è¨ˆç®—é€™ä¸€å€‹å­—ä¸²çš„Zå‡½æ•¸ï¼Œå°±è¡¨ç¤ºäº† $A$ å’Œ $B$ çš„æœ€é•·å…±åŒå‰ç¶´ï¼Œéœ€è¦å…©å€‹Açš„åŸå› æ˜¯å› ç‚ºæ¨¡æ“¬ä¸åŒçš„k-ä½ç§»ä¸‹æƒ…å½¢ã€‚\n\n\n            å¯¦ä½œå°ç´°ç¯€ç¨‹å¼ç¢¼çš„ç¬¬42è¡Œå¯ä»¥è©¦è‘—æ¨æ¨çœ‹é€†åºä¹‹å¾Œçš„å°¾å·´çš„ç´¢å¼•å€¼ç‚ºä½•ã€‚æˆ‘æ˜¯åˆ©ç”¨åˆ—å‡ºå¹¾å€‹æ•¸å­—ä¹‹å¾Œæ¨å‡ºä¾†çš„ï¼Œä¸éæ‡‰è©²å¯ä»¥å¯«æˆæ¯”è¼ƒåš´è¬¹çš„æ•¸å­¸è­‰æ˜ï¼Z1[n+1+i]+Z2[2*n-i+1]+1 == n\n          \næ™‚é–“è¤‡é›œåº¦$O(n)$ å»ºç«‹zå‡½æ•¸ï¼Œ$O(n)$ æšèˆ‰æ¯ä¸€å€‹èµ·å§‹é»ï¼Œç¸½æ™‚é–“ç‚º $O(n)$ã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 1000005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,m,Z1[3*N],Z2[3*N];char A[3*N],B[3*N];void Z_algo(int *z,char *S)&#123;    int l = 0,r = 0;    z[0] = 0;    for(int i=1;i&lt;m;i++)&#123;        z[i] = max(min(z[i-l],r-i),0);        while(S[i+z[i]] &amp;&amp; S[z[i]] == S[i+z[i]])&#123;            l = i;r = i+z[i];            z[i]++;        &#125;    &#125;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n&gt;&gt;A&gt;&gt;B;    m = 3*n+1;    B[n] = &#x27;@&#x27;;    //æ­£å¸¸åºåˆ—æ±‚Z value    rep(i,n+1,2*n)B[i] = A[i-n-1];    rep(i,2*n+1,3*n)B[i] = A[i-2*n-1];    Z_algo(Z1,B);    //é€†åºæ±‚Z value    reverse(B,B+n);reverse(B+n+1,B+m);    Z_algo(Z2,B);        vector&lt;int&gt; vec;    for(int i=0;i&lt;n;i++)&#123;        if(Z1[n+1+i]+Z2[2*n-i+1]+1 == n)vec.push_back(i);    &#125;    if(vec.size())&#123;        cout&lt;&lt;&quot;TAK&quot;&lt;&lt;endl;        for(auto i:vec)cout&lt;&lt;i&lt;&lt;&quot; &quot;;        cout&lt;&lt;endl;    &#125;    else cout&lt;&lt;&quot;NIE&quot;&lt;&lt;endl;    &#125;//[0,n-1][n,n][n+1,2n][2n+1,3n]\nTIOJ 1497 å–é†‰çš„å®¿ä¸» The drunk hosté¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°è£¸å¾Œç¶´æ•¸çµ„ã€‚\n\nå¾Œç¶´æ•¸çµ„æˆ‘çœ‹äº†å¥½ä¹…ï¼ˆå¤§æ¦‚æœ‰4å¤©å§ï¼‰ï¼Œä¸€ç›´å°è‘—å®ƒç™¼å‘†ï¼Œä¸çŸ¥é“å®ƒçš„ç²¾é«“åˆ°åº•åœ¨å“ªè£¡ã€‚ã€‚å‰›å¥½åˆé‡åˆ°é–‹å­¸ï¼Œä¸èƒ½æ•´å¤©å¿«æ¨‚å¯«é¡ŒXD\nå€å¢å„ªåŒ–å°è‘—è¢å¹•ç™¼å‘†çš„æ—¥å­çµ‚æ–¼çµæŸäº†ï¼Œç›´åˆ°æˆ‘çœ‹äº†é€™ä¸€ç¯‡ï¼ˆé›–ç„¶èªªæˆ‘å‰å¹¾å¤©ä¹Ÿæœ‰çœ‹ä½†çœ‹ä¸æ‡‚ï¼Œå¯èƒ½æ˜¯æ¶ˆåŒ–çš„å¤©æ•¸ä¸å¤ å¤šå§ï¼‰ï¼Œå°¤å…¶æ˜¯è£¡é¢çš„ä¸€å¼µåœ–ï¼Œæ·±åˆ»èªªæ˜äº†å€å¢çš„ç²¾é«“ã€‚\nå¾Œç¶´æ•¸çµ„æ±‚æ³•å°±ä¸å¤šè§£é‡‹ï¼ˆä¸Šé¢æœ‰ï¼‰ï¼Œæ”¾å¹¾å€‹å¯¦ä½œä¸Šçš„å°ç´°ç¯€ã€‚\n\n            å¯¦ä½œå°ç´°ç¯€æˆ‘å€‘è¦æ±‚é€²è¡Œ $O(\\log n)$ å±¤çš„å€å¢ï¼Œå¯ä»¥ä½¿ç”¨C++å…§å»ºçš„log10()å†ç”¨ceilå»è™•ç†ï¼Œä½†é¡¯ç„¶æœ‰é»æ…¢ï¼Œå¦‚æœå¥—ç”¨ä»¥ä¸‹å‡½æ•¸ï¼Œå®ƒæœƒå›å‚³æ•¸å­—äºŒé€²ä½ä¹‹å¾Œæœ€å¤§çš„1å‰é¢ç¸½å…±æœ‰å¤šå°‘å€‹0ï¼ˆå‰ç¶´0çš„æ•¸é‡ï¼‰ï¼Œèˆ‡32ç›¸æ¸›ï¼ˆ32æ˜¯long longçš„é—œä¿‚ï¼‰å°±æ˜¯æˆ‘å€‘è¦çš„logçš„æ¬¡æ•¸ã€‚int lg = __builtin_clz(n)å¦å¤–ä¸€å€‹å°å°ç´°ç¯€ï¼Œå°±æ˜¯åœ¨å­—ä¸²çš„å¾ŒåŠéƒ¨åˆ†ï¼Œå¦‚æœè·Ÿå‰é¢ä¸€æ¨£å€å¢ä¸€å€‹æ¯”è¼ƒå¤§çš„æ•¸å­—ï¼Œæœ‰å¯èƒ½æœƒè¶…å‡ºç¯„åœï¼Œé€™æ™‚å€™åˆå§‹å€¼å°±å¾ˆé‡è¦äº†ï¼åˆå§‹è¨­å®šrk[n] = -1ï¼Œå°è‡´ä»»ä½•åªè¦è¶…å‡ºç¯„åœçš„éƒ½æœƒå–åˆ°é€™å€‹-1ï¼Œè¡¨ç¤ºåªè¦å¾Œé¢æ²’æœ‰å­—ä¸²ã€å¦‚æœå‰é¢éƒ½ç›¸åŒä½†é•·åº¦æ¯”è¼ƒé•·çš„å­—ä¸²æ¯”èµ·ä¾†ï¼Œè¼ƒçŸ­çš„æœƒæ’åœ¨æ¯”è¼ƒå‰é¢çš„ä½ç½®ï¼\n          \né€™å€‹ç®—æ³•æ˜¯ $O(n\\log^2 n)$ï¼ŒTIOJé€™ä¸€é¡Œå¯ä»¥éï¼Œä¸éåˆ°SPOJå°±æœƒè¢«å¡TLE\n\n$O(n^2 log(n))$ is expected to score about 20-30. (Naive sorting all suffixes)$O(n log^2(n))$ is expected to score about 40. (OK for most programming contest problems)$O(n log n)$ is expected to score about 60-70. (Use counting sort for small alphabet size)$O(n)$ without tweaks is expected to score about 80-90.$O(n)$ with tweaks is expected to score 100. (This is meant for fun only :)\n\nè¶Šå¾Œé¢å°±è¶Šæ¯’ç˜¤XD\n\ntest 1 - AC (score=0.000000, sig=0, time=0.009123, mem=5372)test 2 - AC (score=0.000000, sig=0, time=0.006427, mem=5508)test 3 - AC (score=0.000000, sig=0, time=0.014975, mem=5468)test 4 - AC (score=0.000000, sig=0, time=0.031332, mem=5536)test 5 - AC (score=0.000000, sig=0, time=0.026948, mem=5456)test 6 - AC (score=0.000000, sig=0, time=0.023113, mem=5396)test 7 - TLE (score=0.000000, sig=0, time=0.210000, mem=7340)test 8 - TLE (score=0.000000, sig=0, time=0.210000, mem=7152)test 9 - AC (score=0.000000, sig=0, time=0.170094, mem=7284)test 10 - AC (score=0.000000, sig=0, time=0.140098, mem=7340)\n\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//ç¬¬ä¸€ä½ã€ç¬¬äºŒä½æ¯”è¼ƒä»¥åŠå¾Œç¶´ç·¨è™Ÿbool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //å›å‚³ç¬¬ä¸€å€‹1ä¹‹å‰0çš„å€‹æ•¸ï¼ˆäºŒé€²ä½ï¼‰    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //ç¾åœ¨å€å¢çš„å¤§å°        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)&#123;            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //è¨­å®šrkï¼Œèˆ‡å‰ä¸€å€‹ç›¸åŒå‰‡è¨­å®šè·Ÿå‰ä¸€å€‹ä¸€æ¨£        &#125;        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\nRadix Sort å„ªåŒ–Submission\næ¯”è¼ƒä¸€ä¸‹ $O(n\\log^2 n)$ ä»¥åŠ $O(n\\log n)$ çš„æ™‚é–“ï¼Œå…©è€…èŠ±äº†è¿‘å…©å€çš„æ™‚é–“å·®è·ã€‚çœ‹äº†ä¸€ä¸‹é€™ä¸€é¡Œçš„TopCoderï¼Œç«Ÿç„¶å¯ä»¥åšåˆ°åä½æ•¸æ¯«ç§’ï¼å¦‚æœè¦ç¹¼çºŒå„ªåŒ–æˆç·šæ€§ $O(n)$ çš„è¤‡é›œåº¦ï¼Œå°±æœƒä½¿ç”¨åˆ° DC3 çš„æ¼”ç®—æ³•ï¼Œé›–ç„¶å¥½åƒå¾ˆè¤‡é›œä¸å¯¦ç”¨QQ\n\n\n\nä½¿ç”¨ $O(n\\log^2n)$ çš„ç®—æ³•æœƒTLEç¬¬å…«ã€ä¹ç­†æ¸¬è³‡ï¼Œä¸éä½¿ç”¨åŸºæ•¸æ’åºå°±å¯ä»¥ACäº†ï¼\n\ntest 1 - AC (score=0.000000, sig=0, time=0.006565, mem=6048)test 2 - AC (score=0.000000, sig=0, time=0.006594, mem=6300)test 3 - AC (score=0.000000, sig=0, time=0.012431, mem=7860)test 4 - AC (score=0.000000, sig=0, time=0.012267, mem=7208)test 5 - AC (score=0.000000, sig=0, time=0.011158, mem=6804)test 6 - AC (score=0.000000, sig=0, time=0.012057, mem=7892)test 7 - AC (score=0.000000, sig=0, time=0.140876, mem=17720)test 8 - AC (score=0.000000, sig=0, time=0.077631, mem=21952)test 9 - AC (score=0.000000, sig=0, time=0.074905, mem=21340)test 10 - AC (score=0.000000, sig=0, time=0.076732, mem=30160)\n\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define N 100005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//ç¬¬ä¸€ä½ã€ç¬¬äºŒä½æ¯”è¼ƒä»¥åŠå¾Œç¶´ç·¨è™Ÿvector&lt;pt&gt; temp,box[N];void init()&#123;    temp.clear();    rep(i,0,n-1)box[i].clear();&#125;bool cmp(pt a,pt b)&#123;    if(a.x == b.x)return a.y &lt; b.y;    return a.x &lt; b.x;&#125;void raddix_sort(vector&lt;pt&gt; &amp;cur)&#123;    init();    rep(i,0,n-1)&#123;        if(cur[i].y == -1)temp.push_back(cur[i]);        else box[cur[i].y].push_back(cur[i]);    &#125;    rep(i,0,n-1)        for(auto j : box[i])temp.push_back(j);    rep(i,0,n-1)box[i].clear();    rep(i,0,n-1)        box[temp[i].x].push_back(temp[i]);    cur.clear();    rep(i,0,n-1)        for(auto j : box[i])cur.push_back(j);&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);//å›å‚³ç¬¬ä¸€å€‹1ä¹‹å‰0çš„å€‹æ•¸ï¼ˆäºŒé€²ä½ï¼‰    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1) cur[i] = &#123;S[i],0,i&#125;;    sort(all(cur),cmp);    rk[cur[0].id] = 0;    rep(i,1,n-1)        rk[cur[i].id] = (cur[i]==cur[i-1])?rk[cur[i-1].id]:i;    rep(i,0,n-1)cur[i] = &#123;rk[i],0,i&#125;;    rep(p,0,lg)&#123;                //é€²è¡ŒO(lgn)æ¬¡        int k = 1 &lt;&lt; p;         //ç¾åœ¨å€å¢çš„å¤§å°        raddix_sort(cur);        rk[cur[0].id] = 0;        rep(i,1,n-1)            //è¨­å®šrkï¼Œèˆ‡å‰ä¸€å€‹ç›¸åŒå‰‡è¨­å®šè·Ÿå‰ä¸€å€‹ä¸€æ¨£            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);        rep(i,0,n-1)            //å€å¢pairçš„second            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;    &#125;    raddix_sort(cur);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;signed main()&#123;    Orz;    string S;getline(cin,S);    suffix_array(S);    rep(i,0,n-1)cout&lt;&lt;sa[i]&lt;&lt;&#x27;\\n&#x27;;&#125;\nTIOJ 1515 Problem E. ä¼¼æ›¾ç›¸è­˜é¡Œç›®é€£çµSubmission\n\né¡Œç›®æ•˜è¿°è£¸å¾Œç¶´æ•¸çµ„ LCPã€‚\n\né€™é¡Œæˆ‘æƒ³å¥½ä¹…ï¼Œä¸€ç›´æƒ³ä¸é€šè½‰ç§»çš„æ¢ä»¶ä»¥åŠk-1çš„åŸå› ï¼Œä¸éæœ€å¾Œé‚„æ˜¯æƒ³é€šäº†ï¼é€™ä¸€é¡Œåªè¦æŠŠ $lcp$ æ±‚å‡ºä¾†ä¹‹å¾Œï¼Œæ‰¾æœ€å¤§å€¼å°±æ˜¯é¡Œç›®è¦æ±‚çš„ç­”æ¡ˆã€‚\nç¨‹å¼ç¢¼#include &lt;bits/stdc++.h&gt;#define ll long long#define ld long double#define int long long#define N 200005#define Orz ios::sync_with_stdio(0),cin.tie(0)#define INF 2e18#define rep(i,l,r) for(int i=l;i&lt;=r;i++)#define all(x) x.begin(),x.end()#define pii pair&lt;int,int&gt;#define x first#define y secondusing namespace std;int n,sa[N];struct pt&#123;    int x,y,id;    bool operator==(pt b)&#123;        if(x==b.x &amp;&amp; y==b.y)return true;        return false;    &#125;&#125;;//ç¬¬ä¸€ä½ã€ç¬¬äºŒä½æ¯”è¼ƒä»¥åŠå¾Œç¶´ç·¨è™Ÿbool cmp(pt a,pt b)&#123;    if(a.x != b.x)return a.x &lt; b.x;    return a.y &lt; b.y;&#125;void suffix_array(string S)&#123;    n = S.size();    int lg = 32-__builtin_clz(n);    //å›å‚³ç¬¬ä¸€å€‹1ä¹‹å‰0çš„å€‹æ•¸ï¼ˆäºŒé€²ä½ï¼‰    vector&lt;pt&gt; cur(n,&#123;0,0,0&#125;);    vector&lt;int&gt; rk(n+1,-1);    rep(i,0,n-1)cur[i] = &#123;S[i],0,i&#125;;    rep(p,0,lg)&#123;        int k = 1 &lt;&lt; p;         //ç¾åœ¨å€å¢çš„å¤§å°        sort(all(cur),cmp);        rk[cur[0].id] = 0;        rep(i,1,n-1)            rk[cur[i].id] = (cur[i-1]==cur[i] ? rk[cur[i-1].id]:i);            //è¨­å®šrkï¼Œèˆ‡å‰ä¸€å€‹ç›¸åŒå‰‡è¨­å®šè·Ÿå‰ä¸€å€‹ä¸€æ¨£        rep(i,0,n-1)&#123;            cur[i] = &#123;rk[i],rk[min(n,i+k)],i&#125;;        &#125;    &#125;    sort(all(cur),cmp);    rep(i,0,n-1)sa[i] = cur[i].id;&#125;vector&lt;int&gt; LCP(string s)&#123;    vector&lt;int&gt; rk(n,0),lcp(n,0);    rep(i,0,n-1)rk[sa[i]] = i;      //åˆ©ç”¨saåå‡½æ•¸å¾—åˆ°rk    int k = 0;    rep(i,0,n-1)&#123;        if(k)k--;        if(rk[i] == n-1)continue;   //rk[n-1]æœªå®šç¾©        int j = sa[rk[i]+1];        //ä¸‹ä¸€åå¾Œç¶´å¾ä½•é–‹å§‹        while(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; s[i+k] == s[j+k])k++;        lcp[rk[i]] = k;    &#125;    return lcp;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;cin.ignore();    string S;getline(cin,S);    suffix_array(S);    vector&lt;int&gt; lcp = LCP(S);        int ans = 0;    rep(i,0,n-1)ans = max(lcp[i],ans);    cout&lt;&lt;ans&lt;&lt;endl;&#125;\nå¿ƒå¾—å­—ä¸²æ¼”ç®—æ³•è·Ÿæœ€çŸ­è·¯å¾‘ã€è¨ˆç®—å¹¾ä½•æ¯”èµ·ä¾†ï¼Œæ•¸å­¸æ¨å°æˆåˆ†å°±å¤šäº†å¾ˆå¤šï¼Œæœ‰è¨±å¤šçš„éè¿´æ¦‚å¿µï¼Œä¾‹å¦‚å¤±æ•—å‡½æ•¸ä»¥åŠzå‡½æ•¸çš„æ¦‚å¿µï¼Œä¹Ÿæœ‰å¾ˆå¤šæ˜¯è¦ç†è§£åœ¨ä¸åŒæ¢ä»¶ä¸‹åšä»€éº¼äº‹ï¼Œä»¥åŠå…¶ä»–å„ªåŒ–è™•ç†ã€‚æœ€åˆçš„æ˜¯å­—å…¸æ¨¹Trieï¼Œå°±æ˜¯ä¸€äº›è³‡æ–™çµæ§‹çš„é‹ç”¨ï¼›æ¥ä¸‹ä¾†çš„KMPã€Z Algorithmä»¥åŠLPSå°±å¾ˆåƒè§€å¿µï¼Œè¿½è¹¤æ•´å€‹ç¨‹å¼çš„éç¨‹ã€‚æœ€å¾Œæ˜¯å¾Œç¶´æ•¸çµ„ï¼Œåœ¨é€™é‚Šå¡äº†è¶…ä¹…ï¼Œé²é²ç„¡æ³•ç†è§£å€å¢çš„æ¦‚å¿µã€ä»¥åŠLCPçš„ä½œæ³•ã€‚å¯èƒ½é€™å°±æ˜¯é “æ‚Ÿå§ï¼Œæ¯å¤©çœ‹äº†åŒç¯‡è§£èªªå¾ˆä¹…ä¹‹å¾Œï¼Œç¸½æœ‰ä¸€å¤©æœƒçªç„¶é “æ‚Ÿï¼Œæƒ³åˆ°æ¼”ç®—æ³•çš„ç²¾é«“ï¼\n","categories":["C++é€²éšä¸»é¡Œ","å­—ä¸²æ¼”ç®—æ³•"],"tags":["æ¼”ç®—æ³•","å­—ä¸²"]},{"title":"æ­æ‹‰å‡½æ•¸ (Euler's Ï† Function)","url":"/totient/","content":"å¤šå…ƒé¸ä¿®èª²æåˆ°æ­æ‹‰å‡½æ•¸ $\\phi$ï¼Œæƒ³èªªè »æœ‰è¶£çš„å¯ä»¥è·Ÿç¨‹å¼çµåˆä¸€ä¸‹ï¼Œçœ‹æœƒç™¼ç”Ÿä»€éº¼æœ‰è¶£çš„äº‹æƒ…ï¼\nå®šç¾©èˆ‡å…¬å¼å°æ–¼ä¸€å€‹æ­£æ•´æ•¸ $n$ï¼Œæ­æ‹‰å‡½æ•¸ $\\phi(n)$ è¡¨ç¤ºé–‰å€é–“ $[1,n]$ ä¸­çš„æ­£æ•´æ•¸èˆ‡ $n$ äº’è³ªçš„å€‹æ•¸ã€‚å®šç¾©åºåˆ— $p$ ç‚ºæ‰€æœ‰æ­£æ•´æ•¸ $n$ è³ªå› æ•¸åˆ†è§£ä¹‹å¾Œçš„æ•¸å­—ã€‚åœ¨ä¸å¤±ä¸€èˆ¬æ€§çš„å‡è¨­åºåˆ— $p$ çš„é•·åº¦ç‚º $r$ï¼Œä»¥è³ªå› æ•¸åˆ†è§£è¡¨ç¤º $n$ å³ç‚º $n = p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_r^{k_r}$ï¼Œå‰‡æ­æ‹‰å‡½æ•¸æ»¿è¶³ä»¥ä¸‹é—œä¿‚å¼ï¼š\n\\begin{split}\\phi(n) &= n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r})\n\\\\&=n\\prod_{p|n}(1-\\frac{1}{p})\n\\end{split}\nç‰¹åˆ¥å®šç¾© $\\phi(1) = 1$\nä¾†çœ‹çœ‹å¯¦éš›çš„ä¾‹å­ï¼Œä»¥20ç‚ºä¾‹ã€‚ä»¥è³ªå› æ•¸åˆ†è§£ä¾†çœ‹ï¼Œ$20 = 2^2\\times 5$ï¼Œå› æ­¤åºåˆ— $p = {2,5}$ï¼Œå‰‡æ­æ‹‰å‡½æ•¸ $\\phi(20) = 20\\times (1-\\frac{1}{2})(1-\\frac{1}{5}) = 8$ï¼Œç¨å¾®é©—è­‰ä¸€ä¸‹ï¼Œå¾1åˆ°20çš„æ­£æ•´æ•¸ä¸­ï¼Œèˆ‡20äº’è³ªçš„æœ‰ $1,3,7,9,11,13,17,19$ ä¸€å…±8å€‹æ•¸å­—ã€‚\næ¨å°èˆ‡è­‰æ˜è­‰æ˜1è­‰æ˜ä¸€å€‹å…¬å¼ï¼Œå¯ä»¥å…ˆå¤šåŠ ä¸Šä¸€äº›é™åˆ¶ï¼Œå¾ç°¡å–®æ¨å°åˆ°è¼ƒè¤‡é›œçš„æƒ…æ³ã€‚\n\n$n$ æ˜¯è³ªæ•¸é€™ç¨®æƒ…æ³æ¯”è¼ƒå¥½è™•ç†ï¼Œå› ç‚ºæ‰€æœ‰å°æ–¼ç­‰æ–¼ $n$ çš„æ­£æ•´æ•¸éƒ½æœƒå’Œ $n$ äº’è³ªï¼Œå› æ­¤å°æ–¼ $n$ æ˜¯è³ªæ•¸çš„æƒ…æ³ä¸‹ï¼š\n\\phi(n) = n-1\n$n$ æ˜¯åˆæ•¸é¦–å…ˆçœ‹ç°¡åŒ–çš„æƒ…æ³ã€‚å‡è¨­ $n = p^a$ï¼Œå…¶ä¸­ $p$ ç‚ºè³ªæ•¸ï¼Œ$a$ ç‚ºä¸€å¤§æ–¼ç­‰æ–¼2çš„æ­£æ•´æ•¸ã€‚å› ç‚º $p$ æ˜¯è³ªæ•¸ï¼Œæ‰€æœ‰ä¸å’Œ $p$ äº’è³ªçš„æ•¸å­—å¤§æ¦‚æœƒæ˜¯ä»¥ä¸‹é€™äº›ï¼š$p,2p,3p,â€¦,(p^{a-1})p$ï¼Œä¸€å…±æœ‰ $p^{a-1}$ å€‹æ•¸å­—ã€‚æˆ‘å€‘åªè¦æŠŠæ‰€æœ‰çš„æ•¸å­—æ‰£æ‰é€™äº›å³ç‚ºæ­æ‹‰å‡½æ•¸ $\\phi$ çš„å‡½æ•¸å€¼ï¼š\n\\phi(p^a) = p^a - p^{a-1} = p^a(1-\\frac{1}{p})\n\nç”±é€™å€‹å¼å­æ¨å»£åˆ°æ­æ‹‰å‡½æ•¸åŸæœ¬çš„å…¬å¼ã€‚æˆ‘å€‘è®“ $n = p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_r^{k_r}$ï¼Œå› ç‚ºæ­æ‹‰å‡½æ•¸ç‚ºä¸€ç©æ€§å‡½æ•¸ï¼Œæ»¿è¶³ $\\phi(nm) = \\phi(n)\\phi(m)$ï¼Œå…¶è­‰æ˜å¦‚ä¸‹ï¼š\nè§€å¯Ÿä¸€å€‹æœ‰ $m$ åˆ— $n$ è¡Œçš„çŸ©é™£ï¼Œä¸€å…±æœ‰ $mn$ å€‹æ•¸å­—ï¼Œå¾ $1$ åˆ° $mn$ ã€‚å¦‚ä»¥ä¸‹çŸ©é™£ï¼š\n\\begin{matrix}\n1 & 2 & \\cdots & n\n\\\\n+1 & n+2 & \\cdots & 2n\n\\\\\\vdots&\\vdots&\\ddots&\\vdots\n\\\\(m-1)n+1 &  & \\cdots & mn\n\\end{matrix}\\quadå› ç‚ºæ¯ä¸€åˆ—éƒ½æ˜¯åŠ ä¸Šä¸å®šæ•¸é‡çš„ $n$ï¼Œæˆ‘å€‘å¾ç¬¬ä¸€åˆ—æŒ‘å‡º $\\phi(n)$ å€‹èˆ‡ $n$ äº’è³ªçš„æ•¸ï¼Œå…¶ä»–æ¯ä¸€åˆ—ä¹Ÿéƒ½æ˜¯å¦‚æ­¤ï¼ŒæŠŠä»–å€‘è¨­ç‚º $t1,t_2,â€¦,t{\\phi(n)}$ï¼š\n\\begin{matrix}\nt_1 & t_2 & \\cdots & t_{\\phi(n)}\n\\\\n+t_1 & n+t_2 & \\cdots & n+t_{\\phi(n)}\n\\\\\\vdots&\\vdots&\\ddots&\\vdots\n\\\\(m-1)n+t_1 &  & \\cdots & (m-1)n+t_{\\phi(n)}\n\\end{matrix}\\quadè§€å¯Ÿä¸€ä¸‹æ¯ä¸€ç›´è¡Œï¼Œç”±æ–¼ $n$ å’Œ $m$ äº’è³ªï¼ŒåŒä¸€ç›´è¡Œä¸­çš„æ¯ä¸€å€‹æ•¸å­—å’Œ $m$ éƒ½æœƒä¸åŒé¤˜ã€‚åœ¨ä¸åŒé¤˜çš„æƒ…æ³ä¸‹ï¼Œæ¯ä¸€ç›´è¡Œéƒ½æœƒæœ‰ $\\phi(m)$ å€‹èˆ‡ $m$ äº’è³ªçš„æ•¸å­—ã€‚å› æ­¤ï¼Œå¾ä¸Šé¢çš„çŸ©é™£å¯ä»¥ç™¼ç¾ç¸½å…±æœ‰ $\\phi(n)\\phi(m)$ å€‹èˆ‡ $nm$ äº’è³ªçš„æ•¸å­—ï¼Œå› æ­¤æœ‰$\\phi(nm)=\\phi(n)\\phi(m)$ã€‚\næœ‰äº†ä¸Šè¿°æ€§è³ªä¹‹å¾Œï¼Œæˆ‘å€‘å°±å¯ä»¥ç›´æ¥æ¨å°å…¬å¼ï¼š\n\\begin{split}\\phi(n) &=\\phi(p_1^{k_1})\\cdot\\phi(p_2^{k_2})\\cdots\\phi(p_r^{k_r})\n\\\\&=p_1^{k_1}(1-\\frac{1}{p_1})\\cdot p_2^{k_2}(1-\\frac{1}{p_2})\\cdots p_r^{k_r}(1-\\frac{1}{p_r})\n\\\\&=p_1^{k_1}\\cdot p_2^{k_2}\\cdots p_r^{k_r}\\cdot(1-\\frac{1}{p_1})\\cdot(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r})\n\\\\&= n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})\\cdots(1-\\frac{1}{p_r})\\end{split}ä»¥ä¸Šå°±æ˜¯æ­æ‹‰å‡½æ•¸å…¬å¼çš„æ¨å°éç¨‹ï¼\nè­‰æ˜2ä½¿ç”¨åˆ°çš„æ˜¯æ’å®¹åŸç†ã€‚é€™å€‹è­‰æ˜å°±æ²’æœ‰åƒä¸Šé¢é‚£éº½ç¹é›œï¼Œä¸éæœ‰é»é›£ç†è§£å°±æ˜¯äº†ã€‚é¦–å…ˆæˆ‘å€‘è¨è«– $n$ çš„è³ªå› æ•¸åˆ†è§£ç”±ä¸‰å€‹è³ªæ•¸çµ„æˆï¼Œå¯«æˆï¼š$n = p_1^{k_1}\\cdot p_2^{k_2}\\cdot p_3^{k_3}$ï¼Œå‡è¨­åœ¨å°æ–¼ç­‰æ–¼ $n$ ä¸­èƒ½è¢« $p_1$,$p_2$,$p_3$ çµ¦æ•´é™¤çš„æ•¸å­—é›†åˆç‚º $A_1,A_2,A_3$ï¼Œå‰‡æˆ‘å€‘è¦æ±‚çš„å°±æ˜¯ï¼š\n(A_1' \\cap A_2' \\cap A_3') = (A_1 \\cup A_2 \\cup A_3)'æˆ‘å€‘è¦æ±‚çš„å°±æ˜¯è¯é›†çš„è£œé›†çš„éƒ¨åˆ†ï¼š\né€™æ˜¯å…¬å¼å±•é–‹çš„æƒ…æ³ï¼š\n\\begin{split}\\phi(n) &= n(1-\\frac{1}{p_1})(1-\\frac{1}{p_2})(1-\\frac{1}{p_3})\n\\\\&=n(1-\\frac{1}{p_1}-\\frac{1}{p_2}-\\frac{1}{p_3}+\\frac{1}{p_1p_2}+\\frac{1}{p_1p_3}+\\frac{1}{p_2p_3}-\\frac{1}{p_1p_2p_3})\n\\\\&=(n-\\frac{n}{p_1}-\\frac{n}{p_2}-\\frac{n}{p_3}+\\frac{n}{p_1p_2}+\\frac{n}{p_1p_3}+\\frac{n}{p_2p_3}-\\frac{n}{p_1p_2p_3})\\end{split}é€™å±•é–‹ä¹‹å¾Œè·Ÿé›†åˆå¯«æˆçš„æ¨£å­æ˜¯ä¸€æ¨£çš„ï¼Œæ ¹æ“šæ’å®¹åŸç†ä¹Ÿé–“æ¥è­‰æ˜å…¬å¼çš„æ­£ç¢ºæ€§ï¼\nç¨‹å¼å¯¦ç¾åŸºæœ¬æ¦‚å¿µå°±æ˜¯å¾2é–‹å§‹å¾€å¾Œæ‰¾æ‰€æœ‰çš„è³ªå› æ•¸ï¼Œå› ç‚ºå€‹æ•¸ä¸é‡è¦ï¼Œåªè¦æ¯ä¸€æ¬¡æ‰¾åˆ°ä¹‹å¾Œæ›´æ–°ç­”æ¡ˆå³å¯ã€‚å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæœ€å¾Œå¿…é ˆå°å‰©ä¸‹çš„ $n$ åœ¨åšä¸€æ¬¡ï¼Œå…¶åŸå› ä¸é›£ç†è§£ï¼Œç•¶æˆ‘æœ‰å…©å€‹è³ªå› æ•¸å‰©ä¸‹é‚„æ²’æœ‰è¢« i èµ°éçš„æ™‚å€™ï¼Œå› ç‚ºå…©å€‹äº’è³ªï¼Œå› æ­¤å¿…å®šæœ‰ä¸€å€‹æ•¸æœƒåœ¨è¿´åœˆå…§è¢«èµ°åˆ°ï¼Œå‰©ä¸‹é‚£ä¸€å€‹ç•™ä¸‹ä¾†çš„å°±æœƒåœ¨å¤–é¢è¢«æ›´æ–°ç­”æ¡ˆã€‚\n#include &lt;bits/stdc++.h&gt;using namespace std;int n,ans;int phi()&#123;    ans = n;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n % i == 0)&#123;            ans = ans - ans/i;            while(n % i==0)n /= i;        &#125;    &#125;    if(n &gt; 1)ans = ans - ans/n;    return ans;&#125;int main()&#123;    cin&gt;&gt;n;    cout&lt;&lt;phi()&lt;&lt;endl;&#125;\né€™æ˜¯ç”¨ç¨‹å¼è·‘å‡ºä¾†çš„1åˆ°10000çš„æ­æ‹‰å‡½æ•¸ï¼Œå¯ä»¥åƒè€ƒçœ‹çœ‹ï¼\nå¥½é›£çš„åœ–å½¢é€™å¼µåœ–æ˜¯æ­æ‹‰å‡½æ•¸çš„å‡½æ•¸åœ–å½¢ï¼Œxè»¸æ˜¯ $n$ï¼Œyè»¸å‰‡æ˜¯ $\\phi(n)$ã€‚åˆ©ç”¨pythonçš„matplotlibæ¨¡çµ„ç¹ªè£½å‡ºä¾†çš„ï¼\nä»¥ä¸‹ç‚ºå¾…è§£æ±ºå•é¡Œï¼š\n\n$(n,\\phi(n))$ çš„åœ–å½¢ä¸­ï¼Œæ–œç‡ç‚º $1,\\frac{1}{2},\\frac{2}{3},\\frac{4}{5},\\frac{1}{3}$ï¼Œå…¶åŸå› ï¼Ÿ\né€™äº›æ–œç‡æ˜¯å¦å¯ä»¥æ±‚å‡ºæ•¸å­—è½åœ¨æ¯ä¸€æ¢ç·šä¸Šçš„æ©Ÿç‡ï¼Ÿ\nå‡½æ•¸ç¸½å’Œçš„åœ–å½¢ï¼Œå…¶æ–¹ç¨‹å¼æ˜¯å¦‚ä½•æ¨å°çš„ï¼Ÿ\nå‡½æ•¸ç¸½å’Œå…¬å¼çš„èª¤å·®åœ–å½¢å‘ˆç¾é¡ä¼¼å¸¸æ…‹åˆ†ä½ˆï¼Œæ±‚å…¶åŸå› ã€‚\nå€’æ•¸ç¸½å’Œçš„å…¬å¼å¦‚ä½•æ¨å°ï¼Ÿ\næœ€å¾Œä¸€å€‹æ¥µé™ä¸‹ç•Œå…¬å¼çš„æ¨å°ï¼Œè·Ÿæ­æ‹‰-é¦¬æ–¯åˆ»è‹¥å°¼å¸¸æ•¸é—œä¿‚ç‚ºä½•ï¼Ÿ\n\nä¸€èˆ¬çš„ $n$ èˆ‡ $\\phi(n)$ é—œä¿‚åœ–æˆ‘è¦ºå¾—é€™æ±è¥¿è¶…é…·ï¼Œæœ‰ä¸€æ¢æ–œç‡ç‚º1çš„å¾ˆæ˜é¡¯çš„ç›´ç·šï¼Œä»–ä»£è¡¨çš„æ˜¯ $\\phi(n) = n-1$ï¼Œé€™ç¨®æƒ…æ³å°±æ˜¯ç•¶ $n$ å±¬æ–¼è³ªæ•¸çš„æ™‚å€™æœƒç™¼ç”Ÿã€‚\n$n$ çš„ç¯„åœæ˜¯1åˆ°150\n$n$ çš„ç¯„åœæ˜¯1åˆ°1500\n$n$ çš„ç¯„åœæ˜¯1åˆ°10000\næ–œç‡ $\\frac{1}{2}$ çš„æƒ…æ³é€™æ˜¯å˜—è©¦è§£æ±ºå•é¡Œçš„å€åŸŸã€‚\né¦–å…ˆï¼Œæˆ‘æŠŠæ–œç‡ç‚º $0.5\\pm0.01$ çš„é»å…¨éƒ¨æå‡ºä¾†ï¼Œå¤§æ¦‚å°±æ˜¯é€™æ¨£ï¼š\nå°ç¯„åœè·‘å‡ºä¾†ï¼Œåœ¨100å…§ä¸€å…±æœ‰6å€‹ç¬¦åˆæ¢ä»¶çš„æ•¸å­—ï¼Œåˆ†åˆ¥æ˜¯ï¼š\n\n248163264\n\nå“‡ï¼ä¸€åˆ‡è±ç„¶é–‹æœ—ã€‚ç•¶ $n$ ç‚º 2 çš„å†ªæ¬¡æ™‚ï¼Œå°±åªæœ‰ä¸€å€‹ $2$ æ˜¯è³ªå› æ•¸ï¼Œå› æ­¤ $\\phi(n) = n(1-\\frac{1}{2}) = \\frac{n}{2}$ã€‚ä½†é€™æ¨£çš„æ•¸å­—åªæœƒè¶Šä¾†è¶Šå°‘ï¼Œä½†é»å»æ²’æœ‰è®Šå¾—è¶Šä¾†è¶Šç¨€ç–ï¼Œæ–¼æ˜¯æˆ‘å€‘å¿…é ˆåŠ å¤§æ•¸å­—ç¯„åœè§€å¯Ÿï¼Œæ•¸å­—çš„åˆ—è¡¨åœ¨é€™ï¼Œä¸Ÿåˆ°ç·šä¸Šè³ªå› æ•¸åˆ†è§£å™¨ï¼Œæœƒç™¼ç¾æœ‰å¾ˆå¤šæ•¸å­—éƒ½æ˜¯æœ‰2å€‹å› æ•¸ï¼Œå…¶ä¸­ä¸€å€‹ç‚º2ï¼Œå¦å¤–ä¸€å€‹ç‚ºä¸€å€‹è¼ƒå¤§çš„è³ªæ•¸ï¼Œæ•¸å­—è¶Šå¤§å°å½±éŸ¿åŠ›å°±è¶Šå°ï¼Œå› æ­¤ä»–å€‘æœƒåœ¨æ–œç‡ç‚º $\\frac{1}{2}$ çš„ç·šä¸Šã€‚\n\nåƒ1964å°±æœƒæ˜¯$\\frac{1}{2}\\times \\frac{490}{491}$ï¼Œå¾Œé¢çš„å½±éŸ¿å¾ˆå°ï¼Œæ‰€æœ‰å¤§è‡´ä¸Šæ¥è¿‘ $\\frac{1}{2}$ã€‚\næ–œç‡ $\\frac{1}{3}$ çš„æƒ…æ³ç´…ç·šæ¨™å‡ºä¾†çš„æ˜¯æ–œç‡ç‚º $\\frac{1}{3}$ çš„ç·šæ¢ã€‚\næƒ…æ³å¤§æ¦‚å°±æ˜¯é€™å¹¾ç¨®ï¼Œé€™äº›è³ªå› æ•¸ç®—å‡ºä¾†å¤§æ¦‚å°±æ˜¯ $\\frac{1}{3}$ å·¦å³ã€‚\næ–œç‡ $\\frac{2}{3}$ çš„æƒ…æ³\né€™äº›æ•¸å­—å¾ˆå¤šäº‹3ä¹˜ä¸ŠæŸå€‹å¤§è³ªæ•¸ã€‚\næ–œç‡ $\\frac{4}{5}$ çš„æƒ…æ³\nä¸€æ¨£çš„æƒ…æ³ï¼Œå¤§å¤šæ˜¯5ç››æ”¾æŸå€‹å¤§è³ªæ•¸\nä¾†æ¯”è¼ƒä¸€ä¸‹\næˆ‘å€‘è¨­å®šä¸åŒçš„ $n$ ï¼Œçœ‹åœ¨ä¸åŒå€¼åŸŸä¸­å€‹åˆ¥æ–œç‡ä¸Šé¢çš„é»çš„æ•¸é‡ï¼Œä¸éå› ç‚ºæˆ‘è¨­äº†å°æ•¸é»å¾Œå…©ä½ç•¶ä½œå¯æ¥å—çš„èª¤å·®ç¯„åœï¼Œå› æ­¤æœƒç¨å¾®å¤šä¸€é»ï¼š\n\n\n\n\næ–œç‡/æ¬¡æ•¸\n1000\n10000\n100000\n1000000\n10000000\n\n\n\n\n1\n144\n1205\n10860\n118298\n1186321\n\n\n1/2\n152\n1425\n13531\n141771\n1401372\n\n\n1/3\n78\n858\n8031\n82782\n826322\n\n\n2/3\n67\n721\n6131\n65638\n664881\n\n\n4/5\n32\n387\n3281\n33560\n348334\n\n\nå…¶ä»–\n572\n5404\n58166\n557951\n5572770\n\n\n\n\n\n\n\n\næ–œç‡\né»çš„å æ¯”\n\n\n\n\n1\n11.86%\n\n\n1/2\n14.01%\n\n\n1/3\n8.26%\n\n\n2/3\n6.65%\n\n\n4/5\n3.48%\n\n\nå…¶ä»–\n55.73%\n\n\n\n\næˆ‘æƒ³è¦è¨ˆç®—ä¸€ä¸‹ä»–å€‘è®ŠåŒ–çš„ç‹€æ³ï¼š\n\nè§€å¯Ÿåœ–å½¢ï¼Œå¥½åƒæœ‰é‚£éº¼ä¸€é»æœƒè¶¨è¿‘æ–¼ä¸€å€‹å¸¸æ•¸ä¹‹é¡çš„ï¼Œä¸éç•¶æ•¸å­—è¶…é $10^7$ ä¹‹å¾Œï¼Œä¸ç®¡æ˜¯ç”¨ C++æˆ–æ˜¯ PYTHON éƒ½è·‘ä¸å¤ªå‡ºä¾†ã€‚\nimport numpy as npimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansx = []y = []x2 = []y2 = []times = [1000000]for j in range(1):    cnt = 0    for i in range(1,1000000+1):        if i%100000 == 0:            print(&quot;Now = &quot;,i/100000)        ans = int(phi(i))        x.append(i)        y.append(ans)        if abs(ans/i-(4/5)) &lt;= 0.01:            x2.append(i)            y2.append(ans)            #print(i)            cnt += 1    print(&quot;Cnt = &quot;,cnt)        #plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.1)#plt.plot(x,y,&#x27;o&#x27;,markersize = 1)#plt.plot(x2,y2,&#x27;o&#x27;,markersize = 1,c = &quot;red&quot;)#plt.show()\nimport numpy as npimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansx = []y = []for i in range(1,1500+1):    ans = int(phi(i))    x.append(i)    y.append(ans)    plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.1)plt.plot(x,y,&#x27;o&#x27;,markersize = 1)plt.show()\nç¸½å’Œçš„é—œä¿‚åœ–é™¤æ­¤ä¹‹å¤–ï¼Œé€™å€‹æ±è¥¿ä¹Ÿå¾ˆé…·ï¼Œä»¥ä¸‹æ˜¯ $f(n)$ èˆ‡ $n$ çš„é—œä¿‚åœ–ã€‚æ»¿è¶³ä»¥ä¸‹å¼å­ï¼š\nf(n) = \\sum^n_{i=1}\\phi(i)\nä¸Šç¶²æŸ¥å¾Œç™¼ç¾é€™ä¸€æ¢ç·šå¯ä»¥ç”¨ä¸€å€‹é—œä¿‚å¼è¡¨é”ï¼š\nf(n) = \\sum^n_{i=1}\\phi(i) = \\frac{3n^2}{\\pi^2}ä¸‹åœ–è—ç·šå°±æ˜¯å…¬å¼çš„åœ–ï¼Œç´…è‰²çš„é»å‰‡æ˜¯ $\\phi(n)$ï¼š\nimport numpy as npimport math import matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansdef func(x):    s = (math.pi)*(math.pi)    return 3*x*x/s    x = []y = []y2 = []sum = 0for i in range(1,101):    ans = int(phi(i))    sum += ans    x.append(i)    y2.append(func(i))    y.append(sum)plt.plot(x,y,&#x27;o&#x27;,color = &#x27;red&#x27;,markersize = 2)plt.plot(x,y2,color = &#x27;blue&#x27;,markersize = 0.1)plt.show()\nå¦‚æœè¨ˆç®—ä¸€ä¸‹é€™ä¸€æ¢ç†è«–ç·šè·Ÿå¯¦éš›çš„èª¤å·®ç¹ªè£½å‡ºä¾†çš„åœ–å½¢ï¼š\n\\frac{1}{n}(\\sum^n_{i=1}\\phi(i)-\\frac{3n^2}{\\pi^2})\nå¾ˆé…·å–”ï¼Œç•¶æˆ‘æŠŠæ¯ä¸€å€‹èª¤å·®çš„æ•¸å­—ç•¶åšxè»¸ï¼Œyè»¸å‰‡æ˜¯ç™¼ç”Ÿçš„æ¬¡æ•¸ï¼Œè·‘äº†1000000æ¬¡ä¹‹å¾Œï¼Œä»–çš„åœ–æœƒå‡ºä¾†æœƒæ˜¯åƒé€™æ¨£ï¼Œæœ‰é»åƒå¸¸æ…‹åˆ†ä½ˆçš„æ±è¥¿ï¼ˆç¶²è·¯ä¸Šæ˜¯èªªåŸƒçˆ¾ç±³ç‰¹å¤šé …å¼ä¹˜ä¸Šé«˜æ–¯å‡½æ•¸ä¹‹é¡çš„æ±è¥¿ï¼‰ï¼š\n\nThe histogram has a distinctive shape, maybe hard to prove. I suspect itâ€™s the Gaussian Unitary Ensemble (a Hermite polynomial times a Gaussian).\n\n\nimport numpy as npimport mathimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansdef func(x):    s = (math.pi)*(math.pi)    return 3*x*x/sx = []y = []box = [0]*2000sum = 0for i in range(1000):    box[i] = 0    for i in range(1,10000000+1):    ans = int(phi(i))    sum += ans    temp = int(((sum-func(i))/i)*2000)    box[temp] += 1    if i % 100000 == 0:        print(&quot;Cur = &quot;,i/100000)    for i in range(1400):    x.append(i/2000)    y.append(box[i])plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.4)plt.plot(x,y,&#x27;o&#x27;,markersize = 2)plt.show()\nå€’æ•¸åŠ ç¸½çš„åœ–å½¢ä¸‹åœ–å‰‡æ˜¯æ¯ä¸€å€‹ $\\phi$ çš„å€’æ•¸ç¹ªè£½å‡ºä¾†çš„åœ–å½¢ï¼š\nf(n) = \\sum^n_{i=1}\\frac{1}{\\phi(i)}\nå¾ˆé…·ï¼Œä½†æˆ‘ä¸€æ¨£ä¸çŸ¥é“æ€éº¼è§£é‡‹\nå–ä¸€å †æ€ªæ€ªçš„æ±è¥¿é‚„æ²’æœ‰çµæŸï¼Œé€™ä¸€å¼µåœ–è¡¨ç¤ºçš„æ˜¯ $n$ å°ä¸Š $\\phi(n)\\frac{\\ln\\ln n}{n}$ å‘ˆç¾çš„åœ–å½¢ï¼Œæ“šèªªæœƒæ»¿è¶³ä»¥ä¸‹é—œä¿‚å¼ï¼š\n\\lim_{n\\to\\infty}\\inf\\phi(n)\\frac{\\ln\\ln n}{n} = e^{-\\gamma}æŒ‡æ•¸æ¬¡æ–¹ä¸Šé¢æ˜¯æ­æ‹‰-é¦¬æ–¯åˆ»è‹¥å°¼å¸¸æ•¸ï¼Œç•«å‡ºä¾†çš„åœ–é•·é€™æ¨£ï¼š\n\nä¸€æ¨£ï¼Œå…¬å¼æœ‰å¤ è¤‡é›œï¼\nimport numpy as npimport mathimport matplotlib.pyplot as pltdef phi(n):    ans = int(n)    for i in range(2,n+1):        if i*i &gt; n:            break        if n % i == 0:            ans = ans - ans/i            while n % i == 0:                n = n / i    if n &gt; 1:        ans = ans - ans/n    return ansx = []y = []for i in range(1,5000+1):    ans = int(phi(i))    x.append(i)    temp = np.log(i)    ans *= np.log(temp)        y.append(ans/i)    plt.vlines(x, 0, y, linestyle=&quot;-&quot;,linewidth=0.05)plt.plot(x,y,&#x27;o&#x27;,markersize = 1)plt.show()\n\nåƒè€ƒé€£çµï¼š\n\né€£çµ1\né€£çµ2\né€£çµ3\n\nP2303 [SDOI2012] Longge çš„é—®é¢˜é¡Œç›®æ•˜è¿°Submission\né€™æ˜¯æ­æ‹‰å‡½æ•¸ç°¡å–®çš„æ‡‰ç”¨ï¼Œå°æ–¼ä¸€å€‹è¼¸å…¥ $n$ è¦è¼¸å‡ºçš„æ˜¯ $\\sum_{i=1}^n gcd(i,n)$ï¼Œä¹Ÿå°±æ˜¯æ¯ä¸€å€‹æ•¸å­—èˆ‡ $n$ çš„æœ€å¤§å…¬å› æ•¸ç¸½å’Œã€‚ç°¡å–®çš„æ¦‚å¿µå°±æ˜¯ï¼Œ$O(n)$ æšèˆ‰æ‰€æœ‰çš„å› æ•¸ $i$ ä½œç‚ºæœ€å¤§å…¬å› æ•¸ï¼Œæ­¤æ™‚åªè¦çœ‹èˆ‡ $\\frac{n}{i}$ äº’è³ªçš„æ•¸é‡ï¼Œ$i\\times\\phi(\\frac{n}{i})$ å°±æœƒæ˜¯ä»¥ $i$ ä½œç‚ºæœ€å¤§å…¬å› æ•¸çš„ç¸½å’Œã€‚\nç‰¹åˆ¥æ³¨æ„åˆ°ï¼Œæˆ‘å€‘å¯ä»¥åœ¨æšèˆ‰ $i$ çš„æ™‚å€™ï¼Œä¹Ÿå¯ä»¥é †ä¾¿è™•ç† $\\frac{n}{i}$ çš„æƒ…æ³ï¼Œé€™æ¨£å°±å¯ä»¥åªæšèˆ‰ $\\sqrt{n}$ æ¬¡å°±å¥½äº†ï¼\n#include &lt;bits/stdc++.h&gt;#define int long long#define Orz ios::sync_with_stdio(0),cin.tie(0)using namespace std;int n,ans = 0;int phi(int n)&#123;    int ans = n;    for(int i=2;i*i&lt;=n;i++)&#123;        if(n % i == 0)&#123;            ans = ans - ans/i;            while(n % i==0)n /= i;        &#125;    &#125;    if(n &gt; 1)ans = ans - ans/n;    return ans;&#125;signed main()&#123;    Orz;    cin&gt;&gt;n;    int qt = sqrt(n);    for(int i=1;i&lt;=qt;i++)&#123;        if(n % i == 0)&#123;            ans += (n/i) * phi(i);            if(i*i!=n)ans += i * phi(n/i);        &#125;    &#125;    cout&lt;&lt;ans&lt;&lt;endl;&#125;\n","categories":["æ•¸å­¸ç­†è¨˜"],"tags":["æ•¸å­¸","é«˜äºŒä¸Šç­†è¨˜"]}]